var o7 = Object.defineProperty;
var a7 = (t, e, n) => e in t ? o7(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var ti = (t, e, n) => a7(t, typeof e != "symbol" ? e + "" : e, n);
import { jsxs as Fe, jsx as z, Fragment as pn } from "react/jsx-runtime";
import * as Mt from "react";
import Lt, { forwardRef as Om, createContext as rF, useState as nt, useEffect as Tt, useRef as Wr, useDebugValue as iF, useContext as oF, useLayoutEffect as s7, useSyncExternalStore as aF, useMemo as Yt, useCallback as Et, useImperativeHandle as Kv, Fragment as Xv } from "react";
import { X as sF, ChevronRight as l7, Check as lF, Circle as c7, Plus as cF, Bold as u7, LoaderCircle as d7, Italic as f7, Underline as h7, Quote as p7, Strikethrough as m7, Minus as g7, Eraser as y7, PaintRoller as b7, Redo2 as v7, Undo2 as w7, ChevronDown as uF, Subscript as x7, Superscript as _7, Code as S7, CodeXml as T7, Type as D7, IndentIncrease as E7, IndentDecrease as C7, List as k7, ListOrdered as A7, ListTodo as R7, Link as I7, ImageUp as O7, Video as F7, Maximize as U7, Minimize as N7, Table as M7, Sparkles as B7, Pencil as L7, Unlink as P7, BetweenHorizonalEnd as W7, BetweenHorizonalStart as z7, BetweenVerticalStart as $7, BetweenVerticalEnd as H7, TableCellsMerge as j7, TableCellsSplit as V7, Trash2 as q7, Trash as G7, Replace as ak, ChevronsUpDown as K7, Heading1 as X7, Heading2 as Y7, Heading3 as J7, Heading4 as Z7, Heading5 as Q7, Heading6 as eW, Columns2 as sk, Columns3 as tW, Columns4 as nW, GripVertical as rW, Copy as iW, Clipboard as oW, PanelLeft as aW, PanelRight as sW, Frame as lW, SmilePlus as cW, SmilePlusIcon as uW, BookMarked as dW, ZoomIn as fW, ZoomOut as hW, Settings as pW, Eye as mW, Paperclip as gW, ChevronUp as yW, CropIcon as bW, FlipVertical as vW, FlipHorizontal as wW, Clock3 as xW, Laugh as _W, LucideAudioLines as SW, LucideVideo as TW, LucideFile as DW, LucideImage as EW, LucideSheet as CW, LucideTableProperties as kW } from "lucide-react";
import Fm, { sticky as AW } from "tippy.js";
import RW, { flushSync as jp } from "react-dom";
import { Slot as KT } from "@radix-ui/react-slot";
import * as Um from "@radix-ui/react-tooltip";
import { TextAlignCenterIcon as IW, TextAlignJustifyIcon as OW, TextAlignLeftIcon as FW, TextAlignRightIcon as UW } from "@radix-ui/react-icons";
import * as dF from "@radix-ui/react-toggle";
import * as no from "@radix-ui/react-dialog";
import * as Vp from "@radix-ui/react-popover";
import * as fF from "@radix-ui/react-label";
import { Resizable as NW } from "re-resizable";
import { Tweet as MW } from "react-tweet";
import { HexColorPicker as BW } from "react-colorful";
import * as hF from "@radix-ui/react-separator";
import * as Z_ from "@radix-ui/react-switch";
import * as wn from "@radix-ui/react-dropdown-menu";
import * as ki from "@radix-ui/react-toast";
import * as cu from "@radix-ui/react-tabs";
import LW from "react-image-crop";
import * as Q_ from "@radix-ui/react-checkbox";
import XT from "scroll-into-view-if-needed";
function or(t) {
  this.content = t;
}
or.prototype = {
  constructor: or,
  find: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t) return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(t, e, n) {
    var r = n && n != t ? this.remove(n) : this, i = r.find(t), o = r.content.slice();
    return i == -1 ? o.push(n || t, e) : (o[i + 1] = e, n && (o[i] = n)), new or(o);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(t) {
    var e = this.find(t);
    if (e == -1) return this;
    var n = this.content.slice();
    return n.splice(e, 2), new or(n);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(t, e) {
    return new or([t, e].concat(this.remove(t).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(t, e) {
    var n = this.remove(t).content.slice();
    return n.push(t, e), new or(n);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(t, e, n) {
    var r = this.remove(e), i = r.content.slice(), o = r.find(t);
    return i.splice(o == -1 ? i.length : o, 0, e, n), new or(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(t) {
    return t = or.from(t), t.size ? new or(t.content.concat(this.subtract(t).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(t) {
    return t = or.from(t), t.size ? new or(this.subtract(t).content.concat(t.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(t) {
    var e = this;
    t = or.from(t);
    for (var n = 0; n < t.content.length; n += 2)
      e = e.remove(t.content[n]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var t = {};
    return this.forEach(function(e, n) {
      t[e] = n;
    }), t;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
or.from = function(t) {
  if (t instanceof or) return t;
  var e = [];
  if (t) for (var n in t) e.push(n, t[n]);
  return new or(e);
};
function pF(t, e, n) {
  for (let r = 0; ; r++) {
    if (r == t.childCount || r == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let i = t.child(r), o = e.child(r);
    if (i == o) {
      n += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(o))
      return n;
    if (i.isText && i.text != o.text) {
      for (let a = 0; i.text[a] == o.text[a]; a++)
        n++;
      return n;
    }
    if (i.content.size || o.content.size) {
      let a = pF(i.content, o.content, n + 1);
      if (a != null)
        return a;
    }
    n += i.nodeSize;
  }
}
function mF(t, e, n, r) {
  for (let i = t.childCount, o = e.childCount; ; ) {
    if (i == 0 || o == 0)
      return i == o ? null : { a: n, b: r };
    let a = t.child(--i), s = e.child(--o), l = a.nodeSize;
    if (a == s) {
      n -= l, r -= l;
      continue;
    }
    if (!a.sameMarkup(s))
      return { a: n, b: r };
    if (a.isText && a.text != s.text) {
      let c = 0, u = Math.min(a.text.length, s.text.length);
      for (; c < u && a.text[a.text.length - c - 1] == s.text[s.text.length - c - 1]; )
        c++, n--, r--;
      return { a: n, b: r };
    }
    if (a.content.size || s.content.size) {
      let c = mF(a.content, s.content, n - 1, r - 1);
      if (c)
        return c;
    }
    n -= l, r -= l;
  }
}
class ze {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, r, i = 0, o) {
    for (let a = 0, s = 0; s < n; a++) {
      let l = this.content[a], c = s + l.nodeSize;
      if (c > e && r(l, i + s, o || null, a) !== !1 && l.content.size) {
        let u = s + 1;
        l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, n - u), r, i + u);
      }
      s = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, r, i) {
    let o = "", a = !0;
    return this.nodesBetween(e, n, (s, l) => {
      let c = s.isText ? s.text.slice(Math.max(e, l) - l, n - l) : s.isLeaf ? i ? typeof i == "function" ? i(s) : i : s.type.spec.leafText ? s.type.spec.leafText(s) : "" : "";
      s.isBlock && (s.isLeaf && c || s.isTextblock) && r && (a ? a = !1 : o += r), o += c;
    }, 0), o;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, r = e.firstChild, i = this.content.slice(), o = 0;
    for (n.isText && n.sameMarkup(r) && (i[i.length - 1] = n.withText(n.text + r.text), o = 1); o < e.content.length; o++)
      i.push(e.content[o]);
    return new ze(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let r = [], i = 0;
    if (n > e)
      for (let o = 0, a = 0; a < n; o++) {
        let s = this.content[o], l = a + s.nodeSize;
        l > e && ((a < e || l > n) && (s.isText ? s = s.cut(Math.max(0, e - a), Math.min(s.text.length, n - a)) : s = s.cut(Math.max(0, e - a - 1), Math.min(s.content.size, n - a - 1))), r.push(s), i += s.nodeSize), a = l;
      }
    return new ze(r, i);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? ze.empty : e == 0 && n == this.content.length ? this : new ze(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let r = this.content[e];
    if (r == n)
      return this;
    let i = this.content.slice(), o = this.size + n.nodeSize - r.nodeSize;
    return i[e] = n, new ze(i, o);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new ze([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new ze(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let i = this.content[n];
      e(i, r, n), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return pF(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, r = e.size) {
    return mF(this, e, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e, n = -1) {
    if (e == 0)
      return $g(0, e);
    if (e == this.size)
      return $g(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let r = 0, i = 0; ; r++) {
      let o = this.child(r), a = i + o.nodeSize;
      if (a >= e)
        return a == e || n > 0 ? $g(r + 1, a) : $g(r, i);
      i = a;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return ze.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new ze(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return ze.empty;
    let n, r = 0;
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      r += o.nodeSize, i && o.isText && e[i - 1].sameMarkup(o) ? (n || (n = e.slice(0, i)), n[n.length - 1] = o.withText(n[n.length - 1].text + o.text)) : n && n.push(o);
    }
    return new ze(n || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return ze.empty;
    if (e instanceof ze)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new ze([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
ze.empty = new ze([], 0);
const Aw = { index: 0, offset: 0 };
function $g(t, e) {
  return Aw.index = t, Aw.offset = e, Aw;
}
function hb(t, e) {
  if (t === e)
    return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object"))
    return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n)
    return !1;
  if (n) {
    if (t.length != e.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (!hb(t[r], e[r]))
        return !1;
  } else {
    for (let r in t)
      if (!(r in e) || !hb(t[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in t))
        return !1;
  }
  return !0;
}
let tn = class eS {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n, r = !1;
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      if (this.eq(o))
        return e;
      if (this.type.excludes(o.type))
        n || (n = e.slice(0, i));
      else {
        if (o.type.excludes(this.type))
          return e;
        !r && o.type.rank > this.type.rank && (n || (n = e.slice(0, i)), n.push(this), r = !0), n && n.push(o);
      }
    }
    return n || (n = e.slice()), r || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && hb(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let i = r.create(n.attrs);
    return r.checkAttrs(i.attrs), i;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n)
      return !0;
    if (e.length != n.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(n[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return eS.none;
    if (e instanceof eS)
      return [e];
    let n = e.slice();
    return n.sort((r, i) => r.type.rank - i.type.rank), n;
  }
};
tn.none = [];
class pb extends Error {
}
class Xe {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, r) {
    this.content = e, this.openStart = n, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let r = yF(this.content, e + this.openStart, n);
    return r && new Xe(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new Xe(gF(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return Xe.empty;
    let r = n.openStart || 0, i = n.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Xe(ze.fromJSON(e, n.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let r = 0, i = 0;
    for (let o = e.firstChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.firstChild)
      r++;
    for (let o = e.lastChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.lastChild)
      i++;
    return new Xe(e, r, i);
  }
}
Xe.empty = new Xe(ze.empty, 0, 0);
function gF(t, e, n) {
  let { index: r, offset: i } = t.findIndex(e), o = t.maybeChild(r), { index: a, offset: s } = t.findIndex(n);
  if (i == e || o.isText) {
    if (s != n && !t.child(a).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (r != a)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(r, o.copy(gF(o.content, e - i - 1, n - i - 1)));
}
function yF(t, e, n, r) {
  let { index: i, offset: o } = t.findIndex(e), a = t.maybeChild(i);
  if (o == e || a.isText)
    return t.cut(0, e).append(n).append(t.cut(e));
  let s = yF(a.content, e - o - 1, n);
  return s && t.replaceChild(i, a.copy(s));
}
function PW(t, e, n) {
  if (n.openStart > t.depth)
    throw new pb("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new pb("Inconsistent open depths");
  return bF(t, e, n, 0);
}
function bF(t, e, n, r) {
  let i = t.index(r), o = t.node(r);
  if (i == e.index(r) && r < t.depth - n.openStart) {
    let a = bF(t, e, n, r + 1);
    return o.copy(o.content.replaceChild(i, a));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
      let a = t.parent, s = a.content;
      return Wc(a, s.cut(0, t.parentOffset).append(n.content).append(s.cut(e.parentOffset)));
    } else {
      let { start: a, end: s } = WW(n, t);
      return Wc(o, wF(t, a, s, e, r));
    }
  else return Wc(o, mb(t, e, r));
}
function vF(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new pb("Cannot join " + e.type.name + " onto " + t.type.name);
}
function tS(t, e, n) {
  let r = t.node(n);
  return vF(r, e.node(n)), r;
}
function Pc(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t);
}
function kp(t, e, n, r) {
  let i = (e || t).node(n), o = 0, a = e ? e.index(n) : i.childCount;
  t && (o = t.index(n), t.depth > n ? o++ : t.textOffset && (Pc(t.nodeAfter, r), o++));
  for (let s = o; s < a; s++)
    Pc(i.child(s), r);
  e && e.depth == n && e.textOffset && Pc(e.nodeBefore, r);
}
function Wc(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function wF(t, e, n, r, i) {
  let o = t.depth > i && tS(t, e, i + 1), a = r.depth > i && tS(n, r, i + 1), s = [];
  return kp(null, t, i, s), o && a && e.index(i) == n.index(i) ? (vF(o, a), Pc(Wc(o, wF(t, e, n, r, i + 1)), s)) : (o && Pc(Wc(o, mb(t, e, i + 1)), s), kp(e, n, i, s), a && Pc(Wc(a, mb(n, r, i + 1)), s)), kp(r, null, i, s), new ze(s);
}
function mb(t, e, n) {
  let r = [];
  if (kp(null, t, n, r), t.depth > n) {
    let i = tS(t, e, n + 1);
    Pc(Wc(i, mb(t, e, n + 1)), r);
  }
  return kp(e, null, n, r), new ze(r);
}
function WW(t, e) {
  let n = e.depth - t.openStart, i = e.node(n).copy(t.content);
  for (let o = n - 1; o >= 0; o--)
    i = e.node(o).copy(ze.from(i));
  return {
    start: i.resolveNoCache(t.openStart + n),
    end: i.resolveNoCache(i.content.size - t.openEnd - n)
  };
}
class qp {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, n = this.index(this.depth);
    if (n == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = e.child(n);
    return r ? e.child(n).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3], i = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let o = 0; o < e; o++)
      i += r.child(o).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, n = this.index();
    if (e.content.size == 0)
      return tn.none;
    if (this.textOffset)
      return e.child(n).marks;
    let r = e.maybeChild(n - 1), i = e.maybeChild(n);
    if (!r) {
      let s = r;
      r = i, i = s;
    }
    let o = r.marks;
    for (var a = 0; a < o.length; a++)
      o[a].type.spec.inclusive === !1 && (!i || !o[a].isInSet(i.marks)) && (o = o[a--].removeFromSet(o));
    return o;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let r = n.marks, i = e.parent.maybeChild(e.index());
    for (var o = 0; o < r.length; o++)
      r[o].type.spec.inclusive === !1 && (!i || !r[o].isInSet(i.marks)) && (r = r[o--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!n || n(this.node(r))))
        return new Gp(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [], i = 0, o = n;
    for (let a = e; ; ) {
      let { index: s, offset: l } = a.content.findIndex(o), c = o - l;
      if (r.push(a, s, i + l), !c || (a = a.child(s), a.isText))
        break;
      o = c - 1, i += l + 1;
    }
    return new qp(n, r, o);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    let r = lk.get(e);
    if (r)
      for (let o = 0; o < r.elts.length; o++) {
        let a = r.elts[o];
        if (a.pos == n)
          return a;
      }
    else
      lk.set(e, r = new zW());
    let i = r.elts[r.i] = qp.resolve(e, n);
    return r.i = (r.i + 1) % $W, i;
  }
}
class zW {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const $W = 12, lk = /* @__PURE__ */ new WeakMap();
class Gp {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const HW = /* @__PURE__ */ Object.create(null);
let ns = class nS {
  /**
  @internal
  */
  constructor(e, n, r, i = tn.none) {
    this.type = e, this.attrs = n, this.marks = i, this.content = r || ze.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, n, r, i = 0) {
    this.content.nodesBetween(e, n, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, n, r, i) {
    return this.content.textBetween(e, n, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, r) {
    return this.type == e && hb(this.attrs, n || e.defaultAttrs || HW) && tn.sameSet(this.marks, r || tn.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new nS(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new nS(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, r = !1) {
    if (e == n)
      return Xe.empty;
    let i = this.resolve(e), o = this.resolve(n), a = r ? 0 : i.sharedDepth(n), s = i.start(a), c = i.node(a).content.cut(i.pos - s, o.pos - s);
    return new Xe(c, i.depth - a, o.depth - a);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, r) {
    return PW(this.resolve(e), this.resolve(n), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: r, offset: i } = n.content.findIndex(e);
      if (n = n.maybeChild(r), !n)
        return null;
      if (i == e || n.isText)
        return n;
      e -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(n), index: n, offset: r };
    let i = this.content.child(n - 1);
    return { node: i, index: n - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return qp.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return qp.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, r) {
    let i = !1;
    return n > e && this.nodesBetween(e, n, (o) => (r.isInSet(o.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), xF(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, r = ze.empty, i = 0, o = r.childCount) {
    let a = this.contentMatchAt(e).matchFragment(r, i, o), s = a && a.matchFragment(this.content, n);
    if (!s || !s.validEnd)
      return !1;
    for (let l = i; l < o; l++)
      if (!this.type.allowsMarks(r.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let o = this.contentMatchAt(e).matchType(r), a = o && o.matchFragment(this.content, n);
    return a ? a.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = tn.none;
    for (let n = 0; n < this.marks.length; n++) {
      let r = this.marks[n];
      r.type.checkAttrs(r.attrs), e = r.addToSet(e);
    }
    if (!tn.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, r);
    }
    let i = ze.fromJSON(e, n.content), o = e.nodeType(n.type).create(n.attrs, i, r);
    return o.type.checkAttrs(o.attrs), o;
  }
};
ns.prototype.text = void 0;
class gb extends ns {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    if (super(e, n, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : xF(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new gb(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new gb(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function xF(t, e) {
  for (let n = t.length - 1; n >= 0; n--)
    e = t[n].type.name + "(" + e + ")";
  return e;
}
class Kc {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, n) {
    let r = new jW(e, n);
    if (r.next == null)
      return Kc.empty;
    let i = _F(r);
    r.next && r.err("Unexpected trailing text");
    let o = JW(YW(i));
    return ZW(o, r), o;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, n = 0, r = e.childCount) {
    let i = this;
    for (let o = n; i && o < r; o++)
      i = i.matchType(e.child(o).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[n].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, n = !1, r = 0) {
    let i = [this];
    function o(a, s) {
      let l = a.matchFragment(e, r);
      if (l && (!n || l.validEnd))
        return ze.from(s.map((c) => c.createAndFill()));
      for (let c = 0; c < a.next.length; c++) {
        let { type: u, next: d } = a.next[c];
        if (!(u.isText || u.hasRequiredAttrs()) && i.indexOf(d) == -1) {
          i.push(d);
          let f = o(d, s.concat(u));
          if (f)
            return f;
        }
      }
      return null;
    }
    return o(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let n = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), o = i.match;
      if (o.matchType(e)) {
        let a = [];
        for (let s = i; s.type; s = s.via)
          a.push(s.type);
        return a.reverse();
      }
      for (let a = 0; a < o.next.length; a++) {
        let { type: s, next: l } = o.next[a];
        !s.isLeaf && !s.hasRequiredAttrs() && !(s.name in n) && (!i.type || l.validEnd) && (r.push({ match: s.contentMatch, type: s, via: i }), n[s.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function n(r) {
      e.push(r);
      for (let i = 0; i < r.next.length; i++)
        e.indexOf(r.next[i].next) == -1 && n(r.next[i].next);
    }
    return n(this), e.map((r, i) => {
      let o = i + (r.validEnd ? "*" : " ") + " ";
      for (let a = 0; a < r.next.length; a++)
        o += (a ? ", " : "") + r.next[a].type.name + "->" + e.indexOf(r.next[a].next);
      return o;
    }).join(`
`);
  }
}
Kc.empty = new Kc(!0);
class jW {
  constructor(e, n) {
    this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function _F(t) {
  let e = [];
  do
    e.push(VW(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function VW(t) {
  let e = [];
  do
    e.push(qW(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function qW(t) {
  let e = XW(t);
  for (; ; )
    if (t.eat("+"))
      e = { type: "plus", expr: e };
    else if (t.eat("*"))
      e = { type: "star", expr: e };
    else if (t.eat("?"))
      e = { type: "opt", expr: e };
    else if (t.eat("{"))
      e = GW(t, e);
    else
      break;
  return e;
}
function ck(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function GW(t, e) {
  let n = ck(t), r = n;
  return t.eat(",") && (t.next != "}" ? r = ck(t) : r = -1), t.eat("}") || t.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: e };
}
function KW(t, e) {
  let n = t.nodeTypes, r = n[e];
  if (r)
    return [r];
  let i = [];
  for (let o in n) {
    let a = n[o];
    a.isInGroup(e) && i.push(a);
  }
  return i.length == 0 && t.err("No node type or group '" + e + "' found"), i;
}
function XW(t) {
  if (t.eat("(")) {
    let e = _F(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next))
    t.err("Unexpected token '" + t.next + "'");
  else {
    let e = KW(t, t.next).map((n) => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"), { type: "name", value: n }));
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function YW(t) {
  let e = [[]];
  return i(o(t, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function r(a, s, l) {
    let c = { term: l, to: s };
    return e[a].push(c), c;
  }
  function i(a, s) {
    a.forEach((l) => l.to = s);
  }
  function o(a, s) {
    if (a.type == "choice")
      return a.exprs.reduce((l, c) => l.concat(o(c, s)), []);
    if (a.type == "seq")
      for (let l = 0; ; l++) {
        let c = o(a.exprs[l], s);
        if (l == a.exprs.length - 1)
          return c;
        i(c, s = n());
      }
    else if (a.type == "star") {
      let l = n();
      return r(s, l), i(o(a.expr, l), l), [r(l)];
    } else if (a.type == "plus") {
      let l = n();
      return i(o(a.expr, s), l), i(o(a.expr, l), l), [r(l)];
    } else {
      if (a.type == "opt")
        return [r(s)].concat(o(a.expr, s));
      if (a.type == "range") {
        let l = s;
        for (let c = 0; c < a.min; c++) {
          let u = n();
          i(o(a.expr, l), u), l = u;
        }
        if (a.max == -1)
          i(o(a.expr, l), l);
        else
          for (let c = a.min; c < a.max; c++) {
            let u = n();
            r(l, u), i(o(a.expr, l), u), l = u;
          }
        return [r(l)];
      } else {
        if (a.type == "name")
          return [r(s, void 0, a.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function SF(t, e) {
  return e - t;
}
function uk(t, e) {
  let n = [];
  return r(e), n.sort(SF);
  function r(i) {
    let o = t[i];
    if (o.length == 1 && !o[0].term)
      return r(o[0].to);
    n.push(i);
    for (let a = 0; a < o.length; a++) {
      let { term: s, to: l } = o[a];
      !s && n.indexOf(l) == -1 && r(l);
    }
  }
}
function JW(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return n(uk(t, 0));
  function n(r) {
    let i = [];
    r.forEach((a) => {
      t[a].forEach(({ term: s, to: l }) => {
        if (!s)
          return;
        let c;
        for (let u = 0; u < i.length; u++)
          i[u][0] == s && (c = i[u][1]);
        uk(t, l).forEach((u) => {
          c || i.push([s, c = []]), c.indexOf(u) == -1 && c.push(u);
        });
      });
    });
    let o = e[r.join(",")] = new Kc(r.indexOf(t.length - 1) > -1);
    for (let a = 0; a < i.length; a++) {
      let s = i[a][1].sort(SF);
      o.next.push({ type: i[a][0], next: e[s.join(",")] || n(s) });
    }
    return o;
  }
}
function ZW(t, e) {
  for (let n = 0, r = [t]; n < r.length; n++) {
    let i = r[n], o = !i.validEnd, a = [];
    for (let s = 0; s < i.next.length; s++) {
      let { type: l, next: c } = i.next[s];
      a.push(l.name), o && !(l.isText || l.hasRequiredAttrs()) && (o = !1), r.indexOf(c) == -1 && r.push(c);
    }
    o && e.err("Only non-generatable nodes (" + a.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function TF(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let r = t[n];
    if (!r.hasDefault)
      return null;
    e[n] = r.default;
  }
  return e;
}
function DF(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let i = e && e[r];
    if (i === void 0) {
      let o = t[r];
      if (o.hasDefault)
        i = o.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = i;
  }
  return n;
}
function EF(t, e, n, r) {
  for (let i in e)
    if (!(i in t))
      throw new RangeError(`Unsupported attribute ${i} for ${n} of type ${i}`);
  for (let i in t) {
    let o = t[i];
    o.validate && o.validate(e[i]);
  }
}
function CF(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let r in e)
      n[r] = new ez(t, r, e[r]);
  return n;
}
let dk = class kF {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.name = e, this.schema = n, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = CF(e, r.attrs), this.defaultAttrs = TF(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == Kc.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : DF(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new ns(this, this.computeAttrs(e), ze.from(n), tn.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, n, r) {
    return n = ze.from(n), this.checkContent(n), new ns(this, this.computeAttrs(e), n, tn.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, n, r) {
    if (e = this.computeAttrs(e), n = ze.from(n), n.size) {
      let a = this.contentMatch.fillBefore(n);
      if (!a)
        return null;
      n = a.append(n);
    }
    let i = this.contentMatch.matchFragment(n), o = i && i.fillBefore(ze.empty, !0);
    return o ? new ns(this, e, n.append(o), tn.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    EF(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let n;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r));
    return n ? n.length ? n : tn.none : e;
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((o, a) => r[o] = new kF(o, n, a));
    let i = n.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let o in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function QW(t, e, n) {
  let r = n.split("|");
  return (i) => {
    let o = i === null ? "null" : typeof i;
    if (r.indexOf(o) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${t}, got ${o}`);
  };
}
class ez {
  constructor(e, n, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? QW(e, n, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class Yv {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    this.name = e, this.rank = n, this.schema = r, this.spec = i, this.attrs = CF(e, i.attrs), this.excluded = null;
    let o = TF(this.attrs);
    this.instance = o ? new tn(this, o) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new tn(this, DF(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((o, a) => r[o] = new Yv(o, i++, n, a)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].type == this)
        return e[n];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    EF(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class AF {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let i in e)
      n[i] = e[i];
    n.nodes = or.from(e.nodes), n.marks = or.from(e.marks || {}), this.nodes = dk.compile(this.spec.nodes, this), this.marks = Yv.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let o = this.nodes[i], a = o.spec.content || "", s = o.spec.marks;
      if (o.contentMatch = r[a] || (r[a] = Kc.parse(a, this.nodes)), o.inlineContent = o.contentMatch.inlineContent, o.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!o.isInline || !o.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = o;
      }
      o.markSet = s == "_" ? null : s ? fk(this, s.split(" ")) : s == "" || !o.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let o = this.marks[i], a = o.spec.excludes;
      o.excluded = a == null ? [o] : a == "" ? [] : fk(this, a.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, n = null, r, i) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof dk) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, n) {
    let r = this.nodes.text;
    return new gb(r, r.defaultAttrs, e, tn.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return ns.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return tn.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let n = this.nodes[e];
    if (!n)
      throw new RangeError("Unknown node type: " + e);
    return n;
  }
}
function fk(t, e) {
  let n = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r], o = t.marks[i], a = o;
    if (o)
      n.push(o);
    else
      for (let s in t.marks) {
        let l = t.marks[s];
        (i == "_" || l.spec.group && l.spec.group.split(" ").indexOf(i) > -1) && n.push(a = l);
      }
    if (!a)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return n;
}
function tz(t) {
  return t.tag != null;
}
function nz(t) {
  return t.style != null;
}
let Ap = class rS {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    this.schema = e, this.rules = n, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    n.forEach((i) => {
      if (tz(i))
        this.tags.push(i);
      else if (nz(i)) {
        let o = /[^=]*/.exec(i.style)[0];
        r.indexOf(o) < 0 && r.push(o), this.styles.push(i);
      }
    }), this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
        return !1;
      let o = e.nodes[i.node];
      return o.contentMatch.matchType(o);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let r = new pk(this, n, !1);
    return r.addAll(e, tn.none, n.from, n.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let r = new pk(this, n, !0);
    return r.addAll(e, tn.none, n.from, n.to), Xe.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let o = this.tags[i];
      if (oz(e, o.tag) && (o.namespace === void 0 || e.namespaceURI == o.namespace) && (!o.context || n.matchesContext(o.context))) {
        if (o.getAttrs) {
          let a = o.getAttrs(e);
          if (a === !1)
            continue;
          o.attrs = a || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, r, i) {
    for (let o = i ? this.styles.indexOf(i) + 1 : 0; o < this.styles.length; o++) {
      let a = this.styles[o], s = a.style;
      if (!(s.indexOf(e) != 0 || a.context && !r.matchesContext(a.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      s.length > e.length && (s.charCodeAt(e.length) != 61 || s.slice(e.length + 1) != n))) {
        if (a.getAttrs) {
          let l = a.getAttrs(n);
          if (l === !1)
            continue;
          a.attrs = l || void 0;
        }
        return a;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function r(i) {
      let o = i.priority == null ? 50 : i.priority, a = 0;
      for (; a < n.length; a++) {
        let s = n[a];
        if ((s.priority == null ? 50 : s.priority) < o)
          break;
      }
      n.splice(a, 0, i);
    }
    for (let i in e.marks) {
      let o = e.marks[i].spec.parseDOM;
      o && o.forEach((a) => {
        r(a = mk(a)), a.mark || a.ignore || a.clearMark || (a.mark = i);
      });
    }
    for (let i in e.nodes) {
      let o = e.nodes[i].spec.parseDOM;
      o && o.forEach((a) => {
        r(a = mk(a)), a.node || a.ignore || a.mark || (a.node = i);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new rS(e, rS.schemaRules(e)));
  }
};
const RF = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, rz = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, IF = { ol: !0, ul: !0 }, Kp = 1, iS = 2, Rp = 4;
function hk(t, e, n) {
  return e != null ? (e ? Kp : 0) | (e === "full" ? iS : 0) : t && t.whitespace == "pre" ? Kp | iS : n & ~Rp;
}
class Hg {
  constructor(e, n, r, i, o, a) {
    this.type = e, this.attrs = n, this.marks = r, this.solid = i, this.options = a, this.content = [], this.activeMarks = tn.none, this.match = o || (a & Rp ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(ze.from(e));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & Kp)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let o = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = o.withText(o.text.slice(0, o.text.length - i[0].length));
      }
    }
    let n = ze.from(this.content);
    return !e && this.match && (n = n.append(this.match.fillBefore(ze.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !RF.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class pk {
  constructor(e, n, r) {
    this.parser = e, this.options = n, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let i = n.topNode, o, a = hk(null, n.preserveWhitespace, 0) | (r ? Rp : 0);
    i ? o = new Hg(i.type, i.attrs, tn.none, !0, n.topMatch || i.type.contentMatch, a) : r ? o = new Hg(null, null, tn.none, !0, null, a) : o = new Hg(e.schema.topNodeType, null, tn.none, !0, null, a), this.nodes = [o], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, n) {
    e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n);
  }
  addTextNode(e, n) {
    let r = e.nodeValue, i = this.top, o = i.options & iS ? "full" : this.localPreserveWS || (i.options & Kp) > 0;
    if (o === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (o)
        o !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`);
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let a = i.content[i.content.length - 1], s = e.previousSibling;
        (!a || s && s.nodeName == "BR" || a.isText && /[ \t\r\n\u000c]$/.test(a.text)) && (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r), n), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n, r) {
    let i = this.localPreserveWS, o = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let a = e.nodeName.toLowerCase(), s;
    IF.hasOwnProperty(a) && this.parser.normalizeLists && iz(e);
    let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (s = this.parser.matchTag(e, this, r));
    e: if (l ? l.ignore : rz.hasOwnProperty(a))
      this.findInside(e), this.ignoreFallback(e, n);
    else if (!l || l.skip || l.closeParent) {
      l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
      let c, u = this.needsBlock;
      if (RF.hasOwnProperty(a))
        o.content.length && o.content[0].isInline && this.open && (this.open--, o = this.top), c = !0, o.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, n);
        break e;
      }
      let d = l && l.skip ? n : this.readStyles(e, n);
      d && this.addAll(e, d), c && this.sync(o), this.needsBlock = u;
    } else {
      let c = this.readStyles(e, n);
      c && this.addElementByRule(e, l, c, l.consuming === !1 ? s : void 0);
    }
    this.localPreserveWS = i;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, n) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n);
  }
  // Called for ignored nodes
  ignoreFallback(e, n) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, n) {
    let r = e.style;
    if (r && r.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let o = this.parser.matchedStyles[i], a = r.getPropertyValue(o);
        if (a)
          for (let s = void 0; ; ) {
            let l = this.parser.matchStyle(o, a, this, s);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? n = n.filter((c) => !l.clearMark(c)) : n = n.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1)
              s = l;
            else
              break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, r, i) {
    let o, a;
    if (n.node)
      if (a = this.parser.schema.nodes[n.node], a.isLeaf)
        this.insertNode(a.create(n.attrs), r) || this.leafFallback(e, r);
      else {
        let l = this.enter(a, n.attrs || null, r, n.preserveWhitespace);
        l && (o = !0, r = l);
      }
    else {
      let l = this.parser.schema.marks[n.mark];
      r = r.concat(l.create(n.attrs));
    }
    let s = this.top;
    if (a && a.isLeaf)
      this.findInside(e);
    else if (i)
      this.addElement(e, r, i);
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, r));
    else {
      let l = e;
      typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement), this.findAround(e, l, !0), this.addAll(l, r), this.findAround(e, l, !1);
    }
    o && this.sync(s) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, r, i) {
    let o = r || 0;
    for (let a = r ? e.childNodes[r] : e.firstChild, s = i == null ? null : e.childNodes[i]; a != s; a = a.nextSibling, ++o)
      this.findAtPoint(e, o), this.addDOM(a, n);
    this.findAtPoint(e, o);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, n) {
    let r, i;
    for (let o = this.open; o >= 0; o--) {
      let a = this.nodes[o], s = a.findWrapping(e);
      if (s && (!r || r.length > s.length) && (r = s, i = a, !s.length) || a.solid)
        break;
    }
    if (!r)
      return null;
    this.sync(i);
    for (let o = 0; o < r.length; o++)
      n = this.enterInner(r[o], null, n, !1);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, n) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let i = this.textblockFromContext();
      i && (n = this.enterInner(i, null, n));
    }
    let r = this.findPlace(e, n);
    if (r) {
      this.closeExtra();
      let i = this.top;
      i.match && (i.match = i.match.matchType(e.type));
      let o = tn.none;
      for (let a of r.concat(e.marks))
        (i.type ? i.type.allowsMarkType(a.type) : gk(a.type, e.type)) && (o = a.addToSet(o));
      return i.content.push(e.mark(o)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, r, i) {
    let o = this.findPlace(e.create(n), r);
    return o && (o = this.enterInner(e, n, r, !0, i)), o;
  }
  // Open a node of the given type
  enterInner(e, n, r, i = !1, o) {
    this.closeExtra();
    let a = this.top;
    a.match = a.match && a.match.matchType(e);
    let s = hk(e, o, a.options);
    a.options & Rp && a.content.length == 0 && (s |= Rp);
    let l = tn.none;
    return r = r.filter((c) => (a.type ? a.type.allowsMarkType(c.type) : gk(c.type, e)) ? (l = c.addToSet(l), !1) : !0), this.nodes.push(new Hg(e, n, l, i, null, s)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == e)
        return this.open = n, !0;
      this.localPreserveWS && (this.nodes[n].options |= Kp);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let i = r.length - 1; i >= 0; i--)
        e += r[i].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, r) {
    if (e != n && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), o = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), a = (s, l) => {
      for (; s >= 0; s--) {
        let c = n[s];
        if (c == "") {
          if (s == n.length - 1 || s == 0)
            continue;
          for (; l >= o; l--)
            if (a(s - 1, l))
              return !0;
          return !1;
        } else {
          let u = l > 0 || l == 0 && i ? this.nodes[l].type : r && l >= o ? r.node(l - o).type : null;
          if (!u || u.name != c && !u.isInGroup(c))
            return !1;
          l--;
        }
      }
      return !0;
    };
    return a(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function iz(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && IF.hasOwnProperty(r) && n ? (n.appendChild(e), e = n) : r == "li" ? n = e : r && (n = null);
  }
}
function oz(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function mk(t) {
  let e = {};
  for (let n in t)
    e[n] = t[n];
  return e;
}
function gk(t, e) {
  let n = e.schema.nodes;
  for (let r in n) {
    let i = n[r];
    if (!i.allowsMarkType(t))
      continue;
    let o = [], a = (s) => {
      o.push(s);
      for (let l = 0; l < s.edgeCount; l++) {
        let { type: c, next: u } = s.edge(l);
        if (c == e || o.indexOf(u) < 0 && a(u))
          return !0;
      }
    };
    if (a(i.contentMatch))
      return !0;
  }
}
class uu {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, r) {
    r || (r = Rw(n).createDocumentFragment());
    let i = r, o = [];
    return e.forEach((a) => {
      if (o.length || a.marks.length) {
        let s = 0, l = 0;
        for (; s < o.length && l < a.marks.length; ) {
          let c = a.marks[l];
          if (!this.marks[c.type.name]) {
            l++;
            continue;
          }
          if (!c.eq(o[s][0]) || c.type.spec.spanning === !1)
            break;
          s++, l++;
        }
        for (; s < o.length; )
          i = o.pop()[1];
        for (; l < a.marks.length; ) {
          let c = a.marks[l++], u = this.serializeMark(c, a.isInline, n);
          u && (o.push([c, i]), i.appendChild(u.dom), i = u.contentDOM || u.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(a, n));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: r, contentDOM: i } = Ly(Rw(n), this.nodes[e.type.name](e), null, e.attrs);
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let r = this.serializeNodeInner(e, n);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let o = this.serializeMark(e.marks[i], e.isInline, n);
      o && ((o.contentDOM || o.dom).appendChild(r), r = o.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, n, r = {}) {
    let i = this.marks[e.type.name];
    return i && Ly(Rw(r), i(e, n), null, e.attrs);
  }
  static renderSpec(e, n, r = null, i) {
    return Ly(e, n, r, i);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new uu(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = yk(e.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return yk(e.marks);
  }
}
function yk(t) {
  let e = {};
  for (let n in t) {
    let r = t[n].spec.toDOM;
    r && (e[n] = r);
  }
  return e;
}
function Rw(t) {
  return t.document || window.document;
}
const bk = /* @__PURE__ */ new WeakMap();
function az(t) {
  let e = bk.get(t);
  return e === void 0 && bk.set(t, e = sz(t)), e;
}
function sz(t) {
  let e = null;
  function n(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          e || (e = []), e.push(r);
        else
          for (let i = 0; i < r.length; i++)
            n(r[i]);
      else
        for (let i in r)
          n(r[i]);
  }
  return n(t), e;
}
function Ly(t, e, n, r) {
  if (typeof e == "string")
    return { dom: t.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let i = e[0], o;
  if (typeof i != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (o = az(r)) && o.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let a = i.indexOf(" ");
  a > 0 && (n = i.slice(0, a), i = i.slice(a + 1));
  let s, l = n ? t.createElementNS(n, i) : t.createElement(i), c = e[1], u = 1;
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    u = 2;
    for (let d in c)
      if (c[d] != null) {
        let f = d.indexOf(" ");
        f > 0 ? l.setAttributeNS(d.slice(0, f), d.slice(f + 1), c[d]) : l.setAttribute(d, c[d]);
      }
  }
  for (let d = u; d < e.length; d++) {
    let f = e[d];
    if (f === 0) {
      if (d < e.length - 1 || d > u)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: p, contentDOM: m } = Ly(t, f, n, r);
      if (l.appendChild(p), m) {
        if (s)
          throw new RangeError("Multiple content holes");
        s = m;
      }
    }
  }
  return { dom: l, contentDOM: s };
}
const OF = 65535, FF = Math.pow(2, 16);
function lz(t, e) {
  return t + e * FF;
}
function vk(t) {
  return t & OF;
}
function cz(t) {
  return (t - (t & OF)) / FF;
}
const UF = 1, NF = 2, Py = 4, MF = 8;
class oS {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.delInfo = n, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & MF) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (UF | Py)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (NF | Py)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & Py) > 0;
  }
}
class Ti {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (this.ranges = e, this.inverted = n, !e.length && Ti.empty)
      return Ti.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, r = vk(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + n + cz(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let i = 0, o = this.inverted ? 2 : 1, a = this.inverted ? 1 : 2;
    for (let s = 0; s < this.ranges.length; s += 3) {
      let l = this.ranges[s] - (this.inverted ? i : 0);
      if (l > e)
        break;
      let c = this.ranges[s + o], u = this.ranges[s + a], d = l + c;
      if (e <= d) {
        let f = c ? e == l ? -1 : e == d ? 1 : n : n, p = l + i + (f < 0 ? 0 : u);
        if (r)
          return p;
        let m = e == (n < 0 ? l : d) ? null : lz(s / 3, e - l), g = e == l ? NF : e == d ? UF : Py;
        return (n < 0 ? e != l : e != d) && (g |= MF), new oS(p, g, m);
      }
      i += u - c;
    }
    return r ? e + i : new oS(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let r = 0, i = vk(n), o = this.inverted ? 2 : 1, a = this.inverted ? 1 : 2;
    for (let s = 0; s < this.ranges.length; s += 3) {
      let l = this.ranges[s] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let c = this.ranges[s + o], u = l + c;
      if (e <= u && s == i * 3)
        return !0;
      r += this.ranges[s + a] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, o = 0; i < this.ranges.length; i += 3) {
      let a = this.ranges[i], s = a - (this.inverted ? o : 0), l = a + (this.inverted ? 0 : o), c = this.ranges[i + n], u = this.ranges[i + r];
      e(s, s + c, l, l + u), o += u - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Ti(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Ti.empty : new Ti(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
Ti.empty = new Ti([]);
class Qd {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e = [], n, r = 0, i = e.length) {
    this.maps = e, this.mirror = n, this.from = r, this.to = i;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new Qd(this.maps, this.mirror, e, n);
  }
  /**
  @internal
  */
  copy() {
    return new Qd(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    this.to = this.maps.push(e), n != null && this.setMirror(this.maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
      let i = e.getMirror(n);
      this.appendMap(e.maps[n], i != null && i < n ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, r = this.maps.length + e.maps.length; n >= 0; n--) {
      let i = e.getMirror(n);
      this.appendMap(e.maps[n].invert(), i != null && i > n ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new Qd();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror)
      return this._map(e, n, !0);
    for (let r = this.from; r < this.to; r++)
      e = this.maps[r].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let i = 0;
    for (let o = this.from; o < this.to; o++) {
      let a = this.maps[o], s = a.mapResult(e, n);
      if (s.recover != null) {
        let l = this.getMirror(o);
        if (l != null && l > o && l < this.to) {
          o = l, e = this.maps[l].recover(s.recover);
          continue;
        }
      }
      i |= s.delInfo, e = s.pos;
    }
    return r ? e : new oS(e, i, null);
  }
}
const Iw = /* @__PURE__ */ Object.create(null);
class Er {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Ti.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = Iw[n.stepType];
    if (!r)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in Iw)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return Iw[e] = n, n.prototype.jsonID = e, n;
  }
}
class On {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new On(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new On(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, r, i) {
    try {
      return On.ok(e.replace(n, r, i));
    } catch (o) {
      if (o instanceof pb)
        return On.fail(o.message);
      throw o;
    }
  }
}
function YT(t, e, n) {
  let r = [];
  for (let i = 0; i < t.childCount; i++) {
    let o = t.child(i);
    o.content.size && (o = o.copy(YT(o.content, e, o))), o.isInline && (o = e(o, n, i)), r.push(o);
  }
  return ze.fromArray(r);
}
class hl extends Er {
  /**
  Create a mark step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), o = new Xe(YT(n.content, (a, s) => !a.isAtom || !s.type.allowsMarkType(this.mark.type) ? a : a.mark(this.mark.addToSet(a.marks)), i), n.openStart, n.openEnd);
    return On.fromReplace(e, this.from, this.to, o);
  }
  invert() {
    return new ia(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new hl(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof hl && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new hl(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new hl(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Er.jsonID("addMark", hl);
class ia extends Er {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = new Xe(YT(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), n.openStart, n.openEnd);
    return On.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new hl(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new ia(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof ia && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ia(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new ia(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Er.jsonID("removeMark", ia);
class pl extends Er {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return On.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return On.fromReplace(e, this.pos, this.pos + 1, new Xe(ze.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let i = 0; i < n.marks.length; i++)
          if (!n.marks[i].isInSet(r))
            return new pl(this.pos, n.marks[i]);
        return new pl(this.pos, this.mark);
      }
    }
    return new gf(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new pl(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new pl(n.pos, e.markFromJSON(n.mark));
  }
}
Er.jsonID("addNodeMark", pl);
class gf extends Er {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return On.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return On.fromReplace(e, this.pos, this.pos + 1, new Xe(ze.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new pl(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new gf(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new gf(n.pos, e.markFromJSON(n.mark));
  }
}
Er.jsonID("removeNodeMark", gf);
class qn extends Er {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, r, i = !1) {
    super(), this.from = e, this.to = n, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && aS(e, this.from, this.to) ? On.fail("Structure replace would overwrite content") : On.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Ti([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new qn(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross ? null : new qn(n.pos, Math.max(n.pos, r.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof qn) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? Xe.empty : new Xe(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new qn(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? Xe.empty : new Xe(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new qn(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new qn(n.from, n.to, Xe.fromJSON(e, n.slice), !!n.structure);
  }
}
Er.jsonID("replace", qn);
class Gn extends Er {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, r, i, o, a, s = !1) {
    super(), this.from = e, this.to = n, this.gapFrom = r, this.gapTo = i, this.slice = o, this.insert = a, this.structure = s;
  }
  apply(e) {
    if (this.structure && (aS(e, this.from, this.gapFrom) || aS(e, this.gapTo, this.to)))
      return On.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return On.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r ? On.fromReplace(e, this.from, this.to, r) : On.fail("Content does not fit in gap");
  }
  getMap() {
    return new Ti([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new Gn(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), o = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return n.deletedAcross && r.deletedAcross || i < n.pos || o > r.pos ? null : new Gn(n.pos, r.pos, i, o, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Gn(n.from, n.to, n.gapFrom, n.gapTo, Xe.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
}
Er.jsonID("replaceAround", Gn);
function aS(t, e, n) {
  let r = t.resolve(e), i = n - e, o = r.depth;
  for (; i > 0 && o > 0 && r.indexAfter(o) == r.node(o).childCount; )
    o--, i--;
  if (i > 0) {
    let a = r.node(o).maybeChild(r.indexAfter(o));
    for (; i > 0; ) {
      if (!a || a.isLeaf)
        return !0;
      a = a.firstChild, i--;
    }
  }
  return !1;
}
function uz(t, e, n, r) {
  let i = [], o = [], a, s;
  t.doc.nodesBetween(e, n, (l, c, u) => {
    if (!l.isInline)
      return;
    let d = l.marks;
    if (!r.isInSet(d) && u.type.allowsMarkType(r.type)) {
      let f = Math.max(c, e), p = Math.min(c + l.nodeSize, n), m = r.addToSet(d);
      for (let g = 0; g < d.length; g++)
        d[g].isInSet(m) || (a && a.to == f && a.mark.eq(d[g]) ? a.to = p : i.push(a = new ia(f, p, d[g])));
      s && s.to == f ? s.to = p : o.push(s = new hl(f, p, r));
    }
  }), i.forEach((l) => t.step(l)), o.forEach((l) => t.step(l));
}
function dz(t, e, n, r) {
  let i = [], o = 0;
  t.doc.nodesBetween(e, n, (a, s) => {
    if (!a.isInline)
      return;
    o++;
    let l = null;
    if (r instanceof Yv) {
      let c = a.marks, u;
      for (; u = r.isInSet(c); )
        (l || (l = [])).push(u), c = u.removeFromSet(c);
    } else r ? r.isInSet(a.marks) && (l = [r]) : l = a.marks;
    if (l && l.length) {
      let c = Math.min(s + a.nodeSize, n);
      for (let u = 0; u < l.length; u++) {
        let d = l[u], f;
        for (let p = 0; p < i.length; p++) {
          let m = i[p];
          m.step == o - 1 && d.eq(i[p].style) && (f = m);
        }
        f ? (f.to = c, f.step = o) : i.push({ style: d, from: Math.max(s, e), to: c, step: o });
      }
    }
  }), i.forEach((a) => t.step(new ia(a.from, a.to, a.style)));
}
function JT(t, e, n, r = n.contentMatch, i = !0) {
  let o = t.doc.nodeAt(e), a = [], s = e + 1;
  for (let l = 0; l < o.childCount; l++) {
    let c = o.child(l), u = s + c.nodeSize, d = r.matchType(c.type);
    if (!d)
      a.push(new qn(s, u, Xe.empty));
    else {
      r = d;
      for (let f = 0; f < c.marks.length; f++)
        n.allowsMarkType(c.marks[f].type) || t.step(new ia(s, u, c.marks[f]));
      if (i && c.isText && n.whitespace != "pre") {
        let f, p = /\r?\n|\r/g, m;
        for (; f = p.exec(c.text); )
          m || (m = new Xe(ze.from(n.schema.text(" ", n.allowedMarks(c.marks))), 0, 0)), a.push(new qn(s + f.index, s + f.index + f[0].length, m));
      }
    }
    s = u;
  }
  if (!r.validEnd) {
    let l = r.fillBefore(ze.empty, !0);
    t.replace(s, s, new Xe(l, 0, 0));
  }
  for (let l = a.length - 1; l >= 0; l--)
    t.step(a[l]);
}
function fz(t, e, n) {
  return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n));
}
function Hf(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let r = t.depth; ; --r) {
    let i = t.$from.node(r), o = t.$from.index(r), a = t.$to.indexAfter(r);
    if (r < t.depth && i.canReplace(o, a, n))
      return r;
    if (r == 0 || i.type.spec.isolating || !fz(i, o, a))
      break;
  }
  return null;
}
function hz(t, e, n) {
  let { $from: r, $to: i, depth: o } = e, a = r.before(o + 1), s = i.after(o + 1), l = a, c = s, u = ze.empty, d = 0;
  for (let m = o, g = !1; m > n; m--)
    g || r.index(m) > 0 ? (g = !0, u = ze.from(r.node(m).copy(u)), d++) : l--;
  let f = ze.empty, p = 0;
  for (let m = o, g = !1; m > n; m--)
    g || i.after(m + 1) < i.end(m) ? (g = !0, f = ze.from(i.node(m).copy(f)), p++) : c++;
  t.step(new Gn(l, c, a, s, new Xe(u.append(f), d, p), u.size - d, !0));
}
function ZT(t, e, n = null, r = t) {
  let i = pz(t, e), o = i && mz(r, e);
  return o ? i.map(wk).concat({ type: e, attrs: n }).concat(o.map(wk)) : null;
}
function wk(t) {
  return { type: t, attrs: null };
}
function pz(t, e) {
  let { parent: n, startIndex: r, endIndex: i } = t, o = n.contentMatchAt(r).findWrapping(e);
  if (!o)
    return null;
  let a = o.length ? o[0] : e;
  return n.canReplaceWith(r, i, a) ? o : null;
}
function mz(t, e) {
  let { parent: n, startIndex: r, endIndex: i } = t, o = n.child(r), a = e.contentMatch.findWrapping(o.type);
  if (!a)
    return null;
  let l = (a.length ? a[a.length - 1] : e).contentMatch;
  for (let c = r; l && c < i; c++)
    l = l.matchType(n.child(c).type);
  return !l || !l.validEnd ? null : a;
}
function gz(t, e, n) {
  let r = ze.empty;
  for (let a = n.length - 1; a >= 0; a--) {
    if (r.size) {
      let s = n[a].type.contentMatch.matchFragment(r);
      if (!s || !s.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = ze.from(n[a].type.create(n[a].attrs, r));
  }
  let i = e.start, o = e.end;
  t.step(new Gn(i, o, i, o, new Xe(r, 0, 0), n.length, !0));
}
function yz(t, e, n, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let o = t.steps.length;
  t.doc.nodesBetween(e, n, (a, s) => {
    let l = typeof i == "function" ? i(a) : i;
    if (a.isTextblock && !a.hasMarkup(r, l) && bz(t.doc, t.mapping.slice(o).map(s), r)) {
      let c = null;
      if (r.schema.linebreakReplacement) {
        let p = r.whitespace == "pre", m = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        p && !m ? c = !1 : !p && m && (c = !0);
      }
      c === !1 && LF(t, a, s, o), JT(t, t.mapping.slice(o).map(s, 1), r, void 0, c === null);
      let u = t.mapping.slice(o), d = u.map(s, 1), f = u.map(s + a.nodeSize, 1);
      return t.step(new Gn(d, f, d + 1, f - 1, new Xe(ze.from(r.create(l, null, a.marks)), 0, 0), 1, !0)), c === !0 && BF(t, a, s, o), !1;
    }
  });
}
function BF(t, e, n, r) {
  e.forEach((i, o) => {
    if (i.isText) {
      let a, s = /\r?\n|\r/g;
      for (; a = s.exec(i.text); ) {
        let l = t.mapping.slice(r).map(n + 1 + o + a.index);
        t.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function LF(t, e, n, r) {
  e.forEach((i, o) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let a = t.mapping.slice(r).map(n + 1 + o);
      t.replaceWith(a, a + 1, e.type.schema.text(`
`));
    }
  });
}
function bz(t, e, n) {
  let r = t.resolve(e), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, n);
}
function vz(t, e, n, r, i) {
  let o = t.doc.nodeAt(e);
  if (!o)
    throw new RangeError("No node at given position");
  n || (n = o.type);
  let a = n.create(r, null, i || o.marks);
  if (o.isLeaf)
    return t.replaceWith(e, e + o.nodeSize, a);
  if (!n.validContent(o.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(new Gn(e, e + o.nodeSize, e + 1, e + o.nodeSize - 1, new Xe(ze.from(a), 0, 0), 1, !0));
}
function ef(t, e, n = 1, r) {
  let i = t.resolve(e), o = i.depth - n, a = r && r[r.length - 1] || i.parent;
  if (o < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !a.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let c = i.depth - 1, u = n - 2; c > o; c--, u--) {
    let d = i.node(c), f = i.index(c);
    if (d.type.spec.isolating)
      return !1;
    let p = d.content.cutByIndex(f, d.childCount), m = r && r[u + 1];
    m && (p = p.replaceChild(0, m.type.create(m.attrs)));
    let g = r && r[u] || d;
    if (!d.canReplace(f + 1, d.childCount) || !g.type.validContent(p))
      return !1;
  }
  let s = i.indexAfter(o), l = r && r[0];
  return i.node(o).canReplaceWith(s, s, l ? l.type : i.node(o + 1).type);
}
function wz(t, e, n = 1, r) {
  let i = t.doc.resolve(e), o = ze.empty, a = ze.empty;
  for (let s = i.depth, l = i.depth - n, c = n - 1; s > l; s--, c--) {
    o = ze.from(i.node(s).copy(o));
    let u = r && r[c];
    a = ze.from(u ? u.type.create(u.attrs, a) : i.node(s).copy(a));
  }
  t.step(new qn(e, e, new Xe(o.append(a), n, n), !0));
}
function Ol(t, e) {
  let n = t.resolve(e), r = n.index();
  return PF(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function xz(t, e) {
  e.content.size || t.type.compatibleContent(e.type);
  let n = t.contentMatchAt(t.childCount), { linebreakReplacement: r } = t.type.schema;
  for (let i = 0; i < e.childCount; i++) {
    let o = e.child(i), a = o.type == r ? t.type.schema.nodes.text : o.type;
    if (n = n.matchType(a), !n || !t.type.allowsMarks(o.marks))
      return !1;
  }
  return n.validEnd;
}
function PF(t, e) {
  return !!(t && e && !t.isLeaf && xz(t, e));
}
function Jv(t, e, n = -1) {
  let r = t.resolve(e);
  for (let i = r.depth; ; i--) {
    let o, a, s = r.index(i);
    if (i == r.depth ? (o = r.nodeBefore, a = r.nodeAfter) : n > 0 ? (o = r.node(i + 1), s++, a = r.node(i).maybeChild(s)) : (o = r.node(i).maybeChild(s - 1), a = r.node(i + 1)), o && !o.isTextblock && PF(o, a) && r.node(i).canReplace(s, s + 1))
      return e;
    if (i == 0)
      break;
    e = n < 0 ? r.before(i) : r.after(i);
  }
}
function _z(t, e, n) {
  let r = null, { linebreakReplacement: i } = t.doc.type.schema, o = t.doc.resolve(e - n), a = o.node().type;
  if (i && a.inlineContent) {
    let u = a.whitespace == "pre", d = !!a.contentMatch.matchType(i);
    u && !d ? r = !1 : !u && d && (r = !0);
  }
  let s = t.steps.length;
  if (r === !1) {
    let u = t.doc.resolve(e + n);
    LF(t, u.node(), u.before(), s);
  }
  a.inlineContent && JT(t, e + n - 1, a, o.node().contentMatchAt(o.index()), r == null);
  let l = t.mapping.slice(s), c = l.map(e - n);
  if (t.step(new qn(c, l.map(e + n, -1), Xe.empty, !0)), r === !0) {
    let u = t.doc.resolve(c);
    BF(t, u.node(), u.before(), t.steps.length);
  }
  return t;
}
function Sz(t, e, n) {
  let r = t.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), n))
    return e;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.index(i);
      if (r.node(i).canReplaceWith(o, o, n))
        return r.before(i + 1);
      if (o > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.indexAfter(i);
      if (r.node(i).canReplaceWith(o, o, n))
        return r.after(i + 1);
      if (o < r.node(i).childCount)
        return null;
    }
  return null;
}
function WF(t, e, n) {
  let r = t.resolve(e);
  if (!n.content.size)
    return e;
  let i = n.content;
  for (let o = 0; o < n.openStart; o++)
    i = i.firstChild.content;
  for (let o = 1; o <= (n.openStart == 0 && n.size ? 2 : 1); o++)
    for (let a = r.depth; a >= 0; a--) {
      let s = a == r.depth ? 0 : r.pos <= (r.start(a + 1) + r.end(a + 1)) / 2 ? -1 : 1, l = r.index(a) + (s > 0 ? 1 : 0), c = r.node(a), u = !1;
      if (o == 1)
        u = c.canReplace(l, l, i);
      else {
        let d = c.contentMatchAt(l).findWrapping(i.firstChild.type);
        u = d && c.canReplaceWith(l, l, d[0]);
      }
      if (u)
        return s == 0 ? r.pos : s < 0 ? r.before(a + 1) : r.after(a + 1);
    }
  return null;
}
function Zv(t, e, n = e, r = Xe.empty) {
  if (e == n && !r.size)
    return null;
  let i = t.resolve(e), o = t.resolve(n);
  return zF(i, o, r) ? new qn(e, n, r) : new Tz(i, o, r).fit();
}
function zF(t, e, n) {
  return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
}
class Tz {
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = ze.empty;
    for (let i = 0; i <= e.depth; i++) {
      let o = e.node(i);
      this.frontier.push({
        type: o.type,
        match: o.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = ze.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!i)
      return null;
    let o = this.placed, a = r.depth, s = i.depth;
    for (; a && s && o.childCount == 1; )
      o = o.firstChild.content, a--, s--;
    let l = new Xe(o, a, s);
    return e > -1 ? new Gn(r.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || r.pos != this.$to.pos ? new qn(r.pos, i.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let o = n.firstChild;
      if (n.childCount > 1 && (i = 0), o.type.spec.isolating && i <= r) {
        e = r;
        break;
      }
      n = o.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, o = null;
        r ? (o = Ow(this.unplaced.content, r - 1).firstChild, i = o.content) : i = this.unplaced.content;
        let a = i.firstChild;
        for (let s = this.depth; s >= 0; s--) {
          let { type: l, match: c } = this.frontier[s], u, d = null;
          if (n == 1 && (a ? c.matchType(a.type) || (d = c.fillBefore(ze.from(a), !1)) : o && l.compatibleContent(o.type)))
            return { sliceDepth: r, frontierDepth: s, parent: o, inject: d };
          if (n == 2 && a && (u = c.findWrapping(a.type)))
            return { sliceDepth: r, frontierDepth: s, parent: o, wrap: u };
          if (o && c.matchType(o.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, i = Ow(e, n);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new Xe(e, n + 1, Math.max(r, i.size + n >= e.size - r ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, i = Ow(e, n);
    if (i.childCount <= 1 && n > 0) {
      let o = e.size - n <= n + i.size;
      this.unplaced = new Xe(vp(e, n - 1, 1), n - 1, o ? n - 1 : r);
    } else
      this.unplaced = new Xe(vp(e, n, 1), n, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: r, inject: i, wrap: o }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (o)
      for (let g = 0; g < o.length; g++)
        this.openFrontierNode(o[g]);
    let a = this.unplaced, s = r ? r.content : a.content, l = a.openStart - e, c = 0, u = [], { match: d, type: f } = this.frontier[n];
    if (i) {
      for (let g = 0; g < i.childCount; g++)
        u.push(i.child(g));
      d = d.matchFragment(i);
    }
    let p = s.size + e - (a.content.size - a.openEnd);
    for (; c < s.childCount; ) {
      let g = s.child(c), b = d.matchType(g.type);
      if (!b)
        break;
      c++, (c > 1 || l == 0 || g.content.size) && (d = b, u.push($F(g.mark(f.allowedMarks(g.marks)), c == 1 ? l : 0, c == s.childCount ? p : -1)));
    }
    let m = c == s.childCount;
    m || (p = -1), this.placed = wp(this.placed, n, ze.from(u)), this.frontier[n].match = d, m && p < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let g = 0, b = s; g < p; g++) {
      let y = b.lastChild;
      this.frontier.push({ type: y.type, match: y.contentMatchAt(y.childCount) }), b = y.content;
    }
    this.unplaced = m ? e == 0 ? Xe.empty : new Xe(vp(a.content, e - 1, 1), e - 1, p < 0 ? a.openEnd : e - 1) : new Xe(vp(a.content, e, c), a.openStart, a.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], n;
    if (!e.type.isTextblock || !Fw(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
      let { match: r, type: i } = this.frontier[n], o = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), a = Fw(e, n, i, r, o);
      if (a) {
        for (let s = n - 1; s >= 0; s--) {
          let { match: l, type: c } = this.frontier[s], u = Fw(e, s, c, l, !0);
          if (!u || u.childCount)
            continue e;
        }
        return { depth: n, fit: a, move: o ? e.doc.resolve(e.after(n + 1)) : e };
      }
    }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = wp(this.placed, n.depth, n.fit)), e = n.move;
    for (let r = n.depth + 1; r <= e.depth; r++) {
      let i = e.node(r), o = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
      this.openFrontierNode(i.type, i.attrs, o);
    }
    return e;
  }
  openFrontierNode(e, n = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = wp(this.placed, this.depth, ze.from(e.create(n, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(ze.empty, !0);
    n.childCount && (this.placed = wp(this.placed, this.frontier.length, n));
  }
}
function vp(t, e, n) {
  return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(vp(t.firstChild.content, e - 1, n)));
}
function wp(t, e, n) {
  return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(wp(t.lastChild.content, e - 1, n)));
}
function Ow(t, e) {
  for (let n = 0; n < e; n++)
    t = t.firstChild.content;
  return t;
}
function $F(t, e, n) {
  if (e <= 0)
    return t;
  let r = t.content;
  return e > 1 && (r = r.replaceChild(0, $F(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))), e > 0 && (r = t.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(ze.empty, !0)))), t.copy(r);
}
function Fw(t, e, n, r, i) {
  let o = t.node(e), a = i ? t.indexAfter(e) : t.index(e);
  if (a == o.childCount && !n.compatibleContent(o.type))
    return null;
  let s = r.fillBefore(o.content, !0, a);
  return s && !Dz(n, o.content, a) ? s : null;
}
function Dz(t, e, n) {
  for (let r = n; r < e.childCount; r++)
    if (!t.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function Ez(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function Cz(t, e, n, r) {
  if (!r.size)
    return t.deleteRange(e, n);
  let i = t.doc.resolve(e), o = t.doc.resolve(n);
  if (zF(i, o, r))
    return t.step(new qn(e, n, r));
  let a = jF(i, t.doc.resolve(n));
  a[a.length - 1] == 0 && a.pop();
  let s = -(i.depth + 1);
  a.unshift(s);
  for (let f = i.depth, p = i.pos - 1; f > 0; f--, p--) {
    let m = i.node(f).type.spec;
    if (m.defining || m.definingAsContext || m.isolating)
      break;
    a.indexOf(f) > -1 ? s = f : i.before(f) == p && a.splice(1, 0, -f);
  }
  let l = a.indexOf(s), c = [], u = r.openStart;
  for (let f = r.content, p = 0; ; p++) {
    let m = f.firstChild;
    if (c.push(m), p == r.openStart)
      break;
    f = m.content;
  }
  for (let f = u - 1; f >= 0; f--) {
    let p = c[f], m = Ez(p.type);
    if (m && !p.sameMarkup(i.node(Math.abs(s) - 1)))
      u = f;
    else if (m || !p.type.isTextblock)
      break;
  }
  for (let f = r.openStart; f >= 0; f--) {
    let p = (f + u + 1) % (r.openStart + 1), m = c[p];
    if (m)
      for (let g = 0; g < a.length; g++) {
        let b = a[(g + l) % a.length], y = !0;
        b < 0 && (y = !1, b = -b);
        let w = i.node(b - 1), x = i.index(b - 1);
        if (w.canReplaceWith(x, x, m.type, m.marks))
          return t.replace(i.before(b), y ? o.after(b) : n, new Xe(HF(r.content, 0, r.openStart, p), p, r.openEnd));
      }
  }
  let d = t.steps.length;
  for (let f = a.length - 1; f >= 0 && (t.replace(e, n, r), !(t.steps.length > d)); f--) {
    let p = a[f];
    p < 0 || (e = i.before(p), n = o.after(p));
  }
}
function HF(t, e, n, r, i) {
  if (e < n) {
    let o = t.firstChild;
    t = t.replaceChild(0, o.copy(HF(o.content, e + 1, n, r, o)));
  }
  if (e > r) {
    let o = i.contentMatchAt(0), a = o.fillBefore(t).append(t);
    t = a.append(o.matchFragment(a).fillBefore(ze.empty, !0));
  }
  return t;
}
function kz(t, e, n, r) {
  if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let i = Sz(t.doc, e, r.type);
    i != null && (e = n = i);
  }
  t.replaceRange(e, n, new Xe(ze.from(r), 0, 0));
}
function Az(t, e, n) {
  let r = t.doc.resolve(e), i = t.doc.resolve(n), o = jF(r, i);
  for (let a = 0; a < o.length; a++) {
    let s = o[a], l = a == o.length - 1;
    if (l && s == 0 || r.node(s).type.contentMatch.validEnd)
      return t.delete(r.start(s), i.end(s));
    if (s > 0 && (l || r.node(s - 1).canReplace(r.index(s - 1), i.indexAfter(s - 1))))
      return t.delete(r.before(s), i.after(s));
  }
  for (let a = 1; a <= r.depth && a <= i.depth; a++)
    if (e - r.start(a) == r.depth - a && n > r.end(a) && i.end(a) - n != i.depth - a && r.start(a - 1) == i.start(a - 1) && r.node(a - 1).canReplace(r.index(a - 1), i.index(a - 1)))
      return t.delete(r.before(a), n);
  t.delete(e, n);
}
function jF(t, e) {
  let n = [], r = Math.min(t.depth, e.depth);
  for (let i = r; i >= 0; i--) {
    let o = t.start(i);
    if (o < t.pos - (t.depth - i) || e.end(i) > e.pos + (e.depth - i) || t.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (o == e.start(i) || i == t.depth && i == e.depth && t.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == o - 1) && n.push(i);
  }
  return n;
}
class tf extends Er {
  /**
  Construct an attribute step.
  */
  constructor(e, n, r) {
    super(), this.pos = e, this.attr = n, this.value = r;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return On.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let o in n.attrs)
      r[o] = n.attrs[o];
    r[this.attr] = this.value;
    let i = n.type.create(r, null, n.marks);
    return On.fromReplace(e, this.pos, this.pos + 1, new Xe(ze.from(i), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return Ti.empty;
  }
  invert(e) {
    return new tf(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new tf(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new tf(n.pos, n.attr, n.value);
  }
}
Er.jsonID("attr", tf);
class Xp extends Er {
  /**
  Construct an attribute step.
  */
  constructor(e, n) {
    super(), this.attr = e, this.value = n;
  }
  apply(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let i in e.attrs)
      n[i] = e.attrs[i];
    n[this.attr] = this.value;
    let r = e.type.create(n, e.content, e.marks);
    return On.ok(r);
  }
  getMap() {
    return Ti.empty;
  }
  invert(e) {
    return new Xp(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new Xp(n.attr, n.value);
  }
}
Er.jsonID("docAttr", Xp);
let yf = class extends Error {
};
yf = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
yf.prototype = Object.create(Error.prototype);
yf.prototype.constructor = yf;
yf.prototype.name = "TransformError";
class QT {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new Qd();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed)
      throw new yf(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, r = Xe.empty) {
    let i = Zv(this.doc, e, n, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, r) {
    return this.replace(e, n, new Xe(ze.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, Xe.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, r) {
    return Cz(this, e, n, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, r) {
    return kz(this, e, n, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return Az(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return hz(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return _z(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return gz(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, r, i = null) {
    return yz(this, e, n, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, r = null, i) {
    return vz(this, e, n, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, n, r) {
    return this.step(new tf(e, n, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, n) {
    return this.step(new Xp(e, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new pl(e, n)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    if (!(n instanceof tn)) {
      let r = this.doc.nodeAt(e);
      if (!r)
        throw new RangeError("No node at position " + e);
      if (n = n.isInSet(r.marks), !n)
        return this;
    }
    return this.step(new gf(e, n)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(e, n = 1, r) {
    return wz(this, e, n, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, r) {
    return uz(this, e, n, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, r) {
    return dz(this, e, n, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, r) {
    return JT(this, e, n, r), this;
  }
}
const Uw = /* @__PURE__ */ Object.create(null);
let dt = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, n, r) {
    this.$anchor = e, this.$head = n, this.ranges = r || [new eD(e.min(n), e.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, n = Xe.empty) {
    let r = n.content.lastChild, i = null;
    for (let s = 0; s < n.openEnd; s++)
      i = r, r = r.lastChild;
    let o = e.steps.length, a = this.ranges;
    for (let s = 0; s < a.length; s++) {
      let { $from: l, $to: c } = a[s], u = e.mapping.slice(o);
      e.replaceRange(u.map(l.pos), u.map(c.pos), s ? Xe.empty : n), s == 0 && Sk(e, o, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, n) {
    let r = e.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      let { $from: a, $to: s } = i[o], l = e.mapping.slice(r), c = l.map(a.pos), u = l.map(s.pos);
      o ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, n), Sk(e, r, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, n, r = !1) {
    let i = e.parent.inlineContent ? new ot(e) : Wd(e.node(0), e.parent, e.pos, e.index(), n, r);
    if (i)
      return i;
    for (let o = e.depth - 1; o >= 0; o--) {
      let a = n < 0 ? Wd(e.node(0), e.node(o), e.before(o + 1), e.index(o), n, r) : Wd(e.node(0), e.node(o), e.after(o + 1), e.index(o) + 1, n, r);
      if (a)
        return a;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new Ci(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return Wd(e, e, 0, 0, 1) || new Ci(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return Wd(e, e, e.content.size, e.childCount, -1) || new Ci(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = Uw[n.type];
    if (!r)
      throw new RangeError(`No selection type ${n.type} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, n) {
    if (e in Uw)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return Uw[e] = n, n.prototype.jsonID = e, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return ot.between(this.$anchor, this.$head).getBookmark();
  }
};
dt.prototype.visible = !0;
class eD {
  /**
  Create a range.
  */
  constructor(e, n) {
    this.$from = e, this.$to = n;
  }
}
let xk = !1;
function _k(t) {
  !xk && !t.parent.inlineContent && (xk = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"));
}
class ot extends dt {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, n = e) {
    _k(e), _k(n), super(e, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    if (!r.parent.inlineContent)
      return dt.near(r);
    let i = e.resolve(n.map(this.anchor));
    return new ot(i.parent.inlineContent ? i : r, r);
  }
  replace(e, n = Xe.empty) {
    if (super.replace(e, n), n == Xe.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof ot && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new Qv(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new ot(e.resolve(n.anchor), e.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, n, r = n) {
    let i = e.resolve(n);
    return new this(i, r == n ? i : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, n, r) {
    let i = e.pos - n.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let o = dt.findFrom(n, r, !0) || dt.findFrom(n, -r, !0);
      if (o)
        n = o.$head;
      else
        return dt.near(n, r);
    }
    return e.parent.inlineContent || (i == 0 ? e = n : (e = (dt.findFrom(e, -r, !0) || dt.findFrom(e, r, !0)).$anchor, e.pos < n.pos != i < 0 && (e = n))), new ot(e, n);
  }
}
dt.jsonID("text", ot);
class Qv {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new Qv(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return ot.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class st extends dt {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let n = e.nodeAfter, r = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, r), this.node = n;
  }
  map(e, n) {
    let { deleted: r, pos: i } = n.mapResult(this.anchor), o = e.resolve(i);
    return r ? dt.near(o) : new st(o);
  }
  content() {
    return new Xe(ze.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof st && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new tD(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new st(e.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, n) {
    return new st(e.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
st.prototype.visible = !1;
dt.jsonID("node", st);
class tD {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: r } = e.mapResult(this.anchor);
    return n ? new Qv(r, r) : new tD(r);
  }
  resolve(e) {
    let n = e.resolve(this.anchor), r = n.nodeAfter;
    return r && st.isSelectable(r) ? new st(n) : dt.near(n);
  }
}
class Ci extends dt {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = Xe.empty) {
    if (n == Xe.empty) {
      e.delete(0, e.doc.content.size);
      let r = dt.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new Ci(e);
  }
  map(e) {
    return new Ci(e);
  }
  eq(e) {
    return e instanceof Ci;
  }
  getBookmark() {
    return Rz;
  }
}
dt.jsonID("all", Ci);
const Rz = {
  map() {
    return this;
  },
  resolve(t) {
    return new Ci(t);
  }
};
function Wd(t, e, n, r, i, o = !1) {
  if (e.inlineContent)
    return ot.create(t, n);
  for (let a = r - (i > 0 ? 0 : 1); i > 0 ? a < e.childCount : a >= 0; a += i) {
    let s = e.child(a);
    if (s.isAtom) {
      if (!o && st.isSelectable(s))
        return st.create(t, n - (i < 0 ? s.nodeSize : 0));
    } else {
      let l = Wd(t, s, n + i, i < 0 ? s.childCount : 0, i, o);
      if (l)
        return l;
    }
    n += s.nodeSize * i;
  }
  return null;
}
function Sk(t, e, n) {
  let r = t.steps.length - 1;
  if (r < e)
    return;
  let i = t.steps[r];
  if (!(i instanceof qn || i instanceof Gn))
    return;
  let o = t.mapping.maps[r], a;
  o.forEach((s, l, c, u) => {
    a == null && (a = u);
  }), t.setSelection(dt.near(t.doc.resolve(a), n));
}
const Tk = 1, jg = 2, Dk = 4;
let Iz = class extends QT {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Tk) & ~jg, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & Tk) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= jg, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return tn.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & jg) > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    super.addStep(e, n), this.updated = this.updated & ~jg, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, n = !0) {
    let r = this.selection;
    return n && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || tn.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, n, r) {
    let i = this.doc.type.schema;
    if (n == null)
      return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = n), r = r ?? n, !e)
        return this.deleteRange(n, r);
      let o = this.storedMarks;
      if (!o) {
        let a = this.doc.resolve(n);
        o = r == n ? a.marks() : a.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(n, r, i.text(e, o)), this.selection.empty || this.setSelection(dt.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, n) {
    return this.meta[typeof e == "string" ? e : e.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= Dk, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & Dk) > 0;
  }
};
function Ek(t, e) {
  return !e || !t ? t : t.bind(e);
}
class xp {
  constructor(e, n, r) {
    this.name = e, this.init = Ek(n.init, r), this.apply = Ek(n.apply, r);
  }
}
const Oz = [
  new xp("doc", {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply(t) {
      return t.doc;
    }
  }),
  new xp("selection", {
    init(t, e) {
      return t.selection || dt.atStart(e.doc);
    },
    apply(t) {
      return t.selection;
    }
  }),
  new xp("storedMarks", {
    init(t) {
      return t.storedMarks || null;
    },
    apply(t, e, n, r) {
      return r.selection.$cursor ? t.storedMarks : null;
    }
  }),
  new xp("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    }
  })
];
class Nw {
  constructor(e, n) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = Oz.slice(), n && n.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new xp(r.key, r.spec.state, r));
    });
  }
}
class Kd {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let n = [e], r = this.applyInner(e), i = null;
    for (; ; ) {
      let o = !1;
      for (let a = 0; a < this.config.plugins.length; a++) {
        let s = this.config.plugins[a];
        if (s.spec.appendTransaction) {
          let l = i ? i[a].n : 0, c = i ? i[a].state : this, u = l < n.length && s.spec.appendTransaction.call(s, l ? n.slice(l) : n, c, r);
          if (u && r.filterTransaction(u, a)) {
            if (u.setMeta("appendedTransaction", e), !i) {
              i = [];
              for (let d = 0; d < this.config.plugins.length; d++)
                i.push(d < a ? { state: r, n: n.length } : { state: this, n: 0 });
            }
            n.push(u), r = r.applyInner(u), o = !0;
          }
          i && (i[a] = { state: r, n: n.length });
        }
      }
      if (!o)
        return { state: r, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new Kd(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let o = r[i];
      n[o.name] = o.apply(e, this[o.name], this, n);
    }
    return n;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Iz(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let n = new Nw(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new Kd(n);
    for (let i = 0; i < n.fields.length; i++)
      r[n.fields[i].name] = n.fields[i].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let n = new Nw(this.schema, e.plugins), r = n.fields, i = new Kd(n);
    for (let o = 0; o < r.length; o++) {
      let a = r[o].name;
      i[a] = this.hasOwnProperty(a) ? this[a] : r[o].init(e, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[r], o = i.spec.state;
        o && o.toJSON && (n[r] = o.toJSON.call(i, this[i.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, n, r) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new Nw(e.schema, e.plugins), o = new Kd(i);
    return i.fields.forEach((a) => {
      if (a.name == "doc")
        o.doc = ns.fromJSON(e.schema, n.doc);
      else if (a.name == "selection")
        o.selection = dt.fromJSON(o.doc, n.selection);
      else if (a.name == "storedMarks")
        n.storedMarks && (o.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let s in r) {
            let l = r[s], c = l.spec.state;
            if (l.key == a.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(n, s)) {
              o[a.name] = c.fromJSON.call(l, e, n[s], o);
              return;
            }
          }
        o[a.name] = a.init(e, o);
      }
    }), o;
  }
}
function VF(t, e, n) {
  for (let r in t) {
    let i = t[r];
    i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = VF(i, e, {})), n[r] = i;
  }
  return n;
}
class Pt {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && VF(e.props, this, this.props), this.key = e.key ? e.key.key : qF("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Mw = /* @__PURE__ */ Object.create(null);
function qF(t) {
  return t in Mw ? t + "$" + ++Mw[t] : (Mw[t] = 0, t + "$");
}
class Nt {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = qF(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const ar = function(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}, Yp = function(t) {
  let e = t.assignedSlot || t.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let sS = null;
const Ya = function(t, e, n) {
  let r = sS || (sS = document.createRange());
  return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
}, Fz = function() {
  sS = null;
}, Xc = function(t, e, n, r) {
  return n && (Ck(t, e, n, r, -1) || Ck(t, e, n, r, 1));
}, Uz = /^(img|br|input|textarea|hr)$/i;
function Ck(t, e, n, r, i) {
  for (; ; ) {
    if (t == n && e == r)
      return !0;
    if (e == (i < 0 ? 0 : Zi(t))) {
      let o = t.parentNode;
      if (!o || o.nodeType != 1 || Nm(t) || Uz.test(t.nodeName) || t.contentEditable == "false")
        return !1;
      e = ar(t) + (i < 0 ? 0 : 1), t = o;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.contentEditable == "false")
        return !1;
      e = i < 0 ? Zi(t) : 0;
    } else
      return !1;
  }
}
function Zi(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Nz(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e)
      return t;
    if (t.nodeType == 1 && e > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e - 1], e = Zi(t);
    } else if (t.parentNode && !Nm(t))
      e = ar(t), t = t.parentNode;
    else
      return null;
  }
}
function Mz(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e < t.nodeValue.length)
      return t;
    if (t.nodeType == 1 && e < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e], e = 0;
    } else if (t.parentNode && !Nm(t))
      e = ar(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
function Bz(t, e, n) {
  for (let r = e == 0, i = e == Zi(t); r || i; ) {
    if (t == n)
      return !0;
    let o = ar(t);
    if (t = t.parentNode, !t)
      return !1;
    r = r && o == 0, i = i && o == Zi(t);
  }
}
function Nm(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const e1 = function(t) {
  return t.focusNode && Xc(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function Ic(t, e) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n;
}
function Lz(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function Pz(t, e, n) {
  if (t.caretPositionFromPoint)
    try {
      let r = t.caretPositionFromPoint(e, n);
      if (r)
        return { node: r.offsetNode, offset: Math.min(Zi(r.offsetNode), r.offset) };
    } catch {
    }
  if (t.caretRangeFromPoint) {
    let r = t.caretRangeFromPoint(e, n);
    if (r)
      return { node: r.startContainer, offset: Math.min(Zi(r.startContainer), r.startOffset) };
  }
}
const da = typeof navigator < "u" ? navigator : null, kk = typeof document < "u" ? document : null, Fl = da && da.userAgent || "", lS = /Edge\/(\d+)/.exec(Fl), GF = /MSIE \d/.exec(Fl), cS = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Fl), si = !!(GF || cS || lS), bl = GF ? document.documentMode : cS ? +cS[1] : lS ? +lS[1] : 0, To = !si && /gecko\/(\d+)/i.test(Fl);
To && +(/Firefox\/(\d+)/.exec(Fl) || [0, 0])[1];
const uS = !si && /Chrome\/(\d+)/.exec(Fl), yr = !!uS, KF = uS ? +uS[1] : 0, zr = !si && !!da && /Apple Computer/.test(da.vendor), bf = zr && (/Mobile\/\w+/.test(Fl) || !!da && da.maxTouchPoints > 2), Xi = bf || (da ? /Mac/.test(da.platform) : !1), Wz = da ? /Win/.test(da.platform) : !1, Ja = /Android \d/.test(Fl), Mm = !!kk && "webkitFontSmoothing" in kk.documentElement.style, zz = Mm ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function $z(t) {
  let e = t.defaultView && t.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.documentElement.clientWidth,
    top: 0,
    bottom: t.documentElement.clientHeight
  };
}
function Wa(t, e) {
  return typeof t == "number" ? t : t[e];
}
function Hz(t) {
  let e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, r = e.height / t.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * r
  };
}
function Ak(t, e, n) {
  let r = t.someProp("scrollThreshold") || 0, i = t.someProp("scrollMargin") || 5, o = t.dom.ownerDocument;
  for (let a = n || t.dom; a; a = Yp(a)) {
    if (a.nodeType != 1)
      continue;
    let s = a, l = s == o.body, c = l ? $z(o) : Hz(s), u = 0, d = 0;
    if (e.top < c.top + Wa(r, "top") ? d = -(c.top - e.top + Wa(i, "top")) : e.bottom > c.bottom - Wa(r, "bottom") && (d = e.bottom - e.top > c.bottom - c.top ? e.top + Wa(i, "top") - c.top : e.bottom - c.bottom + Wa(i, "bottom")), e.left < c.left + Wa(r, "left") ? u = -(c.left - e.left + Wa(i, "left")) : e.right > c.right - Wa(r, "right") && (u = e.right - c.right + Wa(i, "right")), u || d)
      if (l)
        o.defaultView.scrollBy(u, d);
      else {
        let f = s.scrollLeft, p = s.scrollTop;
        d && (s.scrollTop += d), u && (s.scrollLeft += u);
        let m = s.scrollLeft - f, g = s.scrollTop - p;
        e = { left: e.left - m, top: e.top - g, right: e.right - m, bottom: e.bottom - g };
      }
    if (l || /^(fixed|sticky)$/.test(getComputedStyle(a).position))
      break;
  }
}
function jz(t) {
  let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), r, i;
  for (let o = (e.left + e.right) / 2, a = n + 1; a < Math.min(innerHeight, e.bottom); a += 5) {
    let s = t.root.elementFromPoint(o, a);
    if (!s || s == t.dom || !t.dom.contains(s))
      continue;
    let l = s.getBoundingClientRect();
    if (l.top >= n - 20) {
      r = s, i = l.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: XF(t.dom) };
}
function XF(t) {
  let e = [], n = t.ownerDocument;
  for (let r = t; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n); r = Yp(r))
    ;
  return e;
}
function Vz({ refDOM: t, refTop: e, stack: n }) {
  let r = t ? t.getBoundingClientRect().top : 0;
  YF(n, r == 0 ? 0 : r - e);
}
function YF(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: r, top: i, left: o } = t[n];
    r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != o && (r.scrollLeft = o);
  }
}
let Td = null;
function qz(t) {
  if (t.setActive)
    return t.setActive();
  if (Td)
    return t.focus(Td);
  let e = XF(t);
  t.focus(Td == null ? {
    get preventScroll() {
      return Td = { preventScroll: !0 }, !0;
    }
  } : void 0), Td || (Td = !1, YF(e, 0));
}
function JF(t, e) {
  let n, r = 2e8, i, o = 0, a = e.top, s = e.top, l, c;
  for (let u = t.firstChild, d = 0; u; u = u.nextSibling, d++) {
    let f;
    if (u.nodeType == 1)
      f = u.getClientRects();
    else if (u.nodeType == 3)
      f = Ya(u).getClientRects();
    else
      continue;
    for (let p = 0; p < f.length; p++) {
      let m = f[p];
      if (m.top <= a && m.bottom >= s) {
        a = Math.max(m.bottom, a), s = Math.min(m.top, s);
        let g = m.left > e.left ? m.left - e.left : m.right < e.left ? e.left - m.right : 0;
        if (g < r) {
          n = u, r = g, i = g && n.nodeType == 3 ? {
            left: m.right < e.left ? m.right : m.left,
            top: e.top
          } : e, u.nodeType == 1 && g && (o = d + (e.left >= (m.left + m.right) / 2 ? 1 : 0));
          continue;
        }
      } else m.top > e.top && !l && m.left <= e.left && m.right >= e.left && (l = u, c = { left: Math.max(m.left, Math.min(m.right, e.left)), top: m.top });
      !n && (e.left >= m.right && e.top >= m.top || e.left >= m.left && e.top >= m.bottom) && (o = d + 1);
    }
  }
  return !n && l && (n = l, i = c, r = 0), n && n.nodeType == 3 ? Gz(n, i) : !n || r && n.nodeType == 1 ? { node: t, offset: o } : JF(n, i);
}
function Gz(t, e) {
  let n = t.nodeValue.length, r = document.createRange();
  for (let i = 0; i < n; i++) {
    r.setEnd(t, i + 1), r.setStart(t, i);
    let o = nl(r, 1);
    if (o.top != o.bottom && nD(e, o))
      return { node: t, offset: i + (e.left >= (o.left + o.right) / 2 ? 1 : 0) };
  }
  return { node: t, offset: 0 };
}
function nD(t, e) {
  return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
}
function Kz(t, e) {
  let n = t.parentNode;
  return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
}
function Xz(t, e, n) {
  let { node: r, offset: i } = JF(e, n), o = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let a = r.getBoundingClientRect();
    o = a.left != a.right && n.left > (a.left + a.right) / 2 ? 1 : -1;
  }
  return t.docView.posFromDOM(r, i, o);
}
function Yz(t, e, n, r) {
  let i = -1;
  for (let o = e, a = !1; o != t.dom; ) {
    let s = t.docView.nearestDesc(o, !0), l;
    if (!s)
      return null;
    if (s.dom.nodeType == 1 && (s.node.isBlock && s.parent || !s.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((l = s.dom.getBoundingClientRect()).width || l.height) && (s.node.isBlock && s.parent && (!a && l.left > r.left || l.top > r.top ? i = s.posBefore : (!a && l.right < r.left || l.bottom < r.top) && (i = s.posAfter), a = !0), !s.contentDOM && i < 0 && !s.node.isText))
      return (s.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? s.posBefore : s.posAfter;
    o = s.dom.parentNode;
  }
  return i > -1 ? i : t.docView.posFromDOM(e, n, -1);
}
function ZF(t, e, n) {
  let r = t.childNodes.length;
  if (r && n.top < n.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - n.top) / (n.bottom - n.top)) - 2)), o = i; ; ) {
      let a = t.childNodes[o];
      if (a.nodeType == 1) {
        let s = a.getClientRects();
        for (let l = 0; l < s.length; l++) {
          let c = s[l];
          if (nD(e, c))
            return ZF(a, e, c);
        }
      }
      if ((o = (o + 1) % r) == i)
        break;
    }
  return t;
}
function Jz(t, e) {
  let n = t.dom.ownerDocument, r, i = 0, o = Pz(n, e.left, e.top);
  o && ({ node: r, offset: i } = o);
  let a = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), s;
  if (!a || !t.dom.contains(a.nodeType != 1 ? a.parentNode : a)) {
    let c = t.dom.getBoundingClientRect();
    if (!nD(e, c) || (a = ZF(t.dom, e, c), !a))
      return null;
  }
  if (zr)
    for (let c = a; r && c; c = Yp(c))
      c.draggable && (r = void 0);
  if (a = Kz(a, e), r) {
    if (To && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let u = r.childNodes[i], d;
      u.nodeName == "IMG" && (d = u.getBoundingClientRect()).right <= e.left && d.bottom > e.top && i++;
    }
    let c;
    Mm && i && r.nodeType == 1 && (c = r.childNodes[i - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && i--, r == t.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? s = t.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (s = Yz(t, r, i, e));
  }
  s == null && (s = Xz(t, a, e));
  let l = t.docView.nearestDesc(a, !0);
  return { pos: s, inside: l ? l.posAtStart - l.border : -1 };
}
function Rk(t) {
  return t.top < t.bottom || t.left < t.right;
}
function nl(t, e) {
  let n = t.getClientRects();
  if (n.length) {
    let r = n[e < 0 ? 0 : n.length - 1];
    if (Rk(r))
      return r;
  }
  return Array.prototype.find.call(n, Rk) || t.getBoundingClientRect();
}
const Zz = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function QF(t, e, n) {
  let { node: r, offset: i, atom: o } = t.docView.domFromPos(e, n < 0 ? -1 : 1), a = Mm || To;
  if (r.nodeType == 3)
    if (a && (Zz.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))) {
      let l = nl(Ya(r, i, i), n);
      if (To && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let c = nl(Ya(r, i - 1, i - 1), -1);
        if (c.top == l.top) {
          let u = nl(Ya(r, i, i + 1), -1);
          if (u.top != l.top)
            return tp(u, u.left < c.left);
        }
      }
      return l;
    } else {
      let l = i, c = i, u = n < 0 ? 1 : -1;
      return n < 0 && !i ? (c++, u = -1) : n >= 0 && i == r.nodeValue.length ? (l--, u = 1) : n < 0 ? l-- : c++, tp(nl(Ya(r, l, c), u), u < 0);
    }
  if (!t.state.doc.resolve(e - (o || 0)).parent.inlineContent) {
    if (o == null && i && (n < 0 || i == Zi(r))) {
      let l = r.childNodes[i - 1];
      if (l.nodeType == 1)
        return Bw(l.getBoundingClientRect(), !1);
    }
    if (o == null && i < Zi(r)) {
      let l = r.childNodes[i];
      if (l.nodeType == 1)
        return Bw(l.getBoundingClientRect(), !0);
    }
    return Bw(r.getBoundingClientRect(), n >= 0);
  }
  if (o == null && i && (n < 0 || i == Zi(r))) {
    let l = r.childNodes[i - 1], c = l.nodeType == 3 ? Ya(l, Zi(l) - (a ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (c)
      return tp(nl(c, 1), !1);
  }
  if (o == null && i < Zi(r)) {
    let l = r.childNodes[i];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let c = l ? l.nodeType == 3 ? Ya(l, 0, a ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (c)
      return tp(nl(c, -1), !0);
  }
  return tp(nl(r.nodeType == 3 ? Ya(r) : r, -n), n >= 0);
}
function tp(t, e) {
  if (t.width == 0)
    return t;
  let n = e ? t.left : t.right;
  return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function Bw(t, e) {
  if (t.height == 0)
    return t;
  let n = e ? t.top : t.bottom;
  return { top: n, bottom: n, left: t.left, right: t.right };
}
function eU(t, e, n) {
  let r = t.state, i = t.root.activeElement;
  r != e && t.updateState(e), i != t.dom && t.focus();
  try {
    return n();
  } finally {
    r != e && t.updateState(r), i != t.dom && i && i.focus();
  }
}
function Qz(t, e, n) {
  let r = e.selection, i = n == "up" ? r.$from : r.$to;
  return eU(t, e, () => {
    let { node: o } = t.docView.domFromPos(i.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let s = t.docView.nearestDesc(o, !0);
      if (!s)
        break;
      if (s.node.isBlock) {
        o = s.contentDOM || s.dom;
        break;
      }
      o = s.dom.parentNode;
    }
    let a = QF(t, i.pos, 1);
    for (let s = o.firstChild; s; s = s.nextSibling) {
      let l;
      if (s.nodeType == 1)
        l = s.getClientRects();
      else if (s.nodeType == 3)
        l = Ya(s, 0, s.nodeValue.length).getClientRects();
      else
        continue;
      for (let c = 0; c < l.length; c++) {
        let u = l[c];
        if (u.bottom > u.top + 1 && (n == "up" ? a.top - u.top > (u.bottom - a.top) * 2 : u.bottom - a.bottom > (a.bottom - u.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const e$ = /[\u0590-\u08ac]/;
function t$(t, e, n) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, o = !i, a = i == r.parent.content.size, s = t.domSelection();
  return s ? !e$.test(r.parent.textContent) || !s.modify ? n == "left" || n == "backward" ? o : a : eU(t, e, () => {
    let { focusNode: l, focusOffset: c, anchorNode: u, anchorOffset: d } = t.domSelectionRange(), f = s.caretBidiLevel;
    s.modify("move", n, "character");
    let p = r.depth ? t.docView.domAfterPos(r.before()) : t.dom, { focusNode: m, focusOffset: g } = t.domSelectionRange(), b = m && !p.contains(m.nodeType == 1 ? m : m.parentNode) || l == m && c == g;
    try {
      s.collapse(u, d), l && (l != u || c != d) && s.extend && s.extend(l, c);
    } catch {
    }
    return f != null && (s.caretBidiLevel = f), b;
  }) : r.pos == r.start() || r.pos == r.end();
}
let Ik = null, Ok = null, Fk = !1;
function n$(t, e, n) {
  return Ik == e && Ok == n ? Fk : (Ik = e, Ok = n, Fk = n == "up" || n == "down" ? Qz(t, e, n) : t$(t, e, n));
}
const Qi = 0, Uk = 1, Fc = 2, fa = 3;
class Bm {
  constructor(e, n, r, i) {
    this.parent = e, this.children = n, this.dom = r, this.contentDOM = i, this.dirty = Qi, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, n, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++)
      e += this.children[n].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let i = this.children[n];
      if (i == e)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let o, a;
        if (e == this.contentDOM)
          o = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          o = e.previousSibling;
        }
        for (; o && !((a = o.pmViewDesc) && a.parent == this); )
          o = o.previousSibling;
        return o ? this.posBeforeChild(a) + a.size : this.posAtStart;
      } else {
        let o, a;
        if (e == this.contentDOM)
          o = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          o = e.nextSibling;
        }
        for (; o && !((a = o.pmViewDesc) && a.parent == this); )
          o = o.nextSibling;
        return o ? this.posBeforeChild(a) : this.posAtEnd;
      }
    let i;
    if (e == this.dom && this.contentDOM)
      i = n > ar(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !1;
            break;
          }
          if (o.previousSibling)
            break;
        }
      if (i == null && n == e.childNodes.length)
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !0;
            break;
          }
          if (o.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      let o = this.getDesc(i), a;
      if (o && (!n || o.node))
        if (r && (a = o.nodeDOM) && !(a.nodeType == 1 ? a.contains(e.nodeType == 1 ? e : e.parentNode) : a == e))
          r = !1;
        else
          return o;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let r = n; r; r = r.parent)
      if (r == this)
        return n;
  }
  posFromDOM(e, n, r) {
    for (let i = e; i; i = i.parentNode) {
      let o = this.getDesc(i);
      if (o)
        return o.localPosFromDOM(e, n, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let i = this.children[n], o = r + i.size;
      if (r == e && o != r) {
        for (; !i.border && i.children.length; )
          i = i.children[0];
        return i;
      }
      if (e < o)
        return i.descAt(e - r - i.border);
      r = o;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, i = 0;
    for (let o = 0; r < this.children.length; r++) {
      let a = this.children[r], s = o + a.size;
      if (s > e || a instanceof nU) {
        i = e - o;
        break;
      }
      o = s;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, n);
    for (let o; r && !(o = this.children[r - 1]).size && o instanceof tU && o.side >= 0; r--)
      ;
    if (n <= 0) {
      let o, a = !0;
      for (; o = r ? this.children[r - 1] : null, !(!o || o.dom.parentNode == this.contentDOM); r--, a = !1)
        ;
      return o && n && a && !o.border && !o.domAtom ? o.domFromPos(o.size, n) : { node: this.contentDOM, offset: o ? ar(o.dom) + 1 : 0 };
    } else {
      let o, a = !0;
      for (; o = r < this.children.length ? this.children[r] : null, !(!o || o.dom.parentNode == this.contentDOM); r++, a = !1)
        ;
      return o && a && !o.border && !o.domAtom ? o.domFromPos(0, n) : { node: this.contentDOM, offset: o ? ar(o.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, n, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, o = -1;
    for (let a = r, s = 0; ; s++) {
      let l = this.children[s], c = a + l.size;
      if (i == -1 && e <= c) {
        let u = a + l.border;
        if (e >= u && n <= c - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, n, u);
        e = a;
        for (let d = s; d > 0; d--) {
          let f = this.children[d - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            i = ar(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (c > n || s == this.children.length - 1)) {
        n = c;
        for (let u = s + 1; u < this.children.length; u++) {
          let d = this.children[u];
          if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
            o = ar(d.dom);
            break;
          }
          n += d.size;
        }
        o == -1 && (o = this.contentDOM.childNodes.length);
        break;
      }
      a = c;
    }
    return { node: this.contentDOM, from: e, to: n, fromOffset: i, toOffset: o };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: r } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, n, r, i = !1) {
    let o = Math.min(e, n), a = Math.max(e, n);
    for (let p = 0, m = 0; p < this.children.length; p++) {
      let g = this.children[p], b = m + g.size;
      if (o > m && a < b)
        return g.setSelection(e - m - g.border, n - m - g.border, r, i);
      m = b;
    }
    let s = this.domFromPos(e, e ? -1 : 1), l = n == e ? s : this.domFromPos(n, n ? -1 : 1), c = r.root.getSelection(), u = r.domSelectionRange(), d = !1;
    if ((To || zr) && e == n) {
      let { node: p, offset: m } = s;
      if (p.nodeType == 3) {
        if (d = !!(m && p.nodeValue[m - 1] == `
`), d && m == p.nodeValue.length)
          for (let g = p, b; g; g = g.parentNode) {
            if (b = g.nextSibling) {
              b.nodeName == "BR" && (s = l = { node: b.parentNode, offset: ar(b) + 1 });
              break;
            }
            let y = g.pmViewDesc;
            if (y && y.node && y.node.isBlock)
              break;
          }
      } else {
        let g = p.childNodes[m - 1];
        d = g && (g.nodeName == "BR" || g.contentEditable == "false");
      }
    }
    if (To && u.focusNode && u.focusNode != l.node && u.focusNode.nodeType == 1) {
      let p = u.focusNode.childNodes[u.focusOffset];
      p && p.contentEditable == "false" && (i = !0);
    }
    if (!(i || d && zr) && Xc(s.node, s.offset, u.anchorNode, u.anchorOffset) && Xc(l.node, l.offset, u.focusNode, u.focusOffset))
      return;
    let f = !1;
    if ((c.extend || e == n) && !d) {
      c.collapse(s.node, s.offset);
      try {
        e != n && c.extend(l.node, l.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > n) {
        let m = s;
        s = l, l = m;
      }
      let p = document.createRange();
      p.setEnd(l.node, l.offset), p.setStart(s.node, s.offset), c.removeAllRanges(), c.addRange(p);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, n) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let o = this.children[i], a = r + o.size;
      if (r == a ? e <= a && n >= r : e < a && n > r) {
        let s = r + o.border, l = a - o.border;
        if (e >= s && n <= l) {
          this.dirty = e == r || n == a ? Fc : Uk, e == s && n == l && (o.contentLost || o.dom.parentNode != this.contentDOM) ? o.dirty = fa : o.markDirty(e - s, n - s);
          return;
        } else
          o.dirty = o.dom == o.contentDOM && o.dom.parentNode == this.contentDOM && !o.children.length ? Fc : fa;
      }
      r = a;
    }
    this.dirty = Fc;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let r = e == 1 ? Fc : Uk;
      n.dirty < r && (n.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class tU extends Bm {
  constructor(e, n, r, i) {
    let o, a = n.type.toDOM;
    if (typeof a == "function" && (a = a(r, () => {
      if (!o)
        return i;
      if (o.parent)
        return o.parent.posBeforeChild(o);
    })), !n.type.spec.raw) {
      if (a.nodeType != 1) {
        let s = document.createElement("span");
        s.appendChild(a), a = s;
      }
      a.contentEditable = "false", a.classList.add("ProseMirror-widget");
    }
    super(e, [], a, null), this.widget = n, this.widget = n, o = this;
  }
  matchesWidget(e) {
    return this.dirty == Qi && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class r$ extends Bm {
  constructor(e, n, r, i) {
    super(e, [], n, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class Yc extends Bm {
  constructor(e, n, r, i, o) {
    super(e, [], r, i), this.mark = n, this.spec = o;
  }
  static create(e, n, r, i) {
    let o = i.nodeViews[n.type.name], a = o && o(n, i, r);
    return (!a || !a.dom) && (a = uu.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)), new Yc(e, n, a.dom, a.contentDOM || a.dom, a);
  }
  parseRule() {
    return this.dirty & fa || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != fa && this.mark.eq(e);
  }
  markDirty(e, n) {
    if (super.markDirty(e, n), this.dirty != Qi) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = Qi;
    }
  }
  slice(e, n, r) {
    let i = Yc.create(this.parent, this.mark, !0, r), o = this.children, a = this.size;
    n < a && (o = fS(o, n, a, r)), e > 0 && (o = fS(o, 0, e, r));
    for (let s = 0; s < o.length; s++)
      o[s].parent = i;
    return i.children = o, i;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class vl extends Bm {
  constructor(e, n, r, i, o, a, s, l, c) {
    super(e, [], o, a), this.node = n, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = s;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, n, r, i, o, a) {
    let s = o.nodeViews[n.type.name], l, c = s && s(n, o, () => {
      if (!l)
        return a;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, r, i), u = c && c.dom, d = c && c.contentDOM;
    if (n.isText) {
      if (!u)
        u = document.createTextNode(n.text);
      else if (u.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else u || ({ dom: u, contentDOM: d } = uu.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !d && !n.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), n.type.spec.draggable && (u.draggable = !0));
    let f = u;
    return u = oU(u, r, n), c ? l = new i$(e, n, r, i, u, d || null, f, c, o, a + 1) : n.isText ? new t1(e, n, r, i, u, f, o) : new vl(e, n, r, i, u, d || null, f, o, a + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => ze.empty);
    }
    return e;
  }
  matchesNode(e, n, r) {
    return this.dirty == Qi && e.eq(this.node) && yb(n, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, n) {
    let r = this.node.inlineContent, i = n, o = e.composing ? this.localCompositionInfo(e, n) : null, a = o && o.pos > -1 ? o : null, s = o && o.pos < 0, l = new a$(this, a && a.node, e);
    c$(this.node, this.innerDeco, (c, u, d) => {
      c.spec.marks ? l.syncToMarks(c.spec.marks, r, e) : c.type.side >= 0 && !d && l.syncToMarks(u == this.node.childCount ? tn.none : this.node.child(u).marks, r, e), l.placeWidget(c, e, i);
    }, (c, u, d, f) => {
      l.syncToMarks(c.marks, r, e);
      let p;
      l.findNodeMatch(c, u, d, f) || s && e.state.selection.from > i && e.state.selection.to < i + c.nodeSize && (p = l.findIndexWithChild(o.node)) > -1 && l.updateNodeAt(c, u, d, p, e) || l.updateNextNode(c, u, d, e, f, i) || l.addNode(c, u, d, e, i), i += c.nodeSize;
    }), l.syncToMarks([], r, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == Fc) && (a && this.protectLocalComposition(e, a), rU(this.contentDOM, this.children, e), bf && u$(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: r, to: i } = e.state.selection;
    if (!(e.state.selection instanceof ot) || r < n || i > n + this.node.content.size)
      return null;
    let o = e.input.compositionNode;
    if (!o || !this.dom.contains(o.parentNode))
      return null;
    if (this.node.inlineContent) {
      let a = o.nodeValue, s = d$(this.node.content, a, r - n, i - n);
      return s < 0 ? null : { node: o, pos: s, text: a };
    } else
      return { node: o, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: r, text: i }) {
    if (this.getDesc(n))
      return;
    let o = n;
    for (; o.parentNode != this.contentDOM; o = o.parentNode) {
      for (; o.previousSibling; )
        o.parentNode.removeChild(o.previousSibling);
      for (; o.nextSibling; )
        o.parentNode.removeChild(o.nextSibling);
      o.pmViewDesc && (o.pmViewDesc = void 0);
    }
    let a = new r$(this, o, n, i);
    e.input.compositionNodes.push(a), this.children = fS(this.children, r, r + i.length, e, a);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, n, r, i) {
    return this.dirty == fa || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, i), !0);
  }
  updateInner(e, n, r, i) {
    this.updateOuterDeco(n), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = Qi;
  }
  updateOuterDeco(e) {
    if (yb(e, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = iU(this.dom, this.nodeDOM, dS(this.outerDeco, this.node, n), dS(e, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function Nk(t, e, n, r, i) {
  oU(r, e, t);
  let o = new vl(void 0, t, e, n, r, r, r, i, 0);
  return o.contentDOM && o.updateChildren(i, 0), o;
}
class t1 extends vl {
  constructor(e, n, r, i, o, a, s) {
    super(e, n, r, i, o, null, a, s, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, n, r, i) {
    return this.dirty == fa || this.dirty != Qi && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != Qi || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = Qi, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, r) {
    let i = this.node.cut(e, n), o = document.createTextNode(i.text);
    return new t1(this.parent, i, this.outerDeco, this.innerDeco, o, o, r);
  }
  markDirty(e, n) {
    super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = fa);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class nU extends Bm {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == Qi && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class i$ extends vl {
  constructor(e, n, r, i, o, a, s, l, c, u) {
    super(e, n, r, i, o, a, s, c, u), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, n, r, i) {
    if (this.dirty == fa)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let o = this.spec.update(e, n, r);
      return o && this.updateInner(e, n, r, i), o;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, r, i) {
    this.spec.setSelection ? this.spec.setSelection(e, n, r.root) : super.setSelection(e, n, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function rU(t, e, n) {
  let r = t.firstChild, i = !1;
  for (let o = 0; o < e.length; o++) {
    let a = e[o], s = a.dom;
    if (s.parentNode == t) {
      for (; s != r; )
        r = Mk(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, t.insertBefore(s, r);
    if (a instanceof Yc) {
      let l = r ? r.previousSibling : t.lastChild;
      rU(a.contentDOM, a.children, n), r = l ? l.nextSibling : t.firstChild;
    }
  }
  for (; r; )
    r = Mk(r), i = !0;
  i && n.trackWrites == t && (n.trackWrites = null);
}
const Ip = function(t) {
  t && (this.nodeName = t);
};
Ip.prototype = /* @__PURE__ */ Object.create(null);
const Uc = [new Ip()];
function dS(t, e, n) {
  if (t.length == 0)
    return Uc;
  let r = n ? Uc[0] : new Ip(), i = [r];
  for (let o = 0; o < t.length; o++) {
    let a = t[o].type.attrs;
    if (a) {
      a.nodeName && i.push(r = new Ip(a.nodeName));
      for (let s in a) {
        let l = a[s];
        l != null && (n && i.length == 1 && i.push(r = new Ip(e.isInline ? "span" : "div")), s == "class" ? r.class = (r.class ? r.class + " " : "") + l : s == "style" ? r.style = (r.style ? r.style + ";" : "") + l : s != "nodeName" && (r[s] = l));
      }
    }
  }
  return i;
}
function iU(t, e, n, r) {
  if (n == Uc && r == Uc)
    return e;
  let i = e;
  for (let o = 0; o < r.length; o++) {
    let a = r[o], s = n[o];
    if (o) {
      let l;
      s && s.nodeName == a.nodeName && i != t && (l = i.parentNode) && l.nodeName.toLowerCase() == a.nodeName || (l = document.createElement(a.nodeName), l.pmIsDeco = !0, l.appendChild(i), s = Uc[0]), i = l;
    }
    o$(i, s || Uc[0], a);
  }
  return i;
}
function o$(t, e, n) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in n) && t.removeAttribute(r);
  for (let r in n)
    r != "class" && r != "style" && r != "nodeName" && n[r] != e[r] && t.setAttribute(r, n[r]);
  if (e.class != n.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let o = 0; o < r.length; o++)
      i.indexOf(r[o]) == -1 && t.classList.remove(r[o]);
    for (let o = 0; o < i.length; o++)
      r.indexOf(i[o]) == -1 && t.classList.add(i[o]);
    t.classList.length == 0 && t.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(e.style); )
        t.style.removeProperty(i[1]);
    }
    n.style && (t.style.cssText += n.style);
  }
}
function oU(t, e, n) {
  return iU(t, t, Uc, dS(e, n, t.nodeType != 1));
}
function yb(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].type.eq(e[n].type))
      return !1;
  return !0;
}
function Mk(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class a$ {
  constructor(e, n, r) {
    this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = s$(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, n) {
    if (e != n) {
      for (let r = e; r < n; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, n - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, n, r) {
    let i = 0, o = this.stack.length >> 1, a = Math.min(o, e.length);
    for (; i < a && (i == o - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < o; )
      this.destroyRest(), this.top.dirty = Qi, this.index = this.stack.pop(), this.top = this.stack.pop(), o--;
    for (; o < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let s = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let c = this.top.children[l];
        if (c.matchesMark(e[o]) && !this.isLocked(c.dom)) {
          s = l;
          break;
        }
      }
      if (s > -1)
        s > this.index && (this.changed = !0, this.destroyBetween(this.index, s)), this.top = this.top.children[this.index];
      else {
        let l = Yc.create(this.top, e[o], n, r);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, o++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, n, r, i) {
    let o = -1, a;
    if (i >= this.preMatch.index && (a = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && a.matchesNode(e, n, r))
      o = this.top.children.indexOf(a, this.index);
    else
      for (let s = this.index, l = Math.min(this.top.children.length, s + 5); s < l; s++) {
        let c = this.top.children[s];
        if (c.matchesNode(e, n, r) && !this.preMatch.matched.has(c)) {
          o = s;
          break;
        }
      }
    return o < 0 ? !1 : (this.destroyBetween(this.index, o), this.index++, !0);
  }
  updateNodeAt(e, n, r, i, o) {
    let a = this.top.children[i];
    return a.dirty == fa && a.dom == a.contentDOM && (a.dirty = Fc), a.update(e, n, r, o) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let n = e.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      e = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, n, r, i, o, a) {
    for (let s = this.index; s < this.top.children.length; s++) {
      let l = this.top.children[s];
      if (l instanceof vl) {
        let c = this.preMatch.matched.get(l);
        if (c != null && c != o)
          return !1;
        let u = l.dom, d, f = this.isLocked(u) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != fa && yb(n, l.outerDeco));
        if (!f && l.update(e, n, r, i))
          return this.destroyBetween(this.index, s), l.dom != u && (this.changed = !0), this.index++, !0;
        if (!f && (d = this.recreateWrapper(l, e, n, r, i, a)))
          return this.destroyBetween(this.index, s), this.top.children[this.index] = d, d.contentDOM && (d.dirty = Fc, d.updateChildren(i, a + 1), d.dirty = Qi), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, n, r, i, o, a) {
    if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !yb(r, e.outerDeco) || !i.eq(e.innerDeco))
      return null;
    let s = vl.create(this.top, n, r, i, o, a);
    if (s.contentDOM) {
      s.children = e.children, e.children = [];
      for (let l of s.children)
        l.parent = s;
    }
    return e.destroy(), s;
  }
  // Insert the node as a newly created node desc.
  addNode(e, n, r, i, o) {
    let a = vl.create(this.top, e, n, r, i, o);
    a.contentDOM && a.updateChildren(i, o + 1), this.top.children.splice(this.index++, 0, a), this.changed = !0;
  }
  placeWidget(e, n, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let o = new tU(this.top, e, n, r);
      this.top.children.splice(this.index++, 0, o), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], n = this.top;
    for (; e instanceof Yc; )
      n = e, e = n.children[n.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof t1) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((zr || yr) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new nU(this.top, [], r, null);
      n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function s$(t, e) {
  let n = e, r = n.children.length, i = t.childCount, o = /* @__PURE__ */ new Map(), a = [];
  e: for (; i > 0; ) {
    let s;
    for (; ; )
      if (r) {
        let c = n.children[r - 1];
        if (c instanceof Yc)
          n = c, r = c.children.length;
        else {
          s = c, r--;
          break;
        }
      } else {
        if (n == e)
          break e;
        r = n.parent.children.indexOf(n), n = n.parent;
      }
    let l = s.node;
    if (l) {
      if (l != t.child(i - 1))
        break;
      --i, o.set(s, i), a.push(s);
    }
  }
  return { index: i, matched: o, matches: a.reverse() };
}
function l$(t, e) {
  return t.type.side - e.type.side;
}
function c$(t, e, n, r) {
  let i = e.locals(t), o = 0;
  if (i.length == 0) {
    for (let c = 0; c < t.childCount; c++) {
      let u = t.child(c);
      r(u, i, e.forChild(o, u), c), o += u.nodeSize;
    }
    return;
  }
  let a = 0, s = [], l = null;
  for (let c = 0; ; ) {
    let u, d;
    for (; a < i.length && i[a].to == o; ) {
      let b = i[a++];
      b.widget && (u ? (d || (d = [u])).push(b) : u = b);
    }
    if (u)
      if (d) {
        d.sort(l$);
        for (let b = 0; b < d.length; b++)
          n(d[b], c, !!l);
      } else
        n(u, c, !!l);
    let f, p;
    if (l)
      p = -1, f = l, l = null;
    else if (c < t.childCount)
      p = c, f = t.child(c++);
    else
      break;
    for (let b = 0; b < s.length; b++)
      s[b].to <= o && s.splice(b--, 1);
    for (; a < i.length && i[a].from <= o && i[a].to > o; )
      s.push(i[a++]);
    let m = o + f.nodeSize;
    if (f.isText) {
      let b = m;
      a < i.length && i[a].from < b && (b = i[a].from);
      for (let y = 0; y < s.length; y++)
        s[y].to < b && (b = s[y].to);
      b < m && (l = f.cut(b - o), f = f.cut(0, b - o), m = b, p = -1);
    } else
      for (; a < i.length && i[a].to < m; )
        a++;
    let g = f.isInline && !f.isLeaf ? s.filter((b) => !b.inline) : s.slice();
    r(f, g, e.forChild(o, f), p), o = m;
  }
}
function u$(t) {
  if (t.nodeName == "UL" || t.nodeName == "OL") {
    let e = t.style.cssText;
    t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e;
  }
}
function d$(t, e, n, r) {
  for (let i = 0, o = 0; i < t.childCount && o <= r; ) {
    let a = t.child(i++), s = o;
    if (o += a.nodeSize, !a.isText)
      continue;
    let l = a.text;
    for (; i < t.childCount; ) {
      let c = t.child(i++);
      if (o += c.nodeSize, !c.isText)
        break;
      l += c.text;
    }
    if (o >= n) {
      if (o >= r && l.slice(r - e.length - s, r - s) == e)
        return r - e.length;
      let c = s < r ? l.lastIndexOf(e, r - s - 1) : -1;
      if (c >= 0 && c + e.length + s >= n)
        return s + c;
      if (n == r && l.length >= r + e.length - s && l.slice(r - s, r - s + e.length) == e)
        return r;
    }
  }
  return -1;
}
function fS(t, e, n, r, i) {
  let o = [];
  for (let a = 0, s = 0; a < t.length; a++) {
    let l = t[a], c = s, u = s += l.size;
    c >= n || u <= e ? o.push(l) : (c < e && o.push(l.slice(0, e - c, r)), i && (o.push(i), i = void 0), u > n && o.push(l.slice(n - c, l.size, r)));
  }
  return o;
}
function rD(t, e = null) {
  let n = t.domSelectionRange(), r = t.state.doc;
  if (!n.focusNode)
    return null;
  let i = t.docView.nearestDesc(n.focusNode), o = i && i.size == 0, a = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (a < 0)
    return null;
  let s = r.resolve(a), l, c;
  if (e1(n)) {
    for (l = a; i && !i.node; )
      i = i.parent;
    let d = i.node;
    if (i && d.isAtom && st.isSelectable(d) && i.parent && !(d.isInline && Bz(n.focusNode, n.focusOffset, i.dom))) {
      let f = i.posBefore;
      c = new st(a == f ? s : r.resolve(f));
    }
  } else {
    if (n instanceof t.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
      let d = a, f = a;
      for (let p = 0; p < n.rangeCount; p++) {
        let m = n.getRangeAt(p);
        d = Math.min(d, t.docView.posFromDOM(m.startContainer, m.startOffset, 1)), f = Math.max(f, t.docView.posFromDOM(m.endContainer, m.endOffset, -1));
      }
      if (d < 0)
        return null;
      [l, a] = f == t.state.selection.anchor ? [f, d] : [d, f], s = r.resolve(a);
    } else
      l = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (l < 0)
      return null;
  }
  let u = r.resolve(l);
  if (!c) {
    let d = e == "pointer" || t.state.selection.head < s.pos && !o ? 1 : -1;
    c = iD(t, u, s, d);
  }
  return c;
}
function aU(t) {
  return t.editable ? t.hasFocus() : lU(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function rs(t, e = !1) {
  let n = t.state.selection;
  if (sU(t, n), !!aU(t)) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && yr) {
      let r = t.domSelectionRange(), i = t.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && Xc(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection();
        return;
      }
    }
    if (t.domObserver.disconnectSelection(), t.cursorWrapper)
      h$(t);
    else {
      let { anchor: r, head: i } = n, o, a;
      Bk && !(n instanceof ot) && (n.$from.parent.inlineContent || (o = Lk(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (a = Lk(t, n.to))), t.docView.setSelection(r, i, t, e), Bk && (o && Pk(o), a && Pk(a)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && f$(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const Bk = zr || yr && KF < 63;
function Lk(t, e) {
  let { node: n, offset: r } = t.docView.domFromPos(e, 0), i = r < n.childNodes.length ? n.childNodes[r] : null, o = r ? n.childNodes[r - 1] : null;
  if (zr && i && i.contentEditable == "false")
    return Lw(i);
  if ((!i || i.contentEditable == "false") && (!o || o.contentEditable == "false")) {
    if (i)
      return Lw(i);
    if (o)
      return Lw(o);
  }
}
function Lw(t) {
  return t.contentEditable = "true", zr && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
}
function Pk(t) {
  t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
}
function f$(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(), r = n.anchorNode, i = n.anchorOffset;
  e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
    (n.anchorNode != r || n.anchorOffset != i) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
      (!aU(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function h$(t) {
  let e = t.domSelection(), n = document.createRange();
  if (!e)
    return;
  let r = t.cursorWrapper.dom, i = r.nodeName == "IMG";
  i ? n.setStart(r.parentNode, ar(r) + 1) : n.setStart(r, 0), n.collapse(!0), e.removeAllRanges(), e.addRange(n), !i && !t.state.selection.visible && si && bl <= 11 && (r.disabled = !0, r.disabled = !1);
}
function sU(t, e) {
  if (e instanceof st) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc && (Wk(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
  } else
    Wk(t);
}
function Wk(t) {
  t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
}
function iD(t, e, n, r) {
  return t.someProp("createSelectionBetween", (i) => i(t, e, n)) || ot.between(e, n, r);
}
function zk(t) {
  return t.editable && !t.hasFocus() ? !1 : lU(t);
}
function lU(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function p$(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0), n = t.domSelectionRange();
  return Xc(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function hS(t, e) {
  let { $anchor: n, $head: r } = t.selection, i = e > 0 ? n.max(r) : n.min(r), o = i.parent.inlineContent ? i.depth ? t.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return o && dt.findFrom(o, e);
}
function rl(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function $k(t, e, n) {
  let r = t.state.selection;
  if (r instanceof ot)
    if (n.indexOf("s") > -1) {
      let { $head: i } = r, o = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
      if (!o || o.isText || !o.isLeaf)
        return !1;
      let a = t.state.doc.resolve(i.pos + o.nodeSize * (e < 0 ? -1 : 1));
      return rl(t, new ot(r.$anchor, a));
    } else if (r.empty) {
      if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let i = hS(t.state, e);
        return i && i instanceof st ? rl(t, i) : !1;
      } else if (!(Xi && n.indexOf("m") > -1)) {
        let i = r.$head, o = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, a;
        if (!o || o.isText)
          return !1;
        let s = e < 0 ? i.pos - o.nodeSize : i.pos;
        return o.isAtom || (a = t.docView.descAt(s)) && !a.contentDOM ? st.isSelectable(o) ? rl(t, new st(e < 0 ? t.state.doc.resolve(i.pos - o.nodeSize) : i)) : Mm ? rl(t, new ot(t.state.doc.resolve(e < 0 ? s : s + o.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof st && r.node.isInline)
      return rl(t, new ot(e > 0 ? r.$to : r.$from));
    {
      let i = hS(t.state, e);
      return i ? rl(t, i) : !1;
    }
  }
}
function bb(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Op(t, e) {
  let n = t.pmViewDesc;
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function Dd(t, e) {
  return e < 0 ? m$(t) : g$(t);
}
function m$(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let i, o, a = !1;
  for (To && n.nodeType == 1 && r < bb(n) && Op(n.childNodes[r], -1) && (a = !0); ; )
    if (r > 0) {
      if (n.nodeType != 1)
        break;
      {
        let s = n.childNodes[r - 1];
        if (Op(s, -1))
          i = n, o = --r;
        else if (s.nodeType == 3)
          n = s, r = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (cU(n))
        break;
      {
        let s = n.previousSibling;
        for (; s && Op(s, -1); )
          i = n.parentNode, o = ar(s), s = s.previousSibling;
        if (s)
          n = s, r = bb(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = 0;
        }
      }
    }
  a ? pS(t, n, r) : i && pS(t, i, o);
}
function g$(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let i = bb(n), o, a;
  for (; ; )
    if (r < i) {
      if (n.nodeType != 1)
        break;
      let s = n.childNodes[r];
      if (Op(s, 1))
        o = n, a = ++r;
      else
        break;
    } else {
      if (cU(n))
        break;
      {
        let s = n.nextSibling;
        for (; s && Op(s, 1); )
          o = s.parentNode, a = ar(s) + 1, s = s.nextSibling;
        if (s)
          n = s, r = 0, i = bb(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = i = 0;
        }
      }
    }
  o && pS(t, o, a);
}
function cU(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function y$(t, e) {
  for (; t && e == t.childNodes.length && !Nm(t); )
    e = ar(t) + 1, t = t.parentNode;
  for (; t && e < t.childNodes.length; ) {
    let n = t.childNodes[e];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = 0;
  }
}
function b$(t, e) {
  for (; t && !e && !Nm(t); )
    e = ar(t), t = t.parentNode;
  for (; t && e; ) {
    let n = t.childNodes[e - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = t.childNodes.length;
  }
}
function pS(t, e, n) {
  if (e.nodeType != 3) {
    let o, a;
    (a = y$(e, n)) ? (e = a, n = 0) : (o = b$(e, n)) && (e = o, n = o.nodeValue.length);
  }
  let r = t.domSelection();
  if (!r)
    return;
  if (e1(r)) {
    let o = document.createRange();
    o.setEnd(e, n), o.setStart(e, n), r.removeAllRanges(), r.addRange(o);
  } else r.extend && r.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: i } = t;
  setTimeout(() => {
    t.state == i && rs(t);
  }, 50);
}
function Hk(t, e) {
  let n = t.state.doc.resolve(e);
  if (!(yr || Wz) && n.parent.inlineContent) {
    let i = t.coordsAtPos(e);
    if (e > n.start()) {
      let o = t.coordsAtPos(e - 1), a = (o.top + o.bottom) / 2;
      if (a > i.top && a < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left < i.left ? "ltr" : "rtl";
    }
    if (e < n.end()) {
      let o = t.coordsAtPos(e + 1), a = (o.top + o.bottom) / 2;
      if (a > i.top && a < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function jk(t, e, n) {
  let r = t.state.selection;
  if (r instanceof ot && !r.empty || n.indexOf("s") > -1 || Xi && n.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: o } = r;
  if (!i.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let a = hS(t.state, e);
    if (a && a instanceof st)
      return rl(t, a);
  }
  if (!i.parent.inlineContent) {
    let a = e < 0 ? i : o, s = r instanceof Ci ? dt.near(a, e) : dt.findFrom(a, e);
    return s ? rl(t, s) : !1;
  }
  return !1;
}
function Vk(t, e) {
  if (!(t.state.selection instanceof ot))
    return !0;
  let { $head: n, $anchor: r, empty: i } = t.state.selection;
  if (!n.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let o = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (o && !o.isText) {
    let a = t.state.tr;
    return e < 0 ? a.delete(n.pos - o.nodeSize, n.pos) : a.delete(n.pos, n.pos + o.nodeSize), t.dispatch(a), !0;
  }
  return !1;
}
function qk(t, e, n) {
  t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
}
function v$(t) {
  if (!zr || t.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    qk(t, r, "true"), setTimeout(() => qk(t, r, "false"), 20);
  }
  return !1;
}
function w$(t) {
  let e = "";
  return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
}
function x$(t, e) {
  let n = e.keyCode, r = w$(e);
  if (n == 8 || Xi && n == 72 && r == "c")
    return Vk(t, -1) || Dd(t, -1);
  if (n == 46 && !e.shiftKey || Xi && n == 68 && r == "c")
    return Vk(t, 1) || Dd(t, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || Xi && n == 66 && r == "c") {
    let i = n == 37 ? Hk(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return $k(t, i, r) || Dd(t, i);
  } else if (n == 39 || Xi && n == 70 && r == "c") {
    let i = n == 39 ? Hk(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return $k(t, i, r) || Dd(t, i);
  } else {
    if (n == 38 || Xi && n == 80 && r == "c")
      return jk(t, -1, r) || Dd(t, -1);
    if (n == 40 || Xi && n == 78 && r == "c")
      return v$(t) || jk(t, 1, r) || Dd(t, 1);
    if (r == (Xi ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function uU(t, e) {
  t.someProp("transformCopied", (p) => {
    e = p(e, t);
  });
  let n = [], { content: r, openStart: i, openEnd: o } = e;
  for (; i > 1 && o > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, o--;
    let p = r.firstChild;
    n.push(p.type.name, p.attrs != p.type.defaultAttrs ? p.attrs : null), r = p.content;
  }
  let a = t.someProp("clipboardSerializer") || uu.fromSchema(t.state.schema), s = gU(), l = s.createElement("div");
  l.appendChild(a.serializeFragment(r, { document: s }));
  let c = l.firstChild, u, d = 0;
  for (; c && c.nodeType == 1 && (u = mU[c.nodeName.toLowerCase()]); ) {
    for (let p = u.length - 1; p >= 0; p--) {
      let m = s.createElement(u[p]);
      for (; l.firstChild; )
        m.appendChild(l.firstChild);
      l.appendChild(m), d++;
    }
    c = l.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${i} ${o}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`);
  let f = t.someProp("clipboardTextSerializer", (p) => p(e, t)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: f, slice: e };
}
function dU(t, e, n, r, i) {
  let o = i.parent.type.spec.code, a, s;
  if (!n && !e)
    return null;
  let l = e && (r || o || !n);
  if (l) {
    if (t.someProp("transformPastedText", (f) => {
      e = f(e, o || r, t);
    }), o)
      return e ? new Xe(ze.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : Xe.empty;
    let d = t.someProp("clipboardTextParser", (f) => f(e, i, r, t));
    if (d)
      s = d;
    else {
      let f = i.marks(), { schema: p } = t.state, m = uu.fromSchema(p);
      a = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((g) => {
        let b = a.appendChild(document.createElement("p"));
        g && b.appendChild(m.serializeNode(p.text(g, f)));
      });
    }
  } else
    t.someProp("transformPastedHTML", (d) => {
      n = d(n, t);
    }), a = D$(n), Mm && E$(a);
  let c = a && a.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (u && u[3])
    for (let d = +u[3]; d > 0; d--) {
      let f = a.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      a = f;
    }
  if (s || (s = (t.someProp("clipboardParser") || t.someProp("domParser") || Ap.fromSchema(t.state.schema)).parseSlice(a, {
    preserveWhitespace: !!(l || u),
    context: i,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !_$.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), u)
    s = C$(Gk(s, +u[1], +u[2]), u[4]);
  else if (s = Xe.maxOpen(S$(s.content, i), !0), s.openStart || s.openEnd) {
    let d = 0, f = 0;
    for (let p = s.content.firstChild; d < s.openStart && !p.type.spec.isolating; d++, p = p.firstChild)
      ;
    for (let p = s.content.lastChild; f < s.openEnd && !p.type.spec.isolating; f++, p = p.lastChild)
      ;
    s = Gk(s, d, f);
  }
  return t.someProp("transformPasted", (d) => {
    s = d(s, t);
  }), s;
}
const _$ = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function S$(t, e) {
  if (t.childCount < 2)
    return t;
  for (let n = e.depth; n >= 0; n--) {
    let i = e.node(n).contentMatchAt(e.index(n)), o, a = [];
    if (t.forEach((s) => {
      if (!a)
        return;
      let l = i.findWrapping(s.type), c;
      if (!l)
        return a = null;
      if (c = a.length && o.length && hU(l, o, s, a[a.length - 1], 0))
        a[a.length - 1] = c;
      else {
        a.length && (a[a.length - 1] = pU(a[a.length - 1], o.length));
        let u = fU(s, l);
        a.push(u), i = i.matchType(u.type), o = l;
      }
    }), a)
      return ze.from(a);
  }
  return t;
}
function fU(t, e, n = 0) {
  for (let r = e.length - 1; r >= n; r--)
    t = e[r].create(null, ze.from(t));
  return t;
}
function hU(t, e, n, r, i) {
  if (i < t.length && i < e.length && t[i] == e[i]) {
    let o = hU(t, e, n, r.lastChild, i + 1);
    if (o)
      return r.copy(r.content.replaceChild(r.childCount - 1, o));
    if (r.contentMatchAt(r.childCount).matchType(i == t.length - 1 ? n.type : t[i + 1]))
      return r.copy(r.content.append(ze.from(fU(n, t, i + 1))));
  }
}
function pU(t, e) {
  if (e == 0)
    return t;
  let n = t.content.replaceChild(t.childCount - 1, pU(t.lastChild, e - 1)), r = t.contentMatchAt(t.childCount).fillBefore(ze.empty, !0);
  return t.copy(n.append(r));
}
function mS(t, e, n, r, i, o) {
  let a = e < 0 ? t.firstChild : t.lastChild, s = a.content;
  return t.childCount > 1 && (o = 0), i < r - 1 && (s = mS(s, e, n, r, i + 1, o)), i >= n && (s = e < 0 ? a.contentMatchAt(0).fillBefore(s, o <= i).append(s) : s.append(a.contentMatchAt(a.childCount).fillBefore(ze.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, a.copy(s));
}
function Gk(t, e, n) {
  return e < t.openStart && (t = new Xe(mS(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new Xe(mS(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t;
}
const mU = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let Kk = null;
function gU() {
  return Kk || (Kk = document.implementation.createHTMLDocument("title"));
}
let Pw = null;
function T$(t) {
  let e = window.trustedTypes;
  return e ? (Pw || (Pw = e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), Pw.createHTML(t)) : t;
}
function D$(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = gU().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t), i;
  if ((i = r && mU[r[1].toLowerCase()]) && (t = i.map((o) => "<" + o + ">").join("") + t + i.map((o) => "</" + o + ">").reverse().join("")), n.innerHTML = T$(t), i)
    for (let o = 0; o < i.length; o++)
      n = n.querySelector(i[o]) || n;
  return n;
}
function E$(t) {
  let e = t.querySelectorAll(yr ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
  }
}
function C$(t, e) {
  if (!t.size)
    return t;
  let n = t.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: i, openStart: o, openEnd: a } = t;
  for (let s = r.length - 2; s >= 0; s -= 2) {
    let l = n.nodes[r[s]];
    if (!l || l.hasRequiredAttrs())
      break;
    i = ze.from(l.create(r[s + 1], i)), o++, a++;
  }
  return new Xe(i, o, a);
}
const $r = {}, Hr = {}, k$ = { touchstart: !0, touchmove: !0 };
class A$ {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function R$(t) {
  for (let e in $r) {
    let n = $r[e];
    t.dom.addEventListener(e, t.input.eventHandlers[e] = (r) => {
      O$(t, r) && !oD(t, r) && (t.editable || !(r.type in Hr)) && n(t, r);
    }, k$[e] ? { passive: !0 } : void 0);
  }
  zr && t.dom.addEventListener("input", () => null), gS(t);
}
function ml(t, e) {
  t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
}
function I$(t) {
  t.domObserver.stop();
  for (let e in t.input.eventHandlers)
    t.dom.removeEventListener(e, t.input.eventHandlers[e]);
  clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function gS(t) {
  t.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = (r) => oD(t, r));
  });
}
function oD(t, e) {
  return t.someProp("handleDOMEvents", (n) => {
    let r = n[e.type];
    return r ? r(t, e) || e.defaultPrevented : !1;
  });
}
function O$(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function F$(t, e) {
  !oD(t, e) && $r[e.type] && (t.editable || !(e.type in Hr)) && $r[e.type](t, e);
}
Hr.keydown = (t, e) => {
  let n = e;
  if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !bU(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !(Ja && yr && n.keyCode == 13)))
    if (n.keyCode != 229 && t.domObserver.forceFlush(), bf && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let r = Date.now();
      t.input.lastIOSEnter = r, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == r && (t.someProp("handleKeyDown", (i) => i(t, Ic(13, "Enter"))), t.input.lastIOSEnter = 0);
      }, 200);
    } else t.someProp("handleKeyDown", (r) => r(t, n)) || x$(t, n) ? n.preventDefault() : ml(t, "key");
};
Hr.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
Hr.keypress = (t, e) => {
  let n = e;
  if (bU(t, n) || !n.charCode || n.ctrlKey && !n.altKey || Xi && n.metaKey)
    return;
  if (t.someProp("handleKeyPress", (i) => i(t, n))) {
    n.preventDefault();
    return;
  }
  let r = t.state.selection;
  if (!(r instanceof ot) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(n.charCode);
    !/[\r\n]/.test(i) && !t.someProp("handleTextInput", (o) => o(t, r.$from.pos, r.$to.pos, i)) && t.dispatch(t.state.tr.insertText(i).scrollIntoView()), n.preventDefault();
  }
};
function n1(t) {
  return { left: t.clientX, top: t.clientY };
}
function U$(t, e) {
  let n = e.x - t.clientX, r = e.y - t.clientY;
  return n * n + r * r < 100;
}
function aD(t, e, n, r, i) {
  if (r == -1)
    return !1;
  let o = t.state.doc.resolve(r);
  for (let a = o.depth + 1; a > 0; a--)
    if (t.someProp(e, (s) => a > o.depth ? s(t, n, o.nodeAfter, o.before(a), i, !0) : s(t, n, o.node(a), o.before(a), i, !1)))
      return !0;
  return !1;
}
function nf(t, e, n) {
  if (t.focused || t.focus(), t.state.selection.eq(e))
    return;
  let r = t.state.tr.setSelection(e);
  r.setMeta("pointer", !0), t.dispatch(r);
}
function N$(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.doc.resolve(e), r = n.nodeAfter;
  return r && r.isAtom && st.isSelectable(r) ? (nf(t, new st(n)), !0) : !1;
}
function M$(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.selection, r, i;
  n instanceof st && (r = n.node);
  let o = t.state.doc.resolve(e);
  for (let a = o.depth + 1; a > 0; a--) {
    let s = a > o.depth ? o.nodeAfter : o.node(a);
    if (st.isSelectable(s)) {
      r && n.$from.depth > 0 && a >= n.$from.depth && o.before(n.$from.depth + 1) == n.$from.pos ? i = o.before(n.$from.depth) : i = o.before(a);
      break;
    }
  }
  return i != null ? (nf(t, st.create(t.state.doc, i)), !0) : !1;
}
function B$(t, e, n, r, i) {
  return aD(t, "handleClickOn", e, n, r) || t.someProp("handleClick", (o) => o(t, e, r)) || (i ? M$(t, n) : N$(t, n));
}
function L$(t, e, n, r) {
  return aD(t, "handleDoubleClickOn", e, n, r) || t.someProp("handleDoubleClick", (i) => i(t, e, r));
}
function P$(t, e, n, r) {
  return aD(t, "handleTripleClickOn", e, n, r) || t.someProp("handleTripleClick", (i) => i(t, e, r)) || W$(t, n, r);
}
function W$(t, e, n) {
  if (n.button != 0)
    return !1;
  let r = t.state.doc;
  if (e == -1)
    return r.inlineContent ? (nf(t, ot.create(r, 0, r.content.size)), !0) : !1;
  let i = r.resolve(e);
  for (let o = i.depth + 1; o > 0; o--) {
    let a = o > i.depth ? i.nodeAfter : i.node(o), s = i.before(o);
    if (a.inlineContent)
      nf(t, ot.create(r, s + 1, s + 1 + a.content.size));
    else if (st.isSelectable(a))
      nf(t, st.create(r, s));
    else
      continue;
    return !0;
  }
}
function sD(t) {
  return vb(t);
}
const yU = Xi ? "metaKey" : "ctrlKey";
$r.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let r = sD(t), i = Date.now(), o = "singleClick";
  i - t.input.lastClick.time < 500 && U$(n, t.input.lastClick) && !n[yU] && (t.input.lastClick.type == "singleClick" ? o = "doubleClick" : t.input.lastClick.type == "doubleClick" && (o = "tripleClick")), t.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: o };
  let a = t.posAtCoords(n1(n));
  a && (o == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new z$(t, a, n, !!r)) : (o == "doubleClick" ? L$ : P$)(t, a.pos, a.inside, n) ? n.preventDefault() : ml(t, "pointer"));
};
class z$ {
  constructor(e, n, r, i) {
    this.view = e, this.pos = n, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[yU], this.allowDefault = r.shiftKey;
    let o, a;
    if (n.inside > -1)
      o = e.state.doc.nodeAt(n.inside), a = n.inside;
    else {
      let u = e.state.doc.resolve(n.pos);
      o = u.parent, a = u.depth ? u.before() : 0;
    }
    const s = i ? null : r.target, l = s ? e.docView.nearestDesc(s, !0) : null;
    this.target = l && l.dom.nodeType == 1 ? l.dom : null;
    let { selection: c } = e.state;
    (r.button == 0 && o.type.spec.draggable && o.type.spec.selectable !== !1 || c instanceof st && c.from <= a && c.to > a) && (this.mightDrag = {
      node: o,
      pos: a,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && To && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), ml(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => rs(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(n1(e))), this.updateAllowDefault(e), this.allowDefault || !n ? ml(this.view, "pointer") : B$(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    zr && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    yr && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (nf(this.view, dt.near(this.view.state.doc.resolve(n.pos))), e.preventDefault()) : ml(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), ml(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
$r.touchstart = (t) => {
  t.input.lastTouch = Date.now(), sD(t), ml(t, "pointer");
};
$r.touchmove = (t) => {
  t.input.lastTouch = Date.now(), ml(t, "pointer");
};
$r.contextmenu = (t) => sD(t);
function bU(t, e) {
  return t.composing ? !0 : zr && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1;
}
const $$ = Ja ? 5e3 : -1;
Hr.compositionstart = Hr.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t, n = e.selection.$to;
    if (e.selection instanceof ot && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      t.markCursor = t.state.storedMarks || n.marks(), vb(t, !0), t.markCursor = null;
    else if (vb(t, !e.selection.empty), To && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let r = t.domSelectionRange();
      for (let i = r.focusNode, o = r.focusOffset; i && i.nodeType == 1 && o != 0; ) {
        let a = o < 0 ? i.lastChild : i.childNodes[o - 1];
        if (!a)
          break;
        if (a.nodeType == 3) {
          let s = t.domSelection();
          s && s.collapse(a, a.nodeValue.length);
          break;
        } else
          i = a, o = -1;
      }
    }
    t.input.composing = !0;
  }
  vU(t, $$);
};
Hr.compositionend = (t, e) => {
  t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0, t.input.compositionNode = null, t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()), t.input.compositionID++, vU(t, 20));
};
function vU(t, e) {
  clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => vb(t), e));
}
function wU(t) {
  for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = j$()); t.input.compositionNodes.length > 0; )
    t.input.compositionNodes.pop().markParentsDirty();
}
function H$(t) {
  let e = t.domSelectionRange();
  if (!e.focusNode)
    return null;
  let n = Nz(e.focusNode, e.focusOffset), r = Mz(e.focusNode, e.focusOffset);
  if (n && r && n != r) {
    let i = r.pmViewDesc, o = t.domObserver.lastChangedTextNode;
    if (n == o || r == o)
      return o;
    if (!i || !i.isText(r.nodeValue))
      return r;
    if (t.input.compositionNode == r) {
      let a = n.pmViewDesc;
      if (!(!a || !a.isText(n.nodeValue)))
        return r;
    }
  }
  return n || r;
}
function j$() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function vb(t, e = !1) {
  if (!(Ja && t.domObserver.flushingSoon >= 0)) {
    if (t.domObserver.forceFlush(), wU(t), e || t.docView && t.docView.dirty) {
      let n = rD(t);
      return n && !n.eq(t.state.selection) ? t.dispatch(t.state.tr.setSelection(n)) : (t.markCursor || e) && !t.state.selection.empty ? t.dispatch(t.state.tr.deleteSelection()) : t.updateState(t.state), !0;
    }
    return !1;
  }
}
function V$(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(e), t.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t.focus();
  }, 50);
}
const Jp = si && bl < 15 || bf && zz < 604;
$r.copy = Hr.cut = (t, e) => {
  let n = e, r = t.state.selection, i = n.type == "cut";
  if (r.empty)
    return;
  let o = Jp ? null : n.clipboardData, a = r.content(), { dom: s, text: l } = uU(t, a);
  o ? (n.preventDefault(), o.clearData(), o.setData("text/html", s.innerHTML), o.setData("text/plain", l)) : V$(t, s), i && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function q$(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function G$(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, r = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = t.input.shiftKey && t.input.lastKeyCode != 45;
  setTimeout(() => {
    t.focus(), r.parentNode && r.parentNode.removeChild(r), n ? Zp(t, r.value, null, i, e) : Zp(t, r.textContent, r.innerHTML, i, e);
  }, 50);
}
function Zp(t, e, n, r, i) {
  let o = dU(t, e, n, r, t.state.selection.$from);
  if (t.someProp("handlePaste", (l) => l(t, i, o || Xe.empty)))
    return !0;
  if (!o)
    return !1;
  let a = q$(o), s = a ? t.state.tr.replaceSelectionWith(a, r) : t.state.tr.replaceSelection(o);
  return t.dispatch(s.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function xU(t) {
  let e = t.getData("text/plain") || t.getData("Text");
  if (e)
    return e;
  let n = t.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
Hr.paste = (t, e) => {
  let n = e;
  if (t.composing && !Ja)
    return;
  let r = Jp ? null : n.clipboardData, i = t.input.shiftKey && t.input.lastKeyCode != 45;
  r && Zp(t, xU(r), r.getData("text/html"), i, n) ? n.preventDefault() : G$(t, n);
};
class _U {
  constructor(e, n, r) {
    this.slice = e, this.move = n, this.node = r;
  }
}
const SU = Xi ? "altKey" : "ctrlKey";
$r.dragstart = (t, e) => {
  let n = e, r = t.input.mouseDown;
  if (r && r.done(), !n.dataTransfer)
    return;
  let i = t.state.selection, o = i.empty ? null : t.posAtCoords(n1(n)), a;
  if (!(o && o.pos >= i.from && o.pos <= (i instanceof st ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      a = st.create(t.state.doc, r.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let d = t.docView.nearestDesc(n.target, !0);
      d && d.node.type.spec.draggable && d != t.docView && (a = st.create(t.state.doc, d.posBefore));
    }
  }
  let s = (a || t.state.selection).content(), { dom: l, text: c, slice: u } = uU(t, s);
  (!n.dataTransfer.files.length || !yr || KF > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(Jp ? "Text" : "text/html", l.innerHTML), n.dataTransfer.effectAllowed = "copyMove", Jp || n.dataTransfer.setData("text/plain", c), t.dragging = new _U(u, !n[SU], a);
};
$r.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
Hr.dragover = Hr.dragenter = (t, e) => e.preventDefault();
Hr.drop = (t, e) => {
  let n = e, r = t.dragging;
  if (t.dragging = null, !n.dataTransfer)
    return;
  let i = t.posAtCoords(n1(n));
  if (!i)
    return;
  let o = t.state.doc.resolve(i.pos), a = r && r.slice;
  a ? t.someProp("transformPasted", (m) => {
    a = m(a, t);
  }) : a = dU(t, xU(n.dataTransfer), Jp ? null : n.dataTransfer.getData("text/html"), !1, o);
  let s = !!(r && !n[SU]);
  if (t.someProp("handleDrop", (m) => m(t, n, a || Xe.empty, s))) {
    n.preventDefault();
    return;
  }
  if (!a)
    return;
  n.preventDefault();
  let l = a ? WF(t.state.doc, o.pos, a) : o.pos;
  l == null && (l = o.pos);
  let c = t.state.tr;
  if (s) {
    let { node: m } = r;
    m ? m.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(l), d = a.openStart == 0 && a.openEnd == 0 && a.content.childCount == 1, f = c.doc;
  if (d ? c.replaceRangeWith(u, u, a.content.firstChild) : c.replaceRange(u, u, a), c.doc.eq(f))
    return;
  let p = c.doc.resolve(u);
  if (d && st.isSelectable(a.content.firstChild) && p.nodeAfter && p.nodeAfter.sameMarkup(a.content.firstChild))
    c.setSelection(new st(p));
  else {
    let m = c.mapping.map(l);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((g, b, y, w) => m = w), c.setSelection(iD(t, p, c.doc.resolve(m)));
  }
  t.focus(), t.dispatch(c.setMeta("uiEvent", "drop"));
};
$r.focus = (t) => {
  t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => {
    t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && rs(t);
  }, 20));
};
$r.blur = (t, e) => {
  let n = e;
  t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1);
};
$r.beforeinput = (t, e) => {
  if (yr && Ja && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: r } = t.input;
    setTimeout(() => {
      if (t.input.domChangeCount != r || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (o) => o(t, Ic(8, "Backspace")))))
        return;
      let { $cursor: i } = t.state.selection;
      i && i.pos > 0 && t.dispatch(t.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in Hr)
  $r[t] = Hr[t];
function Qp(t, e) {
  if (t == e)
    return !0;
  for (let n in t)
    if (t[n] !== e[n])
      return !1;
  for (let n in e)
    if (!(n in t))
      return !1;
  return !0;
}
class wb {
  constructor(e, n) {
    this.toDOM = e, this.spec = n || zc, this.side = this.spec.side || 0;
  }
  map(e, n, r, i) {
    let { pos: o, deleted: a } = e.mapResult(n.from + i, this.side < 0 ? -1 : 1);
    return a ? null : new vn(o - r, o - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof wb && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Qp(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class wl {
  constructor(e, n) {
    this.attrs = e, this.spec = n || zc;
  }
  map(e, n, r, i) {
    let o = e.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r, a = e.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return o >= a ? null : new vn(o, a, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return this == e || e instanceof wl && Qp(this.attrs, e.attrs) && Qp(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof wl;
  }
  destroy() {
  }
}
let K$ = class TU {
  constructor(e, n) {
    this.attrs = e, this.spec = n || zc;
  }
  map(e, n, r, i) {
    let o = e.mapResult(n.from + i, 1);
    if (o.deleted)
      return null;
    let a = e.mapResult(n.to + i, -1);
    return a.deleted || a.pos <= o.pos ? null : new vn(o.pos - r, a.pos - r, this);
  }
  valid(e, n) {
    let { index: r, offset: i } = e.content.findIndex(n.from), o;
    return i == n.from && !(o = e.child(r)).isText && i + o.nodeSize == n.to;
  }
  eq(e) {
    return this == e || e instanceof TU && Qp(this.attrs, e.attrs) && Qp(this.spec, e.spec);
  }
  destroy() {
  }
};
class vn {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.from = e, this.to = n, this.type = r;
  }
  /**
  @internal
  */
  copy(e, n) {
    return new vn(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
  }
  /**
  @internal
  */
  map(e, n, r) {
    return this.type.map(e, this, n, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, r) {
    return new vn(e, e, new wb(n, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, r, i) {
    return new vn(e, n, new wl(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, r, i) {
    return new vn(e, n, new K$(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof wl;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof wb;
  }
}
const zd = [], zc = {};
class Bt {
  /**
  @internal
  */
  constructor(e, n) {
    this.local = e.length ? e : zd, this.children = n.length ? n : zd;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, n) {
    return n.length ? xb(n, e, 0, zc) : gr;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, r) {
    let i = [];
    return this.findInner(e ?? 0, n ?? 1e9, i, 0, r), i;
  }
  findInner(e, n, r, i, o) {
    for (let a = 0; a < this.local.length; a++) {
      let s = this.local[a];
      s.from <= n && s.to >= e && (!o || o(s.spec)) && r.push(s.copy(s.from + i, s.to + i));
    }
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] < n && this.children[a + 1] > e) {
        let s = this.children[a] + 1;
        this.children[a + 2].findInner(e - s, n - s, r, i + s, o);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, r) {
    return this == gr || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || zc);
  }
  /**
  @internal
  */
  mapInner(e, n, r, i, o) {
    let a;
    for (let s = 0; s < this.local.length; s++) {
      let l = this.local[s].map(e, r, i);
      l && l.type.valid(n, l) ? (a || (a = [])).push(l) : o.onRemove && o.onRemove(this.local[s].spec);
    }
    return this.children.length ? X$(this.children, a || [], e, n, r, i, o) : a ? new Bt(a.sort($c), zd) : gr;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, n) {
    return n.length ? this == gr ? Bt.create(e, n) : this.addInner(e, n, 0) : this;
  }
  addInner(e, n, r) {
    let i, o = 0;
    e.forEach((s, l) => {
      let c = l + r, u;
      if (u = EU(n, s, c)) {
        for (i || (i = this.children.slice()); o < i.length && i[o] < l; )
          o += 3;
        i[o] == l ? i[o + 2] = i[o + 2].addInner(s, u, c + 1) : i.splice(o, 0, l, l + s.nodeSize, xb(u, s, c + 1, zc)), o += 3;
      }
    });
    let a = DU(o ? CU(n) : n, -r);
    for (let s = 0; s < a.length; s++)
      a[s].type.valid(e, a[s]) || a.splice(s--, 1);
    return new Bt(a.length ? this.local.concat(a).sort($c) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == gr ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let r = this.children, i = this.local;
    for (let o = 0; o < r.length; o += 3) {
      let a, s = r[o] + n, l = r[o + 1] + n;
      for (let u = 0, d; u < e.length; u++)
        (d = e[u]) && d.from > s && d.to < l && (e[u] = null, (a || (a = [])).push(d));
      if (!a)
        continue;
      r == this.children && (r = this.children.slice());
      let c = r[o + 2].removeInner(a, s + 1);
      c != gr ? r[o + 2] = c : (r.splice(o, 3), o -= 3);
    }
    if (i.length) {
      for (let o = 0, a; o < e.length; o++)
        if (a = e[o])
          for (let s = 0; s < i.length; s++)
            i[s].eq(a, n) && (i == this.local && (i = this.local.slice()), i.splice(s--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new Bt(i, r) : gr;
  }
  forChild(e, n) {
    if (this == gr)
      return this;
    if (n.isLeaf)
      return Bt.empty;
    let r, i;
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] >= e) {
        this.children[s] == e && (r = this.children[s + 2]);
        break;
      }
    let o = e + 1, a = o + n.content.size;
    for (let s = 0; s < this.local.length; s++) {
      let l = this.local[s];
      if (l.from < a && l.to > o && l.type instanceof wl) {
        let c = Math.max(o, l.from) - o, u = Math.min(a, l.to) - o;
        c < u && (i || (i = [])).push(l.copy(c, u));
      }
    }
    if (i) {
      let s = new Bt(i.sort($c), zd);
      return r ? new cl([s, r]) : s;
    }
    return r || gr;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Bt) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return lD(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == gr)
      return zd;
    if (e.inlineContent || !this.local.some(wl.is))
      return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof wl || n.push(this.local[r]);
    return n;
  }
  forEachSet(e) {
    e(this);
  }
}
Bt.empty = new Bt([], []);
Bt.removeOverlap = lD;
const gr = Bt.empty;
class cl {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const r = this.members.map((i) => i.map(e, n, zc));
    return cl.from(r);
  }
  forChild(e, n) {
    if (n.isLeaf)
      return Bt.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].forChild(e, n);
      o != gr && (o instanceof cl ? r = r.concat(o.members) : r.push(o));
    }
    return cl.from(r);
  }
  eq(e) {
    if (!(e instanceof cl) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n]))
        return !1;
    return !0;
  }
  locals(e) {
    let n, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].localsInner(e);
      if (o.length)
        if (!n)
          n = o;
        else {
          r && (n = n.slice(), r = !1);
          for (let a = 0; a < o.length; a++)
            n.push(o[a]);
        }
    }
    return n ? lD(r ? n : n.sort($c)) : zd;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return gr;
      case 1:
        return e[0];
      default:
        return new cl(e.every((n) => n instanceof Bt) ? e : e.reduce((n, r) => n.concat(r instanceof Bt ? r : r.members), []));
    }
  }
  forEachSet(e) {
    for (let n = 0; n < this.members.length; n++)
      this.members[n].forEachSet(e);
  }
}
function X$(t, e, n, r, i, o, a) {
  let s = t.slice();
  for (let c = 0, u = o; c < n.maps.length; c++) {
    let d = 0;
    n.maps[c].forEach((f, p, m, g) => {
      let b = g - m - (p - f);
      for (let y = 0; y < s.length; y += 3) {
        let w = s[y + 1];
        if (w < 0 || f > w + u - d)
          continue;
        let x = s[y] + u - d;
        p >= x ? s[y + 1] = f <= x ? -2 : -1 : f >= u && b && (s[y] += b, s[y + 1] += b);
      }
      d += b;
    }), u = n.maps[c].map(u, -1);
  }
  let l = !1;
  for (let c = 0; c < s.length; c += 3)
    if (s[c + 1] < 0) {
      if (s[c + 1] == -2) {
        l = !0, s[c + 1] = -1;
        continue;
      }
      let u = n.map(t[c] + o), d = u - i;
      if (d < 0 || d >= r.content.size) {
        l = !0;
        continue;
      }
      let f = n.map(t[c + 1] + o, -1), p = f - i, { index: m, offset: g } = r.content.findIndex(d), b = r.maybeChild(m);
      if (b && g == d && g + b.nodeSize == p) {
        let y = s[c + 2].mapInner(n, b, u + 1, t[c] + o + 1, a);
        y != gr ? (s[c] = d, s[c + 1] = p, s[c + 2] = y) : (s[c + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let c = Y$(s, t, e, n, i, o, a), u = xb(c, r, 0, a);
    e = u.local;
    for (let d = 0; d < s.length; d += 3)
      s[d + 1] < 0 && (s.splice(d, 3), d -= 3);
    for (let d = 0, f = 0; d < u.children.length; d += 3) {
      let p = u.children[d];
      for (; f < s.length && s[f] < p; )
        f += 3;
      s.splice(f, 0, u.children[d], u.children[d + 1], u.children[d + 2]);
    }
  }
  return new Bt(e.sort($c), s);
}
function DU(t, e) {
  if (!e || !t.length)
    return t;
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let i = t[r];
    n.push(new vn(i.from + e, i.to + e, i.type));
  }
  return n;
}
function Y$(t, e, n, r, i, o, a) {
  function s(l, c) {
    for (let u = 0; u < l.local.length; u++) {
      let d = l.local[u].map(r, i, c);
      d ? n.push(d) : a.onRemove && a.onRemove(l.local[u].spec);
    }
    for (let u = 0; u < l.children.length; u += 3)
      s(l.children[u + 2], l.children[u] + c + 1);
  }
  for (let l = 0; l < t.length; l += 3)
    t[l + 1] == -1 && s(t[l + 2], e[l] + o + 1);
  return n;
}
function EU(t, e, n) {
  if (e.isLeaf)
    return null;
  let r = n + e.nodeSize, i = null;
  for (let o = 0, a; o < t.length; o++)
    (a = t[o]) && a.from > n && a.to < r && ((i || (i = [])).push(a), t[o] = null);
  return i;
}
function CU(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    t[n] != null && e.push(t[n]);
  return e;
}
function xb(t, e, n, r) {
  let i = [], o = !1;
  e.forEach((s, l) => {
    let c = EU(t, s, l + n);
    if (c) {
      o = !0;
      let u = xb(c, s, n + l + 1, r);
      u != gr && i.push(l, l + s.nodeSize, u);
    }
  });
  let a = DU(o ? CU(t) : t, -n).sort($c);
  for (let s = 0; s < a.length; s++)
    a[s].type.valid(e, a[s]) || (r.onRemove && r.onRemove(a[s].spec), a.splice(s--, 1));
  return a.length || i.length ? new Bt(a, i) : gr;
}
function $c(t, e) {
  return t.from - e.from || t.to - e.to;
}
function lD(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let r = e[n];
    if (r.from != r.to)
      for (let i = n + 1; i < e.length; i++) {
        let o = e[i];
        if (o.from == r.from) {
          o.to != r.to && (e == t && (e = t.slice()), e[i] = o.copy(o.from, r.to), Xk(e, i + 1, o.copy(r.to, o.to)));
          continue;
        } else {
          o.from < r.to && (e == t && (e = t.slice()), e[n] = r.copy(r.from, o.from), Xk(e, i, r.copy(o.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function Xk(t, e, n) {
  for (; e < t.length && $c(n, t[e]) > 0; )
    e++;
  t.splice(e, 0, n);
}
function Ww(t) {
  let e = [];
  return t.someProp("decorations", (n) => {
    let r = n(t.state);
    r && r != gr && e.push(r);
  }), t.cursorWrapper && e.push(Bt.create(t.state.doc, [t.cursorWrapper.deco])), cl.from(e);
}
const J$ = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, Z$ = si && bl <= 11;
class Q$ {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class eH {
  constructor(e, n) {
    this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new Q$(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      si && bl <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), Z$ && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, J$)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++)
          this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (zk(this.view)) {
      if (this.suppressingSelectionUpdates)
        return rs(this.view);
      if (si && bl <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && Xc(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), r;
    for (let o = e.focusNode; o; o = Yp(o))
      n.add(o);
    for (let o = e.anchorNode; o; o = Yp(o))
      if (n.has(o)) {
        r = o;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && zk(e) && !this.ignoreSelectionChange(r), o = -1, a = -1, s = !1, l = [];
    if (e.editable)
      for (let u = 0; u < n.length; u++) {
        let d = this.registerMutation(n[u], l);
        d && (o = o < 0 ? d.from : Math.min(d.from, o), a = a < 0 ? d.to : Math.max(d.to, a), d.typeOver && (s = !0));
      }
    if (To && l.length) {
      let u = l.filter((d) => d.nodeName == "BR");
      if (u.length == 2) {
        let [d, f] = u;
        d.parentNode && d.parentNode.parentNode == f.parentNode ? f.remove() : d.remove();
      } else {
        let { focusNode: d } = this.currentSelection;
        for (let f of u) {
          let p = f.parentNode;
          p && p.nodeName == "LI" && (!d || rH(e, d) != p) && f.remove();
        }
      }
    }
    let c = null;
    o < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && e1(r) && (c = rD(e)) && c.eq(dt.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, rs(e), this.currentSelection.set(r), e.scrollToSelection()) : (o > -1 || i) && (o > -1 && (e.docView.markDirty(o, a), tH(e)), this.handleDOMChange(o, a, s, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || rs(e), this.currentSelection.set(r));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let u = 0; u < e.addedNodes.length; u++) {
        let d = e.addedNodes[u];
        n.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = e.previousSibling, o = e.nextSibling;
      if (si && bl <= 11 && e.addedNodes.length)
        for (let u = 0; u < e.addedNodes.length; u++) {
          let { previousSibling: d, nextSibling: f } = e.addedNodes[u];
          (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (i = d), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (o = f);
        }
      let a = i && i.parentNode == e.target ? ar(i) + 1 : 0, s = r.localPosFromDOM(e.target, a, -1), l = o && o.parentNode == e.target ? ar(o) : e.target.childNodes.length, c = r.localPosFromDOM(e.target, l, 1);
      return { from: s, to: c };
    } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let Yk = /* @__PURE__ */ new WeakMap(), Jk = !1;
function tH(t) {
  if (!Yk.has(t) && (Yk.set(t, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
    if (t.requiresGeckoHackNode = To, Jk)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), Jk = !0;
  }
}
function Zk(t, e) {
  let n = e.startContainer, r = e.startOffset, i = e.endContainer, o = e.endOffset, a = t.domAtPos(t.state.selection.anchor);
  return Xc(a.node, a.offset, i, o) && ([n, r, i, o] = [i, o, n, r]), { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o };
}
function nH(t, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(t.root)[0];
    if (i)
      return Zk(t, i);
  }
  let n;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
  }
  return t.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), t.dom.removeEventListener("beforeinput", r, !0), n ? Zk(t, n) : null;
}
function rH(t, e) {
  for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
    let r = t.docView.nearestDesc(n, !0);
    if (r && r.node.isBlock)
      return n;
  }
  return null;
}
function iH(t, e, n) {
  let { node: r, fromOffset: i, toOffset: o, from: a, to: s } = t.docView.parseRange(e, n), l = t.domSelectionRange(), c, u = l.anchorNode;
  if (u && t.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{ node: u, offset: l.anchorOffset }], e1(l) || c.push({ node: l.focusNode, offset: l.focusOffset })), yr && t.input.lastKeyCode === 8)
    for (let b = o; b > i; b--) {
      let y = r.childNodes[b - 1], w = y.pmViewDesc;
      if (y.nodeName == "BR" && !w) {
        o = b;
        break;
      }
      if (!w || w.size)
        break;
    }
  let d = t.state.doc, f = t.someProp("domParser") || Ap.fromSchema(t.state.schema), p = d.resolve(a), m = null, g = f.parse(r, {
    topNode: p.parent,
    topMatch: p.parent.contentMatchAt(p.index()),
    topOpen: !0,
    from: i,
    to: o,
    preserveWhitespace: p.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: c,
    ruleFromNode: oH,
    context: p
  });
  if (c && c[0].pos != null) {
    let b = c[0].pos, y = c[1] && c[1].pos;
    y == null && (y = b), m = { anchor: b + a, head: y + a };
  }
  return { doc: g, sel: m, from: a, to: s };
}
function oH(t) {
  let e = t.pmViewDesc;
  if (e)
    return e.parseRule();
  if (t.nodeName == "BR" && t.parentNode) {
    if (zr && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (t.parentNode.lastChild == t || zr && /^(tr|table)$/i.test(t.parentNode.nodeName))
      return { ignore: !0 };
  } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const aH = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function sH(t, e, n, r, i) {
  let o = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
  if (t.input.compositionPendingChanges = 0, e < 0) {
    let I = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null, le = rD(t, I);
    if (le && !t.state.selection.eq(le)) {
      if (yr && Ja && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", (F) => F(t, Ic(13, "Enter"))))
        return;
      let be = t.state.tr.setSelection(le);
      I == "pointer" ? be.setMeta("pointer", !0) : I == "key" && be.scrollIntoView(), o && be.setMeta("composition", o), t.dispatch(be);
    }
    return;
  }
  let a = t.state.doc.resolve(e), s = a.sharedDepth(n);
  e = a.before(s + 1), n = t.state.doc.resolve(n).after(s + 1);
  let l = t.state.selection, c = iH(t, e, n), u = t.state.doc, d = u.slice(c.from, c.to), f, p;
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (f = t.state.selection.to, p = "end") : (f = t.state.selection.from, p = "start"), t.input.lastKeyCode = null;
  let m = uH(d.content, c.doc.content, c.from, f, p);
  if (m && t.input.domChangeCount++, (bf && t.input.lastIOSEnter > Date.now() - 225 || Ja) && i.some((I) => I.nodeType == 1 && !aH.test(I.nodeName)) && (!m || m.endA >= m.endB) && t.someProp("handleKeyDown", (I) => I(t, Ic(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (!m)
    if (r && l instanceof ot && !l.empty && l.$head.sameParent(l.$anchor) && !t.composing && !(c.sel && c.sel.anchor != c.sel.head))
      m = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (c.sel) {
        let I = Qk(t, t.state.doc, c.sel);
        if (I && !I.eq(t.state.selection)) {
          let le = t.state.tr.setSelection(I);
          o && le.setMeta("composition", o), t.dispatch(le);
        }
      }
      return;
    }
  t.state.selection.from < t.state.selection.to && m.start == m.endB && t.state.selection instanceof ot && (m.start > t.state.selection.from && m.start <= t.state.selection.from + 2 && t.state.selection.from >= c.from ? m.start = t.state.selection.from : m.endA < t.state.selection.to && m.endA >= t.state.selection.to - 2 && t.state.selection.to <= c.to && (m.endB += t.state.selection.to - m.endA, m.endA = t.state.selection.to)), si && bl <= 11 && m.endB == m.start + 1 && m.endA == m.start && m.start > c.from && c.doc.textBetween(m.start - c.from - 1, m.start - c.from + 1) == "  " && (m.start--, m.endA--, m.endB--);
  let g = c.doc.resolveNoCache(m.start - c.from), b = c.doc.resolveNoCache(m.endB - c.from), y = u.resolve(m.start), w = g.sameParent(b) && g.parent.inlineContent && y.end() >= m.endA, x;
  if ((bf && t.input.lastIOSEnter > Date.now() - 225 && (!w || i.some((I) => I.nodeName == "DIV" || I.nodeName == "P")) || !w && g.pos < c.doc.content.size && !g.sameParent(b) && (x = dt.findFrom(c.doc.resolve(g.pos + 1), 1, !0)) && x.head == b.pos) && t.someProp("handleKeyDown", (I) => I(t, Ic(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (t.state.selection.anchor > m.start && cH(u, m.start, m.endA, g, b) && t.someProp("handleKeyDown", (I) => I(t, Ic(8, "Backspace")))) {
    Ja && yr && t.domObserver.suppressSelectionUpdates();
    return;
  }
  yr && m.endB == m.start && (t.input.lastChromeDelete = Date.now()), Ja && !w && g.start() != b.start() && b.parentOffset == 0 && g.depth == b.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == m.endA && (m.endB -= 2, b = c.doc.resolveNoCache(m.endB - c.from), setTimeout(() => {
    t.someProp("handleKeyDown", function(I) {
      return I(t, Ic(13, "Enter"));
    });
  }, 20));
  let k = m.start, A = m.endA, U, P, V;
  if (w) {
    if (g.pos == b.pos)
      si && bl <= 11 && g.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(), setTimeout(() => rs(t), 20)), U = t.state.tr.delete(k, A), P = u.resolve(m.start).marksAcross(u.resolve(m.endA));
    else if (
      // Adding or removing a mark
      m.endA == m.endB && (V = lH(g.parent.content.cut(g.parentOffset, b.parentOffset), y.parent.content.cut(y.parentOffset, m.endA - y.start())))
    )
      U = t.state.tr, V.type == "add" ? U.addMark(k, A, V.mark) : U.removeMark(k, A, V.mark);
    else if (g.parent.child(g.index()).isText && g.index() == b.index() - (b.textOffset ? 0 : 1)) {
      let I = g.parent.textBetween(g.parentOffset, b.parentOffset);
      if (t.someProp("handleTextInput", (le) => le(t, k, A, I)))
        return;
      U = t.state.tr.insertText(I, k, A);
    }
  }
  if (U || (U = t.state.tr.replace(k, A, c.doc.slice(m.start - c.from, m.endB - c.from))), c.sel) {
    let I = Qk(t, U.doc, c.sel);
    I && !(yr && t.composing && I.empty && (m.start != m.endB || t.input.lastChromeDelete < Date.now() - 100) && (I.head == k || I.head == U.mapping.map(A) - 1) || si && I.empty && I.head == k) && U.setSelection(I);
  }
  P && U.ensureMarks(P), o && U.setMeta("composition", o), t.dispatch(U.scrollIntoView());
}
function Qk(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size ? null : iD(t, e.resolve(n.anchor), e.resolve(n.head));
}
function lH(t, e) {
  let n = t.firstChild.marks, r = e.firstChild.marks, i = n, o = r, a, s, l;
  for (let u = 0; u < r.length; u++)
    i = r[u].removeFromSet(i);
  for (let u = 0; u < n.length; u++)
    o = n[u].removeFromSet(o);
  if (i.length == 1 && o.length == 0)
    s = i[0], a = "add", l = (u) => u.mark(s.addToSet(u.marks));
  else if (i.length == 0 && o.length == 1)
    s = o[0], a = "remove", l = (u) => u.mark(s.removeFromSet(u.marks));
  else
    return null;
  let c = [];
  for (let u = 0; u < e.childCount; u++)
    c.push(l(e.child(u)));
  if (ze.from(c).eq(t))
    return { mark: s, type: a };
}
function cH(t, e, n, r, i) {
  if (
    // The content must have shrunk
    n - e <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    zw(r, !0, !1) < i.pos
  )
    return !1;
  let o = t.resolve(e);
  if (!r.parent.isTextblock) {
    let s = o.nodeAfter;
    return s != null && n == e + s.nodeSize;
  }
  if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock)
    return !1;
  let a = t.resolve(zw(o, !0, !0));
  return !a.parent.isTextblock || a.pos > n || zw(a, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(a.parent.content);
}
function zw(t, e, n) {
  let r = t.depth, i = e ? t.end() : t.pos;
  for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
    r--, i++, e = !1;
  if (n) {
    let o = t.node(r).maybeChild(t.indexAfter(r));
    for (; o && !o.isLeaf; )
      o = o.firstChild, i++;
  }
  return i;
}
function uH(t, e, n, r, i) {
  let o = t.findDiffStart(e, n);
  if (o == null)
    return null;
  let { a, b: s } = t.findDiffEnd(e, n + t.size, n + e.size);
  if (i == "end") {
    let l = Math.max(0, o - Math.min(a, s));
    r -= a + l - o;
  }
  if (a < o && t.size < e.size) {
    let l = r <= o && r >= a ? o - r : 0;
    o -= l, o && o < e.size && eA(e.textBetween(o - 1, o + 1)) && (o += l ? 1 : -1), s = o + (s - a), a = o;
  } else if (s < o) {
    let l = r <= o && r >= s ? o - r : 0;
    o -= l, o && o < t.size && eA(t.textBetween(o - 1, o + 1)) && (o += l ? 1 : -1), a = o + (a - s), s = o;
  }
  return { start: o, endA: a, endB: s };
}
function eA(t) {
  if (t.length != 2)
    return !1;
  let e = t.charCodeAt(0), n = t.charCodeAt(1);
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
class dH {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new A$(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(oA), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = rA(this), nA(this), this.nodeViews = iA(this), this.docView = Nk(this.state.doc, tA(this), Ww(this), this.dom, this), this.domObserver = new eH(this, (r, i, o, a) => sH(this, r, i, o, a)), this.domObserver.start(), R$(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e)
        this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && gS(this);
    let n = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(oA), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let n = {};
    for (let r in this._props)
      n[r] = this._props[r];
    n.state = this.state;
    for (let r in e)
      n[r] = e[r];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    var r;
    let i = this.state, o = !1, a = !1;
    e.storedMarks && this.composing && (wU(this), a = !0), this.state = e;
    let s = i.plugins != e.plugins || this._props.plugins != n.plugins;
    if (s || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let p = iA(this);
      hH(p, this.nodeViews) && (this.nodeViews = p, o = !0);
    }
    (s || n.handleDOMEvents != this._props.handleDOMEvents) && gS(this), this.editable = rA(this), nA(this);
    let l = Ww(this), c = tA(this), u = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", d = o || !this.docView.matchesNode(e.doc, c, l);
    (d || !e.selection.eq(i.selection)) && (a = !0);
    let f = u == "preserve" && a && this.dom.style.overflowAnchor == null && jz(this);
    if (a) {
      this.domObserver.stop();
      let p = d && (si || yr) && !this.composing && !i.selection.empty && !e.selection.empty && fH(i.selection, e.selection);
      if (d) {
        let m = yr ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = H$(this)), (o || !this.docView.update(e.doc, c, l, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = Nk(e.doc, c, l, this.dom, this)), m && !this.trackWrites && (p = !0);
      }
      p || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && p$(this)) ? rs(this, p) : (sU(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && Vz(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof st) {
      let n = this.docView.domAfterPos(this.state.selection.from);
      n.nodeType == 1 && Ak(this, n.getBoundingClientRect(), e);
    } else
      Ak(this, this.coordsAtPos(this.state.selection.head, 1), e);
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, n) {
    let r = e.node, i = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      i = r.from;
    else {
      let o = r.from + (this.state.doc.content.size - n.doc.content.size);
      (o > 0 && this.state.doc.nodeAt(o)) == r.node && (i = o);
    }
    this.dragging = new _U(e.slice, e.move, i < 0 ? void 0 : st.create(this.state.doc, i));
  }
  someProp(e, n) {
    let r = this._props && this._props[e], i;
    if (r != null && (i = n ? n(r) : r))
      return i;
    for (let a = 0; a < this.directPlugins.length; a++) {
      let s = this.directPlugins[a].props[e];
      if (s != null && (i = n ? n(s) : s))
        return i;
    }
    let o = this.state.plugins;
    if (o)
      for (let a = 0; a < o.length; a++) {
        let s = o[a].props[e];
        if (s != null && (i = n ? n(s) : s))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (si) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && qz(this.dom), rs(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return Jz(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, n = 1) {
    return QF(this, e, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, n, r = -1) {
    let i = this.docView.posFromDOM(e, n, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, n) {
    return n$(this, n || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, n) {
    return Zp(this, "", e, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, n) {
    return Zp(this, e, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (I$(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Ww(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, Fz());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return F$(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let n = this._props.dispatchTransaction;
    n ? n.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? zr && this.root.nodeType === 11 && Lz(this.dom.ownerDocument) == this.dom && nH(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function tA(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(t.editable), t.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(t.state)), n)
      for (let r in n)
        r == "class" ? e.class += " " + n[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + n[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(n[r]));
  }), e.translate || (e.translate = "no"), [vn.node(0, t.state.doc.content.size, e)];
}
function nA(t) {
  if (t.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t.cursorWrapper = { dom: e, deco: vn.widget(t.state.selection.from, e, { raw: !0, marks: t.markCursor }) };
  } else
    t.cursorWrapper = null;
}
function rA(t) {
  return !t.someProp("editable", (e) => e(t.state) === !1);
}
function fH(t, e) {
  let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
  return t.$anchor.start(n) != e.$anchor.start(n);
}
function iA(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
  }
  return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function hH(t, e) {
  let n = 0, r = 0;
  for (let i in t) {
    if (t[i] != e[i])
      return !0;
    n++;
  }
  for (let i in e)
    r++;
  return n != r;
}
function oA(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Tl = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, _b = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, pH = typeof navigator < "u" && /Mac/.test(navigator.platform), mH = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var sr = 0; sr < 10; sr++) Tl[48 + sr] = Tl[96 + sr] = String(sr);
for (var sr = 1; sr <= 24; sr++) Tl[sr + 111] = "F" + sr;
for (var sr = 65; sr <= 90; sr++)
  Tl[sr] = String.fromCharCode(sr + 32), _b[sr] = String.fromCharCode(sr);
for (var $w in Tl) _b.hasOwnProperty($w) || (_b[$w] = Tl[$w]);
function gH(t) {
  var e = pH && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || mH && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? _b : Tl)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const yH = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function bH(t) {
  let e = t.split(/-(?!$)/), n = e[e.length - 1];
  n == "Space" && (n = " ");
  let r, i, o, a;
  for (let s = 0; s < e.length - 1; s++) {
    let l = e[s];
    if (/^(cmd|meta|m)$/i.test(l))
      a = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      o = !0;
    else if (/^mod$/i.test(l))
      yH ? a = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return r && (n = "Alt-" + n), i && (n = "Ctrl-" + n), a && (n = "Meta-" + n), o && (n = "Shift-" + n), n;
}
function vH(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t)
    e[bH(n)] = t[n];
  return e;
}
function Hw(t, e, n = !0) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n && e.shiftKey && (t = "Shift-" + t), t;
}
function wH(t) {
  return new Pt({ props: { handleKeyDown: cD(t) } });
}
function cD(t) {
  let e = vH(t);
  return function(n, r) {
    let i = gH(r), o, a = e[Hw(i, r)];
    if (a && a(n.state, n.dispatch, n))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let s = e[Hw(i, r, !1)];
        if (s && s(n.state, n.dispatch, n))
          return !0;
      }
      if ((r.shiftKey || r.altKey || r.metaKey || i.charCodeAt(0) > 127) && (o = Tl[r.keyCode]) && o != i) {
        let s = e[Hw(o, r)];
        if (s && s(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
const r1 = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function kU(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n;
}
const xH = (t, e, n) => {
  let r = kU(t, n);
  if (!r)
    return !1;
  let i = uD(r);
  if (!i) {
    let a = r.blockRange(), s = a && Hf(a);
    return s == null ? !1 : (e && e(t.tr.lift(a, s).scrollIntoView()), !0);
  }
  let o = i.nodeBefore;
  if (OU(t, i, e, -1))
    return !0;
  if (r.parent.content.size == 0 && (vf(o, "end") || st.isSelectable(o)))
    for (let a = r.depth; ; a--) {
      let s = Zv(t.doc, r.before(a), r.after(a), Xe.empty);
      if (s && s.slice.size < s.to - s.from) {
        if (e) {
          let l = t.tr.step(s);
          l.setSelection(vf(o, "end") ? dt.findFrom(l.doc.resolve(l.mapping.map(i.pos, -1)), -1) : st.create(l.doc, i.pos - o.nodeSize)), e(l.scrollIntoView());
        }
        return !0;
      }
      if (a == 1 || r.node(a - 1).childCount > 1)
        break;
    }
  return o.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos - o.nodeSize, i.pos).scrollIntoView()), !0) : !1;
}, _H = (t, e, n) => {
  let r = kU(t, n);
  if (!r)
    return !1;
  let i = uD(r);
  return i ? AU(t, i, e) : !1;
}, SH = (t, e, n) => {
  let r = RU(t, n);
  if (!r)
    return !1;
  let i = dD(r);
  return i ? AU(t, i, e) : !1;
};
function AU(t, e, n) {
  let r = e.nodeBefore, i = r, o = e.pos - 1;
  for (; !i.isTextblock; o--) {
    if (i.type.spec.isolating)
      return !1;
    let u = i.lastChild;
    if (!u)
      return !1;
    i = u;
  }
  let a = e.nodeAfter, s = a, l = e.pos + 1;
  for (; !s.isTextblock; l++) {
    if (s.type.spec.isolating)
      return !1;
    let u = s.firstChild;
    if (!u)
      return !1;
    s = u;
  }
  let c = Zv(t.doc, o, l, Xe.empty);
  if (!c || c.from != o || c instanceof qn && c.slice.size >= l - o)
    return !1;
  if (n) {
    let u = t.tr.step(c);
    u.setSelection(ot.create(u.doc, o)), n(u.scrollIntoView());
  }
  return !0;
}
function vf(t, e, n = !1) {
  for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (n && r.childCount != 1)
      return !1;
  }
  return !1;
}
const TH = (t, e, n) => {
  let { $head: r, empty: i } = t.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
      return !1;
    o = uD(r);
  }
  let a = o && o.nodeBefore;
  return !a || !st.isSelectable(a) ? !1 : (e && e(t.tr.setSelection(st.create(t.doc, o.pos - a.nodeSize)).scrollIntoView()), !0);
};
function uD(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0)
        return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function RU(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n;
}
const DH = (t, e, n) => {
  let r = RU(t, n);
  if (!r)
    return !1;
  let i = dD(r);
  if (!i)
    return !1;
  let o = i.nodeAfter;
  if (OU(t, i, e, 1))
    return !0;
  if (r.parent.content.size == 0 && (vf(o, "start") || st.isSelectable(o))) {
    let a = Zv(t.doc, r.before(), r.after(), Xe.empty);
    if (a && a.slice.size < a.to - a.from) {
      if (e) {
        let s = t.tr.step(a);
        s.setSelection(vf(o, "start") ? dt.findFrom(s.doc.resolve(s.mapping.map(i.pos)), 1) : st.create(s.doc, s.mapping.map(i.pos))), e(s.scrollIntoView());
      }
      return !0;
    }
  }
  return o.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos, i.pos + o.nodeSize).scrollIntoView()), !0) : !1;
}, EH = (t, e, n) => {
  let { $head: r, empty: i } = t.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size)
      return !1;
    o = dD(r);
  }
  let a = o && o.nodeAfter;
  return !a || !st.isSelectable(a) ? !1 : (e && e(t.tr.setSelection(st.create(t.doc, o.pos)).scrollIntoView()), !0);
};
function dD(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e);
      if (t.index(e) + 1 < n.childCount)
        return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const CH = (t, e) => {
  let n = t.selection, r = n instanceof st, i;
  if (r) {
    if (n.node.isTextblock || !Ol(t.doc, n.from))
      return !1;
    i = n.from;
  } else if (i = Jv(t.doc, n.from, -1), i == null)
    return !1;
  if (e) {
    let o = t.tr.join(i);
    r && o.setSelection(st.create(o.doc, i - t.doc.resolve(i).nodeBefore.nodeSize)), e(o.scrollIntoView());
  }
  return !0;
}, kH = (t, e) => {
  let n = t.selection, r;
  if (n instanceof st) {
    if (n.node.isTextblock || !Ol(t.doc, n.to))
      return !1;
    r = n.to;
  } else if (r = Jv(t.doc, n.to, 1), r == null)
    return !1;
  return e && e(t.tr.join(r).scrollIntoView()), !0;
}, AH = (t, e) => {
  let { $from: n, $to: r } = t.selection, i = n.blockRange(r), o = i && Hf(i);
  return o == null ? !1 : (e && e(t.tr.lift(i, o).scrollIntoView()), !0);
}, RH = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0);
};
function IU(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const IH = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  if (!n.parent.type.spec.code || !n.sameParent(r))
    return !1;
  let i = n.node(-1), o = n.indexAfter(-1), a = IU(i.contentMatchAt(o));
  if (!a || !i.canReplaceWith(o, o, a))
    return !1;
  if (e) {
    let s = n.after(), l = t.tr.replaceWith(s, s, a.createAndFill());
    l.setSelection(dt.near(l.doc.resolve(s), 1)), e(l.scrollIntoView());
  }
  return !0;
}, OH = (t, e) => {
  let n = t.selection, { $from: r, $to: i } = n;
  if (n instanceof Ci || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let o = IU(i.parent.contentMatchAt(i.indexAfter()));
  if (!o || !o.isTextblock)
    return !1;
  if (e) {
    let a = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, s = t.tr.insert(a, o.createAndFill());
    s.setSelection(ot.create(s.doc, a + 1)), e(s.scrollIntoView());
  }
  return !0;
}, FH = (t, e) => {
  let { $cursor: n } = t.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let o = n.before();
    if (ef(t.doc, o))
      return e && e(t.tr.split(o).scrollIntoView()), !0;
  }
  let r = n.blockRange(), i = r && Hf(r);
  return i == null ? !1 : (e && e(t.tr.lift(r, i).scrollIntoView()), !0);
}, UH = (t, e) => {
  let { $from: n, to: r } = t.selection, i, o = n.sharedDepth(r);
  return o == 0 ? !1 : (i = n.before(o), e && e(t.tr.setSelection(st.create(t.doc, i))), !0);
};
function NH(t, e, n) {
  let r = e.nodeBefore, i = e.nodeAfter, o = e.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(o - 1, o) ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(o, o + 1) || !(i.isTextblock || Ol(t.doc, e.pos)) ? !1 : (n && n(t.tr.join(e.pos).scrollIntoView()), !0);
}
function OU(t, e, n, r) {
  let i = e.nodeBefore, o = e.nodeAfter, a, s, l = i.type.spec.isolating || o.type.spec.isolating;
  if (!l && NH(t, e, n))
    return !0;
  let c = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (c && (a = (s = i.contentMatchAt(i.childCount)).findWrapping(o.type)) && s.matchType(a[0] || o.type).validEnd) {
    if (n) {
      let p = e.pos + o.nodeSize, m = ze.empty;
      for (let y = a.length - 1; y >= 0; y--)
        m = ze.from(a[y].create(null, m));
      m = ze.from(i.copy(m));
      let g = t.tr.step(new Gn(e.pos - 1, p, e.pos, p, new Xe(m, 1, 0), a.length, !0)), b = g.doc.resolve(p + 2 * a.length);
      b.nodeAfter && b.nodeAfter.type == i.type && Ol(g.doc, b.pos) && g.join(b.pos), n(g.scrollIntoView());
    }
    return !0;
  }
  let u = o.type.spec.isolating || r > 0 && l ? null : dt.findFrom(e, 1), d = u && u.$from.blockRange(u.$to), f = d && Hf(d);
  if (f != null && f >= e.depth)
    return n && n(t.tr.lift(d, f).scrollIntoView()), !0;
  if (c && vf(o, "start", !0) && vf(i, "end")) {
    let p = i, m = [];
    for (; m.push(p), !p.isTextblock; )
      p = p.lastChild;
    let g = o, b = 1;
    for (; !g.isTextblock; g = g.firstChild)
      b++;
    if (p.canReplace(p.childCount, p.childCount, g.content)) {
      if (n) {
        let y = ze.empty;
        for (let x = m.length - 1; x >= 0; x--)
          y = ze.from(m[x].copy(y));
        let w = t.tr.step(new Gn(e.pos - m.length, e.pos + o.nodeSize, e.pos + b, e.pos + o.nodeSize - b, new Xe(y, m.length, 0), 0, !0));
        n(w.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function FU(t) {
  return function(e, n) {
    let r = e.selection, i = t < 0 ? r.$from : r.$to, o = i.depth;
    for (; i.node(o).isInline; ) {
      if (!o)
        return !1;
      o--;
    }
    return i.node(o).isTextblock ? (n && n(e.tr.setSelection(ot.create(e.doc, t < 0 ? i.start(o) : i.end(o)))), !0) : !1;
  };
}
const MH = FU(-1), BH = FU(1);
function LH(t, e = null) {
  return function(n, r) {
    let { $from: i, $to: o } = n.selection, a = i.blockRange(o), s = a && ZT(a, t, e);
    return s ? (r && r(n.tr.wrap(a, s).scrollIntoView()), !0) : !1;
  };
}
function aA(t, e = null) {
  return function(n, r) {
    let i = !1;
    for (let o = 0; o < n.selection.ranges.length && !i; o++) {
      let { $from: { pos: a }, $to: { pos: s } } = n.selection.ranges[o];
      n.doc.nodesBetween(a, s, (l, c) => {
        if (i)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(t, e)))
          if (l.type == t)
            i = !0;
          else {
            let u = n.doc.resolve(c), d = u.index();
            i = u.parent.canReplaceWith(d, d + 1, t);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let o = n.tr;
      for (let a = 0; a < n.selection.ranges.length; a++) {
        let { $from: { pos: s }, $to: { pos: l } } = n.selection.ranges[a];
        o.setBlockType(s, l, t, e);
      }
      r(o.scrollIntoView());
    }
    return !0;
  };
}
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function PH(t, e = null) {
  return function(n, r) {
    let { $from: i, $to: o } = n.selection, a = i.blockRange(o), s = !1, l = a;
    if (!a)
      return !1;
    if (a.depth >= 2 && i.node(a.depth - 1).type.compatibleContent(t) && a.startIndex == 0) {
      if (i.index(a.depth - 1) == 0)
        return !1;
      let u = n.doc.resolve(a.start - 2);
      l = new Gp(u, u, a.depth), a.endIndex < a.parent.childCount && (a = new Gp(i, n.doc.resolve(o.end(a.depth)), a.depth)), s = !0;
    }
    let c = ZT(l, t, e, a);
    return c ? (r && r(WH(n.tr, a, c, s, t).scrollIntoView()), !0) : !1;
  };
}
function WH(t, e, n, r, i) {
  let o = ze.empty;
  for (let u = n.length - 1; u >= 0; u--)
    o = ze.from(n[u].type.create(n[u].attrs, o));
  t.step(new Gn(e.start - (r ? 2 : 0), e.end, e.start, e.end, new Xe(o, 0, 0), n.length, !0));
  let a = 0;
  for (let u = 0; u < n.length; u++)
    n[u].type == i && (a = u + 1);
  let s = n.length - a, l = e.start + n.length - (r ? 2 : 0), c = e.parent;
  for (let u = e.startIndex, d = e.endIndex, f = !0; u < d; u++, f = !1)
    !f && ef(t.doc, l, s) && (t.split(l, s), l += 2 * s), l += c.child(u).nodeSize;
  return t;
}
function zH(t) {
  return function(e, n) {
    let { $from: r, $to: i } = e.selection, o = r.blockRange(i, (a) => a.childCount > 0 && a.firstChild.type == t);
    return o ? n ? r.node(o.depth - 1).type == t ? $H(e, n, t, o) : HH(e, n, o) : !0 : !1;
  };
}
function $H(t, e, n, r) {
  let i = t.tr, o = r.end, a = r.$to.end(r.depth);
  o < a && (i.step(new Gn(o - 1, a, o, a, new Xe(ze.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new Gp(i.doc.resolve(r.$from.pos), i.doc.resolve(a), r.depth));
  const s = Hf(r);
  if (s == null)
    return !1;
  i.lift(r, s);
  let l = i.mapping.map(o, -1) - 1;
  return Ol(i.doc, l) && i.join(l), e(i.scrollIntoView()), !0;
}
function HH(t, e, n) {
  let r = t.tr, i = n.parent;
  for (let p = n.end, m = n.endIndex - 1, g = n.startIndex; m > g; m--)
    p -= i.child(m).nodeSize, r.delete(p - 1, p + 1);
  let o = r.doc.resolve(n.start), a = o.nodeAfter;
  if (r.mapping.map(n.end) != n.start + o.nodeAfter.nodeSize)
    return !1;
  let s = n.startIndex == 0, l = n.endIndex == i.childCount, c = o.node(-1), u = o.index(-1);
  if (!c.canReplace(u + (s ? 0 : 1), u + 1, a.content.append(l ? ze.empty : ze.from(i))))
    return !1;
  let d = o.pos, f = d + a.nodeSize;
  return r.step(new Gn(d - (s ? 1 : 0), f + (l ? 1 : 0), d + 1, f - 1, new Xe((s ? ze.empty : ze.from(i.copy(ze.empty))).append(l ? ze.empty : ze.from(i.copy(ze.empty))), s ? 0 : 1, l ? 0 : 1), s ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function jH(t) {
  return function(e, n) {
    let { $from: r, $to: i } = e.selection, o = r.blockRange(i, (c) => c.childCount > 0 && c.firstChild.type == t);
    if (!o)
      return !1;
    let a = o.startIndex;
    if (a == 0)
      return !1;
    let s = o.parent, l = s.child(a - 1);
    if (l.type != t)
      return !1;
    if (n) {
      let c = l.lastChild && l.lastChild.type == s.type, u = ze.from(c ? t.create() : null), d = new Xe(ze.from(t.create(null, ze.from(s.type.create(null, u)))), c ? 3 : 1, 0), f = o.start, p = o.end;
      n(e.tr.step(new Gn(f - (c ? 3 : 1), p, f, p, d, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function i1(t) {
  const { state: e, transaction: n } = t;
  let { selection: r } = n, { doc: i } = n, { storedMarks: o } = n;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return o;
    },
    get selection() {
      return r;
    },
    get doc() {
      return i;
    },
    get tr() {
      return r = n.selection, i = n.doc, o = n.storedMarks, n;
    }
  };
}
class o1 {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: n, state: r } = this, { view: i } = n, { tr: o } = r, a = this.buildProps(o);
    return Object.fromEntries(Object.entries(e).map(([s, l]) => [s, (...u) => {
      const d = l(...u)(a);
      return !o.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(o), d;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, n = !0) {
    const { rawCommands: r, editor: i, state: o } = this, { view: a } = i, s = [], l = !!e, c = e || o.tr, u = () => (!l && n && !c.getMeta("preventDispatch") && !this.hasCustomState && a.dispatch(c), s.every((f) => f === !0)), d = {
      ...Object.fromEntries(Object.entries(r).map(([f, p]) => [f, (...g) => {
        const b = this.buildProps(c, n), y = p(...g)(b);
        return s.push(y), d;
      }])),
      run: u
    };
    return d;
  }
  createCan(e) {
    const { rawCommands: n, state: r } = this, i = !1, o = e || r.tr, a = this.buildProps(o, i);
    return {
      ...Object.fromEntries(Object.entries(n).map(([l, c]) => [l, (...u) => c(...u)({ ...a, dispatch: void 0 })])),
      chain: () => this.createChain(o, i)
    };
  }
  buildProps(e, n = !0) {
    const { rawCommands: r, editor: i, state: o } = this, { view: a } = i, s = {
      tr: e,
      editor: i,
      view: a,
      state: i1({
        state: o,
        transaction: e
      }),
      dispatch: n ? () => {
      } : void 0,
      chain: () => this.createChain(e, n),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(Object.entries(r).map(([l, c]) => [l, (...u) => c(...u)(s)]));
      }
    };
    return s;
  }
}
let VH = class {
  constructor() {
    this.callbacks = {};
  }
  on(e, n) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
  }
  emit(e, ...n) {
    const r = this.callbacks[e];
    return r && r.forEach((i) => i.apply(this, n)), this;
  }
  off(e, n) {
    const r = this.callbacks[e];
    return r && (n ? this.callbacks[e] = r.filter((i) => i !== n) : delete this.callbacks[e]), this;
  }
  once(e, n) {
    const r = (...i) => {
      this.off(e, r), n.apply(this, i);
    };
    return this.on(e, r);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function tt(t, e, n) {
  return t.config[e] === void 0 && t.parent ? tt(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({
    ...n,
    parent: t.parent ? tt(t.parent, e, n) : null
  }) : t.config[e];
}
function a1(t) {
  const e = t.filter((i) => i.type === "extension"), n = t.filter((i) => i.type === "node"), r = t.filter((i) => i.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: n,
    markExtensions: r
  };
}
function UU(t) {
  const e = [], { nodeExtensions: n, markExtensions: r } = a1(t), i = [...n, ...r], o = {
    default: null,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return t.forEach((a) => {
    const s = {
      name: a.name,
      options: a.options,
      storage: a.storage,
      extensions: i
    }, l = tt(a, "addGlobalAttributes", s);
    if (!l)
      return;
    l().forEach((u) => {
      u.types.forEach((d) => {
        Object.entries(u.attributes).forEach(([f, p]) => {
          e.push({
            type: d,
            name: f,
            attribute: {
              ...o,
              ...p
            }
          });
        });
      });
    });
  }), i.forEach((a) => {
    const s = {
      name: a.name,
      options: a.options,
      storage: a.storage
    }, l = tt(a, "addAttributes", s);
    if (!l)
      return;
    const c = l();
    Object.entries(c).forEach(([u, d]) => {
      const f = {
        ...o,
        ...d
      };
      typeof (f == null ? void 0 : f.default) == "function" && (f.default = f.default()), f != null && f.isRequired && (f == null ? void 0 : f.default) === void 0 && delete f.default, e.push({
        type: a.name,
        name: u,
        attribute: f
      });
    });
  }), e;
}
function Xn(t, e) {
  if (typeof t == "string") {
    if (!e.nodes[t])
      throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
    return e.nodes[t];
  }
  return t;
}
function bt(...t) {
  return t.filter((e) => !!e).reduce((e, n) => {
    const r = { ...e };
    return Object.entries(n).forEach(([i, o]) => {
      if (!r[i]) {
        r[i] = o;
        return;
      }
      if (i === "class") {
        const s = o ? o.split(" ") : [], l = r[i] ? r[i].split(" ") : [], c = s.filter((u) => !l.includes(u));
        r[i] = [...l, ...c].join(" ");
      } else if (i === "style") {
        const s = o ? o.split(";").map((u) => u.trim()).filter(Boolean) : [], l = r[i] ? r[i].split(";").map((u) => u.trim()).filter(Boolean) : [], c = /* @__PURE__ */ new Map();
        l.forEach((u) => {
          const [d, f] = u.split(":").map((p) => p.trim());
          c.set(d, f);
        }), s.forEach((u) => {
          const [d, f] = u.split(":").map((p) => p.trim());
          c.set(d, f);
        }), r[i] = Array.from(c.entries()).map(([u, d]) => `${u}: ${d}`).join("; ");
      } else
        r[i] = o;
    }), r;
  }, {});
}
function Sb(t, e) {
  return e.filter((n) => n.type === t.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : {
    [n.name]: t.attrs[n.name]
  }).reduce((n, r) => bt(n, r), {});
}
function NU(t) {
  return typeof t == "function";
}
function yt(t, e = void 0, ...n) {
  return NU(t) ? e ? t.bind(e)(...n) : t(...n) : t;
}
function qH(t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object;
}
function GH(t) {
  return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t;
}
function sA(t, e) {
  return "style" in t ? t : {
    ...t,
    getAttrs: (n) => {
      const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
      if (r === !1)
        return !1;
      const i = e.reduce((o, a) => {
        const s = a.attribute.parseHTML ? a.attribute.parseHTML(n) : GH(n.getAttribute(a.name));
        return s == null ? o : {
          ...o,
          [a.name]: s
        };
      }, {});
      return { ...r, ...i };
    }
  };
}
function lA(t) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(t).filter(([e, n]) => e === "attrs" && qH(n) ? !1 : n != null)
  );
}
function KH(t, e) {
  var n;
  const r = UU(t), { nodeExtensions: i, markExtensions: o } = a1(t), a = (n = i.find((c) => tt(c, "topNode"))) === null || n === void 0 ? void 0 : n.name, s = Object.fromEntries(i.map((c) => {
    const u = r.filter((y) => y.type === c.name), d = {
      name: c.name,
      options: c.options,
      storage: c.storage,
      editor: e
    }, f = t.reduce((y, w) => {
      const x = tt(w, "extendNodeSchema", d);
      return {
        ...y,
        ...x ? x(c) : {}
      };
    }, {}), p = lA({
      ...f,
      content: yt(tt(c, "content", d)),
      marks: yt(tt(c, "marks", d)),
      group: yt(tt(c, "group", d)),
      inline: yt(tt(c, "inline", d)),
      atom: yt(tt(c, "atom", d)),
      selectable: yt(tt(c, "selectable", d)),
      draggable: yt(tt(c, "draggable", d)),
      code: yt(tt(c, "code", d)),
      whitespace: yt(tt(c, "whitespace", d)),
      linebreakReplacement: yt(tt(c, "linebreakReplacement", d)),
      defining: yt(tt(c, "defining", d)),
      isolating: yt(tt(c, "isolating", d)),
      attrs: Object.fromEntries(u.map((y) => {
        var w;
        return [y.name, { default: (w = y == null ? void 0 : y.attribute) === null || w === void 0 ? void 0 : w.default }];
      }))
    }), m = yt(tt(c, "parseHTML", d));
    m && (p.parseDOM = m.map((y) => sA(y, u)));
    const g = tt(c, "renderHTML", d);
    g && (p.toDOM = (y) => g({
      node: y,
      HTMLAttributes: Sb(y, u)
    }));
    const b = tt(c, "renderText", d);
    return b && (p.toText = b), [c.name, p];
  })), l = Object.fromEntries(o.map((c) => {
    const u = r.filter((b) => b.type === c.name), d = {
      name: c.name,
      options: c.options,
      storage: c.storage,
      editor: e
    }, f = t.reduce((b, y) => {
      const w = tt(y, "extendMarkSchema", d);
      return {
        ...b,
        ...w ? w(c) : {}
      };
    }, {}), p = lA({
      ...f,
      inclusive: yt(tt(c, "inclusive", d)),
      excludes: yt(tt(c, "excludes", d)),
      group: yt(tt(c, "group", d)),
      spanning: yt(tt(c, "spanning", d)),
      code: yt(tt(c, "code", d)),
      attrs: Object.fromEntries(u.map((b) => {
        var y;
        return [b.name, { default: (y = b == null ? void 0 : b.attribute) === null || y === void 0 ? void 0 : y.default }];
      }))
    }), m = yt(tt(c, "parseHTML", d));
    m && (p.parseDOM = m.map((b) => sA(b, u)));
    const g = tt(c, "renderHTML", d);
    return g && (p.toDOM = (b) => g({
      mark: b,
      HTMLAttributes: Sb(b, u)
    })), [c.name, p];
  }));
  return new AF({
    topNode: a,
    nodes: s,
    marks: l
  });
}
function jw(t, e) {
  return e.nodes[t] || e.marks[t] || null;
}
function cA(t, e) {
  return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name) : e;
}
function fD(t, e) {
  const n = uu.fromSchema(e).serializeFragment(t), i = document.implementation.createHTMLDocument().createElement("div");
  return i.appendChild(n), i.innerHTML;
}
const XH = (t, e = 500) => {
  let n = "";
  const r = t.parentOffset;
  return t.parent.nodesBetween(Math.max(0, r - e), r, (i, o, a, s) => {
    var l, c;
    const u = ((c = (l = i.type.spec).toText) === null || c === void 0 ? void 0 : c.call(l, {
      node: i,
      pos: o,
      parent: a,
      index: s
    })) || i.textContent || "%leaf%";
    n += i.isAtom && !i.isText ? u : u.slice(0, Math.max(0, r - o));
  }), n;
};
function hD(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
class s1 {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const YH = (t, e) => {
  if (hD(e))
    return e.exec(t);
  const n = e(t);
  if (!n)
    return null;
  const r = [n.text];
  return r.index = n.index, r.input = t, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r;
};
function Vg(t) {
  var e;
  const { editor: n, from: r, to: i, text: o, rules: a, plugin: s } = t, { view: l } = n;
  if (l.composing)
    return !1;
  const c = l.state.doc.resolve(r);
  if (
    // check for code node
    c.parent.type.spec.code || !((e = c.nodeBefore || c.nodeAfter) === null || e === void 0) && e.marks.find((f) => f.type.spec.code)
  )
    return !1;
  let u = !1;
  const d = XH(c) + o;
  return a.forEach((f) => {
    if (u)
      return;
    const p = YH(d, f.find);
    if (!p)
      return;
    const m = l.state.tr, g = i1({
      state: l.state,
      transaction: m
    }), b = {
      from: r - (p[0].length - o.length),
      to: i
    }, { commands: y, chain: w, can: x } = new o1({
      editor: n,
      state: g
    });
    f.handler({
      state: g,
      range: b,
      match: p,
      commands: y,
      chain: w,
      can: x
    }) === null || !m.steps.length || (m.setMeta(s, {
      transform: m,
      from: r,
      to: i,
      text: o
    }), l.dispatch(m), u = !0);
  }), u;
}
function JH(t) {
  const { editor: e, rules: n } = t, r = new Pt({
    state: {
      init() {
        return null;
      },
      apply(i, o, a) {
        const s = i.getMeta(r);
        if (s)
          return s;
        const l = i.getMeta("applyInputRules");
        return !!l && setTimeout(() => {
          let { text: u } = l;
          typeof u == "string" ? u = u : u = fD(ze.from(u), a.schema);
          const { from: d } = l, f = d + u.length;
          Vg({
            editor: e,
            from: d,
            to: f,
            text: u,
            rules: n,
            plugin: r
          });
        }), i.selectionSet || i.docChanged ? null : o;
      }
    },
    props: {
      handleTextInput(i, o, a, s) {
        return Vg({
          editor: e,
          from: o,
          to: a,
          text: s,
          rules: n,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (i) => (setTimeout(() => {
          const { $cursor: o } = i.state.selection;
          o && Vg({
            editor: e,
            from: o.pos,
            to: o.pos,
            text: "",
            rules: n,
            plugin: r
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(i, o) {
        if (o.key !== "Enter")
          return !1;
        const { $cursor: a } = i.state.selection;
        return a ? Vg({
          editor: e,
          from: a.pos,
          to: a.pos,
          text: `
`,
          rules: n,
          plugin: r
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return r;
}
function ZH(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function qg(t) {
  return ZH(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function l1(t, e) {
  const n = { ...t };
  return qg(t) && qg(e) && Object.keys(e).forEach((r) => {
    qg(e[r]) && qg(t[r]) ? n[r] = l1(t[r], e[r]) : n[r] = e[r];
  }), n;
}
class li {
  constructor(e = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = yt(tt(this, "addOptions", {
      name: this.name
    }))), this.storage = yt(tt(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new li(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => l1(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new li(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = yt(tt(n, "addOptions", {
      name: n.name
    })), n.storage = yt(tt(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: r } = e.state, i = e.state.selection.$from;
    if (i.pos === i.end()) {
      const a = i.marks();
      if (!!!a.find((c) => (c == null ? void 0 : c.type.name) === n.name))
        return !1;
      const l = a.find((c) => (c == null ? void 0 : c.type.name) === n.name);
      return l && r.removeStoredMark(l), r.insertText(" ", i.pos), e.view.dispatch(r), !0;
    }
    return !1;
  }
}
function QH(t) {
  return typeof t == "number";
}
class MU {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
}
const ej = (t, e, n) => {
  if (hD(e))
    return [...t.matchAll(e)];
  const r = e(t, n);
  return r ? r.map((i) => {
    const o = [i.text];
    return o.index = i.index, o.input = t, o.data = i.data, i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), o.push(i.replaceWith)), o;
  }) : [];
};
function tj(t) {
  const { editor: e, state: n, from: r, to: i, rule: o, pasteEvent: a, dropEvent: s } = t, { commands: l, chain: c, can: u } = new o1({
    editor: e,
    state: n
  }), d = [];
  return n.doc.nodesBetween(r, i, (p, m) => {
    if (!p.isTextblock || p.type.spec.code)
      return;
    const g = Math.max(r, m), b = Math.min(i, m + p.content.size), y = p.textBetween(g - m, b - m, void 0, "￼");
    ej(y, o.find, a).forEach((x) => {
      if (x.index === void 0)
        return;
      const k = g + x.index + 1, A = k + x[0].length, U = {
        from: n.tr.mapping.map(k),
        to: n.tr.mapping.map(A)
      }, P = o.handler({
        state: n,
        range: U,
        match: x,
        commands: l,
        chain: c,
        can: u,
        pasteEvent: a,
        dropEvent: s
      });
      d.push(P);
    });
  }), d.every((p) => p !== null);
}
const nj = (t) => {
  var e;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t), n;
};
function rj(t) {
  const { editor: e, rules: n } = t;
  let r = null, i = !1, o = !1, a = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, s;
  try {
    s = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    s = null;
  }
  const l = ({ state: u, from: d, to: f, rule: p, pasteEvt: m }) => {
    const g = u.tr, b = i1({
      state: u,
      transaction: g
    });
    if (!(!tj({
      editor: e,
      state: b,
      from: Math.max(d - 1, 0),
      to: f.b - 1,
      rule: p,
      pasteEvent: m,
      dropEvent: s
    }) || !g.steps.length)) {
      try {
        s = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        s = null;
      }
      return a = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, g;
    }
  };
  return n.map((u) => new Pt({
    // we register a global drag handler to track the current drag source element
    view(d) {
      const f = (p) => {
        var m;
        r = !((m = d.dom.parentElement) === null || m === void 0) && m.contains(p.target) ? d.dom.parentElement : null;
      };
      return window.addEventListener("dragstart", f), {
        destroy() {
          window.removeEventListener("dragstart", f);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (d, f) => (o = r === d.dom.parentElement, s = f, !1),
        paste: (d, f) => {
          var p;
          const m = (p = f.clipboardData) === null || p === void 0 ? void 0 : p.getData("text/html");
          return a = f, i = !!(m != null && m.includes("data-pm-slice")), !1;
        }
      }
    },
    appendTransaction: (d, f, p) => {
      const m = d[0], g = m.getMeta("uiEvent") === "paste" && !i, b = m.getMeta("uiEvent") === "drop" && !o, y = m.getMeta("applyPasteRules"), w = !!y;
      if (!g && !b && !w)
        return;
      if (w) {
        let { text: A } = y;
        typeof A == "string" ? A = A : A = fD(ze.from(A), p.schema);
        const { from: U } = y, P = U + A.length, V = nj(A);
        return l({
          rule: u,
          state: p,
          from: U,
          to: { b: P },
          pasteEvt: V
        });
      }
      const x = f.doc.content.findDiffStart(p.doc.content), k = f.doc.content.findDiffEnd(p.doc.content);
      if (!(!QH(x) || !k || x === k.b))
        return l({
          rule: u,
          state: p,
          from: x,
          to: k,
          pasteEvt: a
        });
    }
  }));
}
function ij(t) {
  const e = t.filter((n, r) => t.indexOf(n) !== r);
  return Array.from(new Set(e));
}
class Xd {
  constructor(e, n) {
    this.splittableMarks = [], this.editor = n, this.extensions = Xd.resolve(e), this.schema = KH(this.extensions, n), this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(e) {
    const n = Xd.sort(Xd.flatten(e)), r = ij(n.map((i) => i.name));
    return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map((i) => `'${i}'`).join(", ")}]. This can lead to issues.`), n;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(e) {
    return e.map((n) => {
      const r = {
        name: n.name,
        options: n.options,
        storage: n.storage
      }, i = tt(n, "addExtensions", r);
      return i ? [n, ...this.flatten(i())] : n;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(e) {
    return e.sort((r, i) => {
      const o = tt(r, "priority") || 100, a = tt(i, "priority") || 100;
      return o > a ? -1 : o < a ? 1 : 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, n) => {
      const r = {
        name: n.name,
        options: n.options,
        storage: n.storage,
        editor: this.editor,
        type: jw(n.name, this.schema)
      }, i = tt(n, "addCommands", r);
      return i ? {
        ...e,
        ...i()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this, n = Xd.sort([...this.extensions].reverse()), r = [], i = [], o = n.map((a) => {
      const s = {
        name: a.name,
        options: a.options,
        storage: a.storage,
        editor: e,
        type: jw(a.name, this.schema)
      }, l = [], c = tt(a, "addKeyboardShortcuts", s);
      let u = {};
      if (a.type === "mark" && tt(a, "exitable", s) && (u.ArrowRight = () => li.handleExit({ editor: e, mark: a })), c) {
        const g = Object.fromEntries(Object.entries(c()).map(([b, y]) => [b, () => y({ editor: e })]));
        u = { ...u, ...g };
      }
      const d = wH(u);
      l.push(d);
      const f = tt(a, "addInputRules", s);
      cA(a, e.options.enableInputRules) && f && r.push(...f());
      const p = tt(a, "addPasteRules", s);
      cA(a, e.options.enablePasteRules) && p && i.push(...p());
      const m = tt(a, "addProseMirrorPlugins", s);
      if (m) {
        const g = m();
        l.push(...g);
      }
      return l;
    }).flat();
    return [
      JH({
        editor: e,
        rules: r
      }),
      ...rj({
        editor: e,
        rules: i
      }),
      ...o
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return UU(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: n } = a1(this.extensions);
    return Object.fromEntries(n.filter((r) => !!tt(r, "addNodeView")).map((r) => {
      const i = this.attributes.filter((l) => l.type === r.name), o = {
        name: r.name,
        options: r.options,
        storage: r.storage,
        editor: e,
        type: Xn(r.name, this.schema)
      }, a = tt(r, "addNodeView", o);
      if (!a)
        return [];
      const s = (l, c, u, d, f) => {
        const p = Sb(l, i);
        return a()({
          // pass-through
          node: l,
          view: c,
          getPos: u,
          decorations: d,
          innerDecorations: f,
          // tiptap-specific
          editor: e,
          extension: r,
          HTMLAttributes: p
        });
      };
      return [r.name, s];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((e) => {
      var n;
      this.editor.extensionStorage[e.name] = e.storage;
      const r = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: jw(e.name, this.schema)
      };
      e.type === "mark" && (!((n = yt(tt(e, "keepOnSplit", r))) !== null && n !== void 0) || n) && this.splittableMarks.push(e.name);
      const i = tt(e, "onBeforeCreate", r), o = tt(e, "onCreate", r), a = tt(e, "onUpdate", r), s = tt(e, "onSelectionUpdate", r), l = tt(e, "onTransaction", r), c = tt(e, "onFocus", r), u = tt(e, "onBlur", r), d = tt(e, "onDestroy", r);
      i && this.editor.on("beforeCreate", i), o && this.editor.on("create", o), a && this.editor.on("update", a), s && this.editor.on("selectionUpdate", s), l && this.editor.on("transaction", l), c && this.editor.on("focus", c), u && this.editor.on("blur", u), d && this.editor.on("destroy", d);
    });
  }
}
class St {
  constructor(e = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = yt(tt(this, "addOptions", {
      name: this.name
    }))), this.storage = yt(tt(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new St(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => l1(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new St({ ...this.config, ...e });
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = yt(tt(n, "addOptions", {
      name: n.name
    })), n.storage = yt(tt(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
}
function BU(t, e, n) {
  const { from: r, to: i } = e, { blockSeparator: o = `

`, textSerializers: a = {} } = n || {};
  let s = "";
  return t.nodesBetween(r, i, (l, c, u, d) => {
    var f;
    l.isBlock && c > r && (s += o);
    const p = a == null ? void 0 : a[l.type.name];
    if (p)
      return u && (s += p({
        node: l,
        pos: c,
        parent: u,
        index: d,
        range: e
      })), !1;
    l.isText && (s += (f = l == null ? void 0 : l.text) === null || f === void 0 ? void 0 : f.slice(Math.max(r, c) - c, i - c));
  }), s;
}
function LU(t) {
  return Object.fromEntries(Object.entries(t.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText]));
}
const oj = St.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Pt({
        key: new Nt("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: t } = this, { state: e, schema: n } = t, { doc: r, selection: i } = e, { ranges: o } = i, a = Math.min(...o.map((u) => u.$from.pos)), s = Math.max(...o.map((u) => u.$to.pos)), l = LU(n);
            return BU(r, { from: a, to: s }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), aj = () => ({ editor: t, view: e }) => (requestAnimationFrame(() => {
  var n;
  t.isDestroyed || (e.dom.blur(), (n = window == null ? void 0 : window.getSelection()) === null || n === void 0 || n.removeAllRanges());
}), !0), sj = (t = !1) => ({ commands: e }) => e.setContent("", t), lj = () => ({ state: t, tr: e, dispatch: n }) => {
  const { selection: r } = e, { ranges: i } = r;
  return n && i.forEach(({ $from: o, $to: a }) => {
    t.doc.nodesBetween(o.pos, a.pos, (s, l) => {
      if (s.type.isText)
        return;
      const { doc: c, mapping: u } = e, d = c.resolve(u.map(l)), f = c.resolve(u.map(l + s.nodeSize)), p = d.blockRange(f);
      if (!p)
        return;
      const m = Hf(p);
      if (s.type.isTextblock) {
        const { defaultType: g } = d.parent.contentMatchAt(d.index());
        e.setNodeMarkup(p.start, g);
      }
      (m || m === 0) && e.lift(p, m);
    });
  }), !0;
}, cj = (t) => (e) => t(e), uj = () => ({ state: t, dispatch: e }) => OH(t, e), dj = (t, e) => ({ editor: n, tr: r }) => {
  const { state: i } = n, o = i.doc.slice(t.from, t.to);
  r.deleteRange(t.from, t.to);
  const a = r.mapping.map(e);
  return r.insert(a, o.content), r.setSelection(new ot(r.doc.resolve(a - 1))), !0;
}, fj = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, r = n.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const i = t.selection.$anchor;
  for (let o = i.depth; o > 0; o -= 1)
    if (i.node(o).type === r.type) {
      if (e) {
        const s = i.before(o), l = i.after(o);
        t.delete(s, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, hj = (t) => ({ tr: e, state: n, dispatch: r }) => {
  const i = Xn(t, n.schema), o = e.selection.$anchor;
  for (let a = o.depth; a > 0; a -= 1)
    if (o.node(a).type === i) {
      if (r) {
        const l = o.before(a), c = o.after(a);
        e.delete(l, c).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, pj = (t) => ({ tr: e, dispatch: n }) => {
  const { from: r, to: i } = t;
  return n && e.delete(r, i), !0;
}, mj = () => ({ state: t, dispatch: e }) => r1(t, e), gj = () => ({ commands: t }) => t.keyboardShortcut("Enter"), yj = () => ({ state: t, dispatch: e }) => IH(t, e);
function Tb(t, e, n = { strict: !0 }) {
  const r = Object.keys(e);
  return r.length ? r.every((i) => n.strict ? e[i] === t[i] : hD(e[i]) ? e[i].test(t[i]) : e[i] === t[i]) : !0;
}
function PU(t, e, n = {}) {
  return t.find((r) => r.type === e && Tb(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(n).map((i) => [i, r.attrs[i]])),
    n
  ));
}
function uA(t, e, n = {}) {
  return !!PU(t, e, n);
}
function c1(t, e, n) {
  var r;
  if (!t || !e)
    return;
  let i = t.parent.childAfter(t.parentOffset);
  if ((!i.node || !i.node.marks.some((u) => u.type === e)) && (i = t.parent.childBefore(t.parentOffset)), !i.node || !i.node.marks.some((u) => u.type === e) || (n = n || ((r = i.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs), !PU([...i.node.marks], e, n)))
    return;
  let a = i.index, s = t.start() + i.offset, l = a + 1, c = s + i.node.nodeSize;
  for (; a > 0 && uA([...t.parent.child(a - 1).marks], e, n); )
    a -= 1, s -= t.parent.child(a).nodeSize;
  for (; l < t.parent.childCount && uA([...t.parent.child(l).marks], e, n); )
    c += t.parent.child(l).nodeSize, l += 1;
  return {
    from: s,
    to: c
  };
}
function Ul(t, e) {
  if (typeof t == "string") {
    if (!e.marks[t])
      throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
    return e.marks[t];
  }
  return t;
}
const bj = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const o = Ul(t, r.schema), { doc: a, selection: s } = n, { $from: l, from: c, to: u } = s;
  if (i) {
    const d = c1(l, o, e);
    if (d && d.from <= c && d.to >= u) {
      const f = ot.create(a, d.from, d.to);
      n.setSelection(f);
    }
  }
  return !0;
}, vj = (t) => (e) => {
  const n = typeof t == "function" ? t(e) : t;
  for (let r = 0; r < n.length; r += 1)
    if (n[r](e))
      return !0;
  return !1;
};
function pD(t) {
  return t instanceof ot;
}
function Za(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function WU(t, e = null) {
  if (!e)
    return null;
  const n = dt.atStart(t), r = dt.atEnd(t);
  if (e === "start" || e === !0)
    return n;
  if (e === "end")
    return r;
  const i = n.from, o = r.to;
  return e === "all" ? ot.create(t, Za(0, i, o), Za(t.content.size, i, o)) : ot.create(t, Za(e, i, o), Za(e, i, o));
}
function u1() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const wj = (t = null, e = {}) => ({ editor: n, view: r, tr: i, dispatch: o }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const a = () => {
    u1() && r.dom.focus(), requestAnimationFrame(() => {
      n.isDestroyed || (r.focus(), e != null && e.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  if (r.hasFocus() && t === null || t === !1)
    return !0;
  if (o && t === null && !pD(n.state.selection))
    return a(), !0;
  const s = WU(i.doc, t) || n.state.selection, l = n.state.selection.eq(s);
  return o && (l || i.setSelection(s), l && i.storedMarks && i.setStoredMarks(i.storedMarks), a()), !0;
}, xj = (t, e) => (n) => t.every((r, i) => e(r, { ...n, index: i })), _j = (t, e) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e), zU = (t) => {
  const e = t.childNodes;
  for (let n = e.length - 1; n >= 0; n -= 1) {
    const r = e[n];
    r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? t.removeChild(r) : r.nodeType === 1 && zU(r);
  }
  return t;
};
function Gg(t) {
  const e = `<body>${t}</body>`, n = new window.DOMParser().parseFromString(e, "text/html").body;
  return zU(n);
}
function Db(t, e, n) {
  if (t instanceof ns || t instanceof ze)
    return t;
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const r = typeof t == "object" && t !== null, i = typeof t == "string";
  if (r)
    try {
      if (Array.isArray(t) && t.length > 0)
        return ze.fromArray(t.map((s) => e.nodeFromJSON(s)));
      const a = e.nodeFromJSON(t);
      return n.errorOnInvalidContent && a.check(), a;
    } catch (o) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: o });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", o), Db("", e, n);
    }
  if (i) {
    if (n.errorOnInvalidContent) {
      let a = !1, s = "";
      const l = new AF({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (c) => (a = !0, s = typeof c == "string" ? c : c.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? Ap.fromSchema(l).parseSlice(Gg(t), n.parseOptions) : Ap.fromSchema(l).parse(Gg(t), n.parseOptions), n.errorOnInvalidContent && a)
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${s}`) });
    }
    const o = Ap.fromSchema(e);
    return n.slice ? o.parseSlice(Gg(t), n.parseOptions).content : o.parse(Gg(t), n.parseOptions);
  }
  return Db("", e, n);
}
function Sj(t, e, n) {
  const r = t.steps.length - 1;
  if (r < e)
    return;
  const i = t.steps[r];
  if (!(i instanceof qn || i instanceof Gn))
    return;
  const o = t.mapping.maps[r];
  let a = 0;
  o.forEach((s, l, c, u) => {
    a === 0 && (a = u);
  }), t.setSelection(dt.near(t.doc.resolve(a), n));
}
const Tj = (t) => !("type" in t), Dj = (t, e, n) => ({ tr: r, dispatch: i, editor: o }) => {
  var a;
  if (i) {
    n = {
      parseOptions: o.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let s;
    try {
      s = Db(e, o.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...n.parseOptions
        },
        errorOnInvalidContent: (a = n.errorOnInvalidContent) !== null && a !== void 0 ? a : o.options.enableContentCheck
      });
    } catch (m) {
      return o.emit("contentError", {
        editor: o,
        error: m,
        disableCollaboration: () => {
          o.storage.collaboration && (o.storage.collaboration.isDisabled = !0);
        }
      }), !1;
    }
    let { from: l, to: c } = typeof t == "number" ? { from: t, to: t } : { from: t.from, to: t.to }, u = !0, d = !0;
    if ((Tj(s) ? s : [s]).forEach((m) => {
      m.check(), u = u ? m.isText && m.marks.length === 0 : !1, d = d ? m.isBlock : !1;
    }), l === c && d) {
      const { parent: m } = r.doc.resolve(l);
      m.isTextblock && !m.type.spec.code && !m.childCount && (l -= 1, c += 1);
    }
    let p;
    if (u) {
      if (Array.isArray(e))
        p = e.map((m) => m.text || "").join("");
      else if (e instanceof ze) {
        let m = "";
        e.forEach((g) => {
          g.text && (m += g.text);
        }), p = m;
      } else typeof e == "object" && e && e.text ? p = e.text : p = e;
      r.insertText(p, l, c);
    } else
      p = s, r.replaceWith(l, c, p);
    n.updateSelection && Sj(r, r.steps.length - 1, -1), n.applyInputRules && r.setMeta("applyInputRules", { from: l, text: p }), n.applyPasteRules && r.setMeta("applyPasteRules", { from: l, text: p });
  }
  return !0;
}, Ej = () => ({ state: t, dispatch: e }) => CH(t, e), Cj = () => ({ state: t, dispatch: e }) => kH(t, e), kj = () => ({ state: t, dispatch: e }) => xH(t, e), Aj = () => ({ state: t, dispatch: e }) => DH(t, e), Rj = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const r = Jv(t.doc, t.selection.$from.pos, -1);
    return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, Ij = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const r = Jv(t.doc, t.selection.$from.pos, 1);
    return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, Oj = () => ({ state: t, dispatch: e }) => _H(t, e), Fj = () => ({ state: t, dispatch: e }) => SH(t, e);
function $U() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function Uj(t) {
  const e = t.split(/-(?!$)/);
  let n = e[e.length - 1];
  n === "Space" && (n = " ");
  let r, i, o, a;
  for (let s = 0; s < e.length - 1; s += 1) {
    const l = e[s];
    if (/^(cmd|meta|m)$/i.test(l))
      a = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      o = !0;
    else if (/^mod$/i.test(l))
      u1() || $U() ? a = !0 : i = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return r && (n = `Alt-${n}`), i && (n = `Ctrl-${n}`), a && (n = `Meta-${n}`), o && (n = `Shift-${n}`), n;
}
const Nj = (t) => ({ editor: e, view: n, tr: r, dispatch: i }) => {
  const o = Uj(t).split(/-(?!$)/), a = o.find((c) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)), s = new KeyboardEvent("keydown", {
    key: a === "Space" ? " " : a,
    altKey: o.includes("Alt"),
    ctrlKey: o.includes("Ctrl"),
    metaKey: o.includes("Meta"),
    shiftKey: o.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = e.captureTransaction(() => {
    n.someProp("handleKeyDown", (c) => c(n, s));
  });
  return l == null || l.steps.forEach((c) => {
    const u = c.map(r.mapping);
    u && i && r.maybeStep(u);
  }), !0;
};
function em(t, e, n = {}) {
  const { from: r, to: i, empty: o } = t.selection, a = e ? Xn(e, t.schema) : null, s = [];
  t.doc.nodesBetween(r, i, (d, f) => {
    if (d.isText)
      return;
    const p = Math.max(r, f), m = Math.min(i, f + d.nodeSize);
    s.push({
      node: d,
      from: p,
      to: m
    });
  });
  const l = i - r, c = s.filter((d) => a ? a.name === d.node.type.name : !0).filter((d) => Tb(d.node.attrs, n, { strict: !1 }));
  return o ? !!c.length : c.reduce((d, f) => d + f.to - f.from, 0) >= l;
}
const Mj = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const i = Xn(t, n.schema);
  return em(n, i, e) ? AH(n, r) : !1;
}, Bj = () => ({ state: t, dispatch: e }) => FH(t, e), Lj = (t) => ({ state: e, dispatch: n }) => {
  const r = Xn(t, e.schema);
  return zH(r)(e, n);
}, Pj = () => ({ state: t, dispatch: e }) => RH(t, e);
function d1(t, e) {
  return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function dA(t, e) {
  const n = typeof e == "string" ? [e] : e;
  return Object.keys(t).reduce((r, i) => (n.includes(i) || (r[i] = t[i]), r), {});
}
const Wj = (t, e) => ({ tr: n, state: r, dispatch: i }) => {
  let o = null, a = null;
  const s = d1(typeof t == "string" ? t : t.name, r.schema);
  return s ? (s === "node" && (o = Xn(t, r.schema)), s === "mark" && (a = Ul(t, r.schema)), i && n.selection.ranges.forEach((l) => {
    r.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, u) => {
      o && o === c.type && n.setNodeMarkup(u, void 0, dA(c.attrs, e)), a && c.marks.length && c.marks.forEach((d) => {
        a === d.type && n.addMark(u, u + c.nodeSize, a.create(dA(d.attrs, e)));
      });
    });
  }), !0) : !1;
}, zj = () => ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0), $j = () => ({ tr: t, commands: e }) => e.setTextSelection({
  from: 0,
  to: t.doc.content.size
}), Hj = () => ({ state: t, dispatch: e }) => TH(t, e), jj = () => ({ state: t, dispatch: e }) => EH(t, e), Vj = () => ({ state: t, dispatch: e }) => UH(t, e), qj = () => ({ state: t, dispatch: e }) => BH(t, e), Gj = () => ({ state: t, dispatch: e }) => MH(t, e);
function yS(t, e, n = {}, r = {}) {
  return Db(t, e, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent
  });
}
const Kj = (t, e = !1, n = {}, r = {}) => ({ editor: i, tr: o, dispatch: a, commands: s }) => {
  var l, c;
  const { doc: u } = o;
  if (n.preserveWhitespace !== "full") {
    const d = yS(t, i.schema, n, {
      errorOnInvalidContent: (l = r.errorOnInvalidContent) !== null && l !== void 0 ? l : i.options.enableContentCheck
    });
    return a && o.replaceWith(0, u.content.size, d).setMeta("preventUpdate", !e), !0;
  }
  return a && o.setMeta("preventUpdate", !e), s.insertContentAt({ from: 0, to: u.content.size }, t, {
    parseOptions: n,
    errorOnInvalidContent: (c = r.errorOnInvalidContent) !== null && c !== void 0 ? c : i.options.enableContentCheck
  });
};
function mD(t, e) {
  const n = Ul(e, t.schema), { from: r, to: i, empty: o } = t.selection, a = [];
  o ? (t.storedMarks && a.push(...t.storedMarks), a.push(...t.selection.$head.marks())) : t.doc.nodesBetween(r, i, (l) => {
    a.push(...l.marks);
  });
  const s = a.find((l) => l.type.name === n.name);
  return s ? { ...s.attrs } : {};
}
function Xj(t, e) {
  const n = new QT(t);
  return e.forEach((r) => {
    r.steps.forEach((i) => {
      n.step(i);
    });
  }), n;
}
function Yj(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function Jj(t, e, n) {
  const r = [];
  return t.nodesBetween(e.from, e.to, (i, o) => {
    n(i) && r.push({
      node: i,
      pos: o
    });
  }), r;
}
function HU(t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const r = t.node(n);
    if (e(r))
      return {
        pos: n > 0 ? t.before(n) : 0,
        start: t.start(n),
        depth: n,
        node: r
      };
  }
}
function Jc(t) {
  return (e) => HU(e.$from, t);
}
function Zj(t, e) {
  const n = {
    from: 0,
    to: t.content.size
  };
  return BU(t, n, e);
}
function Qj(t, e) {
  const n = Xn(e, t.schema), { from: r, to: i } = t.selection, o = [];
  t.doc.nodesBetween(r, i, (s) => {
    o.push(s);
  });
  const a = o.reverse().find((s) => s.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function jU(t, e) {
  const n = d1(typeof e == "string" ? e : e.name, t.schema);
  return n === "node" ? Qj(t, e) : n === "mark" ? mD(t, e) : {};
}
function eV(t, e = JSON.stringify) {
  const n = {};
  return t.filter((r) => {
    const i = e(r);
    return Object.prototype.hasOwnProperty.call(n, i) ? !1 : n[i] = !0;
  });
}
function tV(t) {
  const e = eV(t);
  return e.length === 1 ? e : e.filter((n, r) => !e.filter((o, a) => a !== r).some((o) => n.oldRange.from >= o.oldRange.from && n.oldRange.to <= o.oldRange.to && n.newRange.from >= o.newRange.from && n.newRange.to <= o.newRange.to));
}
function nV(t) {
  const { mapping: e, steps: n } = t, r = [];
  return e.maps.forEach((i, o) => {
    const a = [];
    if (i.ranges.length)
      i.forEach((s, l) => {
        a.push({ from: s, to: l });
      });
    else {
      const { from: s, to: l } = n[o];
      if (s === void 0 || l === void 0)
        return;
      a.push({ from: s, to: l });
    }
    a.forEach(({ from: s, to: l }) => {
      const c = e.slice(o).map(s, -1), u = e.slice(o).map(l), d = e.invert().map(c, -1), f = e.invert().map(u);
      r.push({
        oldRange: {
          from: d,
          to: f
        },
        newRange: {
          from: c,
          to: u
        }
      });
    });
  }), tV(r);
}
function gD(t, e, n) {
  const r = [];
  return t === e ? n.resolve(t).marks().forEach((i) => {
    const o = n.resolve(t), a = c1(o, i.type);
    a && r.push({
      mark: i,
      ...a
    });
  }) : n.nodesBetween(t, e, (i, o) => {
    !i || (i == null ? void 0 : i.nodeSize) === void 0 || r.push(...i.marks.map((a) => ({
      from: o,
      to: o + i.nodeSize,
      mark: a
    })));
  }), r;
}
function Wy(t, e, n) {
  return Object.fromEntries(Object.entries(n).filter(([r]) => {
    const i = t.find((o) => o.type === e && o.name === r);
    return i ? i.attribute.keepOnSplit : !1;
  }));
}
function bS(t, e, n = {}) {
  const { empty: r, ranges: i } = t.selection, o = e ? Ul(e, t.schema) : null;
  if (r)
    return !!(t.storedMarks || t.selection.$from.marks()).filter((d) => o ? o.name === d.type.name : !0).find((d) => Tb(d.attrs, n, { strict: !1 }));
  let a = 0;
  const s = [];
  if (i.forEach(({ $from: d, $to: f }) => {
    const p = d.pos, m = f.pos;
    t.doc.nodesBetween(p, m, (g, b) => {
      if (!g.isText && !g.marks.length)
        return;
      const y = Math.max(p, b), w = Math.min(m, b + g.nodeSize), x = w - y;
      a += x, s.push(...g.marks.map((k) => ({
        mark: k,
        from: y,
        to: w
      })));
    });
  }), a === 0)
    return !1;
  const l = s.filter((d) => o ? o.name === d.mark.type.name : !0).filter((d) => Tb(d.mark.attrs, n, { strict: !1 })).reduce((d, f) => d + f.to - f.from, 0), c = s.filter((d) => o ? d.mark.type !== o && d.mark.type.excludes(o) : !0).reduce((d, f) => d + f.to - f.from, 0);
  return (l > 0 ? l + c : l) >= a;
}
function VU(t, e, n = {}) {
  if (!e)
    return em(t, null, n) || bS(t, null, n);
  const r = d1(e, t.schema);
  return r === "node" ? em(t, e, n) : r === "mark" ? bS(t, e, n) : !1;
}
function vS(t, e) {
  const { nodeExtensions: n } = a1(e), r = n.find((a) => a.name === t);
  if (!r)
    return !1;
  const i = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, o = yt(tt(r, "group", i));
  return typeof o != "string" ? !1 : o.split(" ").includes("list");
}
function f1(t, { checkChildren: e = !0, ignoreWhitespace: n = !1 } = {}) {
  var r;
  if (n) {
    if (t.type.name === "hardBreak")
      return !0;
    if (t.isText)
      return /^\s*$/m.test((r = t.text) !== null && r !== void 0 ? r : "");
  }
  if (t.isText)
    return !t.text;
  if (t.isAtom || t.isLeaf)
    return !1;
  if (t.content.childCount === 0)
    return !0;
  if (e) {
    let i = !0;
    return t.content.forEach((o) => {
      i !== !1 && (f1(o, { ignoreWhitespace: n, checkChildren: e }) || (i = !1));
    }), i;
  }
  return !1;
}
function qU(t) {
  return t instanceof st;
}
function rV(t, e, n) {
  const i = t.state.doc.content.size, o = Za(e, 0, i), a = Za(n, 0, i), s = t.coordsAtPos(o), l = t.coordsAtPos(a, -1), c = Math.min(s.top, l.top), u = Math.max(s.bottom, l.bottom), d = Math.min(s.left, l.left), f = Math.max(s.right, l.right), p = f - d, m = u - c, y = {
    top: c,
    bottom: u,
    left: d,
    right: f,
    width: p,
    height: m,
    x: d,
    y: c
  };
  return {
    ...y,
    toJSON: () => y
  };
}
function iV(t, e, n) {
  var r;
  const { selection: i } = e;
  let o = null;
  if (pD(i) && (o = i.$cursor), o) {
    const s = (r = t.storedMarks) !== null && r !== void 0 ? r : o.marks();
    return !!n.isInSet(s) || !s.some((l) => l.type.excludes(n));
  }
  const { ranges: a } = i;
  return a.some(({ $from: s, $to: l }) => {
    let c = s.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
    return t.doc.nodesBetween(s.pos, l.pos, (u, d, f) => {
      if (c)
        return !1;
      if (u.isInline) {
        const p = !f || f.type.allowsMarkType(n), m = !!n.isInSet(u.marks) || !u.marks.some((g) => g.type.excludes(n));
        c = p && m;
      }
      return !c;
    }), c;
  });
}
const oV = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  const { selection: o } = n, { empty: a, ranges: s } = o, l = Ul(t, r.schema);
  if (i)
    if (a) {
      const c = mD(r, l);
      n.addStoredMark(l.create({
        ...c,
        ...e
      }));
    } else
      s.forEach((c) => {
        const u = c.$from.pos, d = c.$to.pos;
        r.doc.nodesBetween(u, d, (f, p) => {
          const m = Math.max(p, u), g = Math.min(p + f.nodeSize, d);
          f.marks.find((y) => y.type === l) ? f.marks.forEach((y) => {
            l === y.type && n.addMark(m, g, l.create({
              ...y.attrs,
              ...e
            }));
          }) : n.addMark(m, g, l.create(e));
        });
      });
  return iV(r, n, l);
}, aV = (t, e) => ({ tr: n }) => (n.setMeta(t, e), !0), sV = (t, e = {}) => ({ state: n, dispatch: r, chain: i }) => {
  const o = Xn(t, n.schema);
  let a;
  return n.selection.$anchor.sameParent(n.selection.$head) && (a = n.selection.$anchor.parent.attrs), o.isTextblock ? i().command(({ commands: s }) => aA(o, { ...a, ...e })(n) ? !0 : s.clearNodes()).command(({ state: s }) => aA(o, { ...a, ...e })(s, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, lV = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, i = Za(t, 0, r.content.size), o = st.create(r, i);
    e.setSelection(o);
  }
  return !0;
}, cV = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, { from: i, to: o } = typeof t == "number" ? { from: t, to: t } : t, a = ot.atStart(r).from, s = ot.atEnd(r).to, l = Za(i, a, s), c = Za(o, a, s), u = ot.create(r, l, c);
    e.setSelection(u);
  }
  return !0;
}, uV = (t) => ({ state: e, dispatch: n }) => {
  const r = Xn(t, e.schema);
  return jH(r)(e, n);
};
function fA(t, e) {
  const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
  if (n) {
    const r = n.filter((i) => e == null ? void 0 : e.includes(i.type.name));
    t.tr.ensureMarks(r);
  }
}
const dV = ({ keepMarks: t = !0 } = {}) => ({ tr: e, state: n, dispatch: r, editor: i }) => {
  const { selection: o, doc: a } = e, { $from: s, $to: l } = o, c = i.extensionManager.attributes, u = Wy(c, s.node().type.name, s.node().attrs);
  if (o instanceof st && o.node.isBlock)
    return !s.parentOffset || !ef(a, s.pos) ? !1 : (r && (t && fA(n, i.extensionManager.splittableMarks), e.split(s.pos).scrollIntoView()), !0);
  if (!s.parent.isBlock)
    return !1;
  const d = l.parentOffset === l.parent.content.size, f = s.depth === 0 ? void 0 : Yj(s.node(-1).contentMatchAt(s.indexAfter(-1)));
  let p = d && f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0, m = ef(e.doc, e.mapping.map(s.pos), 1, p);
  if (!p && !m && ef(e.doc, e.mapping.map(s.pos), 1, f ? [{ type: f }] : void 0) && (m = !0, p = f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0), r) {
    if (m && (o instanceof ot && e.deleteSelection(), e.split(e.mapping.map(s.pos), 1, p), f && !d && !s.parentOffset && s.parent.type !== f)) {
      const g = e.mapping.map(s.before()), b = e.doc.resolve(g);
      s.node(-1).canReplaceWith(b.index(), b.index() + 1, f) && e.setNodeMarkup(e.mapping.map(s.before()), f);
    }
    t && fA(n, i.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return m;
}, fV = (t, e = {}) => ({ tr: n, state: r, dispatch: i, editor: o }) => {
  var a;
  const s = Xn(t, r.schema), { $from: l, $to: c } = r.selection, u = r.selection.node;
  if (u && u.isBlock || l.depth < 2 || !l.sameParent(c))
    return !1;
  const d = l.node(-1);
  if (d.type !== s)
    return !1;
  const f = o.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== s || l.index(-2) !== l.node(-2).childCount - 1)
      return !1;
    if (i) {
      let y = ze.empty;
      const w = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let V = l.depth - w; V >= l.depth - 3; V -= 1)
        y = ze.from(l.node(V).copy(y));
      const x = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, k = {
        ...Wy(f, l.node().type.name, l.node().attrs),
        ...e
      }, A = ((a = s.contentMatch.defaultType) === null || a === void 0 ? void 0 : a.createAndFill(k)) || void 0;
      y = y.append(ze.from(s.createAndFill(null, A) || void 0));
      const U = l.before(l.depth - (w - 1));
      n.replace(U, l.after(-x), new Xe(y, 4 - w, 0));
      let P = -1;
      n.doc.nodesBetween(U, n.doc.content.size, (V, I) => {
        if (P > -1)
          return !1;
        V.isTextblock && V.content.size === 0 && (P = I + 1);
      }), P > -1 && n.setSelection(ot.near(n.doc.resolve(P))), n.scrollIntoView();
    }
    return !0;
  }
  const p = c.pos === l.end() ? d.contentMatchAt(0).defaultType : null, m = {
    ...Wy(f, d.type.name, d.attrs),
    ...e
  }, g = {
    ...Wy(f, l.node().type.name, l.node().attrs),
    ...e
  };
  n.delete(l.pos, c.pos);
  const b = p ? [
    { type: s, attrs: m },
    { type: p, attrs: g }
  ] : [{ type: s, attrs: m }];
  if (!ef(n.doc, l.pos, 2))
    return !1;
  if (i) {
    const { selection: y, storedMarks: w } = r, { splittableMarks: x } = o.extensionManager, k = w || y.$to.parentOffset && y.$from.marks();
    if (n.split(l.pos, 2, b).scrollIntoView(), !k || !i)
      return !0;
    const A = k.filter((U) => x.includes(U.type.name));
    n.ensureMarks(A);
  }
  return !0;
}, Vw = (t, e) => {
  const n = Jc((a) => a.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (r === void 0)
    return !0;
  const i = t.doc.nodeAt(r);
  return n.node.type === (i == null ? void 0 : i.type) && Ol(t.doc, n.pos) && t.join(n.pos), !0;
}, qw = (t, e) => {
  const n = Jc((a) => a.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(n.start).after(n.depth);
  if (r === void 0)
    return !0;
  const i = t.doc.nodeAt(r);
  return n.node.type === (i == null ? void 0 : i.type) && Ol(t.doc, r) && t.join(r), !0;
}, hV = (t, e, n, r = {}) => ({ editor: i, tr: o, state: a, dispatch: s, chain: l, commands: c, can: u }) => {
  const { extensions: d, splittableMarks: f } = i.extensionManager, p = Xn(t, a.schema), m = Xn(e, a.schema), { selection: g, storedMarks: b } = a, { $from: y, $to: w } = g, x = y.blockRange(w), k = b || g.$to.parentOffset && g.$from.marks();
  if (!x)
    return !1;
  const A = Jc((U) => vS(U.type.name, d))(g);
  if (x.depth >= 1 && A && x.depth - A.depth <= 1) {
    if (A.node.type === p)
      return c.liftListItem(m);
    if (vS(A.node.type.name, d) && p.validContent(A.node.content) && s)
      return l().command(() => (o.setNodeMarkup(A.pos, p), !0)).command(() => Vw(o, p)).command(() => qw(o, p)).run();
  }
  return !n || !k || !s ? l().command(() => u().wrapInList(p, r) ? !0 : c.clearNodes()).wrapInList(p, r).command(() => Vw(o, p)).command(() => qw(o, p)).run() : l().command(() => {
    const U = u().wrapInList(p, r), P = k.filter((V) => f.includes(V.type.name));
    return o.ensureMarks(P), U ? !0 : c.clearNodes();
  }).wrapInList(p, r).command(() => Vw(o, p)).command(() => qw(o, p)).run();
}, pV = (t, e = {}, n = {}) => ({ state: r, commands: i }) => {
  const { extendEmptyMarkRange: o = !1 } = n, a = Ul(t, r.schema);
  return bS(r, a, e) ? i.unsetMark(a, { extendEmptyMarkRange: o }) : i.setMark(a, e);
}, mV = (t, e, n = {}) => ({ state: r, commands: i }) => {
  const o = Xn(t, r.schema), a = Xn(e, r.schema), s = em(r, o, n);
  let l;
  return r.selection.$anchor.sameParent(r.selection.$head) && (l = r.selection.$anchor.parent.attrs), s ? i.setNode(a, l) : i.setNode(o, { ...l, ...n });
}, gV = (t, e = {}) => ({ state: n, commands: r }) => {
  const i = Xn(t, n.schema);
  return em(n, i, e) ? r.lift(i) : r.wrapIn(i, e);
}, yV = () => ({ state: t, dispatch: e }) => {
  const n = t.plugins;
  for (let r = 0; r < n.length; r += 1) {
    const i = n[r];
    let o;
    if (i.spec.isInputRules && (o = i.getState(t))) {
      if (e) {
        const a = t.tr, s = o.transform;
        for (let l = s.steps.length - 1; l >= 0; l -= 1)
          a.step(s.steps[l].invert(s.docs[l]));
        if (o.text) {
          const l = a.doc.resolve(o.from).marks();
          a.replaceWith(o.from, o.to, t.schema.text(o.text, l));
        } else
          a.delete(o.from, o.to);
      }
      return !0;
    }
  }
  return !1;
}, bV = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, { empty: r, ranges: i } = n;
  return r || e && i.forEach((o) => {
    t.removeMark(o.$from.pos, o.$to.pos);
  }), !0;
}, vV = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  var o;
  const { extendEmptyMarkRange: a = !1 } = e, { selection: s } = n, l = Ul(t, r.schema), { $from: c, empty: u, ranges: d } = s;
  if (!i)
    return !0;
  if (u && a) {
    let { from: f, to: p } = s;
    const m = (o = c.marks().find((b) => b.type === l)) === null || o === void 0 ? void 0 : o.attrs, g = c1(c, l, m);
    g && (f = g.from, p = g.to), n.removeMark(f, p, l);
  } else
    d.forEach((f) => {
      n.removeMark(f.$from.pos, f.$to.pos, l);
    });
  return n.removeStoredMark(l), !0;
}, wV = (t, e = {}) => ({ tr: n, state: r, dispatch: i }) => {
  let o = null, a = null;
  const s = d1(typeof t == "string" ? t : t.name, r.schema);
  return s ? (s === "node" && (o = Xn(t, r.schema)), s === "mark" && (a = Ul(t, r.schema)), i && n.selection.ranges.forEach((l) => {
    const c = l.$from.pos, u = l.$to.pos;
    let d, f, p, m;
    n.selection.empty ? r.doc.nodesBetween(c, u, (g, b) => {
      o && o === g.type && (p = Math.max(b, c), m = Math.min(b + g.nodeSize, u), d = b, f = g);
    }) : r.doc.nodesBetween(c, u, (g, b) => {
      b < c && o && o === g.type && (p = Math.max(b, c), m = Math.min(b + g.nodeSize, u), d = b, f = g), b >= c && b <= u && (o && o === g.type && n.setNodeMarkup(b, void 0, {
        ...g.attrs,
        ...e
      }), a && g.marks.length && g.marks.forEach((y) => {
        if (a === y.type) {
          const w = Math.max(b, c), x = Math.min(b + g.nodeSize, u);
          n.addMark(w, x, a.create({
            ...y.attrs,
            ...e
          }));
        }
      }));
    }), f && (d !== void 0 && n.setNodeMarkup(d, void 0, {
      ...f.attrs,
      ...e
    }), a && f.marks.length && f.marks.forEach((g) => {
      a === g.type && n.addMark(p, m, a.create({
        ...g.attrs,
        ...e
      }));
    }));
  }), !0) : !1;
}, xV = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const i = Xn(t, n.schema);
  return LH(i, e)(n, r);
}, _V = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const i = Xn(t, n.schema);
  return PH(i, e)(n, r);
};
var SV = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur: aj,
  clearContent: sj,
  clearNodes: lj,
  command: cj,
  createParagraphNear: uj,
  cut: dj,
  deleteCurrentNode: fj,
  deleteNode: hj,
  deleteRange: pj,
  deleteSelection: mj,
  enter: gj,
  exitCode: yj,
  extendMarkRange: bj,
  first: vj,
  focus: wj,
  forEach: xj,
  insertContent: _j,
  insertContentAt: Dj,
  joinBackward: kj,
  joinDown: Cj,
  joinForward: Aj,
  joinItemBackward: Rj,
  joinItemForward: Ij,
  joinTextblockBackward: Oj,
  joinTextblockForward: Fj,
  joinUp: Ej,
  keyboardShortcut: Nj,
  lift: Mj,
  liftEmptyBlock: Bj,
  liftListItem: Lj,
  newlineInCode: Pj,
  resetAttributes: Wj,
  scrollIntoView: zj,
  selectAll: $j,
  selectNodeBackward: Hj,
  selectNodeForward: jj,
  selectParentNode: Vj,
  selectTextblockEnd: qj,
  selectTextblockStart: Gj,
  setContent: Kj,
  setMark: oV,
  setMeta: aV,
  setNode: sV,
  setNodeSelection: lV,
  setTextSelection: cV,
  sinkListItem: uV,
  splitBlock: dV,
  splitListItem: fV,
  toggleList: hV,
  toggleMark: pV,
  toggleNode: mV,
  toggleWrap: gV,
  undoInputRule: yV,
  unsetAllMarks: bV,
  unsetMark: vV,
  updateAttributes: wV,
  wrapIn: xV,
  wrapInList: _V
});
const TV = St.create({
  name: "commands",
  addCommands() {
    return {
      ...SV
    };
  }
}), DV = St.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Pt({
        key: new Nt("tiptapDrop"),
        props: {
          handleDrop: (t, e, n, r) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: n,
              moved: r
            });
          }
        }
      })
    ];
  }
}), EV = St.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Pt({
        key: new Nt("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), CV = St.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new Pt({
        key: new Nt("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (e, n) => {
              t.isFocused = !0;
              const r = t.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            },
            blur: (e, n) => {
              t.isFocused = !1;
              const r = t.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), kV = St.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const t = () => this.editor.commands.first(({ commands: a }) => [
      () => a.undoInputRule(),
      // maybe convert first text block node to default node
      () => a.command(({ tr: s }) => {
        const { selection: l, doc: c } = s, { empty: u, $anchor: d } = l, { pos: f, parent: p } = d, m = d.parent.isTextblock && f > 0 ? s.doc.resolve(f - 1) : d, g = m.parent.type.spec.isolating, b = d.pos - d.parentOffset, y = g && m.parent.childCount === 1 ? b === d.pos : dt.atStart(c).from === f;
        return !u || !p.type.isTextblock || p.textContent.length || !y || y && d.parent.type.name === "paragraph" ? !1 : a.clearNodes();
      }),
      () => a.deleteSelection(),
      () => a.joinBackward(),
      () => a.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: a }) => [
      () => a.deleteSelection(),
      () => a.deleteCurrentNode(),
      () => a.joinForward(),
      () => a.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: a }) => [
        () => a.newlineInCode(),
        () => a.createParagraphNear(),
        () => a.liftEmptyBlock(),
        () => a.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: t,
      "Mod-Backspace": t,
      "Shift-Backspace": t,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, i = {
      ...r
    }, o = {
      ...r,
      "Ctrl-h": t,
      "Alt-Backspace": t,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return u1() || $U() ? o : i;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Pt({
        key: new Nt("clearDocument"),
        appendTransaction: (t, e, n) => {
          const r = t.some((g) => g.docChanged) && !e.doc.eq(n.doc), i = t.some((g) => g.getMeta("preventClearDocument"));
          if (!r || i)
            return;
          const { empty: o, from: a, to: s } = e.selection, l = dt.atStart(e.doc).from, c = dt.atEnd(e.doc).to;
          if (o || !(a === l && s === c) || !f1(n.doc))
            return;
          const f = n.tr, p = i1({
            state: n,
            transaction: f
          }), { commands: m } = new o1({
            editor: this.editor,
            state: p
          });
          if (m.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), AV = St.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Pt({
        key: new Nt("tiptapPaste"),
        props: {
          handlePaste: (t, e, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: n
            });
          }
        }
      })
    ];
  }
}), RV = St.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Pt({
        key: new Nt("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
class Oc {
  get name() {
    return this.node.type.name;
  }
  constructor(e, n, r = !1, i = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = e, this.editor = n, this.currentNode = i;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let n = this.from, r = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, r = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(e);
    return new Oc(n, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new Oc(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new Oc(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((n, r) => {
      const i = n.isBlock && !n.isTextblock, o = n.isAtom && !n.isText, a = this.pos + r + (o ? 0 : 1), s = this.resolvedPos.doc.resolve(a);
      if (!i && s.depth <= this.depth)
        return;
      const l = new Oc(s, this.editor, i, i ? n : null);
      i && (l.actualDepth = this.depth + 1), e.push(new Oc(s, this.editor, i, i ? n : null));
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, n = {}) {
    let r = null, i = this.parent;
    for (; i && !r; ) {
      if (i.node.type.name === e)
        if (Object.keys(n).length > 0) {
          const o = i.node.attrs, a = Object.keys(n);
          for (let s = 0; s < a.length; s += 1) {
            const l = a[s];
            if (o[l] !== n[l])
              break;
          }
        } else
          r = i;
      i = i.parent;
    }
    return r;
  }
  querySelector(e, n = {}) {
    return this.querySelectorAll(e, n, !0)[0] || null;
  }
  querySelectorAll(e, n = {}, r = !1) {
    let i = [];
    if (!this.children || this.children.length === 0)
      return i;
    const o = Object.keys(n);
    return this.children.forEach((a) => {
      r && i.length > 0 || (a.node.type.name === e && o.every((l) => n[l] === a.node.attrs[l]) && i.push(a), !(r && i.length > 0) && (i = i.concat(a.querySelectorAll(e, n, r))));
    }), i;
  }
  setAttribute(e) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...e
    }), this.editor.view.dispatch(n);
  }
}
const IV = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function OV(t, e, n) {
  const r = document.querySelector("style[data-tiptap-style]");
  if (r !== null)
    return r;
  const i = document.createElement("style");
  return e && i.setAttribute("nonce", e), i.setAttribute("data-tiptap-style", ""), i.innerHTML = t, document.getElementsByTagName("head")[0].appendChild(i), i;
}
class FV extends VH {
  constructor(e = {}) {
    super(), this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: n }) => {
        throw n;
      },
      onPaste: () => null,
      onDrop: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: n, slice: r, moved: i }) => this.options.onDrop(n, r, i)), this.on("paste", ({ event: n, slice: r }) => this.options.onPaste(n, r)), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && document && (this.css = OV(IV, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, n = !0) {
    this.setOptions({ editable: e }), n && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, n) {
    const r = NU(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e], i = this.state.reconfigure({ plugins: r });
    return this.view.updateState(i), i;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const n = this.state.plugins;
    let r = n;
    if ([].concat(e).forEach((o) => {
      const a = typeof o == "string" ? `${o}$` : o.key;
      r = n.filter((s) => !s.key.startsWith(a));
    }), n.length === r.length)
      return;
    const i = this.state.reconfigure({
      plugins: r
    });
    return this.view.updateState(i), i;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, n;
    const i = [...this.options.enableCoreExtensions ? [
      EV,
      oj.configure({
        blockSeparator: (n = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || n === void 0 ? void 0 : n.blockSeparator
      }),
      TV,
      CV,
      kV,
      RV,
      DV,
      AV
    ].filter((o) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[o.name] !== !1 : !0) : [], ...this.options.extensions].filter((o) => ["extension", "node", "mark"].includes(o == null ? void 0 : o.type));
    this.extensionManager = new Xd(i, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new o1({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var e;
    let n;
    try {
      n = yS(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (a) {
      if (!(a instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(a.message))
        throw a;
      this.emit("contentError", {
        editor: this,
        error: a,
        disableCollaboration: () => {
          this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((s) => s.name !== "collaboration"), this.createExtensionManager();
        }
      }), n = yS(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 });
    }
    const r = WU(n, this.options.autofocus);
    this.view = new dH(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: Kd.create({
        doc: n,
        selection: r || void 0
      })
    });
    const i = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(i), this.createNodeViews(), this.prependClass();
    const o = this.view.dom;
    o.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1;
    const n = this.capturedTransaction;
    return this.capturedTransaction = null, n;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((a) => {
        var s;
        return (s = this.capturedTransaction) === null || s === void 0 ? void 0 : s.step(a);
      });
      return;
    }
    const n = this.state.apply(e), r = !this.state.selection.eq(n.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: n
    }), this.view.updateState(n), this.emit("transaction", {
      editor: this,
      transaction: e
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const i = e.getMeta("focus"), o = e.getMeta("blur");
    i && this.emit("focus", {
      editor: this,
      event: i.event,
      transaction: e
    }), o && this.emit("blur", {
      editor: this,
      event: o.event,
      transaction: e
    }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: e
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return jU(this.state, e);
  }
  isActive(e, n) {
    const r = typeof e == "string" ? e : null, i = typeof e == "string" ? n : e;
    return VU(this.state, r, i);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return fD(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: n = `

`, textSerializers: r = {} } = e || {};
    return Zj(this.state.doc, {
      blockSeparator: n,
      textSerializers: {
        ...LU(this.schema),
        ...r
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return f1(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    if (this.emit("destroy"), this.view) {
      const e = this.view.dom;
      e && e.editor && delete e.editor, this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
  $node(e, n) {
    var r;
    return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, n)) || null;
  }
  $nodes(e, n) {
    var r;
    return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, n)) || null;
  }
  $pos(e) {
    const n = this.state.doc.resolve(e);
    return new Oc(n, this);
  }
  get $doc() {
    return this.$pos(0);
  }
}
function Zc(t) {
  return new s1({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = yt(t.getAttributes, void 0, r);
      if (i === !1 || i === null)
        return null;
      const { tr: o } = e, a = r[r.length - 1], s = r[0];
      if (a) {
        const l = s.search(/\S/), c = n.from + s.indexOf(a), u = c + a.length;
        if (gD(n.from, n.to, e.doc).filter((p) => p.mark.type.excluded.find((g) => g === t.type && g !== p.mark.type)).filter((p) => p.to > c).length)
          return null;
        u < n.to && o.delete(u, n.to), c > n.from && o.delete(n.from + l, c);
        const f = n.from + l + a.length;
        o.addMark(n.from + l, f, t.type.create(i || {})), o.removeStoredMark(t.type);
      }
    }
  });
}
function yD(t) {
  return new s1({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = yt(t.getAttributes, void 0, r) || {}, { tr: o } = e, a = n.from;
      let s = n.to;
      const l = t.type.create(i);
      if (r[1]) {
        const c = r[0].lastIndexOf(r[1]);
        let u = a + c;
        u > s ? u = s : s = u + r[1].length;
        const d = r[0][r[0].length - 1];
        o.insertText(d, a + r[0].length - 1), o.replaceWith(u, s, l);
      } else if (r[0]) {
        const c = t.type.isInline ? a : a - 1;
        o.insert(c, t.type.create(i)).delete(o.mapping.map(a), o.mapping.map(s));
      }
      o.scrollIntoView();
    }
  });
}
function UV(t) {
  return new s1({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const i = e.doc.resolve(n.from), o = yt(t.getAttributes, void 0, r) || {};
      if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), t.type))
        return null;
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, o);
    }
  });
}
function wf(t) {
  return new s1({
    find: t.find,
    handler: ({ state: e, range: n, match: r, chain: i }) => {
      const o = yt(t.getAttributes, void 0, r) || {}, a = e.tr.delete(n.from, n.to), l = a.doc.resolve(n.from).blockRange(), c = l && ZT(l, t.type, o);
      if (!c)
        return null;
      if (a.wrap(l, c), t.keepMarks && t.editor) {
        const { selection: d, storedMarks: f } = e, { splittableMarks: p } = t.editor.extensionManager, m = f || d.$to.parentOffset && d.$from.marks();
        if (m) {
          const g = m.filter((b) => p.includes(b.type.name));
          a.ensureMarks(g);
        }
      }
      if (t.keepAttributes) {
        const d = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
        i().updateAttributes(d, o).run();
      }
      const u = a.doc.resolve(n.from - 1).nodeBefore;
      u && u.type === t.type && Ol(a.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(r, u)) && a.join(n.from - 1);
    }
  });
}
let rn = class wS {
  constructor(e = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = yt(tt(this, "addOptions", {
      name: this.name
    }))), this.storage = yt(tt(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new wS(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => l1(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new wS(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = yt(tt(n, "addOptions", {
      name: n.name
    })), n.storage = yt(tt(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
};
function NV() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
class MV {
  constructor(e, n, r) {
    this.isDragging = !1, this.component = e, this.editor = n.editor, this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...r
    }, this.extension = n.extension, this.node = n.node, this.decorations = n.decorations, this.innerDecorations = n.innerDecorations, this.view = n.view, this.HTMLAttributes = n.HTMLAttributes, this.getPos = n.getPos, this.mount();
  }
  mount() {
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(e) {
    var n, r, i, o, a, s, l;
    const { view: c } = this.editor, u = e.target, d = u.nodeType === 3 ? (n = u.parentElement) === null || n === void 0 ? void 0 : n.closest("[data-drag-handle]") : u.closest("[data-drag-handle]");
    if (!this.dom || !((r = this.contentDOM) === null || r === void 0) && r.contains(u) || !d)
      return;
    let f = 0, p = 0;
    if (this.dom !== d) {
      const y = this.dom.getBoundingClientRect(), w = d.getBoundingClientRect(), x = (i = e.offsetX) !== null && i !== void 0 ? i : (o = e.nativeEvent) === null || o === void 0 ? void 0 : o.offsetX, k = (a = e.offsetY) !== null && a !== void 0 ? a : (s = e.nativeEvent) === null || s === void 0 ? void 0 : s.offsetY;
      f = w.x - y.x + x, p = w.y - y.y + k;
    }
    (l = e.dataTransfer) === null || l === void 0 || l.setDragImage(this.dom, f, p);
    const m = this.getPos();
    if (typeof m != "number")
      return;
    const g = st.create(c.state.doc, m), b = c.state.tr.setSelection(g);
    c.dispatch(b);
  }
  stopEvent(e) {
    var n;
    if (!this.dom)
      return !1;
    if (typeof this.options.stopEvent == "function")
      return this.options.stopEvent({ event: e });
    const r = e.target;
    if (!(this.dom.contains(r) && !(!((n = this.contentDOM) === null || n === void 0) && n.contains(r))))
      return !1;
    const o = e.type.startsWith("drag"), a = e.type === "drop";
    if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(r.tagName) || r.isContentEditable) && !a && !o)
      return !0;
    const { isEditable: l } = this.editor, { isDragging: c } = this, u = !!this.node.type.spec.draggable, d = st.isSelectable(this.node), f = e.type === "copy", p = e.type === "paste", m = e.type === "cut", g = e.type === "mousedown";
    if (!u && d && o && e.preventDefault(), u && o && !c)
      return e.preventDefault(), !1;
    if (u && l && !c && g) {
      const b = r.closest("[data-drag-handle]");
      b && (this.dom === b || this.dom.contains(b)) && (this.isDragging = !0, document.addEventListener("dragend", () => {
        this.isDragging = !1;
      }, { once: !0 }), document.addEventListener("drop", () => {
        this.isDragging = !1;
      }, { once: !0 }), document.addEventListener("mouseup", () => {
        this.isDragging = !1;
      }, { once: !0 }));
    }
    return !(c || a || f || p || m || g && d);
  }
  /**
   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
   * @return `true` if it can safely be ignored.
   */
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM ? !0 : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: e }) : this.node.isLeaf || this.node.isAtom ? !0 : e.type === "selection" || this.dom.contains(e.target) && e.type === "childList" && (u1() || NV()) && this.editor.isFocused && [
      ...Array.from(e.addedNodes),
      ...Array.from(e.removedNodes)
    ].every((r) => r.isContentEditable) ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target);
  }
  /**
   * Update the attributes of the prosemirror node.
   */
  updateAttributes(e) {
    this.editor.commands.command(({ tr: n }) => {
      const r = this.getPos();
      return typeof r != "number" ? !1 : (n.setNodeMarkup(r, void 0, {
        ...this.node.attrs,
        ...e
      }), !0);
    });
  }
  /**
   * Delete the node.
   */
  deleteNode() {
    const e = this.getPos();
    if (typeof e != "number")
      return;
    const n = e + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: e, to: n });
  }
}
function Dl(t) {
  return new MU({
    find: t.find,
    handler: ({ state: e, range: n, match: r, pasteEvent: i }) => {
      const o = yt(t.getAttributes, void 0, r, i);
      if (o === !1 || o === null)
        return null;
      const { tr: a } = e, s = r[r.length - 1], l = r[0];
      let c = n.to;
      if (s) {
        const u = l.search(/\S/), d = n.from + l.indexOf(s), f = d + s.length;
        if (gD(n.from, n.to, e.doc).filter((m) => m.mark.type.excluded.find((b) => b === t.type && b !== m.mark.type)).filter((m) => m.to > d).length)
          return null;
        f < n.to && a.delete(f, n.to), d > n.from && a.delete(n.from + u, d), c = n.from + u + s.length, a.addMark(n.from + u, c, t.type.create(o || {})), a.removeStoredMark(t.type);
      }
    }
  });
}
function BV(t) {
  return t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function LV(t) {
  return new MU({
    find: t.find,
    handler({ match: e, chain: n, range: r, pasteEvent: i }) {
      const o = yt(t.getAttributes, void 0, e, i), a = yt(t.getContent, void 0, o);
      if (o === !1 || o === null)
        return null;
      const s = { type: t.type.name, attrs: o };
      a && (s.content = a), e.input && n().deleteRange(r).insertContentAt(r.from, s);
    }
  });
}
const PV = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, WV = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, zV = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, $V = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, HV = li.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (t) => t.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["strong", bt(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: t }) => t.setMark(this.name),
      toggleBold: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetBold: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      Zc({
        find: PV,
        type: this.type
      }),
      Zc({
        find: zV,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Dl({
        find: WV,
        type: this.type
      }),
      Dl({
        find: $V,
        type: this.type
      })
    ];
  }
});
let Gw;
function Kw() {
  return Gw === void 0 && (Gw = navigator.platform.includes("Mac")), Gw;
}
function h1(t) {
  return `${t}`.toLowerCase() === "mod" ? Kw() ? "⌘" : "Ctrl" : `${t}`.toLowerCase() === "alt" ? Kw() ? "⌥" : "Alt" : `${t}`.toLowerCase() === "shift" ? Kw() ? "⇧" : "Shift" : t;
}
function p1(t) {
  return t.map(h1).join(" ");
}
function GU(t) {
  var e, n, r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var i = t.length;
    for (e = 0; e < i; e++) t[e] && (n = GU(t[e])) && (r && (r += " "), r += n);
  } else for (n in t) t[n] && (r && (r += " "), r += n);
  return r;
}
function xo() {
  for (var t, e, n = 0, r = "", i = arguments.length; n < i; n++) (t = arguments[n]) && (e = GU(t)) && (r && (r += " "), r += e);
  return r;
}
const bD = "-", jV = (t) => {
  const e = qV(t), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: r
  } = t;
  return {
    getClassGroupId: (a) => {
      const s = a.split(bD);
      return s[0] === "" && s.length !== 1 && s.shift(), KU(s, e) || VV(a);
    },
    getConflictingClassGroupIds: (a, s) => {
      const l = n[a] || [];
      return s && r[a] ? [...l, ...r[a]] : l;
    }
  };
}, KU = (t, e) => {
  var a;
  if (t.length === 0)
    return e.classGroupId;
  const n = t[0], r = e.nextPart.get(n), i = r ? KU(t.slice(1), r) : void 0;
  if (i)
    return i;
  if (e.validators.length === 0)
    return;
  const o = t.join(bD);
  return (a = e.validators.find(({
    validator: s
  }) => s(o))) == null ? void 0 : a.classGroupId;
}, hA = /^\[(.+)\]$/, VV = (t) => {
  if (hA.test(t)) {
    const e = hA.exec(t)[1], n = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}, qV = (t) => {
  const {
    theme: e,
    prefix: n
  } = t, r = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return KV(Object.entries(t.classGroups), n).forEach(([o, a]) => {
    xS(a, r, o, e);
  }), r;
}, xS = (t, e, n, r) => {
  t.forEach((i) => {
    if (typeof i == "string") {
      const o = i === "" ? e : pA(e, i);
      o.classGroupId = n;
      return;
    }
    if (typeof i == "function") {
      if (GV(i)) {
        xS(i(r), e, n, r);
        return;
      }
      e.validators.push({
        validator: i,
        classGroupId: n
      });
      return;
    }
    Object.entries(i).forEach(([o, a]) => {
      xS(a, pA(e, o), n, r);
    });
  });
}, pA = (t, e) => {
  let n = t;
  return e.split(bD).forEach((r) => {
    n.nextPart.has(r) || n.nextPart.set(r, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(r);
  }), n;
}, GV = (t) => t.isThemeGetter, KV = (t, e) => e ? t.map(([n, r]) => {
  const i = r.map((o) => typeof o == "string" ? e + o : typeof o == "object" ? Object.fromEntries(Object.entries(o).map(([a, s]) => [e + a, s])) : o);
  return [n, i];
}) : t, XV = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  const i = (o, a) => {
    n.set(o, a), e++, e > t && (e = 0, r = n, n = /* @__PURE__ */ new Map());
  };
  return {
    get(o) {
      let a = n.get(o);
      if (a !== void 0)
        return a;
      if ((a = r.get(o)) !== void 0)
        return i(o, a), a;
    },
    set(o, a) {
      n.has(o) ? n.set(o, a) : i(o, a);
    }
  };
}, XU = "!", YV = (t) => {
  const {
    separator: e,
    experimentalParseClassName: n
  } = t, r = e.length === 1, i = e[0], o = e.length, a = (s) => {
    const l = [];
    let c = 0, u = 0, d;
    for (let b = 0; b < s.length; b++) {
      let y = s[b];
      if (c === 0) {
        if (y === i && (r || s.slice(b, b + o) === e)) {
          l.push(s.slice(u, b)), u = b + o;
          continue;
        }
        if (y === "/") {
          d = b;
          continue;
        }
      }
      y === "[" ? c++ : y === "]" && c--;
    }
    const f = l.length === 0 ? s : s.substring(u), p = f.startsWith(XU), m = p ? f.substring(1) : f, g = d && d > u ? d - u : void 0;
    return {
      modifiers: l,
      hasImportantModifier: p,
      baseClassName: m,
      maybePostfixModifierPosition: g
    };
  };
  return n ? (s) => n({
    className: s,
    parseClassName: a
  }) : a;
}, JV = (t) => {
  if (t.length <= 1)
    return t;
  const e = [];
  let n = [];
  return t.forEach((r) => {
    r[0] === "[" ? (e.push(...n.sort(), r), n = []) : n.push(r);
  }), e.push(...n.sort()), e;
}, ZV = (t) => ({
  cache: XV(t.cacheSize),
  parseClassName: YV(t),
  ...jV(t)
}), QV = /\s+/, eq = (t, e) => {
  const {
    parseClassName: n,
    getClassGroupId: r,
    getConflictingClassGroupIds: i
  } = e, o = [], a = t.trim().split(QV);
  let s = "";
  for (let l = a.length - 1; l >= 0; l -= 1) {
    const c = a[l], {
      modifiers: u,
      hasImportantModifier: d,
      baseClassName: f,
      maybePostfixModifierPosition: p
    } = n(c);
    let m = !!p, g = r(m ? f.substring(0, p) : f);
    if (!g) {
      if (!m) {
        s = c + (s.length > 0 ? " " + s : s);
        continue;
      }
      if (g = r(f), !g) {
        s = c + (s.length > 0 ? " " + s : s);
        continue;
      }
      m = !1;
    }
    const b = JV(u).join(":"), y = d ? b + XU : b, w = y + g;
    if (o.includes(w))
      continue;
    o.push(w);
    const x = i(g, m);
    for (let k = 0; k < x.length; ++k) {
      const A = x[k];
      o.push(y + A);
    }
    s = c + (s.length > 0 ? " " + s : s);
  }
  return s;
};
function tq() {
  let t = 0, e, n, r = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (n = YU(e)) && (r && (r += " "), r += n);
  return r;
}
const YU = (t) => {
  if (typeof t == "string")
    return t;
  let e, n = "";
  for (let r = 0; r < t.length; r++)
    t[r] && (e = YU(t[r])) && (n && (n += " "), n += e);
  return n;
};
function nq(t, ...e) {
  let n, r, i, o = a;
  function a(l) {
    const c = e.reduce((u, d) => d(u), t());
    return n = ZV(c), r = n.cache.get, i = n.cache.set, o = s, s(l);
  }
  function s(l) {
    const c = r(l);
    if (c)
      return c;
    const u = eq(l, n);
    return i(l, u), u;
  }
  return function() {
    return o(tq.apply(null, arguments));
  };
}
const cn = (t) => {
  const e = (n) => n[t] || [];
  return e.isThemeGetter = !0, e;
}, JU = /^\[(?:([a-z-]+):)?(.+)\]$/i, rq = /^\d+\/\d+$/, iq = /* @__PURE__ */ new Set(["px", "full", "screen"]), oq = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, aq = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, sq = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, lq = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, cq = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, za = (t) => rf(t) || iq.has(t) || rq.test(t), Ys = (t) => jf(t, "length", yq), rf = (t) => !!t && !Number.isNaN(Number(t)), Xw = (t) => jf(t, "number", rf), np = (t) => !!t && Number.isInteger(Number(t)), uq = (t) => t.endsWith("%") && rf(t.slice(0, -1)), vt = (t) => JU.test(t), Js = (t) => oq.test(t), dq = /* @__PURE__ */ new Set(["length", "size", "percentage"]), fq = (t) => jf(t, dq, ZU), hq = (t) => jf(t, "position", ZU), pq = /* @__PURE__ */ new Set(["image", "url"]), mq = (t) => jf(t, pq, vq), gq = (t) => jf(t, "", bq), rp = () => !0, jf = (t, e, n) => {
  const r = JU.exec(t);
  return r ? r[1] ? typeof e == "string" ? r[1] === e : e.has(r[1]) : n(r[2]) : !1;
}, yq = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  aq.test(t) && !sq.test(t)
), ZU = () => !1, bq = (t) => lq.test(t), vq = (t) => cq.test(t), wq = () => {
  const t = cn("colors"), e = cn("spacing"), n = cn("blur"), r = cn("brightness"), i = cn("borderColor"), o = cn("borderRadius"), a = cn("borderSpacing"), s = cn("borderWidth"), l = cn("contrast"), c = cn("grayscale"), u = cn("hueRotate"), d = cn("invert"), f = cn("gap"), p = cn("gradientColorStops"), m = cn("gradientColorStopPositions"), g = cn("inset"), b = cn("margin"), y = cn("opacity"), w = cn("padding"), x = cn("saturate"), k = cn("scale"), A = cn("sepia"), U = cn("skew"), P = cn("space"), V = cn("translate"), I = () => ["auto", "contain", "none"], le = () => ["auto", "hidden", "clip", "visible", "scroll"], be = () => ["auto", vt, e], F = () => [vt, e], G = () => ["", za, Ys], C = () => ["auto", rf, vt], ie = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], ee = () => ["solid", "dashed", "dotted", "double", "none"], Z = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], oe = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], te = () => ["", "0", vt], _e = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], q = () => [rf, vt];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [rp],
      spacing: [za, Ys],
      blur: ["none", "", Js, vt],
      brightness: q(),
      borderColor: [t],
      borderRadius: ["none", "", "full", Js, vt],
      borderSpacing: F(),
      borderWidth: G(),
      contrast: q(),
      grayscale: te(),
      hueRotate: q(),
      invert: te(),
      gap: F(),
      gradientColorStops: [t],
      gradientColorStopPositions: [uq, Ys],
      inset: be(),
      margin: be(),
      opacity: q(),
      padding: F(),
      saturate: q(),
      scale: q(),
      sepia: te(),
      skew: q(),
      space: F(),
      translate: F()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", vt]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Js]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": _e()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": _e()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...ie(), vt]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: le()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": le()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": le()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: I()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": I()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": I()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [g]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [g]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [g]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [g]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [g]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [g]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [g]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [g]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [g]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", np, vt]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: be()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", vt]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: te()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: te()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", np, vt]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [rp]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", np, vt]
        }, vt]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": C()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": C()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [rp]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [np, vt]
        }, vt]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": C()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": C()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", vt]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", vt]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [f]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [f]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [f]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...oe()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...oe(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...oe(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [w]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [w]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [w]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [w]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [w]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [w]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [w]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [w]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [w]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [b]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [b]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [b]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [b]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [b]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [b]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [b]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [b]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [b]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [P]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [P]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", vt, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [vt, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [vt, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [Js]
        }, Js]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [vt, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [vt, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [vt, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [vt, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", Js, Ys]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Xw]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [rp]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", vt]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", rf, Xw]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", za, vt]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", vt]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", vt]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [t]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [y]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [t]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [y]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...ee(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", za, Ys]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", za, vt]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [t]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: F()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", vt]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", vt]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [y]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...ie(), hq]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", fq]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, mq]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [t]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [m]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [m]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [m]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [p]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [p]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [p]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [o]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [o]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [o]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [o]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [o]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [o]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [o]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [o]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [o]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [o]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [o]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [o]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [o]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [o]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [o]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [s]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [s]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [s]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [s]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [s]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [s]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [s]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [s]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [s]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [y]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...ee(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [s]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [s]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [y]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: ee()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [i]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...ee()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [za, vt]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [za, Ys]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [t]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: G()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [t]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [y]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [za, Ys]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [t]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", Js, gq]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [rp]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [y]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...Z(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": Z()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [n]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [r]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", Js, vt]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [c]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [u]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [d]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [x]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [A]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [n]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [r]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [c]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [u]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [d]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [y]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [x]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [A]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [a]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [a]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [a]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", vt]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: q()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", vt]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: q()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", vt]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [k]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [k]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [k]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [np, vt]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [V]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [V]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [U]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [U]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", vt]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", t]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", vt]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [t]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": F()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": F()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": F()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": F()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": F()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": F()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": F()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": F()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": F()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": F()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": F()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": F()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": F()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": F()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": F()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": F()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": F()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": F()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", vt]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [t, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [za, Ys, Xw]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [t, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, xq = /* @__PURE__ */ nq(wq);
function Ct(...t) {
  return xq(xo(t));
}
const Je = Lt.forwardRef(
  (t, e) => {
    const {
      icon: n = void 0,
      // title = undefined,
      tooltip: r = void 0,
      disabled: i = !1,
      customClass: o = "",
      // color = undefined,
      loading: a = void 0,
      shortcutKeys: s = void 0,
      tooltipOptions: l = {},
      action: c = void 0,
      isActive: u = void 0,
      children: d,
      asChild: f = !1,
      upload: p = !1,
      ...m
    } = t, g = Hm[n];
    return /* @__PURE__ */ Fe(Kf, { children: [
      /* @__PURE__ */ z(Xf, { asChild: !0, children: /* @__PURE__ */ Fe(
        f ? KT : zm,
        {
          ref: e,
          size: "sm",
          className: Ct("richtext-w-[32px] richtext-h-[32px]", o),
          disabled: i,
          onClick: c,
          "data-state": u != null && u() ? "on" : "off",
          ...m,
          children: [
            g && /* @__PURE__ */ z(g, { className: "richtext-w-4 richtext-h-4" }),
            d
          ]
        }
      ) }),
      r && /* @__PURE__ */ z(gu, { ...l, children: /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-flex-col richtext-items-center richtext-text-center richtext-max-w-24", children: [
        /* @__PURE__ */ z("div", { children: r }),
        !!(s != null && s.length) && /* @__PURE__ */ z("span", { children: p1(s) })
      ] }) })
    ] });
  }
), vD = Lt.forwardRef(
  ({ asChild: t, ...e }, n) => {
    var o;
    const r = Hm[e.icon];
    return /* @__PURE__ */ Fe(Kf, { children: [
      /* @__PURE__ */ z(Xf, { asChild: !0, children: /* @__PURE__ */ z(
        t ? KT : fn,
        {
          ref: n,
          className: "richtext-h-[32px] richtext-px-[5px] richtext-py-0 richtext-min-w-24  richtext-overflow-hidden",
          variant: "ghost",
          disabled: e == null ? void 0 : e.disabled,
          ...e,
          children: /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-items-center richtext-h-full richtext-font-normal", children: [
            (e == null ? void 0 : e.title) && /* @__PURE__ */ z("div", { className: "richtext-flex-grow richtext-text-sm richtext-text-left richtext-truncate", children: e == null ? void 0 : e.title }),
            r && /* @__PURE__ */ z(r, { className: "richtext-flex-shrink-0 richtext-w-3 richtext-h-3 richtext-ml-1 richtext-text-zinc-500" })
          ] })
        }
      ) }),
      /* @__PURE__ */ z(gu, { children: /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-flex-col richtext-items-center richtext-text-center richtext-max-w-24", children: [
        (e == null ? void 0 : e.tooltip) && /* @__PURE__ */ z("div", { children: e == null ? void 0 : e.tooltip }),
        /* @__PURE__ */ z("div", { className: "richtext-flex", children: !!((o = e == null ? void 0 : e.shortcutKeys) != null && o.length) && /* @__PURE__ */ z("span", { children: p1(e == null ? void 0 : e.shortcutKeys) }) })
      ] }) })
    ] });
  }
);
class _q {
  constructor({ editor: e, element: n, view: r, tippyOptions: i = {}, updateDelay: o = 250, shouldShow: a }) {
    this.preventHide = !1, this.shouldShow = ({ view: s, state: l, from: c, to: u }) => {
      const { doc: d, selection: f } = l, { empty: p } = f, m = !d.textBetween(c, u).length && pD(l.selection), g = this.element.contains(document.activeElement);
      return !(!(s.hasFocus() || g) || p || m || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: s }) => {
      var l;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      s != null && s.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(s.relatedTarget)) || (s == null ? void 0 : s.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.tippyBlurHandler = (s) => {
      this.blurHandler({ event: s });
    }, this.handleDebouncedUpdate = (s, l) => {
      const c = !(l != null && l.selection.eq(s.state.selection)), u = !(l != null && l.doc.eq(s.state.doc));
      !c && !u || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(s, c, u, l);
      }, this.updateDelay));
    }, this.updateHandler = (s, l, c, u) => {
      var d, f, p;
      const { state: m, composing: g } = s, { selection: b } = m;
      if (g || !l && !c)
        return;
      this.createTooltip();
      const { ranges: w } = b, x = Math.min(...w.map((U) => U.$from.pos)), k = Math.max(...w.map((U) => U.$to.pos));
      if (!((d = this.shouldShow) === null || d === void 0 ? void 0 : d.call(this, {
        editor: this.editor,
        element: this.element,
        view: s,
        state: m,
        oldState: u,
        from: x,
        to: k
      }))) {
        this.hide();
        return;
      }
      (f = this.tippy) === null || f === void 0 || f.setProps({
        getReferenceClientRect: ((p = this.tippyOptions) === null || p === void 0 ? void 0 : p.getReferenceClientRect) || (() => {
          if (qU(m.selection)) {
            let U = s.nodeDOM(x);
            if (U) {
              const P = U.dataset.nodeViewWrapper ? U : U.querySelector("[data-node-view-wrapper]");
              if (P && (U = P.firstChild), U)
                return U.getBoundingClientRect();
            }
          }
          return rV(s, x, k);
        })
      }), this.show();
    }, this.editor = e, this.element = n, this.view = r, this.updateDelay = o, a && (this.shouldShow = a), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = Fm(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: !0,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    const { state: r } = e, i = r.selection.from !== r.selection.to;
    if (this.updateDelay > 0 && i) {
      this.handleDebouncedUpdate(e, n);
      return;
    }
    const o = !(n != null && n.selection.eq(e.state.selection)), a = !(n != null && n.doc.eq(e.state.doc));
    this.updateHandler(e, o, a, n);
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
}
const QU = (t) => new Pt({
  key: typeof t.pluginKey == "string" ? new Nt(t.pluginKey) : t.pluginKey,
  view: (e) => new _q({ view: e, ...t })
});
St.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      QU({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
function Sq(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var _S = { exports: {} }, Yw = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mA;
function Tq() {
  if (mA) return Yw;
  mA = 1;
  var t = Lt;
  function e(d, f) {
    return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f;
  }
  var n = typeof Object.is == "function" ? Object.is : e, r = t.useState, i = t.useEffect, o = t.useLayoutEffect, a = t.useDebugValue;
  function s(d, f) {
    var p = f(), m = r({ inst: { value: p, getSnapshot: f } }), g = m[0].inst, b = m[1];
    return o(function() {
      g.value = p, g.getSnapshot = f, l(g) && b({ inst: g });
    }, [d, p, f]), i(function() {
      return l(g) && b({ inst: g }), d(function() {
        l(g) && b({ inst: g });
      });
    }, [d]), a(p), p;
  }
  function l(d) {
    var f = d.getSnapshot;
    d = d.value;
    try {
      var p = f();
      return !n(d, p);
    } catch {
      return !0;
    }
  }
  function c(d, f) {
    return f();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : s;
  return Yw.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : u, Yw;
}
var Jw = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gA;
function Dq() {
  return gA || (gA = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = Lt, e = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(x) {
      {
        for (var k = arguments.length, A = new Array(k > 1 ? k - 1 : 0), U = 1; U < k; U++)
          A[U - 1] = arguments[U];
        r("error", x, A);
      }
    }
    function r(x, k, A) {
      {
        var U = e.ReactDebugCurrentFrame, P = U.getStackAddendum();
        P !== "" && (k += "%s", A = A.concat([P]));
        var V = A.map(function(I) {
          return String(I);
        });
        V.unshift("Warning: " + k), Function.prototype.apply.call(console[x], console, V);
      }
    }
    function i(x, k) {
      return x === k && (x !== 0 || 1 / x === 1 / k) || x !== x && k !== k;
    }
    var o = typeof Object.is == "function" ? Object.is : i, a = t.useState, s = t.useEffect, l = t.useLayoutEffect, c = t.useDebugValue, u = !1, d = !1;
    function f(x, k, A) {
      u || t.startTransition !== void 0 && (u = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var U = k();
      if (!d) {
        var P = k();
        o(U, P) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), d = !0);
      }
      var V = a({
        inst: {
          value: U,
          getSnapshot: k
        }
      }), I = V[0].inst, le = V[1];
      return l(function() {
        I.value = U, I.getSnapshot = k, p(I) && le({
          inst: I
        });
      }, [x, U, k]), s(function() {
        p(I) && le({
          inst: I
        });
        var be = function() {
          p(I) && le({
            inst: I
          });
        };
        return x(be);
      }, [x]), c(U), U;
    }
    function p(x) {
      var k = x.getSnapshot, A = x.value;
      try {
        var U = k();
        return !o(A, U);
      } catch {
        return !0;
      }
    }
    function m(x, k, A) {
      return k();
    }
    var g = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", b = !g, y = b ? m : f, w = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : y;
    Jw.useSyncExternalStore = w, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Jw;
}
process.env.NODE_ENV === "production" ? _S.exports = Tq() : _S.exports = Dq();
var m1 = _S.exports;
const Eq = (...t) => (e) => {
  t.forEach((n) => {
    typeof n == "function" ? n(e) : n && (n.current = e);
  });
}, Cq = ({ contentComponent: t }) => {
  const e = m1.useSyncExternalStore(t.subscribe, t.getSnapshot, t.getServerSnapshot);
  return Lt.createElement(Lt.Fragment, null, Object.values(e));
};
function kq() {
  const t = /* @__PURE__ */ new Set();
  let e = {};
  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(n) {
      return t.add(n), () => {
        t.delete(n);
      };
    },
    getSnapshot() {
      return e;
    },
    getServerSnapshot() {
      return e;
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(n, r) {
      e = {
        ...e,
        [n]: RW.createPortal(r.reactElement, r.element, n)
      }, t.forEach((i) => i());
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(n) {
      const r = { ...e };
      delete r[n], e = r, t.forEach((i) => i());
    }
  };
}
class Aq extends Lt.Component {
  constructor(e) {
    var n;
    super(e), this.editorContentRef = Lt.createRef(), this.initialized = !1, this.state = {
      hasContentComponentInitialized: !!(!((n = e.editor) === null || n === void 0) && n.contentComponent)
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    const e = this.props.editor;
    if (e && !e.isDestroyed && e.options.element) {
      if (e.contentComponent)
        return;
      const n = this.editorContentRef.current;
      n.append(...e.options.element.childNodes), e.setOptions({
        element: n
      }), e.contentComponent = kq(), this.state.hasContentComponentInitialized || (this.unsubscribeToContentComponent = e.contentComponent.subscribe(() => {
        this.setState((r) => r.hasContentComponentInitialized ? r : {
          hasContentComponentInitialized: !0
        }), this.unsubscribeToContentComponent && this.unsubscribeToContentComponent();
      })), e.createNodeViews(), this.initialized = !0;
    }
  }
  componentWillUnmount() {
    const e = this.props.editor;
    if (!e || (this.initialized = !1, e.isDestroyed || e.view.setProps({
      nodeViews: {}
    }), this.unsubscribeToContentComponent && this.unsubscribeToContentComponent(), e.contentComponent = null, !e.options.element.firstChild))
      return;
    const n = document.createElement("div");
    n.append(...e.options.element.childNodes), e.setOptions({
      element: n
    });
  }
  render() {
    const { editor: e, innerRef: n, ...r } = this.props;
    return Lt.createElement(
      Lt.Fragment,
      null,
      Lt.createElement("div", { ref: Eq(n, this.editorContentRef), ...r }),
      (e == null ? void 0 : e.contentComponent) && Lt.createElement(Cq, { contentComponent: e.contentComponent })
    );
  }
}
const Rq = Om((t, e) => {
  const n = Lt.useMemo(() => Math.floor(Math.random() * 4294967295).toString(), [t.editor]);
  return Lt.createElement(Aq, {
    key: n,
    innerRef: e,
    ...t
  });
}), Iq = Lt.memo(Rq);
var Oq = function t(e, n) {
  if (e === n) return !0;
  if (e && n && typeof e == "object" && typeof n == "object") {
    if (e.constructor !== n.constructor) return !1;
    var r, i, o;
    if (Array.isArray(e)) {
      if (r = e.length, r != n.length) return !1;
      for (i = r; i-- !== 0; )
        if (!t(e[i], n[i])) return !1;
      return !0;
    }
    if (e instanceof Map && n instanceof Map) {
      if (e.size !== n.size) return !1;
      for (i of e.entries())
        if (!n.has(i[0])) return !1;
      for (i of e.entries())
        if (!t(i[1], n.get(i[0]))) return !1;
      return !0;
    }
    if (e instanceof Set && n instanceof Set) {
      if (e.size !== n.size) return !1;
      for (i of e.entries())
        if (!n.has(i[0])) return !1;
      return !0;
    }
    if (ArrayBuffer.isView(e) && ArrayBuffer.isView(n)) {
      if (r = e.length, r != n.length) return !1;
      for (i = r; i-- !== 0; )
        if (e[i] !== n[i]) return !1;
      return !0;
    }
    if (e.constructor === RegExp) return e.source === n.source && e.flags === n.flags;
    if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === n.valueOf();
    if (e.toString !== Object.prototype.toString) return e.toString() === n.toString();
    if (o = Object.keys(e), r = o.length, r !== Object.keys(n).length) return !1;
    for (i = r; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, o[i])) return !1;
    for (i = r; i-- !== 0; ) {
      var a = o[i];
      if (!(a === "_owner" && e.$$typeof) && !t(e[a], n[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && n !== n;
}, Fq = /* @__PURE__ */ Sq(Oq), SS = { exports: {} }, Zw = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yA;
function Uq() {
  if (yA) return Zw;
  yA = 1;
  var t = Lt, e = m1;
  function n(c, u) {
    return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = e.useSyncExternalStore, o = t.useRef, a = t.useEffect, s = t.useMemo, l = t.useDebugValue;
  return Zw.useSyncExternalStoreWithSelector = function(c, u, d, f, p) {
    var m = o(null);
    if (m.current === null) {
      var g = { hasValue: !1, value: null };
      m.current = g;
    } else g = m.current;
    m = s(function() {
      function y(U) {
        if (!w) {
          if (w = !0, x = U, U = f(U), p !== void 0 && g.hasValue) {
            var P = g.value;
            if (p(P, U)) return k = P;
          }
          return k = U;
        }
        if (P = k, r(x, U)) return P;
        var V = f(U);
        return p !== void 0 && p(P, V) ? P : (x = U, k = V);
      }
      var w = !1, x, k, A = d === void 0 ? null : d;
      return [function() {
        return y(u());
      }, A === null ? void 0 : function() {
        return y(A());
      }];
    }, [u, d, f, p]);
    var b = i(c, m[0], m[1]);
    return a(function() {
      g.hasValue = !0, g.value = b;
    }, [b]), l(b), b;
  }, Zw;
}
var Qw = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bA;
function Nq() {
  return bA || (bA = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = Lt, e = m1;
    function n(u, d) {
      return u === d && (u !== 0 || 1 / u === 1 / d) || u !== u && d !== d;
    }
    var r = typeof Object.is == "function" ? Object.is : n, i = e.useSyncExternalStore, o = t.useRef, a = t.useEffect, s = t.useMemo, l = t.useDebugValue;
    function c(u, d, f, p, m) {
      var g = o(null), b;
      g.current === null ? (b = {
        hasValue: !1,
        value: null
      }, g.current = b) : b = g.current;
      var y = s(function() {
        var A = !1, U, P, V = function(F) {
          if (!A) {
            A = !0, U = F;
            var G = p(F);
            if (m !== void 0 && b.hasValue) {
              var C = b.value;
              if (m(C, G))
                return P = C, C;
            }
            return P = G, G;
          }
          var ie = U, ee = P;
          if (r(ie, F))
            return ee;
          var Z = p(F);
          return m !== void 0 && m(ee, Z) ? ee : (U = F, P = Z, Z);
        }, I = f === void 0 ? null : f, le = function() {
          return V(d());
        }, be = I === null ? void 0 : function() {
          return V(I());
        };
        return [le, be];
      }, [d, f, p, m]), w = y[0], x = y[1], k = i(u, w, x);
      return a(function() {
        b.hasValue = !0, b.value = k;
      }, [k]), l(k), k;
    }
    Qw.useSyncExternalStoreWithSelector = c, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Qw;
}
process.env.NODE_ENV === "production" ? SS.exports = Uq() : SS.exports = Nq();
var Mq = SS.exports;
const Bq = typeof window < "u" ? s7 : Tt;
class Lq {
  constructor(e) {
    this.transactionNumber = 0, this.lastTransactionNumber = 0, this.subscribers = /* @__PURE__ */ new Set(), this.editor = e, this.lastSnapshot = { editor: e, transactionNumber: 0 }, this.getSnapshot = this.getSnapshot.bind(this), this.getServerSnapshot = this.getServerSnapshot.bind(this), this.watch = this.watch.bind(this), this.subscribe = this.subscribe.bind(this);
  }
  /**
   * Get the current editor instance.
   */
  getSnapshot() {
    return this.transactionNumber === this.lastTransactionNumber ? this.lastSnapshot : (this.lastTransactionNumber = this.transactionNumber, this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber }, this.lastSnapshot);
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return { editor: null, transactionNumber: 0 };
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(e) {
    return this.subscribers.add(e), () => {
      this.subscribers.delete(e);
    };
  }
  /**
   * Watch the editor instance for changes.
   */
  watch(e) {
    if (this.editor = e, this.editor) {
      const n = () => {
        this.transactionNumber += 1, this.subscribers.forEach((i) => i());
      }, r = this.editor;
      return r.on("transaction", n), () => {
        r.off("transaction", n);
      };
    }
  }
}
function Pq(t) {
  var e;
  const [n] = nt(() => new Lq(t.editor)), r = Mq.useSyncExternalStoreWithSelector(n.subscribe, n.getSnapshot, n.getServerSnapshot, t.selector, (e = t.equalityFn) !== null && e !== void 0 ? e : Fq);
  return Bq(() => n.watch(t.editor), [t.editor, n]), iF(r), r;
}
const vA = process.env.NODE_ENV !== "production", TS = typeof window > "u", Wq = TS || !!(typeof window < "u" && window.next);
class zq {
  constructor(e) {
    this.editor = null, this.subscriptions = /* @__PURE__ */ new Set(), this.isComponentMounted = !1, this.previousDeps = null, this.instanceId = "", this.options = e, this.subscriptions = /* @__PURE__ */ new Set(), this.setEditor(this.getInitialEditor()), this.scheduleDestroy(), this.getEditor = this.getEditor.bind(this), this.getServerSnapshot = this.getServerSnapshot.bind(this), this.subscribe = this.subscribe.bind(this), this.refreshEditorInstance = this.refreshEditorInstance.bind(this), this.scheduleDestroy = this.scheduleDestroy.bind(this), this.onRender = this.onRender.bind(this), this.createEditor = this.createEditor.bind(this);
  }
  setEditor(e) {
    this.editor = e, this.instanceId = Math.random().toString(36).slice(2, 9), this.subscriptions.forEach((n) => n());
  }
  getInitialEditor() {
    if (this.options.current.immediatelyRender === void 0)
      return TS || Wq ? (vA && console.warn("Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches."), null) : this.createEditor();
    if (this.options.current.immediatelyRender && TS && vA)
      throw new Error("Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.");
    return this.options.current.immediatelyRender ? this.createEditor() : null;
  }
  /**
   * Create a new editor instance. And attach event listeners.
   */
  createEditor() {
    const e = {
      ...this.options.current,
      // Always call the most recent version of the callback function by default
      onBeforeCreate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onBeforeCreate) === null || o === void 0 ? void 0 : o.call(i, ...r);
      },
      onBlur: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onBlur) === null || o === void 0 ? void 0 : o.call(i, ...r);
      },
      onCreate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onCreate) === null || o === void 0 ? void 0 : o.call(i, ...r);
      },
      onDestroy: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onDestroy) === null || o === void 0 ? void 0 : o.call(i, ...r);
      },
      onFocus: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onFocus) === null || o === void 0 ? void 0 : o.call(i, ...r);
      },
      onSelectionUpdate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onSelectionUpdate) === null || o === void 0 ? void 0 : o.call(i, ...r);
      },
      onTransaction: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onTransaction) === null || o === void 0 ? void 0 : o.call(i, ...r);
      },
      onUpdate: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onUpdate) === null || o === void 0 ? void 0 : o.call(i, ...r);
      },
      onContentError: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onContentError) === null || o === void 0 ? void 0 : o.call(i, ...r);
      },
      onDrop: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onDrop) === null || o === void 0 ? void 0 : o.call(i, ...r);
      },
      onPaste: (...r) => {
        var i, o;
        return (o = (i = this.options.current).onPaste) === null || o === void 0 ? void 0 : o.call(i, ...r);
      }
    };
    return new FV(e);
  }
  /**
   * Get the current editor instance.
   */
  getEditor() {
    return this.editor;
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return null;
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(e) {
    return this.subscriptions.add(e), () => {
      this.subscriptions.delete(e);
    };
  }
  /**
   * On each render, we will create, update, or destroy the editor instance.
   * @param deps The dependencies to watch for changes
   * @returns A cleanup function
   */
  onRender(e) {
    return () => (this.isComponentMounted = !0, clearTimeout(this.scheduledDestructionTimeout), this.editor && !this.editor.isDestroyed && e.length === 0 ? this.editor.setOptions({
      ...this.options.current,
      editable: this.editor.isEditable
    }) : this.refreshEditorInstance(e), () => {
      this.isComponentMounted = !1, this.scheduleDestroy();
    });
  }
  /**
   * Recreate the editor instance if the dependencies have changed.
   */
  refreshEditorInstance(e) {
    if (this.editor && !this.editor.isDestroyed) {
      if (this.previousDeps === null) {
        this.previousDeps = e;
        return;
      }
      if (this.previousDeps.length === e.length && this.previousDeps.every((r, i) => r === e[i]))
        return;
    }
    this.editor && !this.editor.isDestroyed && this.editor.destroy(), this.setEditor(this.createEditor()), this.previousDeps = e;
  }
  /**
   * Schedule the destruction of the editor instance.
   * This will only destroy the editor if it was not mounted on the next tick.
   * This is to avoid destroying the editor instance when it's actually still mounted.
   */
  scheduleDestroy() {
    const e = this.instanceId, n = this.editor;
    this.scheduledDestructionTimeout = setTimeout(() => {
      if (this.isComponentMounted && this.instanceId === e) {
        n && n.setOptions(this.options.current);
        return;
      }
      n && !n.isDestroyed && (n.destroy(), this.instanceId === e && this.setEditor(null));
    }, 1);
  }
}
function $q(t = {}, e = []) {
  const n = Wr(t);
  n.current = t;
  const [r] = nt(() => new zq(n)), i = m1.useSyncExternalStore(r.subscribe, r.getEditor, r.getServerSnapshot);
  return iF(i), Tt(r.onRender(e)), Pq({
    editor: i,
    selector: ({ transactionNumber: o }) => t.shouldRerenderOnTransaction === !1 ? null : t.immediatelyRender && o === 0 ? 0 : o + 1
  }), i;
}
const e6 = rF({
  editor: null
});
e6.Consumer;
const Hq = () => oF(e6), hs = (t) => {
  const [e, n] = nt(null), { editor: r } = Hq();
  return Tt(() => {
    var i;
    if (!e || !((i = t.editor) === null || i === void 0) && i.isDestroyed || r != null && r.isDestroyed)
      return;
    const { pluginKey: o = "bubbleMenu", editor: a, tippyOptions: s = {}, updateDelay: l, shouldShow: c = null } = t, u = a || r;
    if (!u) {
      console.warn("BubbleMenu component is not rendered inside of an editor component or does not have editor prop.");
      return;
    }
    const d = QU({
      updateDelay: l,
      editor: u,
      element: e,
      pluginKey: o,
      shouldShow: c,
      tippyOptions: s
    });
    return u.registerPlugin(d), () => {
      u.unregisterPlugin(o);
    };
  }, [t.editor, r, e]), Lt.createElement("div", { ref: n, className: t.className, style: { visibility: "hidden" } }, t.children);
}, t6 = rF({
  onDragStart: void 0
}), jq = () => oF(t6), xl = Lt.forwardRef((t, e) => {
  const { onDragStart: n } = jq(), r = t.as || "div";
  return (
    // @ts-ignore
    Lt.createElement(r, { ...t, ref: e, "data-node-view-wrapper": "", onDragStart: n, style: {
      whiteSpace: "normal",
      ...t.style
    } })
  );
});
function Vq(t) {
  return !!(typeof t == "function" && t.prototype && t.prototype.isReactComponent);
}
function qq(t) {
  var e;
  return typeof t == "object" && ((e = t.$$typeof) === null || e === void 0 ? void 0 : e.toString()) === "Symbol(react.forward_ref)";
}
class g1 {
  /**
   * Immediately creates element and renders the provided React component.
   */
  constructor(e, { editor: n, props: r = {}, as: i = "div", className: o = "" }) {
    this.ref = null, this.id = Math.floor(Math.random() * 4294967295).toString(), this.component = e, this.editor = n, this.props = r, this.element = document.createElement(i), this.element.classList.add("react-renderer"), o && this.element.classList.add(...o.split(" ")), this.editor.isInitialized ? jp(() => {
      this.render();
    }) : this.render();
  }
  /**
   * Render the React component.
   */
  render() {
    var e;
    const n = this.component, r = this.props, i = this.editor;
    (Vq(n) || qq(n)) && (r.ref = (o) => {
      this.ref = o;
    }), this.reactElement = Lt.createElement(n, { ...r }), (e = i == null ? void 0 : i.contentComponent) === null || e === void 0 || e.setRenderer(this.id, this);
  }
  /**
   * Re-renders the React component with new props.
   */
  updateProps(e = {}) {
    this.props = {
      ...this.props,
      ...e
    }, this.render();
  }
  /**
   * Destroy the React component.
   */
  destroy() {
    var e;
    const n = this.editor;
    (e = n == null ? void 0 : n.contentComponent) === null || e === void 0 || e.removeRenderer(this.id);
  }
  /**
   * Update the attributes of the element that holds the React component.
   */
  updateAttributes(e) {
    Object.keys(e).forEach((n) => {
      this.element.setAttribute(n, e[n]);
    });
  }
}
class Gq extends MV {
  /**
   * Setup the React component.
   * Called on initialization.
   */
  mount() {
    const e = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      innerDecorations: this.innerDecorations,
      view: this.view,
      selected: !1,
      extension: this.extension,
      HTMLAttributes: this.HTMLAttributes,
      getPos: () => this.getPos(),
      updateAttributes: (c = {}) => this.updateAttributes(c),
      deleteNode: () => this.deleteNode()
    };
    if (!this.component.displayName) {
      const c = (u) => u.charAt(0).toUpperCase() + u.substring(1);
      this.component.displayName = c(this.extension.name);
    }
    const i = { onDragStart: this.onDragStart.bind(this), nodeViewContentRef: (c) => {
      c && this.contentDOMElement && c.firstChild !== this.contentDOMElement && c.appendChild(this.contentDOMElement);
    } }, o = this.component, a = Lt.memo((c) => Lt.createElement(t6.Provider, { value: i }, Lt.createElement(o, c)));
    a.displayName = "ReactNodeView", this.node.isLeaf ? this.contentDOMElement = null : this.options.contentDOMElementTag ? this.contentDOMElement = document.createElement(this.options.contentDOMElementTag) : this.contentDOMElement = document.createElement(this.node.isInline ? "span" : "div"), this.contentDOMElement && (this.contentDOMElement.dataset.nodeViewContentReact = "", this.contentDOMElement.style.whiteSpace = "inherit");
    let s = this.node.isInline ? "span" : "div";
    this.options.as && (s = this.options.as);
    const { className: l = "" } = this.options;
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.renderer = new g1(a, {
      editor: this.editor,
      props: e,
      as: s,
      className: `node-${this.node.type.name} ${l}`.trim()
    }), this.updateElementAttributes();
  }
  /**
   * Return the DOM element.
   * This is the element that will be used to display the node view.
   */
  get dom() {
    var e;
    if (this.renderer.element.firstElementChild && !(!((e = this.renderer.element.firstElementChild) === null || e === void 0) && e.hasAttribute("data-node-view-wrapper")))
      throw Error("Please use the NodeViewWrapper component for your node view.");
    return this.renderer.element;
  }
  /**
   * Return the content DOM element.
   * This is the element that will be used to display the rich-text content of the node.
   */
  get contentDOM() {
    return this.node.isLeaf ? null : this.contentDOMElement;
  }
  /**
   * On editor selection update, check if the node is selected.
   * If it is, call `selectNode`, otherwise call `deselectNode`.
   */
  handleSelectionUpdate() {
    const { from: e, to: n } = this.editor.state.selection, r = this.getPos();
    if (typeof r == "number")
      if (e <= r && n >= r + this.node.nodeSize) {
        if (this.renderer.props.selected)
          return;
        this.selectNode();
      } else {
        if (!this.renderer.props.selected)
          return;
        this.deselectNode();
      }
  }
  /**
   * On update, update the React component.
   * To prevent unnecessary updates, the `update` option can be used.
   */
  update(e, n, r) {
    const i = (o) => {
      this.renderer.updateProps(o), typeof this.options.attrs == "function" && this.updateElementAttributes();
    };
    if (e.type !== this.node.type)
      return !1;
    if (typeof this.options.update == "function") {
      const o = this.node, a = this.decorations, s = this.innerDecorations;
      return this.node = e, this.decorations = n, this.innerDecorations = r, this.options.update({
        oldNode: o,
        oldDecorations: a,
        newNode: e,
        newDecorations: n,
        oldInnerDecorations: s,
        innerDecorations: r,
        updateProps: () => i({ node: e, decorations: n, innerDecorations: r })
      });
    }
    return e === this.node && this.decorations === n && this.innerDecorations === r || (this.node = e, this.decorations = n, this.innerDecorations = r, i({ node: e, decorations: n, innerDecorations: r })), !0;
  }
  /**
   * Select the node.
   * Add the `selected` prop and the `ProseMirror-selectednode` class.
   */
  selectNode() {
    this.renderer.updateProps({
      selected: !0
    }), this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  /**
   * Deselect the node.
   * Remove the `selected` prop and the `ProseMirror-selectednode` class.
   */
  deselectNode() {
    this.renderer.updateProps({
      selected: !1
    }), this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  /**
   * Destroy the React component instance.
   */
  destroy() {
    this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate), this.contentDOMElement = null;
  }
  /**
   * Update the attributes of the top-level element that holds the React component.
   * Applying the attributes defined in the `attrs` option.
   */
  updateElementAttributes() {
    if (this.options.attrs) {
      let e = {};
      if (typeof this.options.attrs == "function") {
        const n = this.editor.extensionManager.attributes, r = Sb(this.node, n);
        e = this.options.attrs({ node: this.node, HTMLAttributes: r });
      } else
        e = this.options.attrs;
      this.renderer.updateAttributes(e);
    }
  }
}
function Vf(t, e) {
  return (n) => n.editor.contentComponent ? new Gq(t, n, e) : {};
}
var wt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function n6(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function r6(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
var wA = Object.prototype.toString, i6 = function(e) {
  var n = wA.call(e), r = n === "[object Arguments]";
  return r || (r = n !== "[object Array]" && e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && wA.call(e.callee) === "[object Function]"), r;
}, ex, xA;
function Kq() {
  if (xA) return ex;
  xA = 1;
  var t;
  if (!Object.keys) {
    var e = Object.prototype.hasOwnProperty, n = Object.prototype.toString, r = i6, i = Object.prototype.propertyIsEnumerable, o = !i.call({ toString: null }, "toString"), a = i.call(function() {
    }, "prototype"), s = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], l = function(f) {
      var p = f.constructor;
      return p && p.prototype === f;
    }, c = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, u = function() {
      if (typeof window > "u")
        return !1;
      for (var f in window)
        try {
          if (!c["$" + f] && e.call(window, f) && window[f] !== null && typeof window[f] == "object")
            try {
              l(window[f]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), d = function(f) {
      if (typeof window > "u" || !u)
        return l(f);
      try {
        return l(f);
      } catch {
        return !1;
      }
    };
    t = function(p) {
      var m = p !== null && typeof p == "object", g = n.call(p) === "[object Function]", b = r(p), y = m && n.call(p) === "[object String]", w = [];
      if (!m && !g && !b)
        throw new TypeError("Object.keys called on a non-object");
      var x = a && g;
      if (y && p.length > 0 && !e.call(p, 0))
        for (var k = 0; k < p.length; ++k)
          w.push(String(k));
      if (b && p.length > 0)
        for (var A = 0; A < p.length; ++A)
          w.push(String(A));
      else
        for (var U in p)
          !(x && U === "prototype") && e.call(p, U) && w.push(String(U));
      if (o)
        for (var P = d(p), V = 0; V < s.length; ++V)
          !(P && s[V] === "constructor") && e.call(p, s[V]) && w.push(s[V]);
      return w;
    };
  }
  return ex = t, ex;
}
var Xq = Array.prototype.slice, Yq = i6, _A = Object.keys, zy = _A ? function(e) {
  return _A(e);
} : Kq(), SA = Object.keys;
zy.shim = function() {
  if (Object.keys) {
    var e = function() {
      var n = Object.keys(arguments);
      return n && n.length === arguments.length;
    }(1, 2);
    e || (Object.keys = function(r) {
      return Yq(r) ? SA(Xq.call(r)) : SA(r);
    });
  } else
    Object.keys = zy;
  return Object.keys || zy;
};
var wD = zy, Jq = Error, Zq = EvalError, Qq = RangeError, eG = ReferenceError, o6 = SyntaxError, Nl = TypeError, tG = URIError, y1 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var e = {}, n = Symbol("test"), r = Object(n);
  if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
    return !1;
  var i = 42;
  e[n] = i;
  for (n in e)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
    return !1;
  var o = Object.getOwnPropertySymbols(e);
  if (o.length !== 1 || o[0] !== n || !Object.prototype.propertyIsEnumerable.call(e, n))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var a = Object.getOwnPropertyDescriptor(e, n);
    if (a.value !== i || a.enumerable !== !0)
      return !1;
  }
  return !0;
}, TA = typeof Symbol < "u" && Symbol, nG = y1, xD = function() {
  return typeof TA != "function" || typeof Symbol != "function" || typeof TA("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : nG();
}, tx = {
  __proto__: null,
  foo: {}
}, rG = Object, iG = function() {
  return { __proto__: tx }.foo === tx.foo && !(tx instanceof rG);
}, oG = "Function.prototype.bind called on incompatible ", aG = Object.prototype.toString, sG = Math.max, lG = "[object Function]", DA = function(e, n) {
  for (var r = [], i = 0; i < e.length; i += 1)
    r[i] = e[i];
  for (var o = 0; o < n.length; o += 1)
    r[o + e.length] = n[o];
  return r;
}, cG = function(e, n) {
  for (var r = [], i = n, o = 0; i < e.length; i += 1, o += 1)
    r[o] = e[i];
  return r;
}, uG = function(t, e) {
  for (var n = "", r = 0; r < t.length; r += 1)
    n += t[r], r + 1 < t.length && (n += e);
  return n;
}, dG = function(e) {
  var n = this;
  if (typeof n != "function" || aG.apply(n) !== lG)
    throw new TypeError(oG + n);
  for (var r = cG(arguments, 1), i, o = function() {
    if (this instanceof i) {
      var u = n.apply(
        this,
        DA(r, arguments)
      );
      return Object(u) === u ? u : this;
    }
    return n.apply(
      e,
      DA(r, arguments)
    );
  }, a = sG(0, n.length - r.length), s = [], l = 0; l < a; l++)
    s[l] = "$" + l;
  if (i = Function("binder", "return function (" + uG(s, ",") + "){ return binder.apply(this,arguments); }")(o), n.prototype) {
    var c = function() {
    };
    c.prototype = n.prototype, i.prototype = new c(), c.prototype = null;
  }
  return i;
}, fG = dG, _D = Function.prototype.bind || fG, hG = Function.prototype.call, pG = Object.prototype.hasOwnProperty, mG = _D, a6 = mG.call(hG, pG), kt, gG = Jq, yG = Zq, bG = Qq, vG = eG, xf = o6, of = Nl, wG = tG, s6 = Function, nx = function(t) {
  try {
    return s6('"use strict"; return (' + t + ").constructor;")();
  } catch {
  }
}, Hc = Object.getOwnPropertyDescriptor;
if (Hc)
  try {
    Hc({}, "");
  } catch {
    Hc = null;
  }
var rx = function() {
  throw new of();
}, xG = Hc ? function() {
  try {
    return arguments.callee, rx;
  } catch {
    try {
      return Hc(arguments, "callee").get;
    } catch {
      return rx;
    }
  }
}() : rx, Ed = xD(), _G = iG(), jn = Object.getPrototypeOf || (_G ? function(t) {
  return t.__proto__;
} : null), $d = {}, SG = typeof Uint8Array > "u" || !jn ? kt : jn(Uint8Array), jc = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? kt : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? kt : ArrayBuffer,
  "%ArrayIteratorPrototype%": Ed && jn ? jn([][Symbol.iterator]()) : kt,
  "%AsyncFromSyncIteratorPrototype%": kt,
  "%AsyncFunction%": $d,
  "%AsyncGenerator%": $d,
  "%AsyncGeneratorFunction%": $d,
  "%AsyncIteratorPrototype%": $d,
  "%Atomics%": typeof Atomics > "u" ? kt : Atomics,
  "%BigInt%": typeof BigInt > "u" ? kt : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? kt : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? kt : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? kt : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": gG,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": yG,
  "%Float32Array%": typeof Float32Array > "u" ? kt : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? kt : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? kt : FinalizationRegistry,
  "%Function%": s6,
  "%GeneratorFunction%": $d,
  "%Int8Array%": typeof Int8Array > "u" ? kt : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? kt : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? kt : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Ed && jn ? jn(jn([][Symbol.iterator]())) : kt,
  "%JSON%": typeof JSON == "object" ? JSON : kt,
  "%Map%": typeof Map > "u" ? kt : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Ed || !jn ? kt : jn((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? kt : Promise,
  "%Proxy%": typeof Proxy > "u" ? kt : Proxy,
  "%RangeError%": bG,
  "%ReferenceError%": vG,
  "%Reflect%": typeof Reflect > "u" ? kt : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? kt : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Ed || !jn ? kt : jn((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? kt : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": Ed && jn ? jn(""[Symbol.iterator]()) : kt,
  "%Symbol%": Ed ? Symbol : kt,
  "%SyntaxError%": xf,
  "%ThrowTypeError%": xG,
  "%TypedArray%": SG,
  "%TypeError%": of,
  "%Uint8Array%": typeof Uint8Array > "u" ? kt : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? kt : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? kt : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? kt : Uint32Array,
  "%URIError%": wG,
  "%WeakMap%": typeof WeakMap > "u" ? kt : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? kt : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? kt : WeakSet
};
if (jn)
  try {
    null.error;
  } catch (t) {
    var TG = jn(jn(t));
    jc["%Error.prototype%"] = TG;
  }
var DG = function t(e) {
  var n;
  if (e === "%AsyncFunction%")
    n = nx("async function () {}");
  else if (e === "%GeneratorFunction%")
    n = nx("function* () {}");
  else if (e === "%AsyncGeneratorFunction%")
    n = nx("async function* () {}");
  else if (e === "%AsyncGenerator%") {
    var r = t("%AsyncGeneratorFunction%");
    r && (n = r.prototype);
  } else if (e === "%AsyncIteratorPrototype%") {
    var i = t("%AsyncGenerator%");
    i && jn && (n = jn(i.prototype));
  }
  return jc[e] = n, n;
}, EA = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Lm = _D, Eb = a6, EG = Lm.call(Function.call, Array.prototype.concat), CG = Lm.call(Function.apply, Array.prototype.splice), CA = Lm.call(Function.call, String.prototype.replace), Cb = Lm.call(Function.call, String.prototype.slice), kG = Lm.call(Function.call, RegExp.prototype.exec), AG = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, RG = /\\(\\)?/g, IG = function(e) {
  var n = Cb(e, 0, 1), r = Cb(e, -1);
  if (n === "%" && r !== "%")
    throw new xf("invalid intrinsic syntax, expected closing `%`");
  if (r === "%" && n !== "%")
    throw new xf("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return CA(e, AG, function(o, a, s, l) {
    i[i.length] = s ? CA(l, RG, "$1") : a || o;
  }), i;
}, OG = function(e, n) {
  var r = e, i;
  if (Eb(EA, r) && (i = EA[r], r = "%" + i[0] + "%"), Eb(jc, r)) {
    var o = jc[r];
    if (o === $d && (o = DG(r)), typeof o > "u" && !n)
      throw new of("intrinsic " + e + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: r,
      value: o
    };
  }
  throw new xf("intrinsic " + e + " does not exist!");
}, ga = function(e, n) {
  if (typeof e != "string" || e.length === 0)
    throw new of("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof n != "boolean")
    throw new of('"allowMissing" argument must be a boolean');
  if (kG(/^%?[^%]*%?$/, e) === null)
    throw new xf("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var r = IG(e), i = r.length > 0 ? r[0] : "", o = OG("%" + i + "%", n), a = o.name, s = o.value, l = !1, c = o.alias;
  c && (i = c[0], CG(r, EG([0, 1], c)));
  for (var u = 1, d = !0; u < r.length; u += 1) {
    var f = r[u], p = Cb(f, 0, 1), m = Cb(f, -1);
    if ((p === '"' || p === "'" || p === "`" || m === '"' || m === "'" || m === "`") && p !== m)
      throw new xf("property names with quotes must have matching quotes");
    if ((f === "constructor" || !d) && (l = !0), i += "." + f, a = "%" + i + "%", Eb(jc, a))
      s = jc[a];
    else if (s != null) {
      if (!(f in s)) {
        if (!n)
          throw new of("base intrinsic for " + e + " exists, but the property is not available.");
        return;
      }
      if (Hc && u + 1 >= r.length) {
        var g = Hc(s, f);
        d = !!g, d && "get" in g && !("originalValue" in g.get) ? s = g.get : s = s[f];
      } else
        d = Eb(s, f), s = s[f];
      d && !l && (jc[a] = s);
    }
  }
  return s;
}, FG = ga, $y = FG("%Object.defineProperty%", !0) || !1;
if ($y)
  try {
    $y({}, "a", { value: 1 });
  } catch {
    $y = !1;
  }
var SD = $y, UG = ga, Hy = UG("%Object.getOwnPropertyDescriptor%", !0);
if (Hy)
  try {
    Hy([], "length");
  } catch {
    Hy = null;
  }
var TD = Hy, kA = SD, NG = o6, Cd = Nl, AA = TD, DD = function(e, n, r) {
  if (!e || typeof e != "object" && typeof e != "function")
    throw new Cd("`obj` must be an object or a function`");
  if (typeof n != "string" && typeof n != "symbol")
    throw new Cd("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new Cd("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new Cd("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new Cd("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new Cd("`loose`, if provided, must be a boolean");
  var i = arguments.length > 3 ? arguments[3] : null, o = arguments.length > 4 ? arguments[4] : null, a = arguments.length > 5 ? arguments[5] : null, s = arguments.length > 6 ? arguments[6] : !1, l = !!AA && AA(e, n);
  if (kA)
    kA(e, n, {
      configurable: a === null && l ? l.configurable : !a,
      enumerable: i === null && l ? l.enumerable : !i,
      value: r,
      writable: o === null && l ? l.writable : !o
    });
  else if (s || !i && !o && !a)
    e[n] = r;
  else
    throw new NG("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, DS = SD, l6 = function() {
  return !!DS;
};
l6.hasArrayLengthDefineBug = function() {
  if (!DS)
    return null;
  try {
    return DS([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var ED = l6, MG = wD, BG = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", LG = Object.prototype.toString, PG = Array.prototype.concat, RA = DD, WG = function(t) {
  return typeof t == "function" && LG.call(t) === "[object Function]";
}, c6 = ED(), zG = function(t, e, n, r) {
  if (e in t) {
    if (r === !0) {
      if (t[e] === n)
        return;
    } else if (!WG(r) || !r())
      return;
  }
  c6 ? RA(t, e, n, !0) : RA(t, e, n);
}, u6 = function(t, e) {
  var n = arguments.length > 2 ? arguments[2] : {}, r = MG(e);
  BG && (r = PG.call(r, Object.getOwnPropertySymbols(e)));
  for (var i = 0; i < r.length; i += 1)
    zG(t, r[i], e[r[i]], n[r[i]]);
};
u6.supportsDescriptors = !!c6;
var du = u6, d6 = { exports: {} }, $G = ga, IA = DD, HG = ED(), OA = TD, FA = Nl, jG = $G("%Math.floor%"), VG = function(e, n) {
  if (typeof e != "function")
    throw new FA("`fn` is not a function");
  if (typeof n != "number" || n < 0 || n > 4294967295 || jG(n) !== n)
    throw new FA("`length` must be a positive 32-bit integer");
  var r = arguments.length > 2 && !!arguments[2], i = !0, o = !0;
  if ("length" in e && OA) {
    var a = OA(e, "length");
    a && !a.configurable && (i = !1), a && !a.writable && (o = !1);
  }
  return (i || o || !r) && (HG ? IA(
    /** @type {Parameters<define>[0]} */
    e,
    "length",
    n,
    !0,
    !0
  ) : IA(
    /** @type {Parameters<define>[0]} */
    e,
    "length",
    n
  )), e;
};
(function(t) {
  var e = _D, n = ga, r = VG, i = Nl, o = n("%Function.prototype.apply%"), a = n("%Function.prototype.call%"), s = n("%Reflect.apply%", !0) || e.call(a, o), l = SD, c = n("%Math.max%");
  t.exports = function(f) {
    if (typeof f != "function")
      throw new i("a function is required");
    var p = s(e, a, arguments);
    return r(
      p,
      1 + c(0, f.length - (arguments.length - 1)),
      !0
    );
  };
  var u = function() {
    return s(e, o, arguments);
  };
  l ? l(t.exports, "apply", { value: u }) : t.exports.apply = u;
})(d6);
var qf = d6.exports, f6 = ga, h6 = qf, qG = h6(f6("String.prototype.indexOf")), io = function(e, n) {
  var r = f6(e, !!n);
  return typeof r == "function" && qG(e, ".prototype.") > -1 ? h6(r) : r;
}, GG = wD, p6 = y1(), m6 = io, UA = Object, KG = m6("Array.prototype.push"), NA = m6("Object.prototype.propertyIsEnumerable"), XG = p6 ? Object.getOwnPropertySymbols : null, g6 = function(e, n) {
  if (e == null)
    throw new TypeError("target must be an object");
  var r = UA(e);
  if (arguments.length === 1)
    return r;
  for (var i = 1; i < arguments.length; ++i) {
    var o = UA(arguments[i]), a = GG(o), s = p6 && (Object.getOwnPropertySymbols || XG);
    if (s)
      for (var l = s(o), c = 0; c < l.length; ++c) {
        var u = l[c];
        NA(o, u) && KG(a, u);
      }
    for (var d = 0; d < a.length; ++d) {
      var f = a[d];
      if (NA(o, f)) {
        var p = o[f];
        r[f] = p;
      }
    }
  }
  return r;
}, ix = g6, YG = function() {
  if (!Object.assign)
    return !1;
  for (var t = "abcdefghijklmnopqrst", e = t.split(""), n = {}, r = 0; r < e.length; ++r)
    n[e[r]] = e[r];
  var i = Object.assign({}, n), o = "";
  for (var a in i)
    o += a;
  return t !== o;
}, JG = function() {
  if (!Object.assign || !Object.preventExtensions)
    return !1;
  var t = Object.preventExtensions({ 1: 2 });
  try {
    Object.assign(t, "xy");
  } catch {
    return t[1] === "y";
  }
  return !1;
}, y6 = function() {
  return !Object.assign || YG() || JG() ? ix : Object.assign;
}, ZG = du, QG = y6, eK = function() {
  var e = QG();
  return ZG(
    Object,
    { assign: e },
    { assign: function() {
      return Object.assign !== e;
    } }
  ), e;
}, tK = du, nK = qf, rK = g6, b6 = y6, iK = eK, oK = nK.apply(b6()), v6 = function(e, n) {
  return oK(Object, arguments);
};
tK(v6, {
  getPolyfill: b6,
  implementation: rK,
  shim: iK
});
var aK = v6, tm = function() {
  return typeof (function() {
  }).name == "string";
}, Fp = Object.getOwnPropertyDescriptor;
if (Fp)
  try {
    Fp([], "length");
  } catch {
    Fp = null;
  }
tm.functionsHaveConfigurableNames = function() {
  if (!tm() || !Fp)
    return !1;
  var e = Fp(function() {
  }, "name");
  return !!e && !!e.configurable;
};
var sK = Function.prototype.bind;
tm.boundFunctionsHaveNames = function() {
  return tm() && typeof sK == "function" && (function() {
  }).bind().name !== "";
};
var lK = tm, MA = DD, cK = ED(), uK = lK.functionsHaveConfigurableNames(), dK = Nl, fK = function(e, n) {
  if (typeof e != "function")
    throw new dK("`fn` is not a function");
  var r = arguments.length > 2 && !!arguments[2];
  return (!r || uK) && (cK ? MA(
    /** @type {Parameters<define>[0]} */
    e,
    "name",
    n,
    !0,
    !0
  ) : MA(
    /** @type {Parameters<define>[0]} */
    e,
    "name",
    n
  )), e;
}, hK = fK, pK = Nl, mK = Object, w6 = hK(function() {
  if (this == null || this !== mK(this))
    throw new pK("RegExp.prototype.flags getter called on non-object");
  var e = "";
  return this.hasIndices && (e += "d"), this.global && (e += "g"), this.ignoreCase && (e += "i"), this.multiline && (e += "m"), this.dotAll && (e += "s"), this.unicode && (e += "u"), this.unicodeSets && (e += "v"), this.sticky && (e += "y"), e;
}, "get flags", !0), gK = w6, yK = du.supportsDescriptors, bK = Object.getOwnPropertyDescriptor, x6 = function() {
  if (yK && /a/mig.flags === "gim") {
    var e = bK(RegExp.prototype, "flags");
    if (e && typeof e.get == "function" && typeof RegExp.prototype.dotAll == "boolean" && typeof RegExp.prototype.hasIndices == "boolean") {
      var n = "", r = {};
      if (Object.defineProperty(r, "hasIndices", {
        get: function() {
          n += "d";
        }
      }), Object.defineProperty(r, "sticky", {
        get: function() {
          n += "y";
        }
      }), n === "dy")
        return e.get;
    }
  }
  return gK;
}, vK = du.supportsDescriptors, wK = x6, xK = Object.getOwnPropertyDescriptor, _K = Object.defineProperty, SK = TypeError, BA = Object.getPrototypeOf, TK = /a/, DK = function() {
  if (!vK || !BA)
    throw new SK("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  var e = wK(), n = BA(TK), r = xK(n, "flags");
  return (!r || r.get !== e) && _K(n, "flags", {
    configurable: !0,
    enumerable: !1,
    get: e
  }), e;
}, EK = du, CK = qf, kK = w6, _6 = x6, AK = DK, S6 = CK(_6());
EK(S6, {
  getPolyfill: _6,
  implementation: kK,
  shim: AK
});
var RK = S6, jy = { exports: {} }, IK = y1, fu = function() {
  return IK() && !!Symbol.toStringTag;
}, OK = fu(), FK = io, ES = FK("Object.prototype.toString"), b1 = function(e) {
  return OK && e && typeof e == "object" && Symbol.toStringTag in e ? !1 : ES(e) === "[object Arguments]";
}, T6 = function(e) {
  return b1(e) ? !0 : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && ES(e) !== "[object Array]" && ES(e.callee) === "[object Function]";
}, UK = function() {
  return b1(arguments);
}();
b1.isLegacyArguments = T6;
var D6 = UK ? b1 : T6;
const NK = {}, MK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: NK
}, Symbol.toStringTag, { value: "Module" })), BK = /* @__PURE__ */ r6(MK);
var CD = typeof Map == "function" && Map.prototype, ox = Object.getOwnPropertyDescriptor && CD ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, kb = CD && ox && typeof ox.get == "function" ? ox.get : null, LA = CD && Map.prototype.forEach, kD = typeof Set == "function" && Set.prototype, ax = Object.getOwnPropertyDescriptor && kD ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, Ab = kD && ax && typeof ax.get == "function" ? ax.get : null, PA = kD && Set.prototype.forEach, LK = typeof WeakMap == "function" && WeakMap.prototype, Up = LK ? WeakMap.prototype.has : null, PK = typeof WeakSet == "function" && WeakSet.prototype, Np = PK ? WeakSet.prototype.has : null, WK = typeof WeakRef == "function" && WeakRef.prototype, WA = WK ? WeakRef.prototype.deref : null, zK = Boolean.prototype.valueOf, $K = Object.prototype.toString, HK = Function.prototype.toString, jK = String.prototype.match, AD = String.prototype.slice, gl = String.prototype.replace, VK = String.prototype.toUpperCase, zA = String.prototype.toLowerCase, E6 = RegExp.prototype.test, $A = Array.prototype.concat, ta = Array.prototype.join, qK = Array.prototype.slice, HA = Math.floor, CS = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, sx = Object.getOwnPropertySymbols, kS = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, _f = typeof Symbol == "function" && typeof Symbol.iterator == "object", _r = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === _f || !0) ? Symbol.toStringTag : null, C6 = Object.prototype.propertyIsEnumerable, jA = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
  return t.__proto__;
} : null);
function VA(t, e) {
  if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || E6.call(/e/, e))
    return e;
  var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof t == "number") {
    var r = t < 0 ? -HA(-t) : HA(t);
    if (r !== t) {
      var i = String(r), o = AD.call(e, i.length + 1);
      return gl.call(i, n, "$&_") + "." + gl.call(gl.call(o, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return gl.call(e, n, "$&_");
}
var AS = BK, qA = AS.custom, GA = A6(qA) ? qA : null, GK = function t(e, n, r, i) {
  var o = n || {};
  if (il(o, "quoteStyle") && o.quoteStyle !== "single" && o.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if (il(o, "maxStringLength") && (typeof o.maxStringLength == "number" ? o.maxStringLength < 0 && o.maxStringLength !== 1 / 0 : o.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var a = il(o, "customInspect") ? o.customInspect : !0;
  if (typeof a != "boolean" && a !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if (il(o, "indent") && o.indent !== null && o.indent !== "	" && !(parseInt(o.indent, 10) === o.indent && o.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if (il(o, "numericSeparator") && typeof o.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var s = o.numericSeparator;
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  if (typeof e == "boolean")
    return e ? "true" : "false";
  if (typeof e == "string")
    return I6(e, o);
  if (typeof e == "number") {
    if (e === 0)
      return 1 / 0 / e > 0 ? "0" : "-0";
    var l = String(e);
    return s ? VA(e, l) : l;
  }
  if (typeof e == "bigint") {
    var c = String(e) + "n";
    return s ? VA(e, c) : c;
  }
  var u = typeof o.depth > "u" ? 5 : o.depth;
  if (typeof r > "u" && (r = 0), r >= u && u > 0 && typeof e == "object")
    return RS(e) ? "[Array]" : "[Object]";
  var d = dX(o, r);
  if (typeof i > "u")
    i = [];
  else if (R6(i, e) >= 0)
    return "[Circular]";
  function f(G, C, ie) {
    if (C && (i = qK.call(i), i.push(C)), ie) {
      var ee = {
        depth: o.depth
      };
      return il(o, "quoteStyle") && (ee.quoteStyle = o.quoteStyle), t(G, ee, r + 1, i);
    }
    return t(G, o, r + 1, i);
  }
  if (typeof e == "function" && !KA(e)) {
    var p = nX(e), m = Kg(e, f);
    return "[Function" + (p ? ": " + p : " (anonymous)") + "]" + (m.length > 0 ? " { " + ta.call(m, ", ") + " }" : "");
  }
  if (A6(e)) {
    var g = _f ? gl.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : kS.call(e);
    return typeof e == "object" && !_f ? ip(g) : g;
  }
  if (lX(e)) {
    for (var b = "<" + zA.call(String(e.nodeName)), y = e.attributes || [], w = 0; w < y.length; w++)
      b += " " + y[w].name + "=" + k6(KK(y[w].value), "double", o);
    return b += ">", e.childNodes && e.childNodes.length && (b += "..."), b += "</" + zA.call(String(e.nodeName)) + ">", b;
  }
  if (RS(e)) {
    if (e.length === 0)
      return "[]";
    var x = Kg(e, f);
    return d && !uX(x) ? "[" + IS(x, d) + "]" : "[ " + ta.call(x, ", ") + " ]";
  }
  if (YK(e)) {
    var k = Kg(e, f);
    return !("cause" in Error.prototype) && "cause" in e && !C6.call(e, "cause") ? "{ [" + String(e) + "] " + ta.call($A.call("[cause]: " + f(e.cause), k), ", ") + " }" : k.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + ta.call(k, ", ") + " }";
  }
  if (typeof e == "object" && a) {
    if (GA && typeof e[GA] == "function" && AS)
      return AS(e, { depth: u - r });
    if (a !== "symbol" && typeof e.inspect == "function")
      return e.inspect();
  }
  if (rX(e)) {
    var A = [];
    return LA && LA.call(e, function(G, C) {
      A.push(f(C, e, !0) + " => " + f(G, e));
    }), XA("Map", kb.call(e), A, d);
  }
  if (aX(e)) {
    var U = [];
    return PA && PA.call(e, function(G) {
      U.push(f(G, e));
    }), XA("Set", Ab.call(e), U, d);
  }
  if (iX(e))
    return lx("WeakMap");
  if (sX(e))
    return lx("WeakSet");
  if (oX(e))
    return lx("WeakRef");
  if (ZK(e))
    return ip(f(Number(e)));
  if (eX(e))
    return ip(f(CS.call(e)));
  if (QK(e))
    return ip(zK.call(e));
  if (JK(e))
    return ip(f(String(e)));
  if (typeof window < "u" && e === window)
    return "{ [object Window] }";
  if (typeof globalThis < "u" && e === globalThis || typeof wt < "u" && e === wt)
    return "{ [object globalThis] }";
  if (!XK(e) && !KA(e)) {
    var P = Kg(e, f), V = jA ? jA(e) === Object.prototype : e instanceof Object || e.constructor === Object, I = e instanceof Object ? "" : "null prototype", le = !V && _r && Object(e) === e && _r in e ? AD.call(Ml(e), 8, -1) : I ? "Object" : "", be = V || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "", F = be + (le || I ? "[" + ta.call($A.call([], le || [], I || []), ": ") + "] " : "");
    return P.length === 0 ? F + "{}" : d ? F + "{" + IS(P, d) + "}" : F + "{ " + ta.call(P, ", ") + " }";
  }
  return String(e);
};
function k6(t, e, n) {
  var r = (n.quoteStyle || e) === "double" ? '"' : "'";
  return r + t + r;
}
function KK(t) {
  return gl.call(String(t), /"/g, "&quot;");
}
function RS(t) {
  return Ml(t) === "[object Array]" && (!_r || !(typeof t == "object" && _r in t));
}
function XK(t) {
  return Ml(t) === "[object Date]" && (!_r || !(typeof t == "object" && _r in t));
}
function KA(t) {
  return Ml(t) === "[object RegExp]" && (!_r || !(typeof t == "object" && _r in t));
}
function YK(t) {
  return Ml(t) === "[object Error]" && (!_r || !(typeof t == "object" && _r in t));
}
function JK(t) {
  return Ml(t) === "[object String]" && (!_r || !(typeof t == "object" && _r in t));
}
function ZK(t) {
  return Ml(t) === "[object Number]" && (!_r || !(typeof t == "object" && _r in t));
}
function QK(t) {
  return Ml(t) === "[object Boolean]" && (!_r || !(typeof t == "object" && _r in t));
}
function A6(t) {
  if (_f)
    return t && typeof t == "object" && t instanceof Symbol;
  if (typeof t == "symbol")
    return !0;
  if (!t || typeof t != "object" || !kS)
    return !1;
  try {
    return kS.call(t), !0;
  } catch {
  }
  return !1;
}
function eX(t) {
  if (!t || typeof t != "object" || !CS)
    return !1;
  try {
    return CS.call(t), !0;
  } catch {
  }
  return !1;
}
var tX = Object.prototype.hasOwnProperty || function(t) {
  return t in this;
};
function il(t, e) {
  return tX.call(t, e);
}
function Ml(t) {
  return $K.call(t);
}
function nX(t) {
  if (t.name)
    return t.name;
  var e = jK.call(HK.call(t), /^function\s*([\w$]+)/);
  return e ? e[1] : null;
}
function R6(t, e) {
  if (t.indexOf)
    return t.indexOf(e);
  for (var n = 0, r = t.length; n < r; n++)
    if (t[n] === e)
      return n;
  return -1;
}
function rX(t) {
  if (!kb || !t || typeof t != "object")
    return !1;
  try {
    kb.call(t);
    try {
      Ab.call(t);
    } catch {
      return !0;
    }
    return t instanceof Map;
  } catch {
  }
  return !1;
}
function iX(t) {
  if (!Up || !t || typeof t != "object")
    return !1;
  try {
    Up.call(t, Up);
    try {
      Np.call(t, Np);
    } catch {
      return !0;
    }
    return t instanceof WeakMap;
  } catch {
  }
  return !1;
}
function oX(t) {
  if (!WA || !t || typeof t != "object")
    return !1;
  try {
    return WA.call(t), !0;
  } catch {
  }
  return !1;
}
function aX(t) {
  if (!Ab || !t || typeof t != "object")
    return !1;
  try {
    Ab.call(t);
    try {
      kb.call(t);
    } catch {
      return !0;
    }
    return t instanceof Set;
  } catch {
  }
  return !1;
}
function sX(t) {
  if (!Np || !t || typeof t != "object")
    return !1;
  try {
    Np.call(t, Np);
    try {
      Up.call(t, Up);
    } catch {
      return !0;
    }
    return t instanceof WeakSet;
  } catch {
  }
  return !1;
}
function lX(t) {
  return !t || typeof t != "object" ? !1 : typeof HTMLElement < "u" && t instanceof HTMLElement ? !0 : typeof t.nodeName == "string" && typeof t.getAttribute == "function";
}
function I6(t, e) {
  if (t.length > e.maxStringLength) {
    var n = t.length - e.maxStringLength, r = "... " + n + " more character" + (n > 1 ? "s" : "");
    return I6(AD.call(t, 0, e.maxStringLength), e) + r;
  }
  var i = gl.call(gl.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, cX);
  return k6(i, "single", e);
}
function cX(t) {
  var e = t.charCodeAt(0), n = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[e];
  return n ? "\\" + n : "\\x" + (e < 16 ? "0" : "") + VK.call(e.toString(16));
}
function ip(t) {
  return "Object(" + t + ")";
}
function lx(t) {
  return t + " { ? }";
}
function XA(t, e, n, r) {
  var i = r ? IS(n, r) : ta.call(n, ", ");
  return t + " (" + e + ") {" + i + "}";
}
function uX(t) {
  for (var e = 0; e < t.length; e++)
    if (R6(t[e], `
`) >= 0)
      return !1;
  return !0;
}
function dX(t, e) {
  var n;
  if (t.indent === "	")
    n = "	";
  else if (typeof t.indent == "number" && t.indent > 0)
    n = ta.call(Array(t.indent + 1), " ");
  else
    return null;
  return {
    base: n,
    prev: ta.call(Array(e + 1), n)
  };
}
function IS(t, e) {
  if (t.length === 0)
    return "";
  var n = `
` + e.prev + e.base;
  return n + ta.call(t, "," + n) + `
` + e.prev;
}
function Kg(t, e) {
  var n = RS(t), r = [];
  if (n) {
    r.length = t.length;
    for (var i = 0; i < t.length; i++)
      r[i] = il(t, i) ? e(t[i], t) : "";
  }
  var o = typeof sx == "function" ? sx(t) : [], a;
  if (_f) {
    a = {};
    for (var s = 0; s < o.length; s++)
      a["$" + o[s]] = o[s];
  }
  for (var l in t)
    il(t, l) && (n && String(Number(l)) === l && l < t.length || _f && a["$" + l] instanceof Symbol || (E6.call(/[^\w$]/, l) ? r.push(e(l, t) + ": " + e(t[l], t)) : r.push(l + ": " + e(t[l], t))));
  if (typeof sx == "function")
    for (var c = 0; c < o.length; c++)
      C6.call(t, o[c]) && r.push("[" + e(o[c]) + "]: " + e(t[o[c]], t));
  return r;
}
var O6 = ga, Gf = io, fX = GK, hX = Nl, Xg = O6("%WeakMap%", !0), Yg = O6("%Map%", !0), pX = Gf("WeakMap.prototype.get", !0), mX = Gf("WeakMap.prototype.set", !0), gX = Gf("WeakMap.prototype.has", !0), yX = Gf("Map.prototype.get", !0), bX = Gf("Map.prototype.set", !0), vX = Gf("Map.prototype.has", !0), RD = function(t, e) {
  for (var n = t, r; (r = n.next) !== null; n = r)
    if (r.key === e)
      return n.next = r.next, r.next = /** @type {NonNullable<typeof list.next>} */
      t.next, t.next = r, r;
}, wX = function(t, e) {
  var n = RD(t, e);
  return n && n.value;
}, xX = function(t, e, n) {
  var r = RD(t, e);
  r ? r.value = n : t.next = /** @type {import('.').ListNode<typeof value>} */
  {
    // eslint-disable-line no-param-reassign, no-extra-parens
    key: e,
    next: t.next,
    value: n
  };
}, _X = function(t, e) {
  return !!RD(t, e);
}, F6 = function() {
  var e, n, r, i = {
    assert: function(o) {
      if (!i.has(o))
        throw new hX("Side channel does not contain " + fX(o));
    },
    get: function(o) {
      if (Xg && o && (typeof o == "object" || typeof o == "function")) {
        if (e)
          return pX(e, o);
      } else if (Yg) {
        if (n)
          return yX(n, o);
      } else if (r)
        return wX(r, o);
    },
    has: function(o) {
      if (Xg && o && (typeof o == "object" || typeof o == "function")) {
        if (e)
          return gX(e, o);
      } else if (Yg) {
        if (n)
          return vX(n, o);
      } else if (r)
        return _X(r, o);
      return !1;
    },
    set: function(o, a) {
      Xg && o && (typeof o == "object" || typeof o == "function") ? (e || (e = new Xg()), mX(e, o, a)) : Yg ? (n || (n = new Yg()), bX(n, o, a)) : (r || (r = { key: {}, next: null }), xX(r, o, a));
    }
  };
  return i;
}, SX = a6, op = F6(), $a = Nl, ID = {
  assert: function(t, e) {
    if (!t || typeof t != "object" && typeof t != "function")
      throw new $a("`O` is not an object");
    if (typeof e != "string")
      throw new $a("`slot` must be a string");
    if (op.assert(t), !ID.has(t, e))
      throw new $a("`" + e + "` is not present on `O`");
  },
  get: function(t, e) {
    if (!t || typeof t != "object" && typeof t != "function")
      throw new $a("`O` is not an object");
    if (typeof e != "string")
      throw new $a("`slot` must be a string");
    var n = op.get(t);
    return n && n["$" + e];
  },
  has: function(t, e) {
    if (!t || typeof t != "object" && typeof t != "function")
      throw new $a("`O` is not an object");
    if (typeof e != "string")
      throw new $a("`slot` must be a string");
    var n = op.get(t);
    return !!n && SX(n, "$" + e);
  },
  set: function(t, e, n) {
    if (!t || typeof t != "object" && typeof t != "function")
      throw new $a("`O` is not an object");
    if (typeof e != "string")
      throw new $a("`slot` must be a string");
    var r = op.get(t);
    r || (r = {}, op.set(t, r)), r["$" + e] = n;
  }
};
Object.freeze && Object.freeze(ID);
var TX = ID, ap = TX, DX = SyntaxError, YA = typeof StopIteration == "object" ? StopIteration : null, EX = function(e) {
  if (!YA)
    throw new DX("this environment lacks StopIteration");
  ap.set(e, "[[Done]]", !1);
  var n = {
    next: function() {
      var i = ap.get(this, "[[Iterator]]"), o = ap.get(i, "[[Done]]");
      try {
        return {
          done: o,
          value: o ? void 0 : i.next()
        };
      } catch (a) {
        if (ap.set(i, "[[Done]]", !0), a !== YA)
          throw a;
        return {
          done: !0,
          value: void 0
        };
      }
    }
  };
  return ap.set(n, "[[Iterator]]", e), n;
}, CX = {}.toString, U6 = Array.isArray || function(t) {
  return CX.call(t) == "[object Array]";
}, kX = String.prototype.valueOf, AX = function(e) {
  try {
    return kX.call(e), !0;
  } catch {
    return !1;
  }
}, RX = Object.prototype.toString, IX = "[object String]", OX = fu(), N6 = function(e) {
  return typeof e == "string" ? !0 : typeof e != "object" ? !1 : OX ? AX(e) : RX.call(e) === IX;
}, OD = typeof Map == "function" && Map.prototype ? Map : null, FX = typeof Set == "function" && Set.prototype ? Set : null, Rb;
OD || (Rb = function(e) {
  return !1;
});
var M6 = OD ? Map.prototype.has : null, JA = FX ? Set.prototype.has : null;
!Rb && !M6 && (Rb = function(e) {
  return !1;
});
var B6 = Rb || function(e) {
  if (!e || typeof e != "object")
    return !1;
  try {
    if (M6.call(e), JA)
      try {
        JA.call(e);
      } catch {
        return !0;
      }
    return e instanceof OD;
  } catch {
  }
  return !1;
}, UX = typeof Map == "function" && Map.prototype ? Map : null, FD = typeof Set == "function" && Set.prototype ? Set : null, Ib;
FD || (Ib = function(e) {
  return !1;
});
var ZA = UX ? Map.prototype.has : null, L6 = FD ? Set.prototype.has : null;
!Ib && !L6 && (Ib = function(e) {
  return !1;
});
var P6 = Ib || function(e) {
  if (!e || typeof e != "object")
    return !1;
  try {
    if (L6.call(e), ZA)
      try {
        ZA.call(e);
      } catch {
        return !0;
      }
    return e instanceof FD;
  } catch {
  }
  return !1;
}, QA = D6, e3 = EX;
if (xD() || y1()) {
  var cx = Symbol.iterator;
  jy.exports = function(e) {
    if (e != null && typeof e[cx] < "u")
      return e[cx]();
    if (QA(e))
      return Array.prototype[cx].call(e);
  };
} else {
  var NX = U6, MX = N6, t3 = ga, BX = t3("%Map%", !0), LX = t3("%Set%", !0), bo = io, n3 = bo("Array.prototype.push"), r3 = bo("String.prototype.charCodeAt"), PX = bo("String.prototype.slice"), WX = function(e, n) {
    var r = e.length;
    if (n + 1 >= r)
      return n + 1;
    var i = r3(e, n);
    if (i < 55296 || i > 56319)
      return n + 1;
    var o = r3(e, n + 1);
    return o < 56320 || o > 57343 ? n + 1 : n + 2;
  }, ux = function(e) {
    var n = 0;
    return {
      next: function() {
        var i = n >= e.length, o;
        return i || (o = e[n], n += 1), {
          done: i,
          value: o
        };
      }
    };
  }, i3 = function(e, n) {
    if (NX(e) || QA(e))
      return ux(e);
    if (MX(e)) {
      var r = 0;
      return {
        next: function() {
          var o = WX(e, r), a = PX(e, r, o);
          return r = o, {
            done: o > e.length,
            value: a
          };
        }
      };
    }
    if (n && typeof e["_es6-shim iterator_"] < "u")
      return e["_es6-shim iterator_"]();
  };
  if (!BX && !LX)
    jy.exports = function(e) {
      if (e != null)
        return i3(e, !0);
    };
  else {
    var zX = B6, $X = P6, o3 = bo("Map.prototype.forEach", !0), a3 = bo("Set.prototype.forEach", !0);
    if (typeof process > "u" || !process.versions || !process.versions.node)
      var s3 = bo("Map.prototype.iterator", !0), l3 = bo("Set.prototype.iterator", !0);
    var c3 = bo("Map.prototype.@@iterator", !0) || bo("Map.prototype._es6-shim iterator_", !0), u3 = bo("Set.prototype.@@iterator", !0) || bo("Set.prototype._es6-shim iterator_", !0), HX = function(e) {
      if (zX(e)) {
        if (s3)
          return e3(s3(e));
        if (c3)
          return c3(e);
        if (o3) {
          var n = [];
          return o3(e, function(i, o) {
            n3(n, [o, i]);
          }), ux(n);
        }
      }
      if ($X(e)) {
        if (l3)
          return e3(l3(e));
        if (u3)
          return u3(e);
        if (a3) {
          var r = [];
          return a3(e, function(i) {
            n3(r, i);
          }), ux(r);
        }
      }
    };
    jy.exports = function(e) {
      return HX(e) || i3(e);
    };
  }
}
var jX = jy.exports, d3 = function(t) {
  return t !== t;
}, W6 = function(e, n) {
  return e === 0 && n === 0 ? 1 / e === 1 / n : !!(e === n || d3(e) && d3(n));
}, VX = W6, z6 = function() {
  return typeof Object.is == "function" ? Object.is : VX;
}, qX = z6, GX = du, KX = function() {
  var e = qX();
  return GX(Object, { is: e }, {
    is: function() {
      return Object.is !== e;
    }
  }), e;
}, XX = du, YX = qf, JX = W6, $6 = z6, ZX = KX, H6 = YX($6(), Object);
XX(H6, {
  getPolyfill: $6,
  implementation: JX,
  shim: ZX
});
var QX = H6, eY = qf, j6 = io, tY = ga, OS = tY("%ArrayBuffer%", !0), Vy = j6("ArrayBuffer.prototype.byteLength", !0), nY = j6("Object.prototype.toString"), f3 = !!OS && !Vy && new OS(0).slice, h3 = !!f3 && eY(f3), V6 = Vy || h3 ? function(e) {
  if (!e || typeof e != "object")
    return !1;
  try {
    return Vy ? Vy(e) : h3(e, 0), !0;
  } catch {
    return !1;
  }
} : OS ? function(e) {
  return nY(e) === "[object ArrayBuffer]";
} : function(e) {
  return !1;
}, rY = Date.prototype.getDay, iY = function(e) {
  try {
    return rY.call(e), !0;
  } catch {
    return !1;
  }
}, oY = Object.prototype.toString, aY = "[object Date]", sY = fu(), lY = function(e) {
  return typeof e != "object" || e === null ? !1 : sY ? iY(e) : oY.call(e) === aY;
}, FS = io, q6 = fu(), G6, K6, US, NS;
if (q6) {
  G6 = FS("Object.prototype.hasOwnProperty"), K6 = FS("RegExp.prototype.exec"), US = {};
  var dx = function() {
    throw US;
  };
  NS = {
    toString: dx,
    valueOf: dx
  }, typeof Symbol.toPrimitive == "symbol" && (NS[Symbol.toPrimitive] = dx);
}
var cY = FS("Object.prototype.toString"), uY = Object.getOwnPropertyDescriptor, dY = "[object RegExp]", fY = q6 ? function(e) {
  if (!e || typeof e != "object")
    return !1;
  var n = uY(e, "lastIndex"), r = n && G6(n, "value");
  if (!r)
    return !1;
  try {
    K6(e, NS);
  } catch (i) {
    return i === US;
  }
} : function(e) {
  return !e || typeof e != "object" && typeof e != "function" ? !1 : cY(e) === dY;
}, hY = io, p3 = hY("SharedArrayBuffer.prototype.byteLength", !0), pY = p3 ? function(e) {
  if (!e || typeof e != "object")
    return !1;
  try {
    return p3(e), !0;
  } catch {
    return !1;
  }
} : function(e) {
  return !1;
}, mY = Number.prototype.toString, gY = function(e) {
  try {
    return mY.call(e), !0;
  } catch {
    return !1;
  }
}, yY = Object.prototype.toString, bY = "[object Number]", vY = fu(), wY = function(e) {
  return typeof e == "number" ? !0 : typeof e != "object" ? !1 : vY ? gY(e) : yY.call(e) === bY;
}, X6 = io, xY = X6("Boolean.prototype.toString"), _Y = X6("Object.prototype.toString"), SY = function(e) {
  try {
    return xY(e), !0;
  } catch {
    return !1;
  }
}, TY = "[object Boolean]", DY = fu(), EY = function(e) {
  return typeof e == "boolean" ? !0 : e === null || typeof e != "object" ? !1 : DY && Symbol.toStringTag in e ? SY(e) : _Y(e) === TY;
}, MS = { exports: {} }, CY = Object.prototype.toString, kY = xD();
if (kY) {
  var AY = Symbol.prototype.toString, RY = /^Symbol\(.*\)$/, IY = function(e) {
    return typeof e.valueOf() != "symbol" ? !1 : RY.test(AY.call(e));
  };
  MS.exports = function(e) {
    if (typeof e == "symbol")
      return !0;
    if (CY.call(e) !== "[object Symbol]")
      return !1;
    try {
      return IY(e);
    } catch {
      return !1;
    }
  };
} else
  MS.exports = function(e) {
    return !1;
  };
var OY = MS.exports, BS = { exports: {} }, m3 = typeof BigInt < "u" && BigInt, FY = function() {
  return typeof m3 == "function" && typeof BigInt == "function" && typeof m3(42) == "bigint" && typeof BigInt(42) == "bigint";
}, UY = FY();
if (UY) {
  var NY = BigInt.prototype.valueOf, MY = function(e) {
    try {
      return NY.call(e), !0;
    } catch {
    }
    return !1;
  };
  BS.exports = function(e) {
    return e === null || typeof e > "u" || typeof e == "boolean" || typeof e == "string" || typeof e == "number" || typeof e == "symbol" || typeof e == "function" ? !1 : typeof e == "bigint" ? !0 : MY(e);
  };
} else
  BS.exports = function(e) {
    return !1;
  };
var BY = BS.exports, LY = N6, PY = wY, WY = EY, zY = OY, $Y = BY, HY = function(e) {
  if (e == null || typeof e != "object" && typeof e != "function")
    return null;
  if (LY(e))
    return "String";
  if (PY(e))
    return "Number";
  if (WY(e))
    return "Boolean";
  if (zY(e))
    return "Symbol";
  if ($Y(e))
    return "BigInt";
}, Ob = typeof WeakMap == "function" && WeakMap.prototype ? WeakMap : null, g3 = typeof WeakSet == "function" && WeakSet.prototype ? WeakSet : null, Fb;
Ob || (Fb = function(e) {
  return !1;
});
var LS = Ob ? Ob.prototype.has : null, fx = g3 ? g3.prototype.has : null;
!Fb && !LS && (Fb = function(e) {
  return !1;
});
var jY = Fb || function(e) {
  if (!e || typeof e != "object")
    return !1;
  try {
    if (LS.call(e, LS), fx)
      try {
        fx.call(e, fx);
      } catch {
        return !0;
      }
    return e instanceof Ob;
  } catch {
  }
  return !1;
}, PS = { exports: {} }, VY = ga, Y6 = io, qY = VY("%WeakSet%", !0), hx = Y6("WeakSet.prototype.has", !0);
if (hx) {
  var px = Y6("WeakMap.prototype.has", !0);
  PS.exports = function(e) {
    if (!e || typeof e != "object")
      return !1;
    try {
      if (hx(e, hx), px)
        try {
          px(e, px);
        } catch {
          return !0;
        }
      return e instanceof qY;
    } catch {
    }
    return !1;
  };
} else
  PS.exports = function(e) {
    return !1;
  };
var GY = PS.exports, KY = B6, XY = P6, YY = jY, JY = GY, ZY = function(e) {
  if (e && typeof e == "object") {
    if (KY(e))
      return "Map";
    if (XY(e))
      return "Set";
    if (YY(e))
      return "WeakMap";
    if (JY(e))
      return "WeakSet";
  }
  return !1;
}, J6 = Function.prototype.toString, Yd = typeof Reflect == "object" && Reflect !== null && Reflect.apply, WS, qy;
if (typeof Yd == "function" && typeof Object.defineProperty == "function")
  try {
    WS = Object.defineProperty({}, "length", {
      get: function() {
        throw qy;
      }
    }), qy = {}, Yd(function() {
      throw 42;
    }, null, WS);
  } catch (t) {
    t !== qy && (Yd = null);
  }
else
  Yd = null;
var QY = /^\s*class\b/, zS = function(e) {
  try {
    var n = J6.call(e);
    return QY.test(n);
  } catch {
    return !1;
  }
}, mx = function(e) {
  try {
    return zS(e) ? !1 : (J6.call(e), !0);
  } catch {
    return !1;
  }
}, Gy = Object.prototype.toString, eJ = "[object Object]", tJ = "[object Function]", nJ = "[object GeneratorFunction]", rJ = "[object HTMLAllCollection]", iJ = "[object HTML document.all class]", oJ = "[object HTMLCollection]", aJ = typeof Symbol == "function" && !!Symbol.toStringTag, sJ = !(0 in [,]), $S = function() {
  return !1;
};
if (typeof document == "object") {
  var lJ = document.all;
  Gy.call(lJ) === Gy.call(document.all) && ($S = function(e) {
    if ((sJ || !e) && (typeof e > "u" || typeof e == "object"))
      try {
        var n = Gy.call(e);
        return (n === rJ || n === iJ || n === oJ || n === eJ) && e("") == null;
      } catch {
      }
    return !1;
  });
}
var cJ = Yd ? function(e) {
  if ($S(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  try {
    Yd(e, null, WS);
  } catch (n) {
    if (n !== qy)
      return !1;
  }
  return !zS(e) && mx(e);
} : function(e) {
  if ($S(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  if (aJ)
    return mx(e);
  if (zS(e))
    return !1;
  var n = Gy.call(e);
  return n !== tJ && n !== nJ && !/^\[object HTML/.test(n) ? !1 : mx(e);
}, uJ = cJ, dJ = Object.prototype.toString, Z6 = Object.prototype.hasOwnProperty, fJ = function(e, n, r) {
  for (var i = 0, o = e.length; i < o; i++)
    Z6.call(e, i) && (r == null ? n(e[i], i, e) : n.call(r, e[i], i, e));
}, hJ = function(e, n, r) {
  for (var i = 0, o = e.length; i < o; i++)
    r == null ? n(e.charAt(i), i, e) : n.call(r, e.charAt(i), i, e);
}, pJ = function(e, n, r) {
  for (var i in e)
    Z6.call(e, i) && (r == null ? n(e[i], i, e) : n.call(r, e[i], i, e));
}, mJ = function(e, n, r) {
  if (!uJ(n))
    throw new TypeError("iterator must be a function");
  var i;
  arguments.length >= 3 && (i = r), dJ.call(e) === "[object Array]" ? fJ(e, n, i) : typeof e == "string" ? hJ(e, n, i) : pJ(e, n, i);
}, gJ = mJ, yJ = [
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], gx = yJ, bJ = typeof globalThis > "u" ? wt : globalThis, vJ = function() {
  for (var e = [], n = 0; n < gx.length; n++)
    typeof bJ[gx[n]] == "function" && (e[e.length] = gx[n]);
  return e;
}, Ub = gJ, wJ = vJ, y3 = qf, UD = io, Ky = TD, xJ = UD("Object.prototype.toString"), Q6 = fu(), b3 = typeof globalThis > "u" ? wt : globalThis, HS = wJ(), ND = UD("String.prototype.slice"), yx = Object.getPrototypeOf, _J = UD("Array.prototype.indexOf", !0) || function(e, n) {
  for (var r = 0; r < e.length; r += 1)
    if (e[r] === n)
      return r;
  return -1;
}, Nb = { __proto__: null };
Q6 && Ky && yx ? Ub(HS, function(t) {
  var e = new b3[t]();
  if (Symbol.toStringTag in e) {
    var n = yx(e), r = Ky(n, Symbol.toStringTag);
    if (!r) {
      var i = yx(n);
      r = Ky(i, Symbol.toStringTag);
    }
    Nb["$" + t] = y3(r.get);
  }
}) : Ub(HS, function(t) {
  var e = new b3[t](), n = e.slice || e.set;
  n && (Nb["$" + t] = y3(n));
});
var SJ = function(e) {
  var n = !1;
  return Ub(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    Nb,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(r, i) {
      if (!n)
        try {
          "$" + r(e) === i && (n = ND(i, 1));
        } catch {
        }
    }
  ), n;
}, TJ = function(e) {
  var n = !1;
  return Ub(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    Nb,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(r, i) {
      if (!n)
        try {
          r(e), n = ND(i, 1);
        } catch {
        }
    }
  ), n;
}, DJ = function(e) {
  if (!e || typeof e != "object")
    return !1;
  if (!Q6) {
    var n = ND(xJ(e), 8, -1);
    return _J(HS, n) > -1 ? n : n !== "Object" ? !1 : TJ(e);
  }
  return Ky ? SJ(e) : null;
}, EJ = io, v3 = EJ("ArrayBuffer.prototype.byteLength", !0), CJ = V6, kJ = function(e) {
  return CJ(e) ? v3 ? v3(e) : e.byteLength : NaN;
}, e4 = aK, ya = io, w3 = RK, AJ = ga, Sf = jX, RJ = F6, x3 = QX, _3 = D6, S3 = U6, T3 = V6, D3 = lY, E3 = fY, C3 = pY, k3 = wD, A3 = HY, R3 = ZY, I3 = DJ, O3 = kJ, F3 = ya("SharedArrayBuffer.prototype.byteLength", !0), U3 = ya("Date.prototype.getTime"), bx = Object.getPrototypeOf, N3 = ya("Object.prototype.toString"), Mb = AJ("%Set%", !0), jS = ya("Map.prototype.has", !0), Bb = ya("Map.prototype.get", !0), M3 = ya("Map.prototype.size", !0), Lb = ya("Set.prototype.add", !0), t4 = ya("Set.prototype.delete", !0), Pb = ya("Set.prototype.has", !0), Xy = ya("Set.prototype.size", !0);
function B3(t, e, n, r) {
  for (var i = Sf(t), o; (o = i.next()) && !o.done; )
    if (_o(e, o.value, n, r))
      return t4(t, o.value), !0;
  return !1;
}
function n4(t) {
  if (typeof t > "u")
    return null;
  if (typeof t != "object")
    return typeof t == "symbol" ? !1 : typeof t == "string" || typeof t == "number" ? +t == +t : !0;
}
function IJ(t, e, n, r, i, o) {
  var a = n4(n);
  if (a != null)
    return a;
  var s = Bb(e, a), l = e4({}, i, { strict: !1 });
  return typeof s > "u" && !jS(e, a) || !_o(r, s, l, o) ? !1 : !jS(t, a) && _o(r, s, l, o);
}
function OJ(t, e, n) {
  var r = n4(n);
  return r ?? (Pb(e, r) && !Pb(t, r));
}
function L3(t, e, n, r, i, o) {
  for (var a = Sf(t), s, l; (s = a.next()) && !s.done; )
    if (l = s.value, // eslint-disable-next-line no-use-before-define
    _o(n, l, i, o) && _o(r, Bb(e, l), i, o))
      return t4(t, l), !0;
  return !1;
}
function _o(t, e, n, r) {
  var i = n || {};
  if (i.strict ? x3(t, e) : t === e)
    return !0;
  var o = A3(t), a = A3(e);
  if (o !== a)
    return !1;
  if (!t || !e || typeof t != "object" && typeof e != "object")
    return i.strict ? x3(t, e) : t == e;
  var s = r.has(t), l = r.has(e), c;
  if (s && l) {
    if (r.get(t) === r.get(e))
      return !0;
  } else
    c = {};
  return s || r.set(t, c), l || r.set(e, c), NJ(t, e, i, r);
}
function P3(t) {
  return !t || typeof t != "object" || typeof t.length != "number" || typeof t.copy != "function" || typeof t.slice != "function" || t.length > 0 && typeof t[0] != "number" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t));
}
function FJ(t, e, n, r) {
  if (Xy(t) !== Xy(e))
    return !1;
  for (var i = Sf(t), o = Sf(e), a, s, l; (a = i.next()) && !a.done; )
    if (a.value && typeof a.value == "object")
      l || (l = new Mb()), Lb(l, a.value);
    else if (!Pb(e, a.value)) {
      if (n.strict || !OJ(t, e, a.value))
        return !1;
      l || (l = new Mb()), Lb(l, a.value);
    }
  if (l) {
    for (; (s = o.next()) && !s.done; )
      if (s.value && typeof s.value == "object") {
        if (!B3(l, s.value, n.strict, r))
          return !1;
      } else if (!n.strict && !Pb(t, s.value) && !B3(l, s.value, n.strict, r))
        return !1;
    return Xy(l) === 0;
  }
  return !0;
}
function UJ(t, e, n, r) {
  if (M3(t) !== M3(e))
    return !1;
  for (var i = Sf(t), o = Sf(e), a, s, l, c, u, d; (a = i.next()) && !a.done; )
    if (c = a.value[0], u = a.value[1], c && typeof c == "object")
      l || (l = new Mb()), Lb(l, c);
    else if (d = Bb(e, c), typeof d > "u" && !jS(e, c) || !_o(u, d, n, r)) {
      if (n.strict || !IJ(t, e, c, u, n, r))
        return !1;
      l || (l = new Mb()), Lb(l, c);
    }
  if (l) {
    for (; (s = o.next()) && !s.done; )
      if (c = s.value[0], d = s.value[1], c && typeof c == "object") {
        if (!L3(l, t, c, d, n, r))
          return !1;
      } else if (!n.strict && (!t.has(c) || !_o(Bb(t, c), d, n, r)) && !L3(l, t, c, d, e4({}, n, { strict: !1 }), r))
        return !1;
    return Xy(l) === 0;
  }
  return !0;
}
function NJ(t, e, n, r) {
  var i, o;
  if (typeof t != typeof e || t == null || e == null || N3(t) !== N3(e) || _3(t) !== _3(e))
    return !1;
  var a = S3(t), s = S3(e);
  if (a !== s)
    return !1;
  var l = t instanceof Error, c = e instanceof Error;
  if (l !== c || (l || c) && (t.name !== e.name || t.message !== e.message))
    return !1;
  var u = E3(t), d = E3(e);
  if (u !== d || (u || d) && (t.source !== e.source || w3(t) !== w3(e)))
    return !1;
  var f = D3(t), p = D3(e);
  if (f !== p || (f || p) && U3(t) !== U3(e) || n.strict && bx && bx(t) !== bx(e))
    return !1;
  var m = I3(t), g = I3(e);
  if (m !== g)
    return !1;
  if (m || g) {
    if (t.length !== e.length)
      return !1;
    for (i = 0; i < t.length; i++)
      if (t[i] !== e[i])
        return !1;
    return !0;
  }
  var b = P3(t), y = P3(e);
  if (b !== y)
    return !1;
  if (b || y) {
    if (t.length !== e.length)
      return !1;
    for (i = 0; i < t.length; i++)
      if (t[i] !== e[i])
        return !1;
    return !0;
  }
  var w = T3(t), x = T3(e);
  if (w !== x)
    return !1;
  if (w || x)
    return O3(t) !== O3(e) ? !1 : typeof Uint8Array == "function" && _o(new Uint8Array(t), new Uint8Array(e), n, r);
  var k = C3(t), A = C3(e);
  if (k !== A)
    return !1;
  if (k || A)
    return F3(t) !== F3(e) ? !1 : typeof Uint8Array == "function" && _o(new Uint8Array(t), new Uint8Array(e), n, r);
  if (typeof t != typeof e)
    return !1;
  var U = k3(t), P = k3(e);
  if (U.length !== P.length)
    return !1;
  for (U.sort(), P.sort(), i = U.length - 1; i >= 0; i--)
    if (U[i] != P[i])
      return !1;
  for (i = U.length - 1; i >= 0; i--)
    if (o = U[i], !_o(t[o], e[o], n, r))
      return !1;
  var V = R3(t), I = R3(e);
  return V !== I ? !1 : V === "Set" || I === "Set" ? FJ(t, e, n, r) : V === "Map" ? UJ(t, e, n, r) : !0;
}
var MJ = function(e, n, r) {
  return _o(e, n, r, RJ());
};
const r4 = /* @__PURE__ */ n6(MJ);
function BJ(t) {
  return t;
}
function LJ(t, e, n, r) {
  const i = BJ, [o, a] = nt(i(n)), s = Wr(o);
  return Tt(() => {
    const l = () => {
      const c = { ...n, ...t.getAttributes(e) };
      Object.keys(c).forEach((d) => {
        (c[d] === null || c[d] === void 0) && (c[d] = n ? n[d] : null);
      });
      const u = i(c);
      r4(s.current, u) || (a(u), s.current = u);
    };
    return t.on("selectionUpdate", l), t.on("transaction", l), () => {
      t.off("selectionUpdate", l), t.off("transaction", l);
    };
  }, [t, n, e, i]), o;
}
const v1 = no.Root, w1 = no.Trigger, PJ = no.Portal, i4 = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  no.Overlay,
  {
    ref: n,
    className: Ct(
      "richtext-fixed richtext-inset-0 richtext-z-50 richtext-bg-black/80 richtext- data-[state=open]:richtext-animate-in data-[state=closed]:richtext-animate-out data-[state=closed]:richtext-fade-out-0 data-[state=open]:richtext-fade-in-0",
      t
    ),
    ...e
  }
));
i4.displayName = no.Overlay.displayName;
const Pm = Mt.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ Fe(PJ, { children: [
  /* @__PURE__ */ z(i4, {}),
  /* @__PURE__ */ Fe(
    no.Content,
    {
      ref: r,
      className: Ct(
        "richtext-dialog-content richtext-fixed richtext-left-[50%] richtext-top-[50%] richtext-z-50 richtext-grid richtext-w-full richtext-max-w-lg richtext-translate-x-[-50%] richtext-translate-y-[-50%] richtext-gap-4 richtext-border richtext-bg-background richtext-p-6 richtext-shadow-lg richtext-duration-200 data-[state=open]:richtext-animate-in data-[state=closed]:richtext-animate-out data-[state=closed]:richtext-fade-out-0 data-[state=open]:richtext-fade-in-0 data-[state=closed]:richtext-zoom-out-95 data-[state=open]:richtext-zoom-in-95 data-[state=closed]:richtext-slide-out-to-left-1/2 data-[state=closed]:richtext-slide-out-to-top-[48%] data-[state=open]:richtext-slide-in-from-left-1/2 data-[state=open]:richtext-slide-in-from-top-[48%] sm:richtext-rounded-lg",
        t
      ),
      ...n,
      children: [
        e,
        /* @__PURE__ */ Fe(no.Close, { className: "richtext-absolute richtext-right-4 richtext-top-4 richtext-rounded-sm richtext-opacity-70 richtext-ring-offset-background richtext-transition-opacity hover:richtext-opacity-100 focus:richtext-outline-none focus:richtext-ring-2 focus:richtext-ring-ring focus:richtext-ring-offset-2 disabled:richtext-pointer-events-none data-[state=open]:richtext-bg-accent data-[state=open]:richtext-text-muted-foreground", children: [
          /* @__PURE__ */ z(sF, { className: "richtext-h-4 richtext-w-4" }),
          /* @__PURE__ */ z("span", { className: "richtext-sr-only", children: "Close" })
        ] })
      ]
    }
  )
] }));
Pm.displayName = no.Content.displayName;
function o4({
  className: t,
  ...e
}) {
  return /* @__PURE__ */ z(
    "div",
    {
      className: Ct(
        "richtext-flex richtext-flex-col richtext-space-y-1.5 richtext-text-center sm:richtext-text-left",
        t
      ),
      ...e
    }
  );
}
o4.displayName = "DialogHeader";
function MD({
  className: t,
  ...e
}) {
  return /* @__PURE__ */ z(
    "div",
    {
      className: Ct(
        "richtext-flex richtext-flex-col-reverse sm:richtext-flex-row sm:richtext-justify-end sm:richtext-space-x-2",
        t
      ),
      ...e
    }
  );
}
MD.displayName = "DialogFooter";
const Wm = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  no.Title,
  {
    ref: n,
    className: Ct(
      "richtext-text-lg richtext-font-semibold richtext-leading-none richtext-tracking-tight",
      t
    ),
    ...e
  }
));
Wm.displayName = no.Title.displayName;
const WJ = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  no.Description,
  {
    ref: n,
    className: Ct("richtext-text-sm richtext-text-muted-foreground", t),
    ...e
  }
));
WJ.displayName = no.Description.displayName;
const W3 = (t) => typeof t == "boolean" ? `${t}` : t === 0 ? "0" : t, z3 = xo, x1 = (t, e) => (n) => {
  var r;
  if ((e == null ? void 0 : e.variants) == null) return z3(t, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
  const { variants: i, defaultVariants: o } = e, a = Object.keys(i).map((c) => {
    const u = n == null ? void 0 : n[c], d = o == null ? void 0 : o[c];
    if (u === null) return null;
    const f = W3(u) || W3(d);
    return i[c][f];
  }), s = n && Object.entries(n).reduce((c, u) => {
    let [d, f] = u;
    return f === void 0 || (c[d] = f), c;
  }, {}), l = e == null || (r = e.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((c, u) => {
    let { class: d, className: f, ...p } = u;
    return Object.entries(p).every((m) => {
      let [g, b] = m;
      return Array.isArray(b) ? b.includes({
        ...o,
        ...s
      }[g]) : {
        ...o,
        ...s
      }[g] === b;
    }) ? [
      ...c,
      d,
      f
    ] : c;
  }, []);
  return z3(t, a, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
}, zJ = x1(
  "richtext-inline-flex richtext-items-center richtext-justify-center richtext-whitespace-nowrap richtext-rounded-md richtext-text-sm richtext-font-medium richtext-ring-offset-background richtext-transition-colors focus-visible:richtext-outline-none focus-visible:richtext-ring-2 focus-visible:richtext-ring-ring focus-visible:richtext-ring-offset-2 disabled:richtext-pointer-events-none disabled:richtext-opacity-50",
  {
    variants: {
      variant: {
        default: "!richtext-bg-primary !richtext-text-primary-foreground hover:!richtext-bg-primary/90",
        destructive: "richtext-bg-destructive richtext-text-destructive-foreground hover:richtext-bg-destructive/90",
        outline: "richtext-border richtext-border-input richtext-bg-background hover:richtext-bg-accent hover:richtext-text-accent-foreground",
        secondary: "richtext-bg-secondary richtext-text-secondary-foreground hover:richtext-bg-secondary/80",
        ghost: "hover:richtext-bg-accent hover:richtext-text-accent-foreground",
        link: "richtext-text-primary richtext-underline-offset-4 hover:richtext-underline"
      },
      size: {
        default: "richtext-h-10 richtext-px-4 richtext-py-2",
        sm: "richtext-h-9 richtext-rounded-md richtext-px-3",
        lg: "richtext-h-11 richtext-rounded-md richtext-px-8",
        icon: "richtext-h-10 richtext-w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), fn = Mt.forwardRef(
  ({ className: t, variant: e, size: n, asChild: r = !1, ...i }, o) => /* @__PURE__ */ z(
    r ? KT : "button",
    {
      className: Ct(zJ({ variant: e, size: n, className: t })),
      ref: o,
      ...i
    }
  )
);
fn.displayName = "Button";
const hu = wn.Root, pu = wn.Trigger, $3 = wn.Portal, H3 = wn.Sub, VS = Mt.forwardRef(({ className: t, inset: e, children: n, ...r }, i) => /* @__PURE__ */ Fe(
  wn.SubTrigger,
  {
    ref: i,
    className: Ct(
      "richtext-flex richtext-cursor-default richtext-select-none richtext-items-center richtext-rounded-sm richtext-px-2 richtext-py-1.5 richtext-text-sm richtext-outline-none focus:richtext-bg-accent data-[state=open]:richtext-bg-accent",
      e && "richtext-pl-8",
      t
    ),
    ...r,
    children: [
      n,
      /* @__PURE__ */ z(l7, { className: "richtext-ml-auto richtext-h-4 richtext-w-4" })
    ]
  }
));
VS.displayName = wn.SubTrigger.displayName;
const qS = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  wn.SubContent,
  {
    ref: n,
    className: Ct(
      "richtext-z-50 richtext-min-w-[8rem] richtext-overflow-hidden richtext-rounded-md !richtext-border richtext-bg-popover richtext-p-1 richtext-text-popover-foreground richtext-shadow-lg data-[state=open]:richtext-animate-in data-[state=closed]:richtext-animate-out data-[state=closed]:richtext-fade-out-0 data-[state=open]:richtext-fade-in-0 data-[state=closed]:richtext-zoom-out-95 data-[state=open]:richtext-zoom-in-95 data-[side=bottom]:richtext-slide-in-from-top-2 data-[side=left]:richtext-slide-in-from-right-2 data-[side=right]:richtext-slide-in-from-left-2 data-[side=top]:richtext-slide-in-from-bottom-2",
      t
    ),
    ...e
  }
));
qS.displayName = wn.SubContent.displayName;
const Bl = Mt.forwardRef(({ className: t, sideOffset: e = 4, ...n }, r) => /* @__PURE__ */ z(wn.Portal, { children: /* @__PURE__ */ z(
  wn.Content,
  {
    ref: r,
    sideOffset: e,
    className: Ct(
      "richtext-z-50 richtext-min-w-[8rem] richtext-overflow-hidden richtext-rounded-md !richtext-border richtext-bg-popover richtext-p-1 richtext-text-popover-foreground richtext-shadow-md data-[state=open]:richtext-animate-in data-[state=closed]:richtext-animate-out data-[state=closed]:richtext-fade-out-0 data-[state=open]:richtext-fade-in-0 data-[state=closed]:richtext-zoom-out-95 data-[state=open]:richtext-zoom-in-95 data-[side=bottom]:richtext-slide-in-from-top-2 data-[side=left]:richtext-slide-in-from-right-2 data-[side=right]:richtext-slide-in-from-left-2 data-[side=top]:richtext-slide-in-from-bottom-2",
      t
    ),
    ...n
  }
) }));
Bl.displayName = wn.Content.displayName;
const Ko = Mt.forwardRef(({ className: t, inset: e, ...n }, r) => /* @__PURE__ */ z(
  wn.Item,
  {
    ref: r,
    className: Ct(
      "richtext-relative richtext-flex richtext-cursor-default richtext-select-none richtext-items-center richtext-rounded-sm richtext-px-2 richtext-py-1.5 richtext-text-sm richtext-outline-none richtext-transition-colors focus:richtext-bg-accent focus:richtext-text-accent-foreground data-[disabled]:richtext-pointer-events-none data-[disabled]:richtext-opacity-50",
      e && "richtext-pl-8",
      t
    ),
    ...n
  }
));
Ko.displayName = wn.Item.displayName;
const mu = Mt.forwardRef(({ className: t, children: e, checked: n, ...r }, i) => /* @__PURE__ */ Fe(
  wn.CheckboxItem,
  {
    ref: i,
    className: Ct(
      "richtext-relative richtext-flex richtext-cursor-default richtext-select-none richtext-items-center richtext-rounded-sm richtext-py-1.5 richtext-pl-8 richtext-pr-2 richtext-text-sm richtext-outline-none richtext-transition-colors focus:richtext-bg-accent focus:richtext-text-accent-foreground data-[disabled]:richtext-pointer-events-none data-[disabled]:richtext-opacity-50",
      t
    ),
    checked: n,
    ...r,
    children: [
      /* @__PURE__ */ z("span", { className: "richtext-absolute richtext-left-2 richtext-flex richtext-h-3.5 richtext-w-3.5 richtext-items-center richtext-justify-center", children: /* @__PURE__ */ z(wn.ItemIndicator, { children: /* @__PURE__ */ z(lF, { className: "richtext-h-4 richtext-w-4" }) }) }),
      e
    ]
  }
));
mu.displayName = wn.CheckboxItem.displayName;
const $J = Mt.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ Fe(
  wn.RadioItem,
  {
    ref: r,
    className: Ct(
      "richtext-relative richtext-flex richtext-cursor-default richtext-select-none richtext-items-center richtext-rounded-sm richtext-py-1.5 richtext-pl-8 richtext-pr-2 richtext-text-sm richtext-outline-none richtext-transition-colors focus:richtext-bg-accent focus:richtext-text-accent-foreground data-[disabled]:richtext-pointer-events-none data-[disabled]:richtext-opacity-50",
      t
    ),
    ...n,
    children: [
      /* @__PURE__ */ z("span", { className: "richtext-absolute richtext-left-2 richtext-flex richtext-h-3.5 richtext-w-3.5 richtext-items-center richtext-justify-center", children: /* @__PURE__ */ z(wn.ItemIndicator, { children: /* @__PURE__ */ z(c7, { className: "richtext-h-2 richtext-w-2 richtext-fill-current" }) }) }),
      e
    ]
  }
));
$J.displayName = wn.RadioItem.displayName;
const HJ = Mt.forwardRef(({ className: t, inset: e, ...n }, r) => /* @__PURE__ */ z(
  wn.Label,
  {
    ref: r,
    className: Ct(
      "richtext-px-2 richtext-py-1.5 richtext-text-sm richtext-font-semibold",
      e && "richtext-pl-8",
      t
    ),
    ...n
  }
));
HJ.displayName = wn.Label.displayName;
const _1 = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  wn.Separator,
  {
    ref: n,
    className: Ct("richtext--mx-1 richtext-my-1 richtext-h-px richtext-bg-muted", t),
    ...e
  }
));
_1.displayName = wn.Separator.displayName;
function a4({
  className: t,
  ...e
}) {
  return /* @__PURE__ */ z(
    "span",
    {
      className: Ct("richtext-ml-auto richtext-text-xs richtext-tracking-widest richtext-opacity-60", t),
      ...e
    }
  );
}
a4.displayName = "DropdownMenuShortcut";
const Pr = Mt.forwardRef(
  ({ className: t, type: e, ...n }, r) => /* @__PURE__ */ z(
    "input",
    {
      type: e,
      className: Ct(
        "richtext-flex richtext-h-10 richtext-w-full richtext-rounded-md !richtext-border richtext-border-input richtext-bg-background richtext-px-3 richtext-py-2 richtext-text-sm richtext-ring-offset-background file:richtext-border-0 file:richtext-bg-transparent file:richtext-text-sm file:richtext-font-medium placeholder:richtext-text-muted-foreground focus-visible:richtext-outline-none  disabled:richtext-cursor-not-allowed disabled:richtext-opacity-50",
        t
      ),
      ref: r,
      ...n
    }
  )
);
Pr.displayName = "Input";
const jJ = x1(
  "richtext-text-sm richtext-font-medium richtext-leading-none peer-disabled:richtext-cursor-not-allowed peer-disabled:richtext-opacity-70"
), eo = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  fF.Root,
  {
    ref: n,
    className: Ct(jJ(), t),
    ...e
  }
));
eo.displayName = fF.Root.displayName;
const Eo = Vp.Root, Co = Vp.Trigger, oo = Mt.forwardRef(({ className: t, align: e = "center", sideOffset: n = 4, ...r }, i) => /* @__PURE__ */ z(Vp.Portal, { children: /* @__PURE__ */ z(
  Vp.Content,
  {
    ref: i,
    align: e,
    sideOffset: n,
    className: Ct(
      "richtext-z-50 richtext-w-72 richtext-rounded-md !richtext-border richtext-bg-popover richtext-p-4 richtext-text-popover-foreground richtext-shadow-md richtext-outline-none data-[state=open]:richtext-animate-in data-[state=closed]:richtext-animate-out data-[state=closed]:richtext-fade-out-0 data-[state=open]:richtext-fade-in-0 data-[state=closed]:richtext-zoom-out-95 data-[state=open]:richtext-zoom-in-95 data-[side=bottom]:richtext-slide-in-from-top-2 data-[side=left]:richtext-slide-in-from-right-2 data-[side=right]:richtext-slide-in-from-left-2 data-[side=top]:richtext-slide-in-from-bottom-2",
      t
    ),
    ...r
  }
) }));
oo.displayName = Vp.Content.displayName;
const aa = Mt.forwardRef(
  ({ className: t, orientation: e = "horizontal", decorative: n = !0, ...r }, i) => /* @__PURE__ */ z(
    hF.Root,
    {
      ref: i,
      decorative: n,
      orientation: e,
      className: Ct(
        "richtext-shrink-0 richtext-bg-border",
        e === "horizontal" ? "richtext-h-[1px] richtext-w-full" : "richtext-h-full richtext-w-[1px]",
        t
      ),
      ...r
    }
  )
);
aa.displayName = hF.Root.displayName;
const BD = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  Z_.Root,
  {
    className: Ct(
      "richtext-peer richtext-inline-flex richtext-h-6 richtext-w-11 richtext-shrink-0 richtext-cursor-pointer richtext-items-center richtext-rounded-full richtext-border-2 richtext-border-transparent richtext-transition-colors focus-visible:richtext-outline-none focus-visible:richtext-ring-2 focus-visible:richtext-ring-ring focus-visible:richtext-ring-offset-2 focus-visible:richtext-ring-offset-background disabled:richtext-cursor-not-allowed disabled:richtext-opacity-50 data-[state=checked]:richtext-bg-primary data-[state=unchecked]:richtext-bg-input",
      t
    ),
    ...e,
    ref: n,
    children: /* @__PURE__ */ z(
      Z_.Thumb,
      {
        className: Ct(
          "richtext-pointer-events-none richtext-block richtext-h-5 richtext-w-5 richtext-rounded-full richtext-bg-background richtext-shadow-lg richtext-ring-0 richtext-transition-transform data-[state=checked]:richtext-translate-x-5 data-[state=unchecked]:richtext-translate-x-0"
        )
      }
    )
  }
));
BD.displayName = Z_.Root.displayName;
const LD = cu.Root, S1 = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  cu.List,
  {
    ref: n,
    className: Ct(
      "richtext-inline-flex richtext-h-10 richtext-items-center richtext-justify-center richtext-rounded-md richtext-bg-muted richtext-p-1 richtext-text-muted-foreground",
      t
    ),
    ...e
  }
));
S1.displayName = cu.List.displayName;
const Tf = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  cu.Trigger,
  {
    ref: n,
    className: Ct(
      "richtext-inline-flex richtext-items-center richtext-justify-center richtext-whitespace-nowrap richtext-rounded-sm richtext-px-3 richtext-py-1.5 richtext-text-sm richtext-font-medium richtext-ring-offset-background richtext-transition-all focus-visible:richtext-outline-none focus-visible:richtext-ring-2 focus-visible:richtext-ring-ring focus-visible:richtext-ring-offset-2 disabled:richtext-pointer-events-none disabled:richtext-opacity-50 data-[state=active]:richtext-bg-background data-[state=active]:richtext-text-foreground data-[state=active]:richtext-shadow-sm",
      t
    ),
    ...e
  }
));
Tf.displayName = cu.Trigger.displayName;
const Df = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  cu.Content,
  {
    ref: n,
    className: Ct(
      "richtext-mt-2 richtext-ring-offset-background focus-visible:richtext-outline-none focus-visible:richtext-ring-2 focus-visible:richtext-ring-ring focus-visible:richtext-ring-offset-2",
      t
    ),
    ...e
  }
));
Df.displayName = cu.Content.displayName;
const VJ = ki.Provider, s4 = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  ki.Viewport,
  {
    ref: n,
    className: Ct(
      "richtext-fixed richtext-top-0 richtext-z-[100] richtext-flex richtext-max-h-screen richtext-w-full richtext-flex-col-reverse richtext-p-4 sm:richtext-bottom-0 sm:richtext-right-0 sm:richtext-top-auto sm:richtext-flex-col md:richtext-max-w-[420px]",
      t
    ),
    ...e
  }
));
s4.displayName = ki.Viewport.displayName;
const qJ = x1(
  "richtext-group richtext-pointer-events-auto richtext-relative richtext-flex richtext-w-full richtext-items-center richtext-justify-between richtext-space-x-4 richtext-overflow-hidden richtext-rounded-md !richtext-border richtext-p-6 richtext-pr-8 richtext-shadow-lg richtext-transition-all data-[swipe=cancel]:richtext-translate-x-0 data-[swipe=end]:richtext-translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:richtext-translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:richtext-transition-none data-[state=open]:richtext-animate-in data-[state=closed]:richtext-animate-out data-[swipe=end]:richtext-animate-out data-[state=closed]:richtext-fade-out-80 data-[state=closed]:richtext-slide-out-to-right-full data-[state=open]:richtext-slide-in-from-top-full data-[state=open]:sm:richtext-slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "richtext-border richtext-bg-background richtext-text-foreground",
        destructive: "richtext-destructive richtext-group richtext-border-destructive richtext-bg-destructive richtext-text-destructive-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
), l4 = Mt.forwardRef(({ className: t, variant: e, ...n }, r) => /* @__PURE__ */ z(
  ki.Root,
  {
    ref: r,
    className: Ct(qJ({ variant: e }), t),
    ...n
  }
));
l4.displayName = ki.Root.displayName;
const GJ = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  ki.Action,
  {
    ref: n,
    className: Ct(
      "richtext-inline-flex richtext-h-8 richtext-shrink-0 richtext-items-center richtext-justify-center richtext-rounded-md !richtext-border richtext-bg-transparent richtext-px-3 richtext-text-sm richtext-font-medium richtext-ring-offset-background richtext-transition-colors hover:richtext-bg-secondary focus:richtext-outline-none focus:richtext-ring-2 focus:richtext-ring-ring focus:richtext-ring-offset-2 disabled:richtext-pointer-events-none disabled:richtext-opacity-50 group-[.destructive]:richtext-border-muted/40 group-[.destructive]:hover:richtext-border-destructive/30 group-[.destructive]:hover:richtext-bg-destructive group-[.destructive]:hover:richtext-text-destructive-foreground group-[.destructive]:focus:richtext-ring-destructive",
      t
    ),
    ...e
  }
));
GJ.displayName = ki.Action.displayName;
const c4 = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  ki.Close,
  {
    ref: n,
    className: Ct(
      "richtext-absolute richtext-right-2 richtext-top-2 richtext-rounded-md richtext-p-1 richtext-text-foreground/50 richtext-opacity-0 richtext-transition-opacity hover:richtext-text-foreground focus:richtext-opacity-100 focus:richtext-outline-none focus:richtext-ring-2 group-hover:richtext-opacity-100 group-[.destructive]:richtext-text-red-300 group-[.destructive]:hover:richtext-text-red-50 group-[.destructive]:focus:richtext-ring-red-400 group-[.destructive]:focus:richtext-ring-offset-red-600",
      t
    ),
    "toast-close": "",
    ...e,
    children: /* @__PURE__ */ z(sF, { className: "richtext-h-4 richtext-w-4" })
  }
));
c4.displayName = ki.Close.displayName;
const u4 = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  ki.Title,
  {
    ref: n,
    className: Ct("richtext-text-sm richtext-font-semibold", t),
    ...e
  }
));
u4.displayName = ki.Title.displayName;
const d4 = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  ki.Description,
  {
    ref: n,
    className: Ct("richtext-text-sm richtext-opacity-90", t),
    ...e
  }
));
d4.displayName = ki.Description.displayName;
const KJ = x1(
  "richtext-inline-flex richtext-items-center richtext-justify-center richtext-rounded-md richtext-text-sm richtext-font-medium richtext-ring-offset-background richtext-transition-colors hover:richtext-bg-muted hover:richtext-text-muted-foreground focus-visible:richtext-outline-none focus-visible:richtext-ring-2 focus-visible:richtext-ring-ring focus-visible:richtext-ring-offset-2 disabled:richtext-pointer-events-none disabled:richtext-opacity-50 data-[state=on]:richtext-bg-accent data-[state=on]:richtext-text-accent-foreground",
  {
    variants: {
      variant: {
        default: "richtext-bg-transparent",
        outline: "richtext-border richtext-border-input richtext-bg-transparent hover:richtext-bg-accent hover:richtext-text-accent-foreground"
      },
      size: {
        default: "richtext-h-10 richtext-px-3",
        sm: "richtext-h-9 richtext-px-2",
        lg: "richtext-h-11 richtext-px-5"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), zm = Mt.forwardRef(({ className: t, variant: e, size: n, ...r }, i) => /* @__PURE__ */ z(
  dF.Root,
  {
    ref: i,
    className: Ct(KJ({ variant: e, size: n, className: t })),
    ...r
  }
));
zm.displayName = dF.Root.displayName;
const XJ = Um.Provider, Kf = Um.Root, Xf = Um.Trigger, gu = Mt.forwardRef(({ className: t, sideOffset: e = 4, ...n }, r) => /* @__PURE__ */ z(
  Um.Content,
  {
    ref: r,
    sideOffset: e,
    className: Ct(
      "richtext-z-50 richtext-overflow-hidden richtext-rounded-md !richtext-border richtext-bg-popover richtext-px-3 richtext-py-1.5 richtext-text-sm richtext-text-popover-foreground richtext-shadow-md richtext-animate-in richtext-fade-in-0 richtext-zoom-in-95 data-[side=bottom]:richtext-slide-in-from-top-2 data-[side=left]:richtext-slide-in-from-right-2 data-[side=right]:richtext-slide-in-from-left-2 data-[side=top]:richtext-slide-in-from-bottom-2",
      t
    ),
    ...n
  }
));
gu.displayName = Um.Content.displayName;
const YJ = 1, JJ = 1e6;
let vx = 0;
function ZJ() {
  return vx = (vx + 1) % Number.MAX_SAFE_INTEGER, vx.toString();
}
const wx = /* @__PURE__ */ new Map();
function j3(t) {
  if (wx.has(t))
    return;
  const e = setTimeout(() => {
    wx.delete(t), Mp({
      type: "REMOVE_TOAST",
      toastId: t
    });
  }, JJ);
  wx.set(t, e);
}
function QJ(t, e) {
  switch (e.type) {
    case "ADD_TOAST":
      return {
        ...t,
        toasts: [e.toast, ...t.toasts].slice(0, YJ)
      };
    case "UPDATE_TOAST":
      return {
        ...t,
        toasts: t.toasts.map(
          (n) => n.id === e.toast.id ? { ...n, ...e.toast } : n
        )
      };
    case "DISMISS_TOAST": {
      const { toastId: n } = e;
      return n ? j3(n) : t.toasts.forEach((r) => {
        j3(r.id);
      }), {
        ...t,
        toasts: t.toasts.map(
          (r) => r.id === n || n === void 0 ? {
            ...r,
            open: !1
          } : r
        )
      };
    }
    case "REMOVE_TOAST":
      return e.toastId === void 0 ? {
        ...t,
        toasts: []
      } : {
        ...t,
        toasts: t.toasts.filter((n) => n.id !== e.toastId)
      };
  }
}
const Yy = [];
let Jy = { toasts: [] };
function Mp(t) {
  Jy = QJ(Jy, t), Yy.forEach((e) => {
    e(Jy);
  });
}
function eZ({ ...t }) {
  const e = ZJ(), n = (i) => Mp({
    type: "UPDATE_TOAST",
    toast: { ...i, id: e }
  }), r = () => Mp({ type: "DISMISS_TOAST", toastId: e });
  return Mp({
    type: "ADD_TOAST",
    toast: {
      ...t,
      id: e,
      open: !0,
      onOpenChange: (i) => {
        i || r();
      }
    }
  }), {
    id: e,
    dismiss: r,
    update: n
  };
}
function f4() {
  const [t, e] = Mt.useState(Jy);
  return Mt.useEffect(() => (Yy.push(e), () => {
    const n = Yy.indexOf(e);
    n > -1 && Yy.splice(n, 1);
  }), [t]), {
    ...t,
    toast: eZ,
    dismiss: (n) => Mp({ type: "DISMISS_TOAST", toastId: n })
  };
}
const h4 = Mt.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ z(
  Q_.Root,
  {
    ref: n,
    className: Ct(
      "!richtext-peer !richtext-h-4 !richtext-w-4 !richtext-p-0 !richtext-shrink-0 !richtext-rounded-sm !richtext-border !richtext-border-primary !richtext-ring-offset-background focus-visible:!richtext-outline-none focus-visible:!richtext-ring-2 focus-visible:!richtext-ring-ring focus-visible:!richtext-ring-offset-2 disabled:!richtext-cursor-not-allowed disabled:!richtext-opacity-50 data-[state=checked]:!richtext-bg-primary data-[state=checked]:!richtext-text-primary-foreground",
      t
    ),
    ...e,
    children: /* @__PURE__ */ z(
      Q_.Indicator,
      {
        className: Ct("!richtext-flex !richtext-p-0 !richtext-items-center !richtext-justify-center !richtext-text-current"),
        children: /* @__PURE__ */ z(lF, { className: "!richtext-h-4 !richtext-w-4" })
      }
    )
  }
));
h4.displayName = Q_.Root.displayName;
var _p, Zy, Bp;
function tZ() {
  for (; _p !== void 0; ) {
    const t = _p, e = t.nextNotify;
    e !== void 0 ? (t.nextNotify = void 0, _p = e) : (_p = void 0, Zy = void 0), t.notify();
  }
}
function p4(t, e) {
  const n = e.depsTail, r = n !== void 0 ? n.nextDep : e.deps;
  return r !== void 0 && r.dep === t ? (e.depsTail = r, r) : nZ(t, e, r, n);
}
function nZ(t, e, n, r) {
  let i;
  if (Bp !== void 0 ? (i = Bp, Bp = i.nextDep, i.nextDep = n, i.dep = t, i.sub = e) : i = {
    dep: t,
    sub: e,
    nextDep: n,
    prevSub: void 0,
    nextSub: void 0
  }, r === void 0 ? e.deps = i : r.nextDep = i, t.subs === void 0)
    t.subs = i;
  else {
    const o = t.subsTail;
    i.prevSub = o, o.nextSub = i;
  }
  return e.depsTail = i, t.subsTail = i, i;
}
function rZ(t) {
  let e = 16, n = t, r = 0, i;
  e: do {
    const o = n.sub, a = o.flags;
    if (a & 1) {
      if (iZ(n, o))
        if (a & 28)
          a & e || (o.flags = a | e);
        else {
          o.flags = a | e | 2;
          const s = o.subs;
          if (s !== void 0) {
            s.nextSub !== void 0 ? (s.prevSub = t, n = t = s, e = 8, ++r) : (n = s, e = "notify" in o ? 4 : 8);
            continue;
          }
        }
    } else if (!(a & 28) && (o.flags = a | e, !0) || a & 2 && (o.flags = a & -3 | e, !0)) {
      const s = o.subs;
      if (s !== void 0) {
        s.nextSub !== void 0 ? (s.prevSub = t, n = t = s, e = 8, ++r) : (n = s, e = "notify" in o ? 4 : 8);
        continue;
      }
      "notify" in o && (Zy !== void 0 ? Zy.nextNotify = o : _p = o, Zy = o);
    } else a & e || (o.flags = a | e);
    if ((i = t.nextSub) === void 0) {
      if (r) {
        let s = t.dep;
        do {
          --r;
          const l = s.subs, c = l.prevSub;
          if (l.prevSub = void 0, n = t = c.nextSub, t !== void 0) {
            e = r ? 8 : 16;
            continue e;
          }
          s = c.dep;
        } while (r);
      }
      break;
    }
    n !== t && (e = r ? 8 : 16), n = t = i;
  } while (!0);
  tZ();
}
function V3(t) {
  do {
    const e = t.sub, n = e.flags;
    (n & 24) === 8 && (e.flags = n | 16), t = t.nextSub;
  } while (t !== void 0);
}
function iZ(t, e) {
  const n = e.depsTail;
  if (n !== void 0) {
    let r = e.deps;
    do {
      if (r === t)
        return !0;
      if (r === n)
        break;
      r = r.nextDep;
    } while (r !== void 0);
  }
  return !1;
}
function oZ(t) {
  let e = 0, n, r;
  e: do {
    n = !1;
    const i = t.dep;
    if ("update" in i) {
      const o = i.flags;
      if (o & 16) {
        if (i.update()) {
          const a = i.subs;
          a.nextSub !== void 0 && V3(a), n = !0;
        }
      } else if (o & 8) {
        const a = i.subs;
        a.nextSub !== void 0 && (a.prevSub = t), t = i.deps, ++e;
        continue;
      }
    }
    if (n || (r = t.nextDep) === void 0) {
      if (e) {
        let o = t.sub;
        do {
          --e;
          const a = o.subs;
          let s = a.prevSub;
          if (s !== void 0)
            if (a.prevSub = void 0, n) {
              if (o.update()) {
                V3(o.subs), o = s.sub;
                continue;
              }
            } else
              o.flags &= -9;
          else {
            if (n) {
              if (o.update()) {
                o = a.sub;
                continue;
              }
            } else
              o.flags &= -9;
            s = a;
          }
          if (t = s.nextDep, t !== void 0)
            continue e;
          o = s.sub, n = !1;
        } while (e);
      }
      return n;
    }
    t = r;
  } while (!0);
}
function q3(t) {
  t.depsTail = void 0, t.flags = 1;
}
function G3(t) {
  const e = t.depsTail;
  e !== void 0 ? e.nextDep !== void 0 && (K3(e.nextDep), e.nextDep = void 0) : t.deps !== void 0 && (K3(t.deps), t.deps = void 0), t.flags &= -2;
}
function K3(t) {
  do {
    const e = t.dep, n = t.nextDep, r = t.nextSub, i = t.prevSub;
    if (r !== void 0 ? (r.prevSub = i, t.nextSub = void 0) : (e.subsTail = i, "lastTrackedId" in e && (e.lastTrackedId = 0)), i !== void 0 ? (i.nextSub = r, t.prevSub = void 0) : e.subs = r, t.dep = void 0, t.sub = void 0, t.nextDep = Bp, Bp = t, e.subs === void 0 && "deps" in e) {
      if ("notify" in e)
        e.flags = 0;
      else {
        const a = e.flags;
        a & 16 || (e.flags = a | 16);
      }
      const o = e.deps;
      if (o !== void 0) {
        t = o, e.depsTail.nextDep = n, e.deps = void 0, e.depsTail = void 0;
        continue;
      }
    }
    t = n;
  } while (t !== void 0);
}
var Wb, af = 0, aZ = 0;
function X3(t, e) {
  Wb = t, af = e;
}
function sZ() {
  return ++aZ;
}
function m4(t) {
  const e = new lZ(t);
  return e.run(), e;
}
var lZ = class {
  constructor(t) {
    this.fn = t, this.nextNotify = void 0, this.subs = void 0, this.subsTail = void 0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, af && p4(this, Wb);
  }
  notify() {
    let t = this.flags;
    if (t & 16) {
      this.run();
      return;
    }
    if (t & 8)
      if (oZ(this.deps)) {
        this.run();
        return;
      } else
        this.flags = t &= -9;
    if (t & 4) {
      this.flags = t & -5;
      let e = this.deps;
      do {
        const n = e.dep;
        "notify" in n && n.notify(), e = e.nextDep;
      } while (e !== void 0);
    }
  }
  run() {
    const t = Wb, e = af;
    X3(this, sZ()), q3(this);
    try {
      return this.fn();
    } finally {
      X3(t, e), G3(this);
    }
  }
  stop() {
    q3(this), G3(this);
  }
};
function cZ(t) {
  return new uZ(t);
}
var uZ = class {
  constructor(t) {
    this.currentValue = t, this.subs = void 0, this.subsTail = void 0, this.lastTrackedId = 0;
  }
  get() {
    return af && this.lastTrackedId !== af && (this.lastTrackedId = af, p4(this, Wb)), this.currentValue;
  }
  set(t) {
    if (this.currentValue !== (this.currentValue = t)) {
      const e = this.subs;
      e !== void 0 && rZ(e);
    }
  }
};
function $m(t) {
  return cZ(t);
}
function dZ(t) {
  return [aF((e) => {
    let n = m4(() => {
      t.get(), e();
    });
    return () => n.stop();
  }, () => t.get(), () => t.get()), (e) => {
    typeof e == "function" ? t.set(e(t.get())) : t.set(e);
  }];
}
function PD(t) {
  return aF((e) => {
    let n = m4(() => {
      t.get(), e();
    });
    return () => n.stop();
  }, () => t.get(), () => t.get());
}
const fZ = {
  "editor.remove": "Remove",
  "editor.copy": "Copy",
  "editor.words": "WORDS",
  "editor.characters": "CHARACTERS",
  "editor.default": "Default",
  "editor.recent": "Recently Used",
  "editor.nofill": "No Fill",
  "editor.format": "Format Painter",
  "editor.delete": "Delete",
  "editor.edit": "Edit",
  "editor.settings": "Settings",
  "editor.table_of_content": "Table of Content",
  "editor.draghandle.tooltip": "Modify",
  "editor.copyToClipboard": "CopyToClipboard",
  "editor.slash": "Press '/' for commands",
  "editor.slash.empty": "No Result",
  "editor.slash.format": "Format",
  "editor.slash.insert": "Insert",
  "editor.slash.embed": "Embed Services",
  "editor.content": "Please input content",
  "editor.fontFamily.tooltip": "Font Family",
  "editor.fontFamily.default.tooltip": "Default",
  "editor.moremark": "More Text Styles",
  "editor.size.small.tooltip": "Small",
  "editor.size.medium.tooltip": "Medium",
  "editor.size.large.tooltip": "Cover",
  "editor.bold.tooltip": "Bold",
  "editor.italic.tooltip": "Italic",
  "editor.underline.tooltip": "Underline",
  "editor.strike.tooltip": "Strike",
  "editor.color.tooltip": "Color",
  "editor.color.more": "More Colors",
  "editor.highlight.tooltip": "Highlight",
  "editor.lineheight.tooltip": "Line Height",
  "editor.heading.tooltip": "Headings",
  "editor.heading.h1.tooltip": "Heading 1",
  "editor.heading.h2.tooltip": "Heading 2",
  "editor.heading.h3.tooltip": "Heading 3",
  "editor.heading.h4.tooltip": "Heading 4",
  "editor.heading.h5.tooltip": "Heading 5",
  "editor.heading.h6.tooltip": "Heading 6",
  "editor.paragraph.tooltip": "Paragraph",
  "editor.textalign.tooltip": "Align",
  "editor.textalign.left.tooltip": "Left",
  "editor.textalign.center.tooltip": "Center",
  "editor.textalign.right.tooltip": "Right",
  "editor.textalign.justify.tooltip": "Justify",
  "editor.indent": "Indent",
  "editor.indent.indent": "Increase Indent",
  "editor.indent.outdent": "Decrease Indent",
  "editor.fontSize.tooltip": "Font size",
  "editor.fontSize.default.tooltip": "Default",
  "editor.superscript.tooltip": "Superscript",
  "editor.subscript.tooltip": "Subscript",
  "editor.bulletlist.tooltip": "Bullet List",
  "editor.orderedlist.tooltip": "Ordered List",
  "editor.tasklist.tooltip": "Task List",
  "editor.indent.tooltip": "Indent",
  "editor.outdent.tooltip": "Outdent",
  "editor.columns.tooltip": "Columns",
  "editor.link.tooltip": "Link",
  "editor.link.unlink.tooltip": "UnLink",
  "editor.link.open.tooltip": "Open Link",
  "editor.link.edit.tooltip": "Edit Link",
  "editor.link.dialog.title": "Insert Link",
  "editor.link.dialog.link": "Link",
  "editor.link.dialog.text": "Text",
  "editor.link.dialog.openInNewTab": "Open In New Tab",
  "editor.link.dialog.link.placeholder": "Link Address",
  "editor.link.dialog.text.placeholder": "Add Description",
  "editor.link.dialog.button.apply": "Apply",
  "editor.image.tooltip": "Image",
  "editor.image.dragger.tooltip": "Click or drag the image to the area to upload",
  "editor.image.float.left.tooltip": "Float left",
  "editor.image.float.none.tooltip": "Float none",
  "editor.image.float.right.tooltip": "Float right",
  "editor.image.dialog.title": "Add an image",
  "editor.image.dialog.tab.url": "Url",
  "editor.image.dialog.tab.upload": "Upload",
  "editor.image.dialog.tab.uploadCrop": "Upload & Crop",
  "editor.image.dialog.uploading": "Uploading",
  "editor.link.dialog.inline": "Inline",
  "editor.image.dialog.form.link": "Link",
  "editor.image.dialog.placeholder": "Link",
  "editor.image.dialog.form.alt": "Alt",
  "editor.image.dialog.form.aspectRatio": "Lock original aspect ratio",
  "editor.image.dialog.form.file": "File",
  "editor.image.dialog.button.apply": "Apply",
  "editor.video.tooltip": "Video",
  "editor.video.dialog.tab.upload": "Upload",
  "editor.video.dialog.uploading": "Uploading",
  "editor.video.dialog.title": "Embed or upload a video",
  "editor.video.dialog.link": "Link",
  "editor.video.dialog.placeholder": "Link",
  "editor.video.dialog.button.apply": "Apply",
  "editor.table.tooltip": "Table",
  "editor.table.menu.insert_table": "Insert Table",
  "editor.table.menu.insert_table.with_header_row": "With header row",
  "editor.table.menu.add_column_before": "Add Column Before",
  "editor.table.menu.add_column_after": "Add Column After",
  "editor.table.menu.delete_column": "Delete Column",
  "editor.table.menu.add_row_before": "Add Row Before",
  "editor.table.menu.add_row_after": "Add Row After",
  "editor.table.menu.delete_row": "Delete Row",
  "editor.table.menu.merge_or_split_cells": "Merge Or Split Cells",
  "editor.table.menu.delete_table": "Delete Table",
  "editor.blockquote.tooltip": "Blockquote",
  "editor.horizontalrule.tooltip": "Horizontal Rule",
  "editor.code.tooltip": "Code",
  "editor.clear.tooltip": "Clear Format",
  "editor.undo.tooltip": "Undo",
  "editor.redo.tooltip": "Redo",
  "editor.fullscreen.tooltip.fullscreen": "Fullscreen",
  "editor.fullscreen.tooltip.exit": "Fullscreen Exit",
  "editor.imageUpload.cancel": "Cancel",
  "editor.imageUpload.crop": "Crop",
  "editor.imageUpload.fileTypeNotSupported": "File type not supported",
  "editor.imageUpload.fileSizeTooBig": "File size too big, Maximum size is",
  "editor.table.menu.insertColumnBefore": "Insert Column Before",
  "editor.table.menu.insertColumnAfter": "Insert Column After",
  "editor.table.menu.deleteColumn": "Delete Column",
  "editor.table.menu.insertRowAbove": "Insert Row Above",
  "editor.table.menu.insertRowBelow": "Insert Row Below",
  "editor.table.menu.deleteRow": "Delete Row",
  "editor.table.menu.mergeCells": "Merge Cells",
  "editor.table.menu.splitCells": "Split Cells",
  "editor.table.menu.deleteTable": "Delete Table",
  "editor.table.menu.setCellsBgColor": "Cell Background Color",
  "editor.emoji.tooltip": "Emoji",
  "editor.iframe.tooltip": "Iframe",
  "editor.searchAndReplace.tooltip": "Search and Replace",
  "editor.search.dialog.text": "Search",
  "editor.replace.dialog.text": "Replace",
  "editor.replaceAll.dialog.text": "Replace All",
  "editor.previous.dialog.text": "Previous",
  "editor.next.dialog.text": "Next",
  no_result_found: "No results found",
  "Smileys & People": "Smileys & People",
  "Animals & Nature": "Animals & Nature",
  "Food & Drink": "Food & Drink",
  Activity: "Activity",
  "Travel & Places": "Travel & Places",
  Object: "Objects",
  Symbol: "Symbols",
  Flags: "Flags",
  "Frequently used": "Frequently used",
  "editor.formula.dialog.text": "Formula",
  "editor.exportPdf.tooltip": "Export PDF",
  "editor.exportWord.tooltip": "Export Word",
  "editor.importWord.tooltip": "Import Word",
  "editor.importWord.limitSize": "File size cannot exceed",
  "editor.importWord.converting": "Converting Word document, please wait...",
  "editor.importWord.convertError": "Error parsing Word document",
  "editor.importWord.importError": "Error importing Word document",
  "editor.textDirection.tooltip": "Text Direction",
  "editor.textDirection.auto.tooltip": "Auto",
  "editor.textDirection.ltr.tooltip": "Left to Right",
  "editor.textDirection.rtl.tooltip": "Right to Left",
  "editor.attachment.tooltip": "Attachment",
  "editor.attachment.uploading": "Uploading",
  "editor.attachment.please_upload": "Please upload the file",
  "editor.imageGif.tooltip": "Gif",
  "editor.replace.caseSensitive": "Case Sensitive",
  "editor.twitter.tooltip": "Twitter",
  "editor.tooltip.flipX": "Flip Horizontal",
  "editor.tooltip.flipY": "Flip Vertical"
}, hZ = fZ, pZ = {
  "editor.remove": "Remover",
  "editor.copy": "Copiar",
  "editor.words": "PALAVRAS",
  "editor.characters": "CARACTERES",
  "editor.default": "Padrão",
  "editor.recent": "Usado recentemente",
  "editor.nofill": "Sem preenchimento",
  "editor.format": "Format Painter",
  "editor.delete": "Deletar",
  "editor.edit": "Editar",
  "editor.settings": "Configurações",
  "editor.table_of_content": "Tabela de conteúdos",
  "editor.draghandle.tooltip": "Modificar",
  "editor.copyToClipboard": "Copiar para a área de transferência",
  "editor.slash": "Pressione '/' para comandos",
  "editor.slash.empty": "Nenhum resultado",
  "editor.slash.format": "Formato",
  "editor.slash.insert": "Inserir",
  "editor.slash.embed": "Incorporar serviços",
  "editor.content": "Por favor, insira o conteúdo",
  "editor.fontFamily.tooltip": "Fonte",
  "editor.fontFamily.default.tooltip": "Padrão",
  "editor.moremark": "Mais estilos de texto",
  "editor.size.small.tooltip": "Pequeno",
  "editor.size.medium.tooltip": "Médio",
  "editor.size.large.tooltip": "Grande",
  "editor.bold.tooltip": "Negrito",
  "editor.italic.tooltip": "Itálico",
  "editor.underline.tooltip": "Sublinhado",
  "editor.strike.tooltip": "Riscado",
  "editor.color.tooltip": "Cor",
  "editor.color.more": "Mais cores",
  "editor.highlight.tooltip": "Destaque",
  "editor.lineheight.tooltip": "Altura da linha",
  "editor.heading.tooltip": "Cabeçalhos",
  "editor.heading.h1.tooltip": "Cabeçalho 1",
  "editor.heading.h2.tooltip": "Cabeçalho 2",
  "editor.heading.h3.tooltip": "Cabeçalho 3",
  "editor.heading.h4.tooltip": "Cabeçalho 4",
  "editor.heading.h5.tooltip": "Cabeçalho 5",
  "editor.heading.h6.tooltip": "Cabeçalho 6",
  "editor.paragraph.tooltip": "Parágrafo",
  "editor.textalign.tooltip": "Alinhar",
  "editor.textalign.left.tooltip": "Esquerda",
  "editor.textalign.center.tooltip": "Centro",
  "editor.textalign.right.tooltip": "Direita",
  "editor.textalign.justify.tooltip": "Justificar",
  "editor.indent": "Recuo",
  "editor.indent.indent": "Aumentar recuo",
  "editor.indent.outdent": "Diminuir recuo",
  "editor.fontSize.tooltip": "Tamanho da fonte",
  "editor.fontSize.default.tooltip": "Padrão",
  "editor.superscript.tooltip": "Sobrescrito",
  "editor.subscript.tooltip": "Subscrito",
  "editor.bulletlist.tooltip": "Lista de marcadores",
  "editor.orderedlist.tooltip": "Lista numerada",
  "editor.tasklist.tooltip": "Lista de tarefas",
  "editor.indent.tooltip": "Recuo",
  "editor.outdent.tooltip": "Diminuir recuo",
  "editor.columns.tooltip": "Colunas",
  "editor.link.tooltip": "Link",
  "editor.link.unlink.tooltip": "Desvincular",
  "editor.link.open.tooltip": "Abrir link",
  "editor.link.edit.tooltip": "Editar link",
  "editor.link.dialog.title": "Inserir link",
  "editor.link.dialog.link": "Link",
  "editor.link.dialog.text": "Texto",
  "editor.link.dialog.openInNewTab": "Abrir em nova guia",
  "editor.link.dialog.link.placeholder": "Endereço do link",
  "editor.link.dialog.text.placeholder": "Texto do link",
  "editor.link.dialog.button.apply": "Aplicar",
  "editor.image.tooltip": "Imagem",
  "editor.image.dragger.tooltip": "Clique ou arraste a imagem para a área de upload",
  "editor.image.float.left.tooltip": "Flutuar à esquerda",
  "editor.image.float.none.tooltip": "Nenhum flutuante",
  "editor.image.float.right.tooltip": "Flutuar à direita",
  "editor.image.dialog.title": "Adicionar uma imagem",
  "editor.image.dialog.tab.url": "Url",
  "editor.image.dialog.tab.upload": "Enviar",
  "editor.link.dialog.inline": "Inline",
  "editor.image.dialog.tab.uploadCrop": "Enviar e cortar",
  "editor.image.dialog.uploading": "Enviando",
  "editor.image.dialog.form.link": "Link",
  "editor.image.dialog.placeholder": "Link",
  "editor.image.dialog.form.alt": "Alt",
  "editor.image.dialog.form.aspectRatio": "Bloquear proporção original",
  "editor.image.dialog.form.file": "Arquivo",
  "editor.image.dialog.button.apply": "Aplicar",
  "editor.video.tooltip": "Vídeo",
  "editor.video.dialog.tab.upload": "Enviar",
  "editor.video.dialog.uploading": "Enviando",
  "editor.video.dialog.title": "Incorporar ou enviar um vídeo",
  "editor.video.dialog.link": "Link",
  "editor.video.dialog.placeholder": "Link",
  "editor.video.dialog.button.apply": "Aplicar",
  "editor.table.tooltip": "Tabela",
  "editor.table.menu.insert_table": "Inserir tabela",
  "editor.table.menu.insert_table.with_header_row": "Com linha de cabeçalho",
  "editor.table.menu.add_column_before": "Adicionar coluna antes",
  "editor.table.menu.add_column_after": "Adicionar coluna depois",
  "editor.table.menu.delete_column": "Excluir coluna",
  "editor.table.menu.add_row_before": "Adicionar linha antes",
  "editor.table.menu.add_row_after": "Adicionar linha depois",
  "editor.table.menu.delete_row": "Deletar linha",
  "editor.table.menu.merge_or_split_cells": "Mesclar ou dividir células",
  "editor.table.menu.delete_table": "Deletar tabela",
  "editor.blockquote.tooltip": "Citação",
  "editor.horizontalrule.tooltip": "Regra horizontal",
  "editor.code.tooltip": "Código",
  "editor.clear.tooltip": "Limpar formato",
  "editor.undo.tooltip": "Desfazer",
  "editor.redo.tooltip": "Refazer",
  "editor.fullscreen.tooltip.fullscreen": "Tela cheia",
  "editor.fullscreen.tooltip.exit": "Sair da tela cheia",
  "editor.imageUpload.cancel": "Cancelar",
  "editor.imageUpload.crop": "Cortar",
  "editor.imageUpload.fileTypeNotSupported": "Tipo de arquivo não suportado",
  "editor.imageUpload.fileSizeTooBig": "Tamanho do arquivo muito grande, tamanho máximo é",
  "editor.table.menu.insertColumnBefore": "Inserir coluna antes",
  "editor.table.menu.insertColumnAfter": "Inserir coluna depois",
  "editor.table.menu.deleteColumn": "Excluir coluna",
  "editor.table.menu.insertRowAbove": "Inserir linha acima",
  "editor.table.menu.insertRowBelow": "Inserir linha abaixo",
  "editor.table.menu.deleteRow": "Deletar linha",
  "editor.table.menu.mergeCells": "Mesclar células",
  "editor.table.menu.splitCells": "Dividir células",
  "editor.table.menu.deleteTable": "Deletar tabela",
  "editor.table.menu.setCellsBgColor": "Cor de fundo da célula",
  "editor.emoji.tooltip": "Emoji",
  "editor.iframe.tooltip": "Iframe",
  "editor.searchAndReplace.tooltip": "Pesquisar e substituir",
  "editor.search.dialog.text": "Pesquisar",
  "editor.replace.dialog.text": "Substituir",
  "editor.replaceAll.dialog.text": "Substituir tudo",
  "editor.previous.dialog.text": "Anterior",
  "editor.next.dialog.text": "Próximo",
  no_result_found: "Nenhum resultado encontrado",
  "Smileys & People": "Emoticons & Pessoas",
  "Animals & Nature": "Animais & Natureza",
  "Food & Drink": "Comida & Bebida",
  Activity: "Atividade",
  "Travel & Places": "Viagem & Lugares",
  Object: "Objetos",
  Symbol: "Símbolos",
  Flags: "Bandeiras",
  "Frequently used": "Frequentemente usado",
  "editor.formula.dialog.text": "Fórmula",
  "editor.exportPdf.tooltip": "Exportar PDF",
  "editor.exportWord.tooltip": "Exportar Word",
  "editor.importWord.tooltip": "Importar Word",
  "editor.importWord.limitSize": "O tamanho do arquivo não pode exceder",
  "editor.importWord.converting": "Convertendo documento do Word, aguarde...",
  "editor.importWord.convertError": "Erro ao analisar documento do Word",
  "editor.importWord.importError": "Erro ao importar documento do Word",
  "editor.textDirection.tooltip": "Direção do texto",
  "editor.textDirection.auto.tooltip": "Automático",
  "editor.textDirection.ltr.tooltip": "Esquerda para Direita",
  "editor.textDirection.rtl.tooltip": "Direita para Esquerda",
  "editor.attachment.tooltip": "Anexo",
  "editor.attachment.uploading": "Enviando",
  "editor.attachment.please_upload": "Por favor, envie o arquivo",
  "editor.imageGif.tooltip": "Gif",
  "editor.replace.caseSensitive": "Sensível a maiúsculas e minúsculas",
  "editor.twitter.tooltip": "Twitter",
  "editor.tooltip.flipX": "Inverter Horizontal",
  "editor.tooltip.flipY": "Inverter Vertical"
}, mZ = pZ, gZ = {
  "editor.remove": "Xóa",
  "editor.copy": "Sao chép",
  "editor.words": "TỪ",
  "editor.characters": "KÝ TỰ",
  "editor.default": "Mặc định",
  "editor.recent": "Đã sử dụng gần đây",
  "editor.nofill": "Không tô",
  "editor.format": "Format Painter",
  "editor.delete": "Xóa",
  "editor.edit": "Chỉnh sửa",
  "editor.settings": "Cài đặt",
  "editor.table_of_content": "Mục lục",
  "editor.draghandle.tooltip": "Sửa đổi",
  "editor.copyToClipboard": "CopyToClipboard",
  "editor.slash": "Nhấn '/' để biết lệnh",
  "editor.slash.empty": "Không có kết quả",
  "editor.slash.format": "Định dạng",
  "editor.slash.insert": "Chèn",
  "editor.slash.embed": "Dịch vụ nhúng",
  "editor.content": "Vui lòng nhập nội dung",
  "editor.moremark": "Nhiều kiểu văn bản hơn",
  "editor.size.small.tooltip": "Nhỏ",
  "editor.fontFamily.tooltip": "Phông chữ",
  "editor.fontFamily.default.tooltip": "Mặc định",
  "editor.size.medium.tooltip": "Trung bình",
  "editor.size.large.tooltip": "Lớn",
  "editor.bold.tooltip": "Đậm",
  "editor.italic.tooltip": "In nghiêng",
  "editor.underline.tooltip": "Gạch chân",
  "editor.strike.tooltip": "Gạch",
  "editor.color.tooltip": "Màu",
  "editor.color.more": "Nhiều màu hơn",
  "editor.highlight.tooltip": "Đánh dấu",
  "editor.lineheight.tooltip": "Chiều cao dòng",
  "editor.heading.tooltip": "Tiêu đề",
  "editor.heading.h1.tooltip": "Tiêu đề 1",
  "editor.heading.h2.tooltip": "Tiêu đề 2",
  "editor.heading.h3.tooltip": "Tiêu đề 3",
  "editor.heading.h4.tooltip": "Tiêu đề 4",
  "editor.heading.h5.tooltip": "Tiêu đề 5",
  "editor.heading.h6.tooltip": "Tiêu đề 6",
  "editor.paragraph.tooltip": "Đoạn văn",
  "editor.textalign.tooltip": "Căn chỉnh",
  "editor.textalign.left.tooltip": "Trái",
  "editor.textalign.center.tooltip": "Giữa",
  "editor.textalign.right.tooltip": "Phải",
  "editor.textalign.justify.tooltip": "Căn đều",
  "editor.indent": "Thụt lề",
  "editor.indent.indent": "Tăng thụt lề",
  "editor.indent.outdent": "Giảm thụt lề",
  "editor.fontSize.tooltip": "Kích thước phông chữ",
  "editor.fontSize.default.tooltip": "Mặc định",
  "editor.superscript.tooltip": "Chỉ số trên",
  "editor.subscript.tooltip": "Chỉ số dưới",
  "editor.bulletlist.tooltip": "Danh sách dấu đầu dòng",
  "editor.orderedlist.tooltip": "Danh sách có thứ tự",
  "editor.tasklist.tooltip": "Danh sách tác vụ",
  "editor.indent.tooltip": "Tăng thụt lề",
  "editor.outdent.tooltip": "Giảm thụt lề",
  "editor.columns.tooltip": "Cột",
  "editor.link.tooltip": "Liên kết",
  "editor.link.unlink.tooltip": "Hủy liên kết",
  "editor.link.open.tooltip": "Mở liên kết",
  "editor.link.edit.tooltip": "Chỉnh sửa liên kết",
  "editor.link.dialog.title": "Chèn liên kết",
  "editor.link.dialog.link": "Liên kết",
  "editor.link.dialog.text": "Văn bản",
  "editor.link.dialog.openInNewTab": "Mở trong tab mới",
  "editor.link.dialog.link.placeholder": "Địa chỉ liên kết",
  "editor.link.dialog.text.placeholder": "Thêm mô tả",
  "editor.link.dialog.button.apply": "Áp dụng",
  "editor.image.tooltip": "Hình ảnh",
  "editor.image.dragger.tooltip": "Nhấp hoặc kéo hình ảnh đến khu vực để tải lên",
  "editor.image.float.left.tooltip": "Trôi sang trái",
  "editor.image.float.none.tooltip": "Trôi không",
  "editor.image.float.right.tooltip": "Trôi sang phải",
  "editor.image.dialog.title": "Thêm hình ảnh",
  "editor.image.dialog.tab.url": "Url",
  "editor.image.dialog.tab.upload": "Tải lên",
  "editor.link.dialog.inline": "Inline",
  "editor.image.dialog.tab.uploadCrop": "Tải lên & Cắt",
  "editor.image.dialog.uploading": "Đang tải lên",
  "editor.image.dialog.form.link": "Liên kết",
  "editor.image.dialog.placeholder": "Liên kết",
  "editor.image.dialog.form.alt": "Alt",
  "editor.image.dialog.form.aspectRatio": "Khóa tỷ lệ khung hình gốc",
  "editor.image.dialog.form.file": "Tệp",
  "editor.image.dialog.button.apply": "Áp dụng",
  "editor.video.tooltip": "Video",
  "editor.video.dialog.tab.upload": "Tải lên",
  "editor.video.dialog.uploading": "Đang tải lên",
  "editor.video.dialog.title": "Nhúng hoặc tải lên video",
  "editor.video.dialog.link": "Liên kết",
  "editor.video.dialog.placeholder": "Liên kết",
  "editor.video.dialog.button.apply": "Áp dụng",
  "editor.table.tooltip": "Bảng",
  "editor.table.menu.insert_table": "Chèn Bảng",
  "editor.table.menu.insert_table.with_header_row": "Có hàng tiêu đề",
  "editor.table.menu.add_column_before": "Thêm Cột Trước",
  "editor.table.menu.add_column_after": "Thêm Cột Sau",
  "editor.table.menu.delete_column": "Xóa Cột",
  "editor.table.menu.add_row_before": "Thêm Hàng Trước",
  "editor.table.menu.add_row_after": "Thêm Hàng Sau",
  "editor.table.menu.delete_row": "Xóa Hàng",
  "editor.table.menu.merge_or_split_cells": "Gộp Hoặc Tách Ô",
  "editor.table.menu.delete_table": "Xóa Bảng",
  "editor.blockquote.tooltip": "Blockquote",
  "editor.horizontalrule.tooltip": "Quy tắc ngang",
  "editor.code.tooltip": "Mã",
  "editor.clear.tooltip": "Xóa định dạng",
  "editor.undo.tooltip": "Hoàn tác",
  "editor.redo.tooltip": "Làm lại",
  "editor.fullscreen.tooltip.fullscreen": "Toàn màn hình",
  "editor.fullscreen.tooltip.exit": "Thoát toàn màn hình",
  "editor.imageUpload.cancel": "Hủy",
  "editor.imageUpload.crop": "Cắt",
  "editor.imageUpload.fileTypeNotSupported": "Loại tệp không được hỗ trợ",
  "editor.imageUpload.fileSizeTooBig": "Kích thước tệp quá lớn, Kích thước tối đa là",
  "editor.table.menu.insertColumnBefore": "Chèn cột trước",
  "editor.table.menu.insertColumnAfter": "Chèn cột sau",
  "editor.table.menu.deleteColumn": "Xóa cột",
  "editor.table.menu.insertRowAbove": "Chèn hàng ở trên",
  "editor.table.menu.insertRowBelow": "Chèn hàng ở dưới",
  "editor.table.menu.deleteRow": "Xóa hàng",
  "editor.table.menu.mergeCells": "Gộp các ô",
  "editor.table.menu.splitCells": "Chia ô",
  "editor.table.menu.deleteTable": "Xóa bảng",
  "editor.table.menu.setCellsBgColor": "Màu nền ô",
  "editor.emoji.tooltip": "Biểu tượng",
  "editor.iframe.tooltip": "Iframe",
  "editor.searchAndReplace.tooltip": "Tìm kiếm và thay thế",
  "editor.search.dialog.text": "Tìm kiếm",
  "editor.replace.dialog.text": "Thay thế",
  "editor.replaceAll.dialog.text": "Thay thế tất cả",
  "editor.previous.dialog.text": "Trước",
  "editor.next.dialog.text": "Tiếp theo",
  no_result_found: "Không tìm thấy kết quả",
  "Smileys & People": "Cười & Mọi người",
  "Animals & Nature": "Động vật & Thiên nhiên",
  "Food & Drink": "Thức ăn & Đồ uống",
  Activity: "Hoạt động",
  "Travel & Places": "Du lịch & Địa điểm",
  Object: "Vật",
  Symbol: "Ký hiệu",
  Flags: "Cờ",
  "Frequently used": "Thường xuyên sử dụng",
  "editor.formula.dialog.text": "Công thức",
  "editor.exportPdf.tooltip": "Xuất PDF",
  "editor.exportWord.tooltip": "Xuất Word",
  "editor.importWord.tooltip": "Nhập Word",
  "editor.importWord.limitSize": "Kích thước tệp không được vượt quá",
  "editor.importWord.converting": "Đang chuyển đổi tài liệu Word, vui lòng đợi...",
  "editor.importWord.convertError": "Lỗi khi phân tích tài liệu Word",
  "editor.importWord.importError": "Lỗi khi nhập tài liệu Word",
  "editor.textDirection.tooltip": "Hướng văn bản",
  "editor.textDirection.auto.tooltip": "Tự động",
  "editor.textDirection.ltr.tooltip": "Trái sang Phải",
  "editor.textDirection.rtl.tooltip": "Phải sang Trái",
  "editor.attachment.tooltip": "Đính kèm",
  "editor.attachment.uploading": "Đang tải lên",
  "editor.attachment.please_upload": "Vui lòng tải lên tệp",
  "editor.imageGif.tooltip": "Gif",
  "editor.replace.caseSensitive": "Phân biệt chữ hoa chữ thường",
  "editor.twitter.tooltip": "Twitter",
  "editor.tooltip.flipX": "Lật Ngang",
  "editor.tooltip.flipY": "Lật Dọc"
}, yZ = gZ, bZ = {
  "editor.remove": "移除",
  "editor.copy": "复制",
  "editor.words": "字数",
  "editor.characters": "字符数",
  "editor.default": "默认",
  "editor.recent": "最近使用",
  "editor.nofill": "无填充",
  "editor.format": "格式刷",
  "editor.delete": "删除",
  "editor.edit": "编辑",
  "editor.settings": "设置",
  "editor.table_of_content": "目录",
  "editor.draghandle.tooltip": "修改",
  "editor.copyToClipboard": "复制到剪贴板",
  "editor.slash": "按 '/' 使用命令",
  "editor.slash.empty": "无结果",
  "editor.slash.format": "格式",
  "editor.slash.insert": "插入",
  "editor.slash.embed": "嵌入服务",
  "editor.content": "请输入内容",
  "editor.fontFamily.tooltip": "字体",
  "editor.fontFamily.default.tooltip": "默认",
  "editor.moremark": "更多文本样式",
  "editor.size.small.tooltip": "小",
  "editor.size.medium.tooltip": "中",
  "editor.size.large.tooltip": "封面",
  "editor.bold.tooltip": "粗体",
  "editor.italic.tooltip": "斜体",
  "editor.underline.tooltip": "下划线",
  "editor.strike.tooltip": "删除线",
  "editor.color.tooltip": "颜色",
  "editor.color.more": "更多颜色",
  "editor.highlight.tooltip": "高亮",
  "editor.lineheight.tooltip": "行高",
  "editor.heading.tooltip": "标题",
  "editor.heading.h1.tooltip": "标题 1",
  "editor.heading.h2.tooltip": "标题 2",
  "editor.heading.h3.tooltip": "标题 3",
  "editor.heading.h4.tooltip": "标题 4",
  "editor.heading.h5.tooltip": "标题 5",
  "editor.heading.h6.tooltip": "标题 6",
  "editor.paragraph.tooltip": "段落",
  "editor.textalign.tooltip": "对齐",
  "editor.textalign.left.tooltip": "左对齐",
  "editor.textalign.center.tooltip": "居中",
  "editor.textalign.right.tooltip": "右对齐",
  "editor.textalign.justify.tooltip": "两端对齐",
  "editor.indent": "缩进",
  "editor.indent.indent": "增加缩进",
  "editor.indent.outdent": "减少缩进",
  "editor.fontSize.tooltip": "字号",
  "editor.fontSize.default.tooltip": "默认",
  "editor.superscript.tooltip": "上标",
  "editor.subscript.tooltip": "下标",
  "editor.bulletlist.tooltip": "无序列表",
  "editor.orderedlist.tooltip": "有序列表",
  "editor.tasklist.tooltip": "任务列表",
  "editor.indent.tooltip": "缩进",
  "editor.outdent.tooltip": "减少缩进",
  "editor.columns.tooltip": "列",
  "editor.link.tooltip": "链接",
  "editor.link.unlink.tooltip": "取消链接",
  "editor.link.open.tooltip": "打开链接",
  "editor.link.edit.tooltip": "编辑链接",
  "editor.link.dialog.title": "插入链接",
  "editor.link.dialog.link": "链接",
  "editor.link.dialog.text": "文本",
  "editor.link.dialog.openInNewTab": "在新标签页中打开",
  "editor.link.dialog.link.placeholder": "链接地址",
  "editor.link.dialog.text.placeholder": "添加描述",
  "editor.link.dialog.button.apply": "应用",
  "editor.image.tooltip": "图片",
  "editor.image.dragger.tooltip": "点击或拖拽图片到此区域上传",
  "editor.image.float.left.tooltip": "左浮动",
  "editor.image.float.none.tooltip": "无浮动",
  "editor.image.float.right.tooltip": "右浮动",
  "editor.image.dialog.title": "添加图片",
  "editor.image.dialog.tab.url": "链接",
  "editor.image.dialog.tab.upload": "上传",
  "editor.link.dialog.inline": "Inline",
  "editor.image.dialog.uploading": "上传中",
  "editor.image.dialog.form.link": "链接",
  "editor.image.dialog.placeholder": "链接",
  "editor.image.dialog.form.alt": "替代文本",
  "editor.image.dialog.form.aspectRatio": "锁定原始宽高比",
  "editor.image.dialog.form.file": "文件",
  "editor.image.dialog.button.apply": "应用",
  "editor.video.tooltip": "视频",
  "editor.video.dialog.tab.upload": "上传",
  "editor.image.dialog.tab.uploadCrop": "上传并裁剪",
  "editor.video.dialog.uploading": "上传中",
  "editor.video.dialog.title": "嵌入或上传视频",
  "editor.video.dialog.link": "链接",
  "editor.video.dialog.placeholder": "链接",
  "editor.video.dialog.button.apply": "应用",
  "editor.table.tooltip": "表格",
  "editor.table.menu.insert_table": "插入表格",
  "editor.table.menu.insert_table.with_header_row": "带标题行",
  "editor.table.menu.add_column_before": "在前面插入列",
  "editor.table.menu.add_column_after": "在后面插入列",
  "editor.table.menu.delete_column": "删除列",
  "editor.table.menu.add_row_before": "在上方插入行",
  "editor.table.menu.add_row_after": "在下方插入行",
  "editor.table.menu.delete_row": "删除行",
  "editor.table.menu.merge_or_split_cells": "合并或拆分单元格",
  "editor.table.menu.delete_table": "删除表格",
  "editor.blockquote.tooltip": "引用",
  "editor.horizontalrule.tooltip": "水平线",
  "editor.code.tooltip": "代码",
  "editor.clear.tooltip": "清除格式",
  "editor.undo.tooltip": "撤销",
  "editor.redo.tooltip": "重做",
  "editor.fullscreen.tooltip.fullscreen": "全屏",
  "editor.fullscreen.tooltip.exit": "退出全屏",
  "editor.imageUpload.cancel": "取消",
  "editor.imageUpload.crop": "裁剪",
  "editor.imageUpload.fileTypeNotSupported": "不支持的文件类型",
  "editor.imageUpload.fileSizeTooBig": "文件大小超出限制，最大大小为",
  "editor.table.menu.insertColumnBefore": "在前面插入列",
  "editor.table.menu.insertColumnAfter": "在后面插入列",
  "editor.table.menu.deleteColumn": "删除列",
  "editor.table.menu.insertRowAbove": "在上方插入行",
  "editor.table.menu.insertRowBelow": "在下方插入行",
  "editor.table.menu.deleteRow": "删除行",
  "editor.table.menu.mergeCells": "合并单元格",
  "editor.table.menu.splitCells": "拆分单元格",
  "editor.table.menu.deleteTable": "删除表格",
  "editor.table.menu.setCellsBgColor": "设置单元格背景色",
  "editor.emoji.tooltip": "表情",
  "editor.iframe.tooltip": "内嵌框架",
  "editor.searchAndReplace.tooltip": "搜索和替换",
  "editor.search.dialog.text": "搜索",
  "editor.replace.dialog.text": "替换",
  "editor.replaceAll.dialog.text": "全部替换",
  "editor.previous.dialog.text": "上一个",
  "editor.next.dialog.text": "下一个",
  no_result_found: "未找到结果",
  "Smileys & People": "笑脸和人",
  "Animals & Nature": "动物和自然",
  "Food & Drink": "食物和饮料",
  Activity: "活动",
  "Travel & Places": "旅行和地点",
  Object: "物体",
  Symbol: "符号",
  Flags: "旗帜",
  "Frequently used": "常用",
  "editor.formula.dialog.text": "公式",
  "editor.exportPdf.tooltip": "导出 PDF",
  "editor.exportWord.tooltip": "导出 Word",
  "editor.importWord.tooltip": "导入 Word",
  "editor.importWord.limitSize": "文件大小不能超过",
  "editor.importWord.converting": "正在转换 Word 文档，请稍后...",
  "editor.importWord.convertError": "解析 Word 文档出错",
  "editor.importWord.importError": "导入 Word 文档出错",
  "editor.textDirection.tooltip": "文本方向",
  "editor.textDirection.auto.tooltip": "自动",
  "editor.textDirection.ltr.tooltip": "从左到右",
  "editor.textDirection.rtl.tooltip": "从右到左",
  "editor.attachment.tooltip": "附件",
  "editor.attachment.uploading": "上传中",
  "editor.attachment.please_upload": "请上传文件",
  "editor.imageGif.tooltip": "Gif",
  "editor.replace.caseSensitive": "区分大小写",
  "editor.twitter.tooltip": "Twitter",
  "editor.tooltip.flipX": "水平翻转",
  "editor.tooltip.flipY": "垂直翻转"
}, vZ = bZ, wZ = {
  "editor.remove": "Eltávolítás",
  "editor.copy": "Másolás",
  "editor.words": "SZAVAK",
  "editor.characters": "KARAKTEREK",
  "editor.default": "Alapértelmezett",
  "editor.recent": "Gyakran használt",
  "editor.nofill": "Kitöltés törlése",
  "editor.format": "Formátummásoló",
  "editor.delete": "Törlés",
  "editor.edit": "Szerkesztés",
  "editor.settings": "Beállítások",
  "editor.table_of_content": "Tartalomjegyzék",
  "editor.draghandle.tooltip": "Módosítás",
  "editor.copyToClipboard": "Másolás vágólapra",
  "editor.slash": "Nyomja meg a '/' gombot a parancsokhoz",
  "editor.slash.empty": "Nincs találat",
  "editor.slash.format": "Formátum",
  "editor.slash.insert": "Beszúrás",
  "editor.slash.embed": "Szolgáltatások beágyazása",
  "editor.content": "Írjon be tartalmat",
  "editor.fontFamily.tooltip": "Betűtípus",
  "editor.fontFamily.default.tooltip": "Alapértelmezett",
  "editor.moremark": "Több betűstílus",
  "editor.size.small.tooltip": "Kicsi",
  "editor.size.medium.tooltip": "Közepes",
  "editor.size.large.tooltip": "Borítókép",
  "editor.bold.tooltip": "Félkövér",
  "editor.italic.tooltip": "Dőlt betű",
  "editor.underline.tooltip": "Aláhúzott",
  "editor.strike.tooltip": "Áthúzott",
  "editor.color.tooltip": "Szín",
  "editor.color.more": "Több szín",
  "editor.highlight.tooltip": "Kiemelés",
  "editor.lineheight.tooltip": "Sorköz",
  "editor.heading.tooltip": "Fejlécek",
  "editor.heading.h1.tooltip": "Fejléc 1",
  "editor.heading.h2.tooltip": "Fejléc 2",
  "editor.heading.h3.tooltip": "Fejléc 3",
  "editor.heading.h4.tooltip": "Fejléc 4",
  "editor.heading.h5.tooltip": "Fejléc 5",
  "editor.heading.h6.tooltip": "Fejléc 6",
  "editor.paragraph.tooltip": "Bekezdés",
  "editor.textalign.tooltip": "Igazítás",
  "editor.textalign.left.tooltip": "Bal",
  "editor.textalign.center.tooltip": "Közép",
  "editor.textalign.right.tooltip": "Jobb",
  "editor.textalign.justify.tooltip": "Sorkizárt",
  "editor.indent": "Behúzás",
  "editor.indent.indent": "Behúzás Növelése",
  "editor.indent.outdent": "Behúzás Csökkentése",
  "editor.fontSize.tooltip": "Betűméret",
  "editor.fontSize.default.tooltip": "Alapértelmezett",
  "editor.superscript.tooltip": "Felső index",
  "editor.subscript.tooltip": "Alsó index",
  "editor.bulletlist.tooltip": "Felsorolás",
  "editor.orderedlist.tooltip": "Rendezett lista",
  "editor.tasklist.tooltip": "Feladat lista",
  "editor.indent.tooltip": "Behúzás növelése",
  "editor.outdent.tooltip": "Behúzás csökkentése",
  "editor.columns.tooltip": "Oszlopok",
  "editor.link.tooltip": "Link",
  "editor.link.unlink.tooltip": "Link törlése",
  "editor.link.open.tooltip": "Link megnyitása",
  "editor.link.edit.tooltip": "Link szerkesztése",
  "editor.link.dialog.title": "Link beszúrása",
  "editor.link.dialog.link": "Link",
  "editor.link.dialog.text": "Szöveg",
  "editor.link.dialog.openInNewTab": "Megnyitás új lapon",
  "editor.link.dialog.link.placeholder": "Link célpont",
  "editor.link.dialog.text.placeholder": "Szöveg",
  "editor.link.dialog.button.apply": "Alkalmaz",
  "editor.image.tooltip": "Kép",
  "editor.image.dragger.tooltip": "Kattintson vagy húzza a feltölteni kívánt képet a területre",
  "editor.image.float.left.tooltip": "Lebegtetés balra",
  "editor.image.float.none.tooltip": "Lebegtetés törlése",
  "editor.image.float.right.tooltip": "Lebegtetés jobbra",
  "editor.image.dialog.title": "Kép hozzáadása",
  "editor.image.dialog.tab.url": "URL",
  "editor.image.dialog.tab.upload": "Feltöltés",
  "editor.image.dialog.tab.uploadCrop": "Feltöltés és körbevágás",
  "editor.image.dialog.uploading": "Feltöltés alatt",
  "editor.link.dialog.inline": "Soron belüli",
  "editor.image.dialog.form.link": "Link",
  "editor.image.dialog.placeholder": "Link",
  "editor.image.dialog.form.alt": "Alternatív szöveg",
  "editor.image.dialog.form.aspectRatio": "Eredeti képarány megtartása",
  "editor.image.dialog.form.file": "Fájl",
  "editor.image.dialog.button.apply": "Alkalmaz",
  "editor.video.tooltip": "Videó",
  "editor.video.dialog.tab.upload": "Feltöltés",
  "editor.video.dialog.uploading": "Feltöltés alatt",
  "editor.video.dialog.title": "Videó beágyazása vagy feltöltése",
  "editor.video.dialog.link": "Link",
  "editor.video.dialog.placeholder": "Link",
  "editor.video.dialog.button.apply": "Alkalmaz",
  "editor.table.tooltip": "Táblázat",
  "editor.table.menu.insert_table": "Táblázat beszúrása",
  "editor.table.menu.insert_table.with_header_row": "Fejléc sorral",
  "editor.table.menu.add_column_before": "Oszlop beszúrása balra",
  "editor.table.menu.add_column_after": "Oszlop beszúrása jobbra",
  "editor.table.menu.delete_column": "Oszlop törlése",
  "editor.table.menu.add_row_before": "Sor beszúrása felülre",
  "editor.table.menu.add_row_after": "Sor beszúrása alulra",
  "editor.table.menu.delete_row": "Sor törlése",
  "editor.table.menu.merge_or_split_cells": "Cellák egyesítése vagy szétválasztása",
  "editor.table.menu.delete_table": "Táblázat törlése",
  "editor.blockquote.tooltip": "Blokkidézet",
  "editor.horizontalrule.tooltip": "Vízszintes vonal",
  "editor.code.tooltip": "Kód",
  "editor.clear.tooltip": "Formatálás Törlése",
  "editor.undo.tooltip": "Visszavonás",
  "editor.redo.tooltip": "Visszaállítás",
  "editor.fullscreen.tooltip.fullscreen": "Teljes képernyős mód",
  "editor.fullscreen.tooltip.exit": "Kilépés teljes képernyős módból",
  "editor.imageUpload.cancel": "Mégsem",
  "editor.imageUpload.crop": "Körbevágás",
  "editor.imageUpload.fileTypeNotSupported": "Fájltípus nem támogatott",
  "editor.imageUpload.fileSizeTooBig": "A fájlméret túl nagy, a maximum méret",
  "editor.table.menu.insertColumnBefore": "Oszlop beszúrása balra",
  "editor.table.menu.insertColumnAfter": "Oszlop beszúrása jobbra",
  "editor.table.menu.deleteColumn": "Oszlop törlése",
  "editor.table.menu.insertRowAbove": "Sor beszúrása felülre",
  "editor.table.menu.insertRowBelow": "Sor beszúrása alulra",
  "editor.table.menu.deleteRow": "Sor törlése",
  "editor.table.menu.mergeCells": "Cellák egyesítése",
  "editor.table.menu.splitCells": "Cellék szétválasztása",
  "editor.table.menu.deleteTable": "Táblázat törlése",
  "editor.table.menu.setCellsBgColor": "Cella háttérszín",
  "editor.emoji.tooltip": "Emoji",
  "editor.iframe.tooltip": "Beágyazás",
  "editor.searchAndReplace.tooltip": "Keresés és csere",
  "editor.search.dialog.text": "Keres",
  "editor.replace.dialog.text": "Csere",
  "editor.replaceAll.dialog.text": "Összes cseréje",
  "editor.previous.dialog.text": "Előző",
  "editor.next.dialog.text": "Következő",
  no_result_found: "Nincs találat",
  "Smileys & People": "Arcok és emberek",
  "Animals & Nature": "Állatok és természet",
  "Food & Drink": "Étel és ital",
  Activity: "Aktivitás",
  "Travel & Places": "Utazás és helyek",
  Object: "Tárgyak",
  Symbol: "Szimbólumok",
  Flags: "Zászlók",
  "Frequently used": "Gyakran használt",
  "editor.formula.dialog.text": "Formula",
  "editor.exportPdf.tooltip": "PDF exportálása",
  "editor.exportWord.tooltip": "Word exportálása",
  "editor.importWord.tooltip": "Word importálása",
  "editor.importWord.limitSize": "A fájl mérete nem haladhatja meg",
  "editor.importWord.converting": "Word dokumentum konvertálása, kérjük, várjon...",
  "editor.importWord.convertError": "Hiba a Word-dokumentum elemzésekor",
  "editor.importWord.importError": "Hiba a Word dokumentum importálásakor",
  "editor.textDirection.tooltip": "Szövegirány",
  "editor.textDirection.auto.tooltip": "Automatikus",
  "editor.textDirection.ltr.tooltip": "Balról jobbra",
  "editor.textDirection.rtl.tooltip": "Jobbról balra",
  "editor.attachment.tooltip": "Csatolmány",
  "editor.attachment.uploading": "Feltöltés alatt",
  "editor.attachment.please_upload": "Töltse fel a fájlt",
  "editor.imageGif.tooltip": "Gif",
  "editor.replace.caseSensitive": "Kisbetű-nagybetű érzékenység",
  "editor.twitter.tooltip": "Twitter",
  "editor.tooltip.flipX": "Vízszintes tükrözés",
  "editor.tooltip.flipY": "Függőleges tükrözés"
}, xZ = wZ;
function _Z(t) {
  return t = t || /* @__PURE__ */ new Map(), {
    /**
     * A Map of event names to registered handler functions.
     */
    all: t,
    /**
     * Register an event handler for the given type.
     * @param {string|symbol} type Type of event to listen for, or `'*'` for all events
     * @param {Function} handler Function to call in response to given event
     * @memberOf mitt
     */
    on(e, n) {
      const r = t.get(e);
      r ? r.push(n) : t.set(e, [n]);
    },
    /**
     * Remove an event handler for the given type.
     * If `handler` is omitted, all handlers of the given type are removed.
     * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)
     * @param {Function} [handler] Handler function to remove
     * @memberOf mitt
     */
    off(e, n) {
      const r = t.get(e);
      r && (n ? r.splice(r.indexOf(n) >>> 0, 1) : t.set(e, []));
    },
    /**
     * Invoke all handlers for the given type.
     * If present, `'*'` handlers are invoked after type-matched handlers.
     *
     * Note: Manually firing '*' handlers is not supported.
     *
     * @param {string|symbol} type The event type to invoke
     * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler
     * @memberOf mitt
     */
    emit(e, n) {
      let r = t.get(e);
      r && [...r].map((i) => {
        i(n);
      }), r = t.get("*"), r && [...r].map((i) => {
        i(e, n);
      });
    }
  };
}
const SZ = "en", TZ = 200, DZ = TZ - 80, g4 = 20, zb = 1e5, $b = 16, Jg = 10, Zg = 10, Qg = 2, EZ = [
  "#000000",
  "#262626",
  "#595959",
  "#8C8C8C",
  "#BFBFBF",
  "#D9D9D9",
  "#E9E9E9",
  "#F5F5F5",
  "#FAFAFA",
  "#FFFFFF",
  "#F5222D",
  "#FA541C",
  "#FA8C16",
  "#FADB14",
  "#52C41A",
  "#13C2C2",
  "#1890FF",
  "#2F54EB",
  "#722ED1",
  "#EB2F96",
  "#FFE8E6",
  "#FFECE0",
  "#FFEFD1",
  "#FCFCCA",
  "#E4F7D2",
  "#D3F5F0",
  "#D4EEFC",
  "#DEE8FC",
  "#EFE1FA",
  "#FAE1EB",
  "#FFA39E",
  "#FFBB96",
  "#FFD591",
  "#FFFB8F",
  "#B7EB8F",
  "#87E8DE",
  "#91D5FF",
  "#ADC6FF",
  "#D3ADF7",
  "#FFADD2",
  "#FF4D4F",
  "#FF7A45",
  "#FFA940",
  "#FFEC3D",
  "#73D13D",
  "#36CFC9",
  "#40A9FF",
  "#597EF7",
  "#9254DE",
  "#F759AB",
  "#CF1322",
  "#D4380D",
  "#D46B08",
  "#D4B106",
  "#389E0D",
  "#08979C",
  "#096DD9",
  "#1D39C4",
  "#531DAB",
  "#C41D7F",
  "#820014",
  "#871400",
  "#873800",
  "#614700",
  "#135200",
  "#00474F",
  "#003A8C",
  "#061178",
  "#22075E",
  "#780650"
], CZ = [
  "Inter",
  "Comic Sans MS, Comic Sans",
  "serif",
  "cursive",
  "Arial",
  "Arial Black",
  "Georgia",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Verdana",
  "Courier New",
  "Lucida Console",
  "Monaco",
  "monospace"
], kZ = [
  "10px",
  "11px",
  "12px",
  "14px",
  "16px",
  "18px",
  "20px",
  "22px",
  "24px",
  "26px",
  "28px",
  "36px",
  "48px",
  "72px"
], Y3 = "default";
var nm = /* @__PURE__ */ ((t) => (t[t["size-small"] = 200] = "size-small", t[t["size-medium"] = 500] = "size-medium", t["size-large"] = "100%", t))(nm || {}), Hb = /* @__PURE__ */ ((t) => (t[t["size-small"] = 480] = "size-small", t[t["size-medium"] = 640] = "size-medium", t["size-large"] = "100%", t))(Hb || {});
const AZ = ["100%", "115%", "150%", "200%", "250%", "300%"], y4 = "1", RZ = [
  "bold",
  "italic",
  "underline",
  "strike",
  "code",
  "link",
  "divider",
  "color",
  "highlight",
  "textAlign"
], Hd = {
  lang: SZ,
  message: {
    en: hZ,
    hu_HU: xZ,
    vi: yZ,
    zh_CN: vZ,
    pt_BR: mZ
  }
};
class IZ {
  constructor() {
    ti(this, "emitter");
    this.emitter = _Z();
  }
  // Getter and setter for current language
  get lang() {
    return Hd.lang;
  }
  set lang(e) {
    if (!this.isLangSupported(e)) {
      console.warn(
        `Can't find the current language "${e}", Using language "${Hd.lang}" by default`
      );
      return;
    }
    Hd.lang = e, this.emitter.emit("lang", e);
  }
  // Getter and setter for messages
  get message() {
    return Hd.message;
  }
  set message(e) {
    Hd.message = e;
  }
  // Load messages for a specific language
  loadLangMessage(e) {
    return this.message[e];
  }
  // Check if a language is supported
  isLangSupported(e) {
    return Object.keys(this.message).includes(e);
  }
  // Set the current language
  setLang(e) {
    this.lang = e;
  }
  // Register a language change watcher
  registerWatchLang(e) {
    return this.emitter.on("lang", e), {
      unsubscribe: () => {
        this.emitter.off("lang", e);
      }
    };
  }
  // Set messages for a specific language
  setMessage(e, n) {
    this.message[e] = n;
  }
  // Build a translation function for a given language
  buildLocalesHandler(e) {
    e || (e = this.lang);
    const n = this.loadLangMessage(e);
    return function(i) {
      return n[i] || i;
    };
  }
}
const jb = new IZ(), b4 = $m(Hd.lang);
function Wt() {
  const [t, e] = dZ(b4), n = Yt(() => jb.buildLocalesHandler(t), [t]);
  return Tt(() => {
    const r = jb.registerWatchLang((i) => {
      e(i);
    });
    return () => {
      r.unsubscribe();
    };
  }, []), {
    lang: t,
    t: n
  };
}
const sn = {
  t: (t) => jb.buildLocalesHandler(b4.get())(t)
}, b2e = jb, OZ = { padding: "0 12px 12px" }, FZ = ({ width: t, maxWidth: e, height: n, onOk: r, children: i }) => {
  const { t: o } = Wt(), [a, s] = nt({
    width: "",
    height: "",
    maxWidth: ""
  });
  Tt(() => {
    s({
      width: t,
      height: n,
      maxWidth: e
    });
  }, [n, e, t]);
  function l(c) {
    c.preventDefault(), c.stopPropagation(), r(a);
  }
  return /* @__PURE__ */ Fe(Eo, { modal: !0, children: [
    /* @__PURE__ */ z(Co, { asChild: !0, children: i }),
    /* @__PURE__ */ z(oo, { children: /* @__PURE__ */ z("div", { style: OZ, children: /* @__PURE__ */ Fe("form", { className: "richtext-flex richtext-flex-col richtext-gap-2", onSubmit: l, children: [
      /* @__PURE__ */ z(eo, { className: "mb-[6px]", children: "Width" }),
      /* @__PURE__ */ z("div", { className: "richtext-flex richtext-w-full richtext-max-w-sm richtext-items-center richtext-gap-1.5", children: /* @__PURE__ */ z("div", { className: "richtext-relative richtext-items-center richtext-w-full richtext-max-w-sm", children: /* @__PURE__ */ z(
        Pr,
        {
          type: "number",
          value: a.width,
          required: !0,
          onChange: (c) => s({ ...a, width: c.target.value })
        }
      ) }) }),
      /* @__PURE__ */ z(eo, { className: "mb-[6px]", children: "Max Width" }),
      /* @__PURE__ */ z("div", { className: "richtext-flex richtext-w-full richtext-max-w-sm richtext-items-center richtext-gap-1.5", children: /* @__PURE__ */ z("div", { className: "richtext-relative richtext-items-center richtext-w-full richtext-max-w-sm", children: /* @__PURE__ */ z(
        Pr,
        {
          type: "number",
          value: a.maxWidth,
          required: !0,
          onChange: (c) => s({ ...a, maxWidth: c.target.value })
        }
      ) }) }),
      /* @__PURE__ */ z(eo, { className: "mb-[6px]", children: "Height" }),
      /* @__PURE__ */ z("div", { className: "richtext-flex richtext-w-full richtext-max-w-sm richtext-items-center richtext-gap-1.5", children: /* @__PURE__ */ z("div", { className: "richtext-relative richtext-items-center richtext-w-full richtext-max-w-sm", children: /* @__PURE__ */ z(
        Pr,
        {
          type: "number",
          value: a.height,
          required: !0,
          onChange: (c) => s({ ...a, height: c.target.value })
        }
      ) }) }),
      /* @__PURE__ */ z(fn, { type: "submit", className: "richtext-self-end richtext-mt-2", children: o("editor.link.dialog.button.apply") })
    ] }) }) })
  ] });
};
function UZ(t, e = "{}") {
  try {
    return JSON.stringify(t);
  } catch {
    return e;
  }
}
function Yi(t, e = !1) {
  return (n) => {
    const r = t.startsWith("data-") ? t : `data-${t}`;
    let i = decodeURIComponent(n.getAttribute(r));
    if (i == null || typeof i == "string" && i === "null")
      try {
        const s = n.outerHTML.match(/([\s\S])+?="([\s\S])+?"/g);
        s && s.length && (i = (s.map((c) => c.trim()).reduce((c, u) => {
          const d = u.indexOf("="), f = [u.slice(0, d), u.slice(d + 1).slice(1, -1)];
          return c[f[0]] = f[1], c;
        }, {})[t.toLowerCase()] || "").replaceAll("&quot;", '"'));
      } catch (a) {
        console.error("Error getDatasetAttribute ", a.message, n);
      }
    if (e)
      try {
        return JSON.parse(i);
      } catch {
        return {};
      }
    if (i.includes("%") || i.includes("auto"))
      return i;
    const o = Number.parseInt(i);
    return o !== o ? i : o;
  };
}
const NZ = "_wrap_5y04w_1", MZ = "_handlerWrap_5y04w_11", BZ = "_innerWrap_5y04w_15", LZ = "_emptyWrap_5y04w_23", J3 = {
  wrap: NZ,
  handlerWrap: MZ,
  innerWrap: BZ,
  emptyWrap: LZ
}, v4 = $m(!1);
function WD() {
  return PD(v4);
}
const PZ = {
  setDisable: (t) => {
    v4.set(t);
  }
};
function WZ({ editor: t, node: e, updateAttributes: n }) {
  const r = WD(), { url: i, width: o, height: a } = e.attrs, [s, l] = nt("");
  function c() {
    s && t.chain().updateAttributes(jd.name, {
      url: s
    }).setNodeSelection(t.state.selection.from).focus().run();
  }
  const u = Et(
    (d) => {
      n({ width: d.width, height: d.height });
    },
    [n]
  );
  return /* @__PURE__ */ Fe(xl, { children: [
    !i && /* @__PURE__ */ Fe("div", { className: "richtext-max-w-[600px] richtext-mx-[auto] richtext-my-[12px] richtext-flex richtext-items-center richtext-justify-center richtext-gap-[10px] richtext-p-[10px] richtext-border-[1px] richtext-border-solid richtext-border-[#ccc] richtext-rounded-[12px]", children: [
      /* @__PURE__ */ z(
        Pr,
        {
          value: s,
          onInput: (d) => l(d.target.value),
          type: "url",
          className: "richtext-flex-1",
          autoFocus: !0,
          placeholder: "Enter link"
        }
      ),
      /* @__PURE__ */ z(fn, { className: "richtext-w-[60px]", onClick: c, children: "OK" })
    ] }),
    i && /* @__PURE__ */ z(
      NW,
      {
        size: { width: Number.parseInt(o), height: Number.parseInt(a) },
        onResizeStop: (d, f, p, m) => {
          u({
            width: Number.parseInt(o) + m.width,
            height: Number.parseInt(a) + m.height
          });
        },
        children: /* @__PURE__ */ z("div", { className: xo(J3.wrap, "render-wrapper"), children: /* @__PURE__ */ z("div", { className: J3.innerWrap, style: { pointerEvents: r ? "none" : "auto" }, children: /* @__PURE__ */ z(
          "iframe",
          {
            src: i,
            className: "richtext-my-[12px] "
          }
        ) }) })
      }
    )
  ] });
}
const jd = rn.create({
  name: "iframe",
  content: "",
  marks: "",
  group: "block",
  selectable: !0,
  atom: !0,
  draggable: !0,
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      HTMLAttributes: {
        class: "iframe"
      },
      button: ({
        editor: e,
        extension: n,
        t: r
      }) => ({
        component: Je,
        componentProps: {
          action: (i) => e.commands.setIframe(i),
          upload: n.options.upload,
          disabled: !e.can().setIframe({}),
          icon: "Iframe",
          tooltip: r("editor.iframe.tooltip")
        }
      })
    };
  },
  addAttributes() {
    return {
      width: {
        default: 600,
        parseHTML: Yi("width")
      },
      height: {
        default: 300,
        parseHTML: Yi("height")
      },
      url: {
        default: null,
        parseHTML: Yi("url")
      },
      defaultShowPicker: {
        default: !1
      },
      frameborder: {
        default: 0
      },
      allowfullscreen: {
        default: this.options.allowFullscreen,
        parseHTML: () => this.options.allowFullscreen
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "iframe"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["iframe", bt(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setIframe: (t) => ({ tr: e, commands: n, chain: r }) => {
        var o, a, s;
        if (((s = (a = (o = e.selection) == null ? void 0 : o.node) == null ? void 0 : a.type) == null ? void 0 : s.name) == this.name)
          return n.updateAttributes(this.name, t);
        const i = t || { url: "" };
        return r().insertContent({
          type: this.name,
          attrs: i
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      yD({
        find: /^\$iframe\$$/,
        type: this.type,
        getAttributes: () => ({ width: "100%" })
      })
    ];
  },
  addNodeView() {
    return Vf(WZ);
  }
});
function zD(t, e) {
  const { state: n } = e, r = n.selection.$anchor;
  let i = !1;
  if (r.depth)
    for (let o = r.depth; o > 0; o--)
      r.node(o).type.name === t && (e.dispatchTransaction && e.dispatchTransaction(n.tr.delete(r.before(o), r.after(o)).scrollIntoView()), i = !0);
  else {
    const o = n.selection.node;
    o && o.type.name === t && (e.chain().deleteSelection().run(), i = !0);
  }
  if (!i) {
    const o = r.pos;
    if (o) {
      const a = n.tr.doc.nodeAt(o);
      a && a.type.name === t && (e.dispatchTransaction && e.dispatchTransaction(n.tr.delete(o, o + a.nodeSize)), i = !0);
    }
  }
  return i;
}
function zZ({ editor: t }) {
  const { t: e } = Wt(), { width: n, height: r, url: i } = LJ(t, jd.name, {
    width: 0,
    height: 0,
    url: "",
    defaultShowPicker: !1
  }), [o, a] = nt(!1), [s, l] = nt(""), c = Et(() => {
    a(!1);
  }, [a]);
  Tt(() => {
    o && l(i);
  }, [o, i]);
  const u = Et(() => {
    t.chain().updateAttributes(jd.name, {
      url: s
    }).setNodeSelection(t.state.selection.from).focus().run(), a(!1);
  }, [t, s, a]), d = Et(() => {
    window.open(i, "_blank");
  }, [i]), f = Et(() => {
    a(!0);
  }, [a]), p = Et(
    (b) => {
      t.chain().updateAttributes(jd.name, b).setNodeSelection(t.state.selection.from).focus().run();
    },
    [t]
  ), m = Et(() => t.isActive(jd.name) && !i, [t, i]), g = Et(() => zD(jd.name, t), [t]);
  return /* @__PURE__ */ Fe(pn, { children: [
    /* @__PURE__ */ z(
      hs,
      {
        className: "bubble-menu",
        editor: t,
        pluginKey: "iframe-bubble-menu",
        shouldShow: m,
        tippyOptions: {
          popperOptions: {
            modifiers: [{ name: "flip", enabled: !1 }]
          },
          placement: "bottom-start",
          offset: [-2, 16],
          zIndex: 9999
          // onHidden: () => {
          //   toggleVisible(false)
          // },
        },
        children: /* @__PURE__ */ Fe("div", { className: "richtext-w-auto richtext-px-3 richtext-py-2 richtext-transition-all !richtext-border richtext-rounded-sm richtext-shadow-sm richtext-pointer-events-auto richtext-select-none richtext-border-neutral-200 dark:richtext-border-neutral-800 richtext-bg-background", children: [
          /* @__PURE__ */ z(
            Je,
            {
              action: d,
              icon: "Eye",
              tooltip: "Visit Link"
            }
          ),
          /* @__PURE__ */ z(
            Je,
            {
              action: f,
              icon: "Pencil",
              tooltip: "Open Edit Link"
            }
          ),
          /* @__PURE__ */ z(FZ, { width: n, height: r, onOk: p, children: /* @__PURE__ */ z(
            Je,
            {
              icon: "Settings",
              tooltip: e("editor.settings")
            }
          ) }),
          /* @__PURE__ */ z(
            Je,
            {
              action: g,
              icon: "Trash2",
              tooltip: e("editor.delete")
            }
          )
        ] })
      }
    ),
    /* @__PURE__ */ Fe(
      v1,
      {
        open: o,
        onOpenChange: a,
        children: [
          /* @__PURE__ */ z(w1, {}),
          /* @__PURE__ */ Fe(Pm, { children: [
            /* @__PURE__ */ z(o4, { children: /* @__PURE__ */ z(Wm, { children: "Edit Link Iframe" }) }),
            /* @__PURE__ */ z(
              Pr,
              {
                value: s,
                onInput: (b) => l(b.target.value),
                type: "url",
                autoFocus: !0,
                placeholder: "Enter link"
              }
            ),
            /* @__PURE__ */ Fe(MD, { children: [
              /* @__PURE__ */ z(fn, { onClick: c, children: "Cancel" }),
              /* @__PURE__ */ z(fn, { onClick: u, children: "OK" })
            ] })
          ] })
        ]
      }
    )
  ] });
}
function $Z({ node: t }) {
  var r;
  const e = ((r = t == null ? void 0 : t.attrs) == null ? void 0 : r.src) || "", n = e == null ? void 0 : e.split("/").pop();
  return n ? /* @__PURE__ */ z(xl, { children: /* @__PURE__ */ z("div", { "data-twitter": "", children: /* @__PURE__ */ z(MW, { id: n }) }) }) : null;
}
function HZ(t) {
  function e(n) {
    t.action && t.action(n);
  }
  return /* @__PURE__ */ Fe(Eo, { modal: !0, children: [
    /* @__PURE__ */ z(Co, { disabled: t == null ? void 0 : t.disabled, asChild: !0, children: /* @__PURE__ */ z(
      Je,
      {
        tooltip: t == null ? void 0 : t.tooltip,
        isActive: t == null ? void 0 : t.isActive,
        disabled: t == null ? void 0 : t.disabled,
        children: /* @__PURE__ */ z($t, { name: t == null ? void 0 : t.icon })
      }
    ) }),
    /* @__PURE__ */ z(oo, { hideWhenDetached: !0, className: "richtext-w-full", align: "start", side: "bottom", children: /* @__PURE__ */ z(w4, { editor: t.editor, onSetLink: e }) })
  ] });
}
const jZ = /(https?:\/\/)?(www\.)?x\.com\/(\w{1,15})(\/status\/(\d+))?(\/\S*)?/g, VZ = /^https?:\/\/(www\.)?x\.com\/(\w{1,15})(\/status\/(\d+))?(\/\S*)?$/;
function Z3(t) {
  return t.match(VZ);
}
const GS = rn.create({
  name: "twitter",
  draggable: !0,
  selectable: !0,
  addOptions() {
    return {
      addPasteHandler: !0,
      HTMLAttributes: {},
      inline: !1,
      origin: "",
      button: ({ editor: t, t: e }) => ({
        component: HZ,
        componentProps: {
          action: (n) => {
            t.commands.setTweet({ src: n });
          },
          isActive: () => !1,
          disabled: !1,
          icon: "Twitter",
          tooltip: e("editor.twitter.tooltip"),
          editor: t
        }
      })
    };
  },
  addNodeView() {
    return Vf($Z, { attrs: this.options.HTMLAttributes });
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  addAttributes() {
    return {
      src: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "div[data-twitter]"
      }
    ];
  },
  addCommands() {
    return {
      setTweet: (t) => ({ commands: e }) => Z3(t.src) ? e.insertContent({
        type: this.name,
        attrs: t
      }) : !1,
      updateTweet: (t) => ({ commands: e }) => Z3(t.src) ? e.updateAttributes(this.name, { src: t.src }) : !1
    };
  },
  addPasteRules() {
    return this.options.addPasteHandler ? [
      LV({
        find: jZ,
        type: this.type,
        getAttributes: (t) => ({ src: t.input })
      })
    ] : [];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["div", bt({ "data-twitter": "" }, t)];
  }
});
function w4(t) {
  const { t: e } = Wt(), [n, r] = nt("");
  Tt(() => {
    var o;
    if (t != null && t.editor) {
      const { src: a } = (o = t.editor) == null ? void 0 : o.getAttributes(GS.name);
      a && r(a);
    }
  }, [t == null ? void 0 : t.editor]);
  function i(o) {
    o.preventDefault(), o.stopPropagation(), t == null || t.onSetLink(n);
  }
  return /* @__PURE__ */ z("div", { className: "richtext-p-2 richtext-bg-white !richtext-border richtext-rounded-lg richtext-shadow-sm dark:richtext-bg-black border-neutral-200 dark:richtext-border-neutral-800", children: /* @__PURE__ */ Fe("form", { className: "richtext-flex richtext-flex-col richtext-gap-2", onSubmit: i, children: [
    /* @__PURE__ */ z(eo, { className: "mb-[6px]", children: e("editor.link.dialog.text") }),
    /* @__PURE__ */ z("div", { className: "richtext-flex richtext-w-full richtext-max-w-sm richtext-items-center richtext-gap-1.5 richtext-mb-[10px]", children: /* @__PURE__ */ z("div", { className: "richtext-relative richtext-items-center richtext-w-full richtext-max-w-sm", children: /* @__PURE__ */ z(
      Pr,
      {
        type: "text",
        value: n,
        required: !0,
        className: "richtext-w-80",
        placeholder: "Text",
        onChange: (o) => r(o.target.value)
      }
    ) }) }),
    /* @__PURE__ */ z(fn, { type: "submit", className: "richtext-self-end richtext-mt-2", children: e("editor.link.dialog.button.apply") })
  ] }) });
}
function qZ({ editor: t, disabled: e }) {
  const [n, r] = nt(!1), { t: i } = Wt(), o = Et(({ editor: l }) => l.isActive(GS.name), []), a = (l) => {
    t.commands.updateTweet({ src: l }), r(!1);
  }, s = Et(() => zD(GS.name, t), [t]);
  return /* @__PURE__ */ z(pn, { children: /* @__PURE__ */ z(
    hs,
    {
      editor: t,
      shouldShow: o,
      tippyOptions: {
        popperOptions: {
          modifiers: [{ name: "flip", enabled: !1 }]
        },
        placement: "bottom-start",
        offset: [-2, 16],
        zIndex: 9999,
        onHidden: () => {
          r(!1);
        }
      },
      children: e ? /* @__PURE__ */ z(pn, {}) : /* @__PURE__ */ z(pn, { children: n ? /* @__PURE__ */ z(
        w4,
        {
          onSetLink: a,
          editor: t
        }
      ) : /* @__PURE__ */ z("div", { className: "richtext-flex richtext-items-center richtext-gap-2 richtext-p-2 richtext-bg-white !richtext-border richtext-rounded-lg richtext-shadow-sm dark:richtext-bg-black richtext-border-neutral-200 dark:richtext-border-neutral-800", children: /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-flex-nowrap", children: [
        /* @__PURE__ */ z(
          Je,
          {
            icon: "Pencil",
            tooltip: i("editor.link.edit.tooltip"),
            action: () => {
              r(!0);
            },
            tooltipOptions: { sideOffset: 15 }
          }
        ),
        /* @__PURE__ */ z(
          Je,
          {
            icon: "Trash",
            tooltip: i("editor.delete"),
            action: s,
            tooltipOptions: { sideOffset: 15 }
          }
        )
      ] }) }) })
    }
  ) });
}
function GZ({ editor: t, disabled: e, bubbleMenu: n }) {
  const r = t.extensionManager.extensions.map((o) => o.name), i = () => {
    var o, a, s, l, c, u, d, f, p, m;
    return [
      r.includes("columns") && !((o = n == null ? void 0 : n.columnConfig) != null && o.hidden) ? /* @__PURE__ */ z(Fae, { editor: t }, "columns") : null,
      r.includes("table") && !((a = n == null ? void 0 : n.tableConfig) != null && a.hidden) ? /* @__PURE__ */ z(Tae, { editor: t }, "table") : null,
      r.includes("link") && !((s = n == null ? void 0 : n.linkConfig) != null && s.hidden) ? /* @__PURE__ */ z(Eae, { editor: t, disabled: e }, "link") : null,
      r.includes("image") && !((l = n == null ? void 0 : n.imageConfig) != null && l.hidden) ? /* @__PURE__ */ z(Rae, { editor: t, disabled: e }, "image") : null,
      r.includes(r7.name) && !((c = n == null ? void 0 : n.imageGifConfig) != null && c.hidden) ? /* @__PURE__ */ z(Iae, { editor: t, disabled: e }, "imageGif") : null,
      r.includes("video") && !((u = n == null ? void 0 : n.videoConfig) != null && u.hidden) ? /* @__PURE__ */ z(Oae, { editor: t, disabled: e }, "video") : null,
      r.includes("iframe") && !((d = n == null ? void 0 : n.iframeConfig) != null && d.hidden) ? /* @__PURE__ */ z(zZ, { editor: t, disabled: e }, "iframe") : null,
      r.includes("twitter") && !((f = n == null ? void 0 : n.twitterConfig) != null && f.hidden) ? /* @__PURE__ */ z(qZ, { editor: t, disabled: e }, "twitter") : null,
      (p = n == null ? void 0 : n.floatingMenuConfig) != null && p.hidden ? null : /* @__PURE__ */ z(vae, { editor: t, disabled: e }, "content"),
      (m = n == null ? void 0 : n.textConfig) != null && m.hidden ? null : /* @__PURE__ */ z(_ae, { editor: t, disabled: e }, "text")
    ];
  };
  return n != null && n.render ? n.render({ editor: t, disabled: e || !1, bubbleMenu: n }, i()) : i().filter(Boolean);
}
function Q3() {
  return /* @__PURE__ */ z("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", children: /* @__PURE__ */ z("path", { fill: "currentColor", d: "M18 14c0-4-6-10.8-6-10.8s-1.33 1.51-2.73 3.52l8.59 8.59c.09-.42.14-.86.14-1.31m-.88 3.12L12.5 12.5L5.27 5.27L4 6.55l3.32 3.32C6.55 11.32 6 12.79 6 14c0 3.31 2.69 6 6 6c1.52 0 2.9-.57 3.96-1.5l2.63 2.63l1.27-1.27z" }) });
}
function x4(t) {
  const { t: e } = Wt(), {
    highlight: n = !1,
    disabled: r = !1,
    selectedColor: i,
    setSelectedColor: o,
    onChange: a,
    colors: s = EZ
  } = t, l = Yt(() => {
    const p = s, m = [];
    for (let g = 0; g < p.length; g += 10)
      m.push(p.slice(g, g + 10));
    return m;
  }, [s]), [c, u] = nt([]), d = (p) => {
    const m = [...c], g = m.indexOf(p);
    g !== -1 && m.splice(g, 1), m.unshift(p), m.length > 10 && m.pop(), u(m);
  };
  function f(p) {
    if (p === void 0) {
      o == null || o(p), a == null || a(p);
      return;
    }
    /^#([\da-f]{3}){1,2}$/i.test(p) && (o == null || o(p), a == null || a(p), d(p));
  }
  return /* @__PURE__ */ Fe(Eo, { modal: !0, children: [
    /* @__PURE__ */ z(Co, { className: "!richtext-p-0", disabled: r, asChild: !0, children: t == null ? void 0 : t.children }),
    /* @__PURE__ */ z(oo, { hideWhenDetached: !0, className: "richtext-w-full richtext-h-full richtext-p-2", align: "start", side: "bottom", children: /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-flex-col", children: [
      n ? /* @__PURE__ */ Fe(
        "div",
        {
          className: "richtext-flex richtext-items-center richtext-p-1 richtext-cursor-pointer rd-1 richtext-gap-[4px] hover:richtext-bg-accent",
          onClick: () => f(void 0),
          children: [
            /* @__PURE__ */ z(Q3, {}),
            /* @__PURE__ */ z("span", { className: "richtext-ml-1 richtext-text-sm", children: e("editor.nofill") })
          ]
        }
      ) : /* @__PURE__ */ Fe(
        "div",
        {
          className: "richtext-flex richtext-items-center richtext-p-1 richtext-cursor-pointer rd-1 richtext-gap-[4px] hover:richtext-bg-accent",
          onClick: () => {
            f(void 0);
          },
          children: [
            /* @__PURE__ */ z(Q3, {}),
            /* @__PURE__ */ z("span", { className: "richtext-ml-1 richtext-text-sm", children: e("editor.default") })
          ]
        }
      ),
      l.map((p, m) => /* @__PURE__ */ z("span", { className: "richtext-relative richtext-flex richtext-w-full richtext-h-auto richtext-p-0 last:richtext-pb-2", children: p.map((g, b) => /* @__PURE__ */ z(
        "span",
        {
          className: "richtext-w-6 richtext-h-6 richtext-p-0.5 richtext-inline-block richtext-rounded-sm !richtext-border richtext-border-transparent richtext-flex-[0_0_auto] richtext-cursor-pointer hover:richtext-border-border hover:richtext-shadow-sm",
          onClick: () => f(g),
          children: /* @__PURE__ */ z(
            "span",
            {
              style: {
                backgroundColor: g
              },
              className: "richtext-relative richtext-w-[18px] richtext-h-[18px] richtext-block richtext-rounded-[2px] richtext-border-transparent",
              children: g === i ? /* @__PURE__ */ z(
                "svg",
                {
                  className: "richtext-absolute richtext-block richtext-top-[-1px] richtext-left-[1px] richtext-w-3 richtext-h-3",
                  viewBox: "0 0 18 18",
                  style: {
                    fill: "rgb(255, 255, 255)"
                  },
                  children: /* @__PURE__ */ z("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" })
                }
              ) : /* @__PURE__ */ z(
                "svg",
                {
                  viewBox: "0 0 18 18",
                  style: {
                    fill: "rgb(255, 255, 255)",
                    display: "none"
                  },
                  children: /* @__PURE__ */ z("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" })
                }
              )
            }
          )
        },
        `sub-color-${b}`
      )) }, m)),
      /* @__PURE__ */ Fe("div", { children: [
        /* @__PURE__ */ z("div", { className: "richtext-my-1 richtext-text-sm", children: e("editor.recent") }),
        /* @__PURE__ */ z("span", { className: "richtext-relative richtext-flex richtext-w-full richtext-h-auto richtext-p-0 last:richtext-pb-2", children: c == null ? void 0 : c.map((p, m) => /* @__PURE__ */ z(
          "span",
          {
            className: "richtext-w-6 richtext-h-6 richtext-p-0.5 richtext-inline-block richtext-rounded-sm !richtext-border richtext-border-transparent richtext-flex-[0_0_auto] richtext-cursor-pointer hover:richtext-border-border hover:richtext-shadow-sm",
            onClick: () => f(p),
            children: /* @__PURE__ */ z(
              "span",
              {
                className: "richtext-relative richtext-w-[18px] richtext-h-[18px] richtext-block richtext-rounded-[2px] richtext-border-transparent",
                style: {
                  backgroundColor: p
                },
                children: /* @__PURE__ */ z(
                  "svg",
                  {
                    viewBox: "0 0 18 18",
                    style: {
                      fill: "rgb(255, 255, 255)",
                      display: "none"
                    },
                    children: /* @__PURE__ */ z("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" })
                  }
                )
              }
            )
          },
          `sub-color-recent-${m}`
        )) })
      ] }),
      /* @__PURE__ */ z(KZ, { setColor: f })
    ] }) })
  ] });
}
function KZ({ setColor: t }) {
  const [e, n] = nt("#000000"), [r, i] = nt(!1), { t: o } = Wt();
  return Tt(() => () => {
    i(!1);
  }, []), /* @__PURE__ */ Fe(Eo, { open: r, children: [
    /* @__PURE__ */ z(Co, { asChild: !0, children: /* @__PURE__ */ Fe(
      "div",
      {
        onClick: (a) => {
          a.preventDefault(), i(!0);
        },
        className: "richtext-text-sm hover:richtext-cursor-pointer hover:richtext-bg-accent richtext-py-1.5 richtext-px-1.5",
        children: [
          o("editor.color.more"),
          "..."
        ]
      }
    ) }),
    /* @__PURE__ */ Fe(oo, { children: [
      /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-flex-col richtext-items-center richtext-justify-center", children: [
        /* @__PURE__ */ z(BW, { color: e, onChange: n }),
        /* @__PURE__ */ z(
          Pr,
          {
            className: "richtext-mt-[8px] richtext-w-full",
            type: "text",
            onChange: (a) => {
              a.preventDefault(), n(`#${a.target.value}`);
            },
            value: e.slice(1)
          }
        )
      ] }),
      /* @__PURE__ */ z(aa, { className: "richtext-my-[10px]" }),
      /* @__PURE__ */ z(
        fn,
        {
          onClick: (a) => {
            a.preventDefault(), t(e), i(!1);
          },
          className: "richtext-w-full",
          children: /* @__PURE__ */ z(cF, { size: 16 })
        }
      )
    ] })
  ] });
}
var _4 = typeof global == "object" && global && global.Object === Object && global, XZ = typeof self == "object" && self && self.Object === Object && self, ba = _4 || XZ || Function("return this")(), ha = ba.Symbol, S4 = Object.prototype, YZ = S4.hasOwnProperty, JZ = S4.toString, sp = ha ? ha.toStringTag : void 0;
function ZZ(t) {
  var e = YZ.call(t, sp), n = t[sp];
  try {
    t[sp] = void 0;
    var r = !0;
  } catch {
  }
  var i = JZ.call(t);
  return r && (e ? t[sp] = n : delete t[sp]), i;
}
var QZ = Object.prototype, eQ = QZ.toString;
function tQ(t) {
  return eQ.call(t);
}
var nQ = "[object Null]", rQ = "[object Undefined]", e5 = ha ? ha.toStringTag : void 0;
function Ll(t) {
  return t == null ? t === void 0 ? rQ : nQ : e5 && e5 in Object(t) ? ZZ(t) : tQ(t);
}
function ss(t) {
  return t != null && typeof t == "object";
}
var iQ = "[object Symbol]";
function T1(t) {
  return typeof t == "symbol" || ss(t) && Ll(t) == iQ;
}
function T4(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length, i = Array(r); ++n < r; )
    i[n] = e(t[n], n, t);
  return i;
}
var pa = Array.isArray, oQ = 1 / 0, t5 = ha ? ha.prototype : void 0, n5 = t5 ? t5.toString : void 0;
function Vb(t) {
  if (typeof t == "string")
    return t;
  if (pa(t))
    return T4(t, Vb) + "";
  if (T1(t))
    return n5 ? n5.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -oQ ? "-0" : e;
}
var aQ = /\s/;
function sQ(t) {
  for (var e = t.length; e-- && aQ.test(t.charAt(e)); )
    ;
  return e;
}
var lQ = /^\s+/;
function cQ(t) {
  return t && t.slice(0, sQ(t) + 1).replace(lQ, "");
}
function El(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var r5 = NaN, uQ = /^[-+]0x[0-9a-f]+$/i, dQ = /^0b[01]+$/i, fQ = /^0o[0-7]+$/i, hQ = parseInt;
function sf(t) {
  if (typeof t == "number")
    return t;
  if (T1(t))
    return r5;
  if (El(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = El(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = cQ(t);
  var n = dQ.test(t);
  return n || fQ.test(t) ? hQ(t.slice(2), n ? 2 : 8) : uQ.test(t) ? r5 : +t;
}
var i5 = 1 / 0, pQ = 17976931348623157e292;
function mQ(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = sf(t), t === i5 || t === -i5) {
    var e = t < 0 ? -1 : 1;
    return e * pQ;
  }
  return t === t ? t : 0;
}
function gQ(t) {
  var e = mQ(t), n = e % 1;
  return e === e ? n ? e - n : e : 0;
}
function $D(t) {
  return t;
}
var yQ = "[object AsyncFunction]", bQ = "[object Function]", vQ = "[object GeneratorFunction]", wQ = "[object Proxy]";
function D4(t) {
  if (!El(t))
    return !1;
  var e = Ll(t);
  return e == bQ || e == vQ || e == yQ || e == wQ;
}
var xx = ba["__core-js_shared__"], o5 = function() {
  var t = /[^.]+$/.exec(xx && xx.keys && xx.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function xQ(t) {
  return !!o5 && o5 in t;
}
var _Q = Function.prototype, SQ = _Q.toString;
function yu(t) {
  if (t != null) {
    try {
      return SQ.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var TQ = /[\\^$.*+?()[\]{}|]/g, DQ = /^\[object .+?Constructor\]$/, EQ = Function.prototype, CQ = Object.prototype, kQ = EQ.toString, AQ = CQ.hasOwnProperty, RQ = RegExp(
  "^" + kQ.call(AQ).replace(TQ, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function IQ(t) {
  if (!El(t) || xQ(t))
    return !1;
  var e = D4(t) ? RQ : DQ;
  return e.test(yu(t));
}
function OQ(t, e) {
  return t == null ? void 0 : t[e];
}
function bu(t, e) {
  var n = OQ(t, e);
  return IQ(n) ? n : void 0;
}
var KS = bu(ba, "WeakMap");
function FQ(t, e, n) {
  switch (n.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, n[0]);
    case 2:
      return t.call(e, n[0], n[1]);
    case 3:
      return t.call(e, n[0], n[1], n[2]);
  }
  return t.apply(e, n);
}
var UQ = 800, NQ = 16, MQ = Date.now;
function BQ(t) {
  var e = 0, n = 0;
  return function() {
    var r = MQ(), i = NQ - (r - n);
    if (n = r, i > 0) {
      if (++e >= UQ)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
function LQ(t) {
  return function() {
    return t;
  };
}
var a5 = function() {
  try {
    var t = bu(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}(), PQ = a5 ? function(t, e) {
  return a5(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: LQ(e),
    writable: !0
  });
} : $D, WQ = BQ(PQ);
function zQ(t, e, n, r) {
  for (var i = t.length, o = n + -1; ++o < i; )
    if (e(t[o], o, t))
      return o;
  return -1;
}
function $Q(t) {
  return t !== t;
}
function HQ(t, e, n) {
  for (var r = n - 1, i = t.length; ++r < i; )
    if (t[r] === e)
      return r;
  return -1;
}
function jQ(t, e, n) {
  return e === e ? HQ(t, e, n) : zQ(t, $Q, n);
}
function VQ(t, e) {
  var n = t == null ? 0 : t.length;
  return !!n && jQ(t, e, 0) > -1;
}
var qQ = 9007199254740991, GQ = /^(?:0|[1-9]\d*)$/;
function E4(t, e) {
  var n = typeof t;
  return e = e ?? qQ, !!e && (n == "number" || n != "symbol" && GQ.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function C4(t, e) {
  return t === e || t !== t && e !== e;
}
var s5 = Math.max;
function KQ(t, e, n) {
  return e = s5(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var r = arguments, i = -1, o = s5(r.length - e, 0), a = Array(o); ++i < o; )
      a[i] = r[e + i];
    i = -1;
    for (var s = Array(e + 1); ++i < e; )
      s[i] = r[i];
    return s[e] = n(a), FQ(t, this, s);
  };
}
function XQ(t, e) {
  return WQ(KQ(t, e, $D), t + "");
}
var YQ = 9007199254740991;
function HD(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= YQ;
}
function k4(t) {
  return t != null && HD(t.length) && !D4(t);
}
var JQ = Object.prototype;
function ZQ(t) {
  var e = t && t.constructor, n = typeof e == "function" && e.prototype || JQ;
  return t === n;
}
function QQ(t, e) {
  for (var n = -1, r = Array(t); ++n < t; )
    r[n] = e(n);
  return r;
}
var eee = "[object Arguments]";
function l5(t) {
  return ss(t) && Ll(t) == eee;
}
var A4 = Object.prototype, tee = A4.hasOwnProperty, nee = A4.propertyIsEnumerable, jD = l5(/* @__PURE__ */ function() {
  return arguments;
}()) ? l5 : function(t) {
  return ss(t) && tee.call(t, "callee") && !nee.call(t, "callee");
};
function ree() {
  return !1;
}
var R4 = typeof exports == "object" && exports && !exports.nodeType && exports, c5 = R4 && typeof module == "object" && module && !module.nodeType && module, iee = c5 && c5.exports === R4, u5 = iee ? ba.Buffer : void 0, oee = u5 ? u5.isBuffer : void 0, XS = oee || ree, aee = "[object Arguments]", see = "[object Array]", lee = "[object Boolean]", cee = "[object Date]", uee = "[object Error]", dee = "[object Function]", fee = "[object Map]", hee = "[object Number]", pee = "[object Object]", mee = "[object RegExp]", gee = "[object Set]", yee = "[object String]", bee = "[object WeakMap]", vee = "[object ArrayBuffer]", wee = "[object DataView]", xee = "[object Float32Array]", _ee = "[object Float64Array]", See = "[object Int8Array]", Tee = "[object Int16Array]", Dee = "[object Int32Array]", Eee = "[object Uint8Array]", Cee = "[object Uint8ClampedArray]", kee = "[object Uint16Array]", Aee = "[object Uint32Array]", un = {};
un[xee] = un[_ee] = un[See] = un[Tee] = un[Dee] = un[Eee] = un[Cee] = un[kee] = un[Aee] = !0;
un[aee] = un[see] = un[vee] = un[lee] = un[wee] = un[cee] = un[uee] = un[dee] = un[fee] = un[hee] = un[pee] = un[mee] = un[gee] = un[yee] = un[bee] = !1;
function Ree(t) {
  return ss(t) && HD(t.length) && !!un[Ll(t)];
}
function VD(t) {
  return function(e) {
    return t(e);
  };
}
var I4 = typeof exports == "object" && exports && !exports.nodeType && exports, Lp = I4 && typeof module == "object" && module && !module.nodeType && module, Iee = Lp && Lp.exports === I4, _x = Iee && _4.process, qb = function() {
  try {
    var t = Lp && Lp.require && Lp.require("util").types;
    return t || _x && _x.binding && _x.binding("util");
  } catch {
  }
}(), d5 = qb && qb.isTypedArray, O4 = d5 ? VD(d5) : Ree, Oee = Object.prototype, Fee = Oee.hasOwnProperty;
function Uee(t, e) {
  var n = pa(t), r = !n && jD(t), i = !n && !r && XS(t), o = !n && !r && !i && O4(t), a = n || r || i || o, s = a ? QQ(t.length, String) : [], l = s.length;
  for (var c in t)
    Fee.call(t, c) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    o && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    E4(c, l))) && s.push(c);
  return s;
}
function Nee(t, e) {
  return function(n) {
    return t(e(n));
  };
}
var Mee = Nee(Object.keys, Object), Bee = Object.prototype, Lee = Bee.hasOwnProperty;
function Pee(t) {
  if (!ZQ(t))
    return Mee(t);
  var e = [];
  for (var n in Object(t))
    Lee.call(t, n) && n != "constructor" && e.push(n);
  return e;
}
function F4(t) {
  return k4(t) ? Uee(t) : Pee(t);
}
var Wee = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, zee = /^\w*$/;
function qD(t, e) {
  if (pa(t))
    return !1;
  var n = typeof t;
  return n == "number" || n == "symbol" || n == "boolean" || t == null || T1(t) ? !0 : zee.test(t) || !Wee.test(t) || e != null && t in Object(e);
}
var rm = bu(Object, "create");
function $ee() {
  this.__data__ = rm ? rm(null) : {}, this.size = 0;
}
function Hee(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var jee = "__lodash_hash_undefined__", Vee = Object.prototype, qee = Vee.hasOwnProperty;
function Gee(t) {
  var e = this.__data__;
  if (rm) {
    var n = e[t];
    return n === jee ? void 0 : n;
  }
  return qee.call(e, t) ? e[t] : void 0;
}
var Kee = Object.prototype, Xee = Kee.hasOwnProperty;
function Yee(t) {
  var e = this.__data__;
  return rm ? e[t] !== void 0 : Xee.call(e, t);
}
var Jee = "__lodash_hash_undefined__";
function Zee(t, e) {
  var n = this.__data__;
  return this.size += this.has(t) ? 0 : 1, n[t] = rm && e === void 0 ? Jee : e, this;
}
function Qc(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
Qc.prototype.clear = $ee;
Qc.prototype.delete = Hee;
Qc.prototype.get = Gee;
Qc.prototype.has = Yee;
Qc.prototype.set = Zee;
function Qee() {
  this.__data__ = [], this.size = 0;
}
function D1(t, e) {
  for (var n = t.length; n--; )
    if (C4(t[n][0], e))
      return n;
  return -1;
}
var ete = Array.prototype, tte = ete.splice;
function nte(t) {
  var e = this.__data__, n = D1(e, t);
  if (n < 0)
    return !1;
  var r = e.length - 1;
  return n == r ? e.pop() : tte.call(e, n, 1), --this.size, !0;
}
function rte(t) {
  var e = this.__data__, n = D1(e, t);
  return n < 0 ? void 0 : e[n][1];
}
function ite(t) {
  return D1(this.__data__, t) > -1;
}
function ote(t, e) {
  var n = this.__data__, r = D1(n, t);
  return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this;
}
function ps(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
ps.prototype.clear = Qee;
ps.prototype.delete = nte;
ps.prototype.get = rte;
ps.prototype.has = ite;
ps.prototype.set = ote;
var im = bu(ba, "Map");
function ate() {
  this.size = 0, this.__data__ = {
    hash: new Qc(),
    map: new (im || ps)(),
    string: new Qc()
  };
}
function ste(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function E1(t, e) {
  var n = t.__data__;
  return ste(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
}
function lte(t) {
  var e = E1(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function cte(t) {
  return E1(this, t).get(t);
}
function ute(t) {
  return E1(this, t).has(t);
}
function dte(t, e) {
  var n = E1(this, t), r = n.size;
  return n.set(t, e), this.size += n.size == r ? 0 : 1, this;
}
function ms(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
ms.prototype.clear = ate;
ms.prototype.delete = lte;
ms.prototype.get = cte;
ms.prototype.has = ute;
ms.prototype.set = dte;
var fte = "Expected a function";
function GD(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(fte);
  var n = function() {
    var r = arguments, i = e ? e.apply(this, r) : r[0], o = n.cache;
    if (o.has(i))
      return o.get(i);
    var a = t.apply(this, r);
    return n.cache = o.set(i, a) || o, a;
  };
  return n.cache = new (GD.Cache || ms)(), n;
}
GD.Cache = ms;
var hte = 500;
function pte(t) {
  var e = GD(t, function(r) {
    return n.size === hte && n.clear(), r;
  }), n = e.cache;
  return e;
}
var mte = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, gte = /\\(\\)?/g, yte = pte(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(mte, function(n, r, i, o) {
    e.push(i ? o.replace(gte, "$1") : r || n);
  }), e;
});
function YS(t) {
  return t == null ? "" : Vb(t);
}
function U4(t, e) {
  return pa(t) ? t : qD(t, e) ? [t] : yte(YS(t));
}
var bte = 1 / 0;
function C1(t) {
  if (typeof t == "string" || T1(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -bte ? "-0" : e;
}
function N4(t, e) {
  e = U4(e, t);
  for (var n = 0, r = e.length; t != null && n < r; )
    t = t[C1(e[n++])];
  return n && n == r ? t : void 0;
}
function vte(t, e, n) {
  var r = t == null ? void 0 : N4(t, e);
  return r === void 0 ? n : r;
}
function M4(t, e) {
  for (var n = -1, r = e.length, i = t.length; ++n < r; )
    t[i + n] = e[n];
  return t;
}
var f5 = ha ? ha.isConcatSpreadable : void 0;
function wte(t) {
  return pa(t) || jD(t) || !!(f5 && t && t[f5]);
}
function xte(t, e, n, r, i) {
  var o = -1, a = t.length;
  for (n || (n = wte), i || (i = []); ++o < a; ) {
    var s = t[o];
    n(s) && M4(i, s);
  }
  return i;
}
function _te(t, e, n) {
  var r = -1, i = t.length;
  e < 0 && (e = -e > i ? 0 : i + e), n = n > i ? i : n, n < 0 && (n += i), i = e > n ? 0 : n - e >>> 0, e >>>= 0;
  for (var o = Array(i); ++r < i; )
    o[r] = t[r + e];
  return o;
}
function Ste(t, e, n) {
  var r = t.length;
  return n = n === void 0 ? r : n, !e && n >= r ? t : _te(t, e, n);
}
var Tte = "\\ud800-\\udfff", Dte = "\\u0300-\\u036f", Ete = "\\ufe20-\\ufe2f", Cte = "\\u20d0-\\u20ff", kte = Dte + Ete + Cte, Ate = "\\ufe0e\\ufe0f", Rte = "\\u200d", Ite = RegExp("[" + Rte + Tte + kte + Ate + "]");
function KD(t) {
  return Ite.test(t);
}
function Ote(t) {
  return t.split("");
}
var B4 = "\\ud800-\\udfff", Fte = "\\u0300-\\u036f", Ute = "\\ufe20-\\ufe2f", Nte = "\\u20d0-\\u20ff", Mte = Fte + Ute + Nte, Bte = "\\ufe0e\\ufe0f", Lte = "[" + B4 + "]", JS = "[" + Mte + "]", ZS = "\\ud83c[\\udffb-\\udfff]", Pte = "(?:" + JS + "|" + ZS + ")", L4 = "[^" + B4 + "]", P4 = "(?:\\ud83c[\\udde6-\\uddff]){2}", W4 = "[\\ud800-\\udbff][\\udc00-\\udfff]", Wte = "\\u200d", z4 = Pte + "?", $4 = "[" + Bte + "]?", zte = "(?:" + Wte + "(?:" + [L4, P4, W4].join("|") + ")" + $4 + z4 + ")*", $te = $4 + z4 + zte, Hte = "(?:" + [L4 + JS + "?", JS, P4, W4, Lte].join("|") + ")", jte = RegExp(ZS + "(?=" + ZS + ")|" + Hte + $te, "g");
function Vte(t) {
  return t.match(jte) || [];
}
function qte(t) {
  return KD(t) ? Vte(t) : Ote(t);
}
function Gte(t, e, n) {
  return t === t && (n !== void 0 && (t = t <= n ? t : n), e !== void 0 && (t = t >= e ? t : e)), t;
}
function H4(t, e, n) {
  return n === void 0 && (n = e, e = void 0), n !== void 0 && (n = sf(n), n = n === n ? n : 0), e !== void 0 && (e = sf(e), e = e === e ? e : 0), Gte(sf(t), e, n);
}
function Kte() {
  this.__data__ = new ps(), this.size = 0;
}
function Xte(t) {
  var e = this.__data__, n = e.delete(t);
  return this.size = e.size, n;
}
function Yte(t) {
  return this.__data__.get(t);
}
function Jte(t) {
  return this.__data__.has(t);
}
var Zte = 200;
function Qte(t, e) {
  var n = this.__data__;
  if (n instanceof ps) {
    var r = n.__data__;
    if (!im || r.length < Zte - 1)
      return r.push([t, e]), this.size = ++n.size, this;
    n = this.__data__ = new ms(r);
  }
  return n.set(t, e), this.size = n.size, this;
}
function is(t) {
  var e = this.__data__ = new ps(t);
  this.size = e.size;
}
is.prototype.clear = Kte;
is.prototype.delete = Xte;
is.prototype.get = Yte;
is.prototype.has = Jte;
is.prototype.set = Qte;
function ene(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length, i = 0, o = []; ++n < r; ) {
    var a = t[n];
    e(a, n, t) && (o[i++] = a);
  }
  return o;
}
function tne() {
  return [];
}
var nne = Object.prototype, rne = nne.propertyIsEnumerable, h5 = Object.getOwnPropertySymbols, ine = h5 ? function(t) {
  return t == null ? [] : (t = Object(t), ene(h5(t), function(e) {
    return rne.call(t, e);
  }));
} : tne;
function one(t, e, n) {
  var r = e(t);
  return pa(t) ? r : M4(r, n(t));
}
function p5(t) {
  return one(t, F4, ine);
}
var QS = bu(ba, "DataView"), eT = bu(ba, "Promise"), tT = bu(ba, "Set"), m5 = "[object Map]", ane = "[object Object]", g5 = "[object Promise]", y5 = "[object Set]", b5 = "[object WeakMap]", v5 = "[object DataView]", sne = yu(QS), lne = yu(im), cne = yu(eT), une = yu(tT), dne = yu(KS), ol = Ll;
(QS && ol(new QS(new ArrayBuffer(1))) != v5 || im && ol(new im()) != m5 || eT && ol(eT.resolve()) != g5 || tT && ol(new tT()) != y5 || KS && ol(new KS()) != b5) && (ol = function(t) {
  var e = Ll(t), n = e == ane ? t.constructor : void 0, r = n ? yu(n) : "";
  if (r)
    switch (r) {
      case sne:
        return v5;
      case lne:
        return m5;
      case cne:
        return g5;
      case une:
        return y5;
      case dne:
        return b5;
    }
  return e;
});
var w5 = ba.Uint8Array, fne = "__lodash_hash_undefined__";
function hne(t) {
  return this.__data__.set(t, fne), this;
}
function pne(t) {
  return this.__data__.has(t);
}
function om(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.__data__ = new ms(); ++e < n; )
    this.add(t[e]);
}
om.prototype.add = om.prototype.push = hne;
om.prototype.has = pne;
function mne(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length; ++n < r; )
    if (e(t[n], n, t))
      return !0;
  return !1;
}
function j4(t, e) {
  return t.has(e);
}
var gne = 1, yne = 2;
function V4(t, e, n, r, i, o) {
  var a = n & gne, s = t.length, l = e.length;
  if (s != l && !(a && l > s))
    return !1;
  var c = o.get(t), u = o.get(e);
  if (c && u)
    return c == e && u == t;
  var d = -1, f = !0, p = n & yne ? new om() : void 0;
  for (o.set(t, e), o.set(e, t); ++d < s; ) {
    var m = t[d], g = e[d];
    if (r)
      var b = a ? r(g, m, d, e, t, o) : r(m, g, d, t, e, o);
    if (b !== void 0) {
      if (b)
        continue;
      f = !1;
      break;
    }
    if (p) {
      if (!mne(e, function(y, w) {
        if (!j4(p, w) && (m === y || i(m, y, n, r, o)))
          return p.push(w);
      })) {
        f = !1;
        break;
      }
    } else if (!(m === g || i(m, g, n, r, o))) {
      f = !1;
      break;
    }
  }
  return o.delete(t), o.delete(e), f;
}
function bne(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r, i) {
    n[++e] = [i, r];
  }), n;
}
function vne(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r) {
    n[++e] = r;
  }), n;
}
var wne = 1, xne = 2, _ne = "[object Boolean]", Sne = "[object Date]", Tne = "[object Error]", Dne = "[object Map]", Ene = "[object Number]", Cne = "[object RegExp]", kne = "[object Set]", Ane = "[object String]", Rne = "[object Symbol]", Ine = "[object ArrayBuffer]", One = "[object DataView]", x5 = ha ? ha.prototype : void 0, Sx = x5 ? x5.valueOf : void 0;
function Fne(t, e, n, r, i, o, a) {
  switch (n) {
    case One:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case Ine:
      return !(t.byteLength != e.byteLength || !o(new w5(t), new w5(e)));
    case _ne:
    case Sne:
    case Ene:
      return C4(+t, +e);
    case Tne:
      return t.name == e.name && t.message == e.message;
    case Cne:
    case Ane:
      return t == e + "";
    case Dne:
      var s = bne;
    case kne:
      var l = r & wne;
      if (s || (s = vne), t.size != e.size && !l)
        return !1;
      var c = a.get(t);
      if (c)
        return c == e;
      r |= xne, a.set(t, e);
      var u = V4(s(t), s(e), r, i, o, a);
      return a.delete(t), u;
    case Rne:
      if (Sx)
        return Sx.call(t) == Sx.call(e);
  }
  return !1;
}
var Une = 1, Nne = Object.prototype, Mne = Nne.hasOwnProperty;
function Bne(t, e, n, r, i, o) {
  var a = n & Une, s = p5(t), l = s.length, c = p5(e), u = c.length;
  if (l != u && !a)
    return !1;
  for (var d = l; d--; ) {
    var f = s[d];
    if (!(a ? f in e : Mne.call(e, f)))
      return !1;
  }
  var p = o.get(t), m = o.get(e);
  if (p && m)
    return p == e && m == t;
  var g = !0;
  o.set(t, e), o.set(e, t);
  for (var b = a; ++d < l; ) {
    f = s[d];
    var y = t[f], w = e[f];
    if (r)
      var x = a ? r(w, y, f, e, t, o) : r(y, w, f, t, e, o);
    if (!(x === void 0 ? y === w || i(y, w, n, r, o) : x)) {
      g = !1;
      break;
    }
    b || (b = f == "constructor");
  }
  if (g && !b) {
    var k = t.constructor, A = e.constructor;
    k != A && "constructor" in t && "constructor" in e && !(typeof k == "function" && k instanceof k && typeof A == "function" && A instanceof A) && (g = !1);
  }
  return o.delete(t), o.delete(e), g;
}
var Lne = 1, _5 = "[object Arguments]", S5 = "[object Array]", ey = "[object Object]", Pne = Object.prototype, T5 = Pne.hasOwnProperty;
function Wne(t, e, n, r, i, o) {
  var a = pa(t), s = pa(e), l = a ? S5 : ol(t), c = s ? S5 : ol(e);
  l = l == _5 ? ey : l, c = c == _5 ? ey : c;
  var u = l == ey, d = c == ey, f = l == c;
  if (f && XS(t)) {
    if (!XS(e))
      return !1;
    a = !0, u = !1;
  }
  if (f && !u)
    return o || (o = new is()), a || O4(t) ? V4(t, e, n, r, i, o) : Fne(t, e, l, n, r, i, o);
  if (!(n & Lne)) {
    var p = u && T5.call(t, "__wrapped__"), m = d && T5.call(e, "__wrapped__");
    if (p || m) {
      var g = p ? t.value() : t, b = m ? e.value() : e;
      return o || (o = new is()), i(g, b, n, r, o);
    }
  }
  return f ? (o || (o = new is()), Bne(t, e, n, r, i, o)) : !1;
}
function XD(t, e, n, r, i) {
  return t === e ? !0 : t == null || e == null || !ss(t) && !ss(e) ? t !== t && e !== e : Wne(t, e, n, r, XD, i);
}
var zne = 1, $ne = 2;
function Hne(t, e, n, r) {
  var i = n.length, o = i;
  if (t == null)
    return !o;
  for (t = Object(t); i--; ) {
    var a = n[i];
    if (a[2] ? a[1] !== t[a[0]] : !(a[0] in t))
      return !1;
  }
  for (; ++i < o; ) {
    a = n[i];
    var s = a[0], l = t[s], c = a[1];
    if (a[2]) {
      if (l === void 0 && !(s in t))
        return !1;
    } else {
      var u = new is(), d;
      if (!(d === void 0 ? XD(c, l, zne | $ne, r, u) : d))
        return !1;
    }
  }
  return !0;
}
function q4(t) {
  return t === t && !El(t);
}
function jne(t) {
  for (var e = F4(t), n = e.length; n--; ) {
    var r = e[n], i = t[r];
    e[n] = [r, i, q4(i)];
  }
  return e;
}
function G4(t, e) {
  return function(n) {
    return n == null ? !1 : n[t] === e && (e !== void 0 || t in Object(n));
  };
}
function Vne(t) {
  var e = jne(t);
  return e.length == 1 && e[0][2] ? G4(e[0][0], e[0][1]) : function(n) {
    return n === t || Hne(n, t, e);
  };
}
function qne(t, e) {
  return t != null && e in Object(t);
}
function Gne(t, e, n) {
  e = U4(e, t);
  for (var r = -1, i = e.length, o = !1; ++r < i; ) {
    var a = C1(e[r]);
    if (!(o = t != null && n(t, a)))
      break;
    t = t[a];
  }
  return o || ++r != i ? o : (i = t == null ? 0 : t.length, !!i && HD(i) && E4(a, i) && (pa(t) || jD(t)));
}
function Kne(t, e) {
  return t != null && Gne(t, e, qne);
}
var Xne = 1, Yne = 2;
function Jne(t, e) {
  return qD(t) && q4(e) ? G4(C1(t), e) : function(n) {
    var r = vte(n, t);
    return r === void 0 && r === e ? Kne(n, t) : XD(e, r, Xne | Yne);
  };
}
function K4(t) {
  return function(e) {
    return e == null ? void 0 : e[t];
  };
}
function Zne(t) {
  return function(e) {
    return N4(e, t);
  };
}
function Qne(t) {
  return qD(t) ? K4(C1(t)) : Zne(t);
}
function ere(t) {
  return typeof t == "function" ? t : t == null ? $D : typeof t == "object" ? pa(t) ? Jne(t[0], t[1]) : Vne(t) : Qne(t);
}
var Tx = function() {
  return ba.Date.now();
}, tre = "Expected a function", nre = Math.max, rre = Math.min;
function k1(t, e, n) {
  var r, i, o, a, s, l, c = 0, u = !1, d = !1, f = !0;
  if (typeof t != "function")
    throw new TypeError(tre);
  e = sf(e) || 0, El(n) && (u = !!n.leading, d = "maxWait" in n, o = d ? nre(sf(n.maxWait) || 0, e) : o, f = "trailing" in n ? !!n.trailing : f);
  function p(U) {
    var P = r, V = i;
    return r = i = void 0, c = U, a = t.apply(V, P), a;
  }
  function m(U) {
    return c = U, s = setTimeout(y, e), u ? p(U) : a;
  }
  function g(U) {
    var P = U - l, V = U - c, I = e - P;
    return d ? rre(I, o - V) : I;
  }
  function b(U) {
    var P = U - l, V = U - c;
    return l === void 0 || P >= e || P < 0 || d && V >= o;
  }
  function y() {
    var U = Tx();
    if (b(U))
      return w(U);
    s = setTimeout(y, g(U));
  }
  function w(U) {
    return s = void 0, f && r ? p(U) : (r = i = void 0, a);
  }
  function x() {
    s !== void 0 && clearTimeout(s), c = 0, r = l = i = s = void 0;
  }
  function k() {
    return s === void 0 ? a : w(Tx());
  }
  function A() {
    var U = Tx(), P = b(U);
    if (r = arguments, i = this, l = U, P) {
      if (s === void 0)
        return m(l);
      if (d)
        return clearTimeout(s), s = setTimeout(y, e), p(l);
    }
    return s === void 0 && (s = setTimeout(y, e)), a;
  }
  return A.cancel = x, A.flush = k, A;
}
function Dx(t) {
  return ss(t) && k4(t);
}
var ire = 200;
function ore(t, e, n, r) {
  var i = -1, o = VQ, a = !0, s = t.length, l = [], c = e.length;
  if (!s)
    return l;
  n && (e = T4(e, VD(n))), e.length >= ire && (o = j4, a = !1, e = new om(e));
  e:
    for (; ++i < s; ) {
      var u = t[i], d = n == null ? u : n(u);
      if (u = u !== 0 ? u : 0, a && d === d) {
        for (var f = c; f--; )
          if (e[f] === d)
            continue e;
        l.push(u);
      } else o(e, d, r) || l.push(u);
    }
  return l;
}
function are(t) {
  var e = t == null ? 0 : t.length;
  return e ? t[e - 1] : void 0;
}
var sre = XQ(function(t, e) {
  var n = are(e);
  return Dx(n) && (n = void 0), Dx(t) ? ore(t, xte(e, 1, Dx), ere(n)) : [];
}), lre = "[object Number]";
function Gb(t) {
  return typeof t == "number" || ss(t) && Ll(t) == lre;
}
var cre = "[object RegExp]";
function ure(t) {
  return ss(t) && Ll(t) == cre;
}
var D5 = qb && qb.isRegExp, dre = D5 ? VD(D5) : ure, fre = K4("length"), X4 = "\\ud800-\\udfff", hre = "\\u0300-\\u036f", pre = "\\ufe20-\\ufe2f", mre = "\\u20d0-\\u20ff", gre = hre + pre + mre, yre = "\\ufe0e\\ufe0f", bre = "[" + X4 + "]", nT = "[" + gre + "]", rT = "\\ud83c[\\udffb-\\udfff]", vre = "(?:" + nT + "|" + rT + ")", Y4 = "[^" + X4 + "]", J4 = "(?:\\ud83c[\\udde6-\\uddff]){2}", Z4 = "[\\ud800-\\udbff][\\udc00-\\udfff]", wre = "\\u200d", Q4 = vre + "?", eN = "[" + yre + "]?", xre = "(?:" + wre + "(?:" + [Y4, J4, Z4].join("|") + ")" + eN + Q4 + ")*", _re = eN + Q4 + xre, Sre = "(?:" + [Y4 + nT + "?", nT, J4, Z4, bre].join("|") + ")", E5 = RegExp(rT + "(?=" + rT + ")|" + Sre + _re, "g");
function Tre(t) {
  for (var e = E5.lastIndex = 0; E5.test(t); )
    ++e;
  return e;
}
function Dre(t) {
  return KD(t) ? Tre(t) : fre(t);
}
var Ere = "Expected a function";
function am(t, e, n) {
  var r = !0, i = !0;
  if (typeof t != "function")
    throw new TypeError(Ere);
  return El(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), k1(t, e, {
    leading: r,
    maxWait: e,
    trailing: i
  });
}
var Cre = 30, kre = "...", Are = /\w*$/;
function Rre(t, e) {
  var n = Cre, r = kre;
  if (El(e)) {
    var i = "separator" in e ? e.separator : i;
    n = "length" in e ? gQ(e.length) : n, r = "omission" in e ? Vb(e.omission) : r;
  }
  t = YS(t);
  var o = t.length;
  if (KD(t)) {
    var a = qte(t);
    o = a.length;
  }
  if (n >= o)
    return t;
  var s = n - Dre(r);
  if (s < 1)
    return r;
  var l = a ? Ste(a, 0, s).join("") : t.slice(0, s);
  if (i === void 0)
    return l + r;
  if (a && (s += l.length - s), dre(i)) {
    if (t.slice(s).search(i)) {
      var c, u = l;
      for (i.global || (i = RegExp(i.source, YS(Are.exec(i)) + "g")), i.lastIndex = 0; c = i.exec(u); )
        var d = c.index;
      l = l.slice(0, d === void 0 ? s : d);
    }
  } else if (t.indexOf(Vb(i), s) != s) {
    var f = l.lastIndexOf(i);
    f > -1 && (l = l.slice(0, f));
  }
  return l + r;
}
function Ire() {
  const { toasts: t } = f4();
  return /* @__PURE__ */ Fe(VJ, { children: [
    t.map(({ id: e, title: n, description: r, action: i, ...o }) => /* @__PURE__ */ Fe(l4, { ...o, children: [
      /* @__PURE__ */ Fe("div", { className: "richtext-grid richtext-gap-1", children: [
        n && /* @__PURE__ */ z(u4, { children: n }),
        r && /* @__PURE__ */ z(d4, { children: r })
      ] }),
      i,
      /* @__PURE__ */ z(c4, {})
    ] }, e)),
    /* @__PURE__ */ z(s4, {})
  ] });
}
const Ore = `
.reactjs-tiptap-editor, .richtext-dialog-content {
  button,
  input:where([type=button]),
  input:where([type=reset]),
  input:where([type=submit]) {
    -webkit-appearance: button;
    background-color: transparent;
    background-image: none
  }

  input,
  optgroup,
  select,
  textarea {
    font-family: inherit;
    font-feature-settings: inherit;
    font-variation-settings: inherit;
    font-size: 100%;
    font-weight: inherit;
    line-height: inherit;
    letter-spacing: inherit;
    color: inherit;
  }

  button {
    font-family: inherit;
    font-feature-settings: inherit;
    font-variation-settings: inherit;
    font-size: 100%;
    font-weight: inherit;
    line-height: inherit;
    letter-spacing: inherit;
    color: inherit;
  }
}

.reactjs-tiptap-editor,
.richtext-dialog-content,
div[data-radix-popper-content-wrapper],
div[data-tippy-root] {
*,
:before,
:after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
  border-color: hsl(var(--richtext-border));
}

background-color: hsl(var(--richtext-background));
color: hsl(var(--richtext-foreground));


html,
:host {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  -moz-tab-size: 4;
  tab-size: 4;
  font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", Segoe UI Symbol, "Noto Color Emoji";
  font-feature-settings: normal;
  font-variation-settings: normal;
  -webkit-tap-highlight-color: transparent
}

hr {
  height: 0;
  color: inherit;
  border-top-width: 1px
}

a {
  color: inherit;
  text-decoration: inherit
}

b,
strong {
  font-weight: bolder
}

code,
kbd,
samp,
pre {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;
  font-feature-settings: normal;
  font-variation-settings: normal;
  font-size: 1em
}

table {
  text-indent: 0;
  border-color: inherit;
  border-collapse: collapse
}

input, textarea {
  border-width: 1px;
}

textarea {
  resize: vertical
}

input::placeholder,
textarea::placeholder {
  opacity: 1;
  color: #9ca3af
}

button, input, textarea {
  cursor: pointer;
  color: inherit;
}

img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block;
  vertical-align: middle
}

img,
video {
  max-width: 100%;
  height: auto
}
}
`, Fre = $m("light"), Ure = {
  setTheme: (t) => {
    Fre.set(t);
  }
}, Nre = (t) => typeof t == "number", Mre = (t) => typeof t == "string", Bre = (t) => typeof t == "function";
function Lre(t, e = "px") {
  if (!t)
    return t;
  const n = Nre(t) ? String(t) : t, r = Number.parseFloat(n), i = n.match(/[a-z%]+$/i), o = i ? i[0] : e;
  return Number.isNaN(r) ? t : r + o;
}
function tN(t, e) {
  if (!t)
    return !1;
  const { extensions: n = [] } = (t == null ? void 0 : t.extensionManager) ?? {};
  return !!n.find((i) => i.name === e);
}
function iT(t) {
  return t.map((e) => Mre(e) ? { value: e, name: e } : e);
}
const C5 = "data-rc-order", k5 = "data-rc-priority", Pre = "rc-util-key", oT = /* @__PURE__ */ new Map();
function Wre(t, e) {
  if (!t)
    return !1;
  if (t.contains)
    return t.contains(e);
  let n = e;
  for (; n; ) {
    if (n === t)
      return !0;
    n = n.parentNode;
  }
  return !1;
}
function nN({ mark: t } = {}) {
  return t ? t.startsWith("data-") ? t : `data-${t}` : Pre;
}
function YD(t) {
  return t.attachTo ? t.attachTo : document.querySelector("head") || document.body;
}
function zre(t) {
  return t === "queue" ? "prependQueue" : t ? "prepend" : "append";
}
function rN(t) {
  return [...(oT.get(t) || t).children].filter(
    (e) => e.tagName === "STYLE"
  );
}
function iN(t, e = {}) {
  const { csp: n, prepend: r, priority: i = 0 } = e, o = zre(r), a = o === "prependQueue", s = document.createElement("style");
  s.setAttribute(C5, o), a && i && s.setAttribute(k5, `${i}`), n != null && n.nonce && (s.nonce = n == null ? void 0 : n.nonce), s.innerHTML = t;
  const l = YD(e), { firstChild: c } = l;
  if (r) {
    if (a) {
      const u = rN(l).filter((d) => {
        if (!["prepend", "prependQueue"].includes(d.getAttribute(C5)))
          return !1;
        const f = Number(d.getAttribute(k5) || 0);
        return i >= f;
      });
      if (u.length > 0)
        return l.insertBefore(s, u.at(-1).nextSibling), s;
    }
    c.before(s);
  } else
    l.append(s);
  return s;
}
function oN(t, e = {}) {
  const n = YD(e);
  return rN(n).find((r) => r.getAttribute(nN(e)) === t);
}
function $re(t, e = {}) {
  const n = oN(t, e);
  n && n.remove();
}
function Hre(t, e) {
  const n = oT.get(t);
  if (!n || !Wre(document, n)) {
    const r = iN("", e), { parentNode: i } = r;
    oT.set(t, i), r.remove();
  }
}
function jre(t, e, n = {}) {
  var a, s, l;
  const r = YD(n);
  Hre(r, n);
  const i = oN(e, n);
  if (i)
    return (a = n.csp) != null && a.nonce && i.nonce !== ((s = n.csp) == null ? void 0 : s.nonce) && (i.nonce = (l = n.csp) == null ? void 0 : l.nonce), i.innerHTML !== t && (i.innerHTML = t), i;
  const o = iN(t, n);
  return o.setAttribute(nN(n), e), o;
}
function Vre({ editor: t, extensions: e }) {
  const { t: n } = Wt(), r = Yt(() => {
    var i, o, a;
    return (a = (o = (i = e == null ? void 0 : e.find((s) => s.name === "base-kit")) == null ? void 0 : i.options) == null ? void 0 : o.characterCount) == null ? void 0 : a.limit;
  }, [e]);
  return r ? /* @__PURE__ */ z("div", { className: "richtext-flex richtext-items-center richtext-justify-between richtext-p-3 richtext-border-t", children: /* @__PURE__ */ z("div", { className: "richtext-flex richtext-flex-col", children: /* @__PURE__ */ z("div", { className: "richtext-flex richtext-justify-end richtext-gap-3 richtext-text-sm", children: /* @__PURE__ */ Fe("span", { children: [
    t.storage.characterCount.characters(),
    "/",
    r,
    " ",
    n("editor.characters")
  ] }) }) }) }) : /* @__PURE__ */ z("div", { className: "richtext-flex richtext-items-center richtext-justify-between richtext-p-3 richtext-border-t", children: /* @__PURE__ */ z("div", { className: "richtext-flex richtext-flex-col", children: /* @__PURE__ */ z("div", { className: "richtext-flex richtext-justify-end richtext-gap-3 richtext-text-sm", children: /* @__PURE__ */ Fe("span", { children: [
    t.storage.characterCount.characters(),
    " ",
    n("editor.characters")
  ] }) }) }) });
}
function qre(t, e) {
  const { content: n, extensions: r, useEditorOptions: i = {} } = t, o = Yt(() => {
    const u = sre(r, r, "name");
    return [...r.map((f) => {
      const p = r.find((m) => m.name === f.name);
      return p ? f.configure(p.options) : f;
    }), ...u].map((f, p) => f.configure({ sort: p }));
  }, [r]), a = am((u) => {
    var f;
    const d = l(u, t.output);
    (f = t == null ? void 0 : t.onChangeContent) == null || f.call(t, d);
  }, DZ), s = $q({
    extensions: o,
    content: n,
    onUpdate: ({ editor: u }) => {
      a && a(u);
    },
    ...i
  });
  Kv(e, () => ({
    editor: s
  })), Tt(() => {
    document.documentElement.classList.toggle("dark", t.dark), Ure.setTheme(t.dark ? "dark" : "light");
  }, [t.dark]), Tt(() => {
    s == null || s.setEditable(!(t != null && t.disabled)), PZ.setDisable(!(t != null && t.disabled));
  }, [s, t == null ? void 0 : t.disabled]), Tt(() => ((t == null ? void 0 : t.resetCSS) !== !1 && jre(Ore, "react-tiptap-reset"), () => {
    $re("react-tiptap-reset");
  }), [t == null ? void 0 : t.resetCSS]);
  function l(u, d) {
    return t != null && t.removeDefaultWrapper ? d === "html" ? u.isEmpty ? "" : u.getHTML() : d === "json" ? u.isEmpty ? {} : u.getJSON() : d === "text" ? u.isEmpty ? "" : u.getText() : "" : d === "html" ? u.getHTML() : d === "json" ? u.getJSON() : d === "text" ? u.getText() : "";
  }
  Tt(() => () => {
    var u;
    (u = s == null ? void 0 : s.destroy) == null || u.call(s);
  }, []);
  const c = tN(s, "characterCount");
  return s ? /* @__PURE__ */ Fe("div", { className: "reactjs-tiptap-editor", children: [
    /* @__PURE__ */ z(XJ, { delayDuration: 0, disableHoverableContent: !0, children: /* @__PURE__ */ z("div", { className: "richtext-rounded-[0.5rem] richtext-bg-background richtext-shadow richtext-overflow-hidden richtext-outline richtext-outline-1", children: /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-flex-col richtext-w-full richtext-max-h-full", children: [
      !(t != null && t.hideToolbar) && /* @__PURE__ */ z(Gre, { editor: s, disabled: !!(t != null && t.disabled), toolbar: t.toolbar }),
      /* @__PURE__ */ z(Iq, { className: `richtext-relative ${(t == null ? void 0 : t.contentClass) || ""}`, editor: s }),
      c && /* @__PURE__ */ z(Vre, { editor: s, extensions: r }),
      !(t != null && t.hideBubble) && /* @__PURE__ */ z(GZ, { bubbleMenu: t == null ? void 0 : t.bubbleMenu, editor: s, disabled: t == null ? void 0 : t.disabled })
    ] }) }) }),
    /* @__PURE__ */ z(Ire, {})
  ] }) : /* @__PURE__ */ z(pn, {});
}
const v2e = Om(qre);
function Gre({ editor: t, disabled: e, toolbar: n }) {
  const { t: r, lang: i } = Wt(), o = Yt(() => {
    const c = [...t.extensionManager.extensions].sort((d, f) => {
      const p = d.options.sort ?? -1, m = f.options.sort ?? -1;
      return p - m;
    });
    let u = [];
    for (const d of c) {
      const {
        button: f,
        divider: p = !1,
        spacer: m = !1,
        toolbar: g = !0
      } = d.options;
      if (!f || !Bre(f) || !g)
        continue;
      const b = f({
        editor: t,
        extension: d,
        t: r
      });
      if (Array.isArray(b)) {
        const y = b.map((w, x) => ({
          button: w,
          divider: x === b.length - 1 ? p : !1,
          spacer: x === 0 ? m : !1,
          type: d.type,
          name: d.name
        }));
        u = [...u, ...y];
        continue;
      }
      u.push({
        button: b,
        divider: p,
        spacer: m,
        type: d.type,
        name: d.name
      });
    }
    return u;
  }, [t, r, i]), a = (l) => /* @__PURE__ */ z(
    "div",
    {
      className: "richtext-px-1 richtext-py-2 !richtext-border-b",
      style: {
        pointerEvents: e ? "none" : "auto",
        opacity: e ? 0.5 : 1
      },
      children: /* @__PURE__ */ z("div", { className: "richtext-relative richtext-flex richtext-flex-wrap richtext-h-auto richtext-gap-y-1 richtext-gap-x-1", children: l })
    }
  ), s = o.map((l, c) => {
    var d, f;
    const u = l.button.component;
    return /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-items-center", children: [
      (l == null ? void 0 : l.spacer) && /* @__PURE__ */ z(aa, { orientation: "vertical", className: "!richtext-h-[16px] !richtext-mx-[10px]" }),
      /* @__PURE__ */ z(
        u,
        {
          ...l.button.componentProps,
          disabled: e || ((f = (d = l == null ? void 0 : l.button) == null ? void 0 : d.componentProps) == null ? void 0 : f.disabled)
        }
      ),
      (l == null ? void 0 : l.divider) && /* @__PURE__ */ z(aa, { orientation: "vertical", className: "!richtext-h-auto !richtext-mx-2" })
    ] }, `toolbar-item-${c}`);
  });
  return n && (n != null && n.render) ? n.render({ editor: t, disabled: e || !1 }, o, s, a) : a(s);
}
function Kre(t) {
  return /* @__PURE__ */ z("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...t, children: /* @__PURE__ */ z(
    "path",
    {
      fill: "currentColor",
      d: "M19 12h-2v3h-3v2h5zM7 9h3V7H5v5h2zm14-6H3a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2m0 16H3V5h18z"
    }
  ) });
}
function Xre(t) {
  return /* @__PURE__ */ z("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...t, children: /* @__PURE__ */ z(
    "path",
    {
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeWidth: "2",
      d: "M6 15h15m0 4H6m9-8h6m0-4h-6M9 9h1a1 1 0 1 1-1 1V7.5a2 2 0 0 1 2-2M3 9h1a1 1 0 1 1-1 1V7.5a2 2 0 0 1 2-2"
    }
  ) });
}
function Yre() {
  return /* @__PURE__ */ z(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      xmlnsXlink: "http://www.w3.org/1999/xlink",
      "aria-hidden": "true",
      role: "img",
      className: "richtext-w-4 richtext-h-4",
      width: "1em",
      height: "1em",
      viewBox: "0 0 24 24",
      children: /* @__PURE__ */ z(
        "path",
        {
          fill: "none",
          stroke: "currentColor",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "1.5",
          d: "M5.5 3c1.404 0 2.107 0 2.611.38c.219.164.406.375.552.62C9 4.568 9 5.358 9 6.938v10.125c0 1.58 0 2.37-.337 2.937a2.1 2.1 0 0 1-.552.621c-.504.38-1.207.38-2.611.38s-2.107 0-2.611-.38a2.1 2.1 0 0 1-.552-.62C2 19.432 2 18.642 2 17.062V6.938c0-1.58 0-2.37.337-2.938a2.1 2.1 0 0 1 .552-.62C3.393 3 4.096 3 5.5 3M20 11.938v5.124c0 1.58 0 2.37-.337 2.938a2.1 2.1 0 0 1-.552.62c-.504.38-1.207.38-2.611.38s-2.107 0-2.611-.38a2.1 2.1 0 0 1-.552-.62C13 19.433 13 18.642 13 17.063V6.938c0-1.58 0-2.37.337-2.938M22 9l-6-6m6 0l-6 6",
          color: "currentColor"
        }
      )
    }
  );
}
function Jre() {
  return /* @__PURE__ */ z(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      xmlnsXlink: "http://www.w3.org/1999/xlink",
      "aria-hidden": "true",
      role: "img",
      className: "richtext-w-4 richtext-h-4",
      width: "1em",
      height: "1em",
      viewBox: "0 0 24 24",
      children: /* @__PURE__ */ z(
        "path",
        {
          fill: "none",
          stroke: "currentColor",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "1.5",
          d: "M21 18.5c0 1.404 0 2.107-.38 2.611a2.1 2.1 0 0 1-.62.552c-.567.337-1.358.337-2.937.337H6.938c-1.58 0-2.37 0-2.938-.337a2.1 2.1 0 0 1-.62-.552C3 20.607 3 19.904 3 18.5s0-2.107.38-2.611c.163-.218.374-.406.62-.552C4.567 15 5.357 15 6.938 15h10.125c1.58 0 2.37 0 2.937.337c.246.146.457.334.62.552c.38.504.38 1.207.38 2.611M12.063 4H6.937C5.358 4 4.568 4 4 4.337a2.1 2.1 0 0 0-.62.552C3 5.393 3 6.096 3 7.5s0 2.107.38 2.611c.163.218.374.406.62.552C4.567 11 5.357 11 6.938 11h10.125c1.58 0 2.37 0 2.937-.337M21 8l-6-6m6 0l-6 6",
          color: "currentColor"
        }
      )
    }
  );
}
function Zre(t) {
  return /* @__PURE__ */ z("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...t, children: /* @__PURE__ */ z(
    "path",
    {
      fill: "currentColor",
      d: "M14 2H6a2 2 0 0 0-2 2v16c0 1.11.89 2 2 2h12c1.11 0 2-.89 2-2V8zm4 18H6V4h7v5h5zm-.65-10l-2.1 9h-1.4l-1.8-6.79l-1.8 6.79h-1.4l-2.2-9h1.5l1.4 6.81l1.8-6.81h1.3l1.8 6.81l1.4-6.81z"
    }
  ) });
}
function $t(t) {
  const e = Hm[t.name];
  return e ? /* @__PURE__ */ z(e, { onClick: t == null ? void 0 : t.onClick, className: `richtext-w-4 richtext-h-4 ${(t == null ? void 0 : t.className) || ""}` }) : null;
}
function Qre(t) {
  return /* @__PURE__ */ z("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...t, children: /* @__PURE__ */ z(
    "path",
    {
      fill: "currentColor",
      d: "M21 22H3v-2h18zm0-18H3V2h18zm-11 9.7h4l-2-5.4zM11.2 6h1.7l4.7 12h-2l-.9-2.6H9.4L8.5 18h-2z"
    }
  ) });
}
function aN(t) {
  return /* @__PURE__ */ z(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      xmlnsXlink: "http://www.w3.org/1999/xlink",
      "aria-hidden": "true",
      role: "img",
      width: "1em",
      height: "1em",
      viewBox: "0 0 48 48",
      ...t,
      children: /* @__PURE__ */ z(
        "path",
        {
          fill: "currentColor",
          stroke: "currentColor",
          strokeLinejoin: "round",
          strokeWidth: 4,
          d: "M36 19L24 31L12 19z"
        }
      )
    }
  );
}
function eie(t) {
  return /* @__PURE__ */ z("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...t, children: /* @__PURE__ */ z("path", { fill: "currentColor", d: "M9 7v10h6v-2h-4V7z" }) });
}
function tie(t) {
  return /* @__PURE__ */ z("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...t, children: /* @__PURE__ */ z(
    "path",
    {
      fill: "currentColor",
      d: "M9 7c-1.1 0-2 .9-2 2v8h2V9h2v7h2V9h2v8h2V9a2 2 0 0 0-2-2z"
    }
  ) });
}
function nie(t) {
  return /* @__PURE__ */ z("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", ...t, children: /* @__PURE__ */ z(
    "path",
    {
      fill: "currentColor",
      d: "M11 7c-1.1 0-2 .9-2 2v2a2 2 0 0 0 2 2h2v2H9v2h4c1.11 0 2-.89 2-2v-2a2 2 0 0 0-2-2h-2V9h4V7z"
    }
  ) });
}
function rie() {
  return /* @__PURE__ */ z(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      xmlnsXlink: "http://www.w3.org/1999/xlink",
      "aria-hidden": "true",
      role: "img",
      width: "1em",
      height: "1em",
      viewBox: "0 0 24 24",
      children: /* @__PURE__ */ z(
        "path",
        {
          fill: "currentColor",
          d: "M14 2H6a2 2 0 0 0-2 2v16c0 1.11.89 2 2 2h12c1.11 0 2-.89 2-2V8zm4 18H6V4h7v5h5zm-.65-10l-2.1 9h-1.4l-1.8-6.79l-1.8 6.79h-1.4l-2.2-9h1.5l1.4 6.81l1.8-6.81h1.3l1.8 6.81l1.4-6.81z"
        }
      )
    }
  );
}
function sN() {
  return /* @__PURE__ */ Fe("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 32 32", children: [
    /* @__PURE__ */ z("path", { fill: "currentColor", d: "M30 18v-2h-6v10h2v-4h3v-2h-3v-2zm-11 8h-4V16h4a3.003 3.003 0 0 1 3 3v4a3.003 3.003 0 0 1-3 3m-2-2h2a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1h-2zm-6-8H6v10h2v-3h3a2.003 2.003 0 0 0 2-2v-3a2 2 0 0 0-2-2m-3 5v-3h3l.001 3z" }),
    /* @__PURE__ */ z("path", { fill: "currentColor", d: "M22 14v-4a.91.91 0 0 0-.3-.7l-7-7A.9.9 0 0 0 14 2H4a2.006 2.006 0 0 0-2 2v24a2 2 0 0 0 2 2h16v-2H4V4h8v6a2.006 2.006 0 0 0 2 2h6v2Zm-8-4V4.4l5.6 5.6Z" })
  ] });
}
function lN() {
  return /* @__PURE__ */ Fe(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "1em",
      height: "1em",
      className: "icon",
      viewBox: "0 0 1024 1024",
      children: [
        /* @__PURE__ */ z(
          "path",
          {
            fill: "currentColor",
            d: "M679.253 402.364 618.77 561.015l-60.348-158.651a30.04 30.04 0 0 0-30.447-18.637 29.76 29.76 0 0 0-30.447 18.637l-60.416 158.651-60.416-158.651a30.515 30.515 0 0 0-38.843-17.272 28.945 28.945 0 0 0-17.954 37.547l88.815 233.267c4.369 11.469 15.7 19.115 28.398 19.115a30.31 30.31 0 0 0 28.468-19.115l62.395-163.908 62.396 163.84c4.437 11.605 15.701 19.183 28.4 19.183a30.31 30.31 0 0 0 28.466-19.115l88.747-233.267a28.945 28.945 0 0 0-17.886-37.547 30.447 30.447 0 0 0-38.912 17.272zm219.478 395.605-51.883-29.218c-28.672-16.18-52.224-3.072-52.224 29.082v.273H643.209a29.833 29.833 0 0 0-30.31 29.354c0 16.18 13.584 29.218 30.31 29.218h151.825c1.092 30.516 24.03 43.077 52.224 27.648l51.063-27.989c29.013-15.906 29.15-42.189.41-58.368"
          }
        ),
        /* @__PURE__ */ z(
          "path",
          {
            fill: "currentColor",
            d: "m810.667 913.135-.478.068H201.796c-19.865 0-36.727-11.673-36.727-25.6v-618.36h154.965c51.268 0 92.911-39.39 92.911-87.858v-87.86H810.19c19.797 0 36.522 11.742 36.522 25.669V739.26h61.987V119.262c0-46.421-44.169-84.241-98.51-84.241H328.364l-225.28 194.56v658.09c0 46.285 44.236 84.105 98.713 84.105H810.19c43.759 0 80.554-24.713 93.32-58.573h-92.842zM350.89 94.89v86.562c0 16.11-13.858 29.286-30.925 29.286H216.815L350.959 94.891z"
          }
        )
      ]
    }
  );
}
function iie() {
  return /* @__PURE__ */ z("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", children: /* @__PURE__ */ z("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M14 4h4a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1m-9 8h4m-2-2v4" }) });
}
function oie() {
  return /* @__PURE__ */ z("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", children: /* @__PURE__ */ z("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M6 4h4a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1m9 8h4m-2-2v4" }) });
}
function aie() {
  return /* @__PURE__ */ z("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", children: /* @__PURE__ */ z("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M12 21v-4m0-4V9m0-4V3m-2 18h4M8 5v4h11l2-2l-2-2zm6 8v4H6l-2-2l2-2z" }) });
}
function sie() {
  return /* @__PURE__ */ z("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 20 20", children: /* @__PURE__ */ z("path", { fill: "currentColor", d: "M6.5 3a.75.75 0 0 1 .697.471l3 7.5a.75.75 0 0 1-1.393.557L7.992 9.5H5.008l-.811 2.028a.75.75 0 0 1-1.393-.556l3-7.5A.75.75 0 0 1 6.5 3m0 2.77L5.608 8h1.784zm8.28-1.55a.75.75 0 1 0-1.06 1.06l.72.72h-3.69a.75.75 0 0 0 0 1.5h3.69l-.72.72a.75.75 0 0 0 1.06 1.06l2-2a.75.75 0 0 0 0-1.06zm0 7.5a.75.75 0 1 0-1.06 1.06l.72.72H3.75a.75.75 0 0 0 0 1.5h10.69l-.72.72a.75.75 0 1 0 1.06 1.06l2-2a.75.75 0 0 0 0-1.06z" }) });
}
function lie() {
  return /* @__PURE__ */ z("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 20 20", children: /* @__PURE__ */ z("path", { fill: "currentColor", d: "M13.5 3a.75.75 0 0 0-.697.471l-3 7.5a.75.75 0 0 0 1.393.557l.812-2.028h2.984l.811 2.028a.75.75 0 0 0 1.393-.556l-3-7.5A.75.75 0 0 0 13.5 3m0 2.77L14.392 8h-1.784zM5.22 4.22a.75.75 0 0 1 1.06 1.06L5.56 6h3.69a.75.75 0 0 1 0 1.5H5.56l.72.72a.75.75 0 0 1-1.06 1.06l-2-2a.75.75 0 0 1 0-1.06zm0 7.5a.75.75 0 0 1 1.06 1.06l-.72.72h10.69a.75.75 0 0 1 0 1.5H5.56l.72.72a.75.75 0 1 1-1.06 1.06l-2-2a.75.75 0 0 1 0-1.06z" }) });
}
function cie() {
  return /* @__PURE__ */ z("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", children: /* @__PURE__ */ Fe("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", color: "currentColor", children: [
    /* @__PURE__ */ z("path", { d: "M14.86 22h-4.312c-3.291 0-4.937 0-6.08-.798a4.2 4.2 0 0 1-.863-.805c-.855-1.066-.855-2.6-.855-5.67v-2.545c0-2.963 0-4.445.473-5.628c.761-1.903 2.37-3.403 4.41-4.113C8.9 2 10.49 2 13.667 2c1.816 0 2.723 0 3.448.252c1.166.406 2.085 1.263 2.52 2.35c.27.676.27 1.523.27 3.216V10" }),
    /* @__PURE__ */ z("path", { d: "M2.75 12c0-1.84 1.506-3.333 3.364-3.333c.672 0 1.464.116 2.117-.057a1.67 1.67 0 0 0 1.19-1.179c.174-.647.057-1.432.057-2.098C9.478 3.493 10.984 2 12.84 2m.002 16h2.523m-4.949-4.15c-.126-.8-.281-.801-1.61-.85h-1.01c-.557 0-1.009.448-1.009 1v3c0 .552.452 1 1.01 1h1.816c.39 0 .803-.313.803-.7v-1.1c0-.11-.113-.304-.224-.304H9.068M12.842 13h1.261m0 0h1.262m-1.262 0v4.875M21.251 13h-2.523c-.557 0-1.009.448-1.009 1v1.5m0 0V18m0-2.5h2.523" })
  ] }) });
}
function uie() {
  return /* @__PURE__ */ z("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1em", height: "1em", viewBox: "0 0 24 24", children: /* @__PURE__ */ z("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "1.5", d: "m3 21l7.548-7.548M21 3l-7.548 7.548m0 0L8 3H3l7.548 10.452m2.904-2.904L21 21h-5l-5.452-7.548", color: "currentColor" }) });
}
const Hm = {
  Bold: u7,
  LoaderCircle: d7,
  Italic: f7,
  Underline: h7,
  Quote: p7,
  TextQuote: Xre,
  Strikethrough: m7,
  Minus: g7,
  Eraser: y7,
  PaintRoller: b7,
  Redo2: v7,
  Undo2: w7,
  AlignCenter: IW,
  AlignJustify: OW,
  AlignLeft: FW,
  AlignRight: UW,
  ChevronDown: uF,
  Subscript: x7,
  Superscript: _7,
  Code: S7,
  Code2: T7,
  Type: D7,
  IndentIncrease: E7,
  IndentDecrease: C7,
  List: k7,
  ListOrdered: A7,
  ListTodo: R7,
  Link: I7,
  ImageUp: O7,
  Video: F7,
  Maximize: U7,
  Minimize: N7,
  Table: M7,
  Sparkles: B7,
  Pencil: L7,
  Unlink: P7,
  BetweenHorizonalEnd: W7,
  BetweenHorizonalStart: z7,
  BetweenVerticalStart: $7,
  BetweenVerticalEnd: H7,
  TableCellsMerge: j7,
  TableCellsSplit: V7,
  Trash2: q7,
  Trash: G7,
  Replace: ak,
  ChevronsUpDown: K7,
  LineHeight: Qre,
  Word: Zre,
  Heading1: X7,
  Heading2: Y7,
  Heading3: J7,
  Heading4: Z7,
  Heading5: Q7,
  Heading6: eW,
  Columns2: sk,
  Columns3: tW,
  Columns4: nW,
  Plus: cF,
  Grip: rW,
  Copy: iW,
  Clipboard: oW,
  PanelLeft: aW,
  PanelRight: sW,
  Columns: sk,
  Iframe: lW,
  MenuDown: aN,
  SizeS: nie,
  SizeM: tie,
  SizeL: eie,
  AspectRatio: Kre,
  Emoji: cW,
  DeleteColumn: Yre,
  DeleteRow: Jre,
  SearchAndReplace: ak,
  EmojiIcon: uW,
  ExportPdf: sN,
  ExportWord: lN,
  ImportWord: rie,
  ColumnAddLeft: iie,
  ColumnAddRight: oie,
  BookMarked: dW,
  ZoomIn: fW,
  ZoomOut: hW,
  Settings: pW,
  Eye: mW,
  TextDirection: aie,
  LeftToRight: sie,
  RightToLeft: lie,
  Attachment: gW,
  GifIcon: cie,
  ChevronUp: yW,
  Crop: bW,
  Twitter: uie,
  FlipX: vW,
  FlipY: wW
};
function die(t) {
  const e = ["size-small", "size-medium", "size-large"], n = [
    "SizeS",
    "SizeM",
    "SizeL"
  ];
  return e.map((r, i) => ({
    type: `image-${r}`,
    component: Je,
    componentProps: {
      tooltip: sn.t(`editor.${r.replace("-", ".")}.tooltip`),
      icon: n[i],
      action: () => t.commands.updateImage({ width: nm[r] }),
      isActive: () => t.isActive("image", { width: nm[r] })
    }
  }));
}
function fie(t) {
  const e = ["size-small", "size-medium", "size-large"], n = [
    "SizeS",
    "SizeM",
    "SizeL"
  ];
  return e.map((r, i) => ({
    type: `image-${r}`,
    component: Je,
    componentProps: {
      tooltip: sn.t(`editor.${r.replace("-", ".")}.tooltip`),
      icon: n[i],
      action: () => t.commands.updateImageGif({ width: nm[r] }),
      isActive: () => t.isActive("image", { width: nm[r] })
    }
  }));
}
function hie(t) {
  const e = ["left", "center", "right"], n = {
    left: "AlignLeft",
    center: "AlignCenter",
    right: "AlignRight"
  };
  return e.map((r) => ({
    type: `image-${r}`,
    component: Je,
    componentProps: {
      tooltip: sn.t(`editor.textalign.${r}.tooltip`),
      icon: n[r],
      action: () => {
        var i, o;
        return (o = (i = t.commands) == null ? void 0 : i.setAlignImage) == null ? void 0 : o.call(i, r);
      },
      isActive: () => t.isActive({ align: r }) || !1,
      disabled: !1
    }
  }));
}
function pie(t) {
  const e = ["left", "center", "right"], n = {
    left: "AlignLeft",
    center: "AlignCenter",
    right: "AlignRight"
  };
  return e.map((r) => ({
    type: `image-${r}`,
    component: Je,
    componentProps: {
      tooltip: sn.t(`editor.textalign.${r}.tooltip`),
      icon: n[r],
      action: () => {
        var i, o;
        return (o = (i = t.commands) == null ? void 0 : i.setAlignImageGif) == null ? void 0 : o.call(i, r);
      },
      isActive: () => t.isActive({ align: r }) || !1,
      disabled: !1
    }
  }));
}
function mie(t) {
  const e = ["size-small", "size-medium", "size-large"], n = [
    "SizeS",
    "SizeM",
    "SizeL"
  ];
  return e.map((r, i) => ({
    type: `video-${r}`,
    component: Je,
    componentProps: {
      tooltip: sn.t(`editor.${r.replace("-", ".")}.tooltip`),
      icon: n[i],
      action: () => t.commands.updateVideo({ width: Hb[r] }),
      isActive: () => t.isActive("video", { width: Hb[r] })
    }
  }));
}
function gie(t) {
  return [
    {
      type: "flipX",
      component: Je,
      componentProps: {
        editor: t,
        tooltip: sn.t("editor.tooltip.flipX"),
        icon: "FlipX",
        action: () => {
          const e = t.getAttributes("image"), { flipX: n } = e;
          t.chain().focus(void 0, { scrollIntoView: !1 }).updateImage({
            flipX: !n
          }).run();
        }
      }
    },
    {
      type: "flipY",
      component: Je,
      componentProps: {
        editor: t,
        tooltip: sn.t("editor.tooltip.flipY"),
        icon: "FlipY",
        action: () => {
          const e = t.getAttributes("image"), { flipY: n } = e;
          t.chain().focus(void 0, { scrollIntoView: !1 }).updateImage({
            flipY: !n
          }).run();
        }
      }
    },
    ...die(t),
    ...hie(t),
    {
      type: "remove",
      component: Je,
      componentProps: {
        editor: t,
        tooltip: sn.t("editor.remove"),
        icon: "Trash2",
        action: () => {
          const { state: e, dispatch: n } = t.view;
          r1(e, n);
        }
      }
    }
  ];
}
function yie(t) {
  return [
    ...fie(t),
    ...pie(t),
    {
      type: "remove",
      component: Je,
      componentProps: {
        editor: t,
        tooltip: sn.t("editor.remove"),
        icon: "Trash2",
        action: () => {
          const { state: e, dispatch: n } = t.view;
          r1(e, n);
        }
      }
    }
  ];
}
function bie(t) {
  return [
    ...mie(t),
    {
      type: "remove",
      component: Je,
      componentProps: {
        editor: t,
        tooltip: sn.t("editor.remove"),
        icon: "Trash2",
        action: () => {
          const { state: e, dispatch: n } = t.view;
          r1(e, n);
        }
      }
    }
  ];
}
function vie(t, e) {
  return RZ.reduce((n, r) => {
    if (r === "divider" && n.length > 0)
      return [...n, {
        type: "divider",
        component: void 0,
        componentProps: {}
      }];
    const i = t.extensionManager.extensions.find((o) => o.name === r);
    return i ? [...n, i.configure().options.button({ editor: t, t: e, extension: i })] : n;
  }, []);
}
const sa = () => /* @__PURE__ */ new Map(), aT = (t) => {
  const e = sa();
  return t.forEach((n, r) => {
    e.set(r, n);
  }), e;
}, Yf = (t, e, n) => {
  let r = t.get(e);
  return r === void 0 && t.set(e, r = n()), r;
}, wie = (t, e) => {
  const n = [];
  for (const [r, i] of t)
    n.push(e(i, r));
  return n;
}, xie = (t, e) => {
  for (const [n, r] of t)
    if (e(r, n))
      return !0;
  return !1;
}, Ef = () => /* @__PURE__ */ new Set(), Ex = (t) => t[t.length - 1], Cf = Array.from, _ie = Array.isArray;
class Sie {
  constructor() {
    this._observers = sa();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(e, n) {
    return Yf(
      this._observers,
      /** @type {string} */
      e,
      Ef
    ).add(n), n;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(e, n) {
    const r = (...i) => {
      this.off(
        e,
        /** @type {any} */
        r
      ), n(...i);
    };
    this.on(
      e,
      /** @type {any} */
      r
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(e, n) {
    const r = this._observers.get(e);
    r !== void 0 && (r.delete(n), r.size === 0 && this._observers.delete(e));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(e, n) {
    return Cf((this._observers.get(e) || sa()).values()).forEach((r) => r(...n));
  }
  destroy() {
    this._observers = sa();
  }
}
const eu = Math.floor, Qy = Math.abs, cN = (t, e) => t < e ? t : e, Jf = (t, e) => t > e ? t : e, Tie = (t) => t !== 0 ? t < 0 : 1 / t < 0, A5 = 1, R5 = 2, Cx = 4, kx = 8, Die = 32, uN = 64, Kb = 128, Eie = 31, I5 = 63, Pp = 127, Cie = 2147483647, kie = Number.isInteger || ((t) => typeof t == "number" && isFinite(t) && eu(t) === t), Aie = (t) => t.toLowerCase(), Rie = /^\s*/g, Iie = (t) => t.replace(Rie, ""), Oie = /([A-Z])/g, O5 = (t, e) => Iie(t.replace(Oie, (n) => `${e}${Aie(n)}`)), Fie = (t) => {
  const e = unescape(encodeURIComponent(t)), n = e.length, r = new Uint8Array(n);
  for (let i = 0; i < n; i++)
    r[i] = /** @type {number} */
    e.codePointAt(i);
  return r;
}, sm = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), Uie = (t) => sm.encode(t), Nie = sm ? Uie : Fie;
let Ax = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
Ax && Ax.decode(new Uint8Array()).length === 1 && (Ax = null);
class jm {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
}
const JD = () => new jm(), Mie = (t) => {
  let e = t.cpos;
  for (let n = 0; n < t.bufs.length; n++)
    e += t.bufs[n].length;
  return e;
}, Qa = (t) => {
  const e = new Uint8Array(Mie(t));
  let n = 0;
  for (let r = 0; r < t.bufs.length; r++) {
    const i = t.bufs[r];
    e.set(i, n), n += i.length;
  }
  return e.set(new Uint8Array(t.cbuf.buffer, 0, t.cpos), n), e;
}, Bie = (t, e) => {
  const n = t.cbuf.length;
  n - t.cpos < e && (t.bufs.push(new Uint8Array(t.cbuf.buffer, 0, t.cpos)), t.cbuf = new Uint8Array(Jf(n, e) * 2), t.cpos = 0);
}, Vn = (t, e) => {
  const n = t.cbuf.length;
  t.cpos === n && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(n * 2), t.cpos = 0), t.cbuf[t.cpos++] = e;
}, sT = Vn, en = (t, e) => {
  for (; e > Pp; )
    Vn(t, Kb | Pp & e), e = eu(e / 128);
  Vn(t, Pp & e);
}, ZD = (t, e) => {
  const n = Tie(e);
  for (n && (e = -e), Vn(t, (e > I5 ? Kb : 0) | (n ? uN : 0) | I5 & e), e = eu(e / 64); e > 0; )
    Vn(t, (e > Pp ? Kb : 0) | Pp & e), e = eu(e / 128);
}, lT = new Uint8Array(3e4), Lie = lT.length / 3, Pie = (t, e) => {
  if (e.length < Lie) {
    const n = sm.encodeInto(e, lT).written || 0;
    en(t, n);
    for (let r = 0; r < n; r++)
      Vn(t, lT[r]);
  } else
    _i(t, Nie(e));
}, Wie = (t, e) => {
  const n = unescape(encodeURIComponent(e)), r = n.length;
  en(t, r);
  for (let i = 0; i < r; i++)
    Vn(
      t,
      /** @type {number} */
      n.codePointAt(i)
    );
}, lf = sm && /** @type {any} */
sm.encodeInto ? Pie : Wie, QD = (t, e) => {
  const n = t.cbuf.length, r = t.cpos, i = cN(n - r, e.length), o = e.length - i;
  t.cbuf.set(e.subarray(0, i), r), t.cpos += i, o > 0 && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(Jf(n * 2, o)), t.cbuf.set(e.subarray(i)), t.cpos = o);
}, _i = (t, e) => {
  en(t, e.byteLength), QD(t, e);
}, eE = (t, e) => {
  Bie(t, e);
  const n = new DataView(t.cbuf.buffer, t.cpos, e);
  return t.cpos += e, n;
}, zie = (t, e) => eE(t, 4).setFloat32(0, e, !1), $ie = (t, e) => eE(t, 8).setFloat64(0, e, !1), Hie = (t, e) => (
  /** @type {any} */
  eE(t, 8).setBigInt64(0, e, !1)
), F5 = new DataView(new ArrayBuffer(4)), jie = (t) => (F5.setFloat32(0, t), F5.getFloat32(0) === t), lm = (t, e) => {
  switch (typeof e) {
    case "string":
      Vn(t, 119), lf(t, e);
      break;
    case "number":
      kie(e) && Qy(e) <= Cie ? (Vn(t, 125), ZD(t, e)) : jie(e) ? (Vn(t, 124), zie(t, e)) : (Vn(t, 123), $ie(t, e));
      break;
    case "bigint":
      Vn(t, 122), Hie(t, e);
      break;
    case "object":
      if (e === null)
        Vn(t, 126);
      else if (_ie(e)) {
        Vn(t, 117), en(t, e.length);
        for (let n = 0; n < e.length; n++)
          lm(t, e[n]);
      } else if (e instanceof Uint8Array)
        Vn(t, 116), _i(t, e);
      else {
        Vn(t, 118);
        const n = Object.keys(e);
        en(t, n.length);
        for (let r = 0; r < n.length; r++) {
          const i = n[r];
          lf(t, i), lm(t, e[i]);
        }
      }
      break;
    case "boolean":
      Vn(t, e ? 120 : 121);
      break;
    default:
      Vn(t, 127);
  }
};
class U5 extends jm {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(e) {
    super(), this.w = e, this.s = null, this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(e) {
    this.s === e ? this.count++ : (this.count > 0 && en(this, this.count - 1), this.count = 1, this.w(this, e), this.s = e);
  }
}
const N5 = (t) => {
  t.count > 0 && (ZD(t.encoder, t.count === 1 ? t.s : -t.s), t.count > 1 && en(t.encoder, t.count - 2));
};
class eb {
  constructor() {
    this.encoder = new jm(), this.s = 0, this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.s === e ? this.count++ : (N5(this), this.count = 1, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return N5(this), Qa(this.encoder);
  }
}
const M5 = (t) => {
  if (t.count > 0) {
    const e = t.diff * 2 + (t.count === 1 ? 0 : 1);
    ZD(t.encoder, e), t.count > 1 && en(t.encoder, t.count - 2);
  }
};
class Rx {
  constructor() {
    this.encoder = new jm(), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.diff === e - this.s ? (this.s = e, this.count++) : (M5(this), this.count = 1, this.diff = e - this.s, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return M5(this), Qa(this.encoder);
  }
}
class Vie {
  constructor() {
    this.sarr = [], this.s = "", this.lensE = new eb();
  }
  /**
   * @param {string} string
   */
  write(e) {
    this.s += e, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(e.length);
  }
  toUint8Array() {
    const e = new jm();
    return this.sarr.push(this.s), this.s = "", lf(e, this.sarr.join("")), QD(e, this.lensE.toUint8Array()), Qa(e);
  }
}
const kf = (t) => new Error(t), la = () => {
  throw kf("Method unimplemented");
}, Cl = () => {
  throw kf("Unexpected case");
}, qie = crypto.getRandomValues.bind(crypto), dN = () => qie(new Uint32Array(1))[0], Gie = "10000000-1000-4000-8000" + -1e11, Kie = () => Gie.replace(
  /[018]/g,
  /** @param {number} c */
  (t) => (t ^ dN() & 15 >> t / 4).toString(16)
), B5 = (t) => (
  /** @type {Promise<T>} */
  new Promise(t)
);
Promise.all.bind(Promise);
const L5 = (t) => t === void 0 ? null : t;
class Xie {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(e, n) {
    this.map.set(e, n);
  }
  /**
   * @param {string} key
   */
  getItem(e) {
    return this.map.get(e);
  }
}
let fN = new Xie(), Yie = !0;
try {
  typeof localStorage < "u" && localStorage && (fN = localStorage, Yie = !1);
} catch {
}
const Jie = fN, Zie = Object.assign, Qie = Object.keys, eoe = (t, e) => {
  for (const n in t)
    e(t[n], n);
}, P5 = (t) => Qie(t).length, toe = (t) => {
  for (const e in t)
    return !1;
  return !0;
}, noe = (t, e) => {
  for (const n in t)
    if (!e(t[n], n))
      return !1;
  return !0;
}, roe = (t, e) => Object.prototype.hasOwnProperty.call(t, e), ioe = (t, e) => t === e || P5(t) === P5(e) && noe(t, (n, r) => (n !== void 0 || roe(e, r)) && e[r] === n), ooe = Object.freeze, hN = (t) => {
  for (const e in t) {
    const n = t[e];
    (typeof n == "object" || typeof n == "function") && hN(t[e]);
  }
  return ooe(t);
}, tE = (t, e, n = 0) => {
  try {
    for (; n < t.length; n++)
      t[n](...e);
  } finally {
    n < t.length && tE(t, e, n + 1);
  }
}, aoe = (t, e) => e.includes(t), cm = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
let Go;
const soe = () => {
  if (Go === void 0)
    if (cm) {
      Go = sa();
      const t = process.argv;
      let e = null;
      for (let n = 0; n < t.length; n++) {
        const r = t[n];
        r[0] === "-" ? (e !== null && Go.set(e, ""), e = r) : e !== null && (Go.set(e, r), e = null);
      }
      e !== null && Go.set(e, "");
    } else typeof location == "object" ? (Go = sa(), (location.search || "?").slice(1).split("&").forEach((t) => {
      if (t.length !== 0) {
        const [e, n] = t.split("=");
        Go.set(`--${O5(e, "-")}`, n), Go.set(`-${O5(e, "-")}`, n);
      }
    })) : Go = sa();
  return Go;
}, cT = (t) => soe().has(t), Xb = (t) => L5(cm ? process.env[t.toUpperCase().replaceAll("-", "_")] : Jie.getItem(t)), pN = (t) => cT("--" + t) || Xb(t) !== null;
pN("production");
const loe = cm && aoe(process.env.FORCE_COLOR, ["true", "1", "2"]), coe = loe || !cT("--no-colors") && // @todo deprecate --no-colors
!pN("no-color") && (!cm || process.stdout.isTTY) && (!cm || cT("--color") || Xb("COLORTERM") !== null || (Xb("TERM") || "").includes("color"));
class uoe {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(e, n) {
    this.left = e, this.right = n;
  }
}
const Ha = (t, e) => new uoe(t, e);
typeof DOMParser < "u" && new DOMParser();
const doe = (t) => wie(t, (e, n) => `${n}:${e};`).join(""), gs = Symbol, mN = gs(), gN = gs(), foe = gs(), hoe = gs(), poe = gs(), yN = gs(), moe = gs(), nE = gs(), goe = gs(), yoe = (t) => {
  var i;
  t.length === 1 && ((i = t[0]) == null ? void 0 : i.constructor) === Function && (t = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  t[0]());
  const e = [], n = [];
  let r = 0;
  for (; r < t.length; r++) {
    const o = t[r];
    if (o === void 0)
      break;
    if (o.constructor === String || o.constructor === Number)
      e.push(o);
    else if (o.constructor === Object)
      break;
  }
  for (r > 0 && n.push(e.join("")); r < t.length; r++) {
    const o = t[r];
    o instanceof Symbol || n.push(o);
  }
  return n;
}, boe = {
  [mN]: Ha("font-weight", "bold"),
  [gN]: Ha("font-weight", "normal"),
  [foe]: Ha("color", "blue"),
  [poe]: Ha("color", "green"),
  [hoe]: Ha("color", "grey"),
  [yN]: Ha("color", "red"),
  [moe]: Ha("color", "purple"),
  [nE]: Ha("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [goe]: Ha("color", "black")
}, voe = (t) => {
  var a;
  t.length === 1 && ((a = t[0]) == null ? void 0 : a.constructor) === Function && (t = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  t[0]());
  const e = [], n = [], r = sa();
  let i = [], o = 0;
  for (; o < t.length; o++) {
    const s = t[o], l = boe[s];
    if (l !== void 0)
      r.set(l.left, l.right);
    else {
      if (s === void 0)
        break;
      if (s.constructor === String || s.constructor === Number) {
        const c = doe(r);
        o > 0 || c.length > 0 ? (e.push("%c" + s), n.push(c)) : e.push(s);
      } else
        break;
    }
  }
  for (o > 0 && (i = n, i.unshift(e.join(""))); o < t.length; o++) {
    const s = t[o];
    s instanceof Symbol || i.push(s);
  }
  return i;
}, bN = coe ? voe : yoe, woe = (...t) => {
  console.log(...bN(t)), vN.forEach((e) => e.print(t));
}, xoe = (...t) => {
  console.warn(...bN(t)), t.unshift(nE), vN.forEach((e) => e.print(t));
}, vN = Ef(), wN = (t) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next: t
}), _oe = (t, e) => wN(() => {
  let n;
  do
    n = t.next();
  while (!n.done && !e(n.value));
  return n;
}), Ix = (t, e) => wN(() => {
  const { done: n, value: r } = t.next();
  return { done: n, value: n ? void 0 : e(r) };
});
class Soe {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(e, n) {
    this.clock = e, this.len = n;
  }
}
class Toe {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const xN = (t, e, n) => e.clients.forEach((r, i) => {
  const o = (
    /** @type {Array<GC|Item>} */
    t.doc.store.clients.get(i)
  );
  for (let a = 0; a < r.length; a++) {
    const s = r[a];
    kN(t, o, s.clock, s.len, n);
  }
}), Doe = (t, e) => {
  let n = 0, r = t.length - 1;
  for (; n <= r; ) {
    const i = eu((n + r) / 2), o = t[i], a = o.clock;
    if (a <= e) {
      if (e < a + o.len)
        return i;
      n = i + 1;
    } else
      r = i - 1;
  }
  return null;
}, _N = (t, e) => {
  const n = t.clients.get(e.client);
  return n !== void 0 && Doe(n, e.clock) !== null;
}, SN = (t) => {
  t.clients.forEach((e) => {
    e.sort((i, o) => i.clock - o.clock);
    let n, r;
    for (n = 1, r = 1; n < e.length; n++) {
      const i = e[r - 1], o = e[n];
      i.clock + i.len >= o.clock ? i.len = Jf(i.len, o.clock + o.len - i.clock) : (r < n && (e[r] = o), r++);
    }
    e.length = r;
  });
}, TN = (t, e, n, r) => {
  Yf(t.clients, e, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new Soe(n, r));
}, Eoe = (t, e) => {
  en(t.restEncoder, e.clients.size), Cf(e.clients.entries()).sort((n, r) => r[0] - n[0]).forEach(([n, r]) => {
    t.resetDsCurVal(), en(t.restEncoder, n);
    const i = r.length;
    en(t.restEncoder, i);
    for (let o = 0; o < i; o++) {
      const a = r[o];
      t.writeDsClock(a.clock), t.writeDsLen(a.len);
    }
  });
}, DN = dN;
class Vm extends Sie {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid: e = Kie(), collectionid: n = null, gc: r = !0, gcFilter: i = () => !0, meta: o = null, autoLoad: a = !1, shouldLoad: s = !0 } = {}) {
    super(), this.gc = r, this.gcFilter = i, this.clientID = DN(), this.guid = e, this.collectionid = n, this.share = /* @__PURE__ */ new Map(), this.store = new Noe(), this._transaction = null, this._transactionCleanups = [], this.subdocs = /* @__PURE__ */ new Set(), this._item = null, this.shouldLoad = s, this.autoLoad = a, this.meta = o, this.isLoaded = !1, this.isSynced = !1, this.isDestroyed = !1, this.whenLoaded = B5((c) => {
      this.on("load", () => {
        this.isLoaded = !0, c(this);
      });
    });
    const l = () => B5((c) => {
      const u = (d) => {
        (d === void 0 || d === !0) && (this.off("sync", u), c());
      };
      this.on("sync", u);
    });
    this.on("sync", (c) => {
      c === !1 && this.isSynced && (this.whenSynced = l()), this.isSynced = c === void 0 || c === !0, this.isSynced && !this.isLoaded && this.emit("load", [this]);
    }), this.whenSynced = l();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const e = this._item;
    e !== null && !this.shouldLoad && dn(
      /** @type {any} */
      e.parent.doc,
      (n) => {
        n.subdocsLoaded.add(this);
      },
      null,
      !0
    ), this.shouldLoad = !0;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(Cf(this.subdocs).map((e) => e.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(e, n = null) {
    return dn(this, e, n);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(e, n = (
    /** @type {any} */
    cr
  )) {
    const r = Yf(this.share, e, () => {
      const o = new n();
      return o._integrate(this, null), o;
    }), i = r.constructor;
    if (n !== cr && i !== n)
      if (i === cr) {
        const o = new n();
        o._map = r._map, r._map.forEach(
          /** @param {Item?} n */
          (a) => {
            for (; a !== null; a = a.left)
              a.parent = o;
          }
        ), o._start = r._start;
        for (let a = o._start; a !== null; a = a.right)
          a.parent = o;
        return o._length = r._length, this.share.set(e, o), o._integrate(this, null), /** @type {InstanceType<Type>} */
        o;
      } else
        throw new Error(`Type with the name ${e} has already been defined with a different constructor`);
    return (
      /** @type {InstanceType<Type>} */
      r
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(e = "") {
    return (
      /** @type {YArray<T>} */
      this.get(e, Wp)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(e = "") {
    return this.get(e, hm);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(e = "") {
    return (
      /** @type {YMap<T>} */
      this.get(e, Qb)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(e = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(e, pm)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(e = "") {
    return this.get(e, Af);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const e = {};
    return this.share.forEach((n, r) => {
      e[r] = n.toJSON();
    }), e;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    this.isDestroyed = !0, Cf(this.subdocs).forEach((n) => n.destroy());
    const e = this._item;
    if (e !== null) {
      this._item = null;
      const n = (
        /** @type {ContentDoc} */
        e.content
      );
      n.doc = new Vm({ guid: this.guid, ...n.opts, shouldLoad: !1 }), n.doc._item = e, dn(
        /** @type {any} */
        e.parent.doc,
        (r) => {
          const i = n.doc;
          e.deleted || r.subdocsAdded.add(i), r.subdocsRemoved.add(this);
        },
        null,
        !0
      );
    }
    this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy();
  }
}
class Coe {
  constructor() {
    this.restEncoder = JD();
  }
  toUint8Array() {
    return Qa(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    en(this.restEncoder, e);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    en(this.restEncoder, e);
  }
}
class koe extends Coe {
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    en(this.restEncoder, e.client), en(this.restEncoder, e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    en(this.restEncoder, e.client), en(this.restEncoder, e.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(e) {
    en(this.restEncoder, e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    sT(this.restEncoder, e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    lf(this.restEncoder, e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    en(this.restEncoder, e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    en(this.restEncoder, e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    en(this.restEncoder, e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    lm(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    _i(this.restEncoder, e);
  }
  /**
   * @param {any} embed
   */
  writeJSON(e) {
    lf(this.restEncoder, JSON.stringify(e));
  }
  /**
   * @param {string} key
   */
  writeKey(e) {
    lf(this.restEncoder, e);
  }
}
class Aoe {
  constructor() {
    this.restEncoder = JD(), this.dsCurrVal = 0;
  }
  toUint8Array() {
    return Qa(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    const n = e - this.dsCurrVal;
    this.dsCurrVal = e, en(this.restEncoder, n);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    e === 0 && Cl(), en(this.restEncoder, e - 1), this.dsCurrVal += e;
  }
}
class Roe extends Aoe {
  constructor() {
    super(), this.keyMap = /* @__PURE__ */ new Map(), this.keyClock = 0, this.keyClockEncoder = new Rx(), this.clientEncoder = new eb(), this.leftClockEncoder = new Rx(), this.rightClockEncoder = new Rx(), this.infoEncoder = new U5(sT), this.stringEncoder = new Vie(), this.parentInfoEncoder = new U5(sT), this.typeRefEncoder = new eb(), this.lenEncoder = new eb();
  }
  toUint8Array() {
    const e = JD();
    return en(e, 0), _i(e, this.keyClockEncoder.toUint8Array()), _i(e, this.clientEncoder.toUint8Array()), _i(e, this.leftClockEncoder.toUint8Array()), _i(e, this.rightClockEncoder.toUint8Array()), _i(e, Qa(this.infoEncoder)), _i(e, this.stringEncoder.toUint8Array()), _i(e, Qa(this.parentInfoEncoder)), _i(e, this.typeRefEncoder.toUint8Array()), _i(e, this.lenEncoder.toUint8Array()), QD(e, Qa(this.restEncoder)), Qa(e);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    this.clientEncoder.write(e.client), this.leftClockEncoder.write(e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    this.clientEncoder.write(e.client), this.rightClockEncoder.write(e.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(e) {
    this.clientEncoder.write(e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    this.infoEncoder.write(e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    this.stringEncoder.write(e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    this.parentInfoEncoder.write(e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    this.typeRefEncoder.write(e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    this.lenEncoder.write(e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    lm(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    _i(this.restEncoder, e);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(e) {
    lm(this.restEncoder, e);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(e) {
    const n = this.keyMap.get(e);
    n === void 0 ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(e)) : this.keyClockEncoder.write(n);
  }
}
const Ioe = (t, e, n, r) => {
  r = Jf(r, e[0].id.clock);
  const i = ls(e, r);
  en(t.restEncoder, e.length - i), t.writeClient(n), en(t.restEncoder, r);
  const o = e[i];
  o.write(t, r - o.id.clock);
  for (let a = i + 1; a < e.length; a++)
    e[a].write(t, 0);
}, Ooe = (t, e, n) => {
  const r = /* @__PURE__ */ new Map();
  n.forEach((i, o) => {
    ai(e, o) > i && r.set(o, i);
  }), rE(e).forEach((i, o) => {
    n.has(o) || r.set(o, 0);
  }), en(t.restEncoder, r.size), Cf(r.entries()).sort((i, o) => o[0] - i[0]).forEach(([i, o]) => {
    Ioe(
      t,
      /** @type {Array<GC|Item>} */
      e.clients.get(i),
      i,
      o
    );
  });
}, Foe = (t, e) => Ooe(t, e.doc.store, e.beforeState);
class Uoe {
  constructor() {
    this.l = [];
  }
}
const W5 = () => new Uoe(), z5 = (t, e) => t.l.push(e), $5 = (t, e) => {
  const n = t.l, r = n.length;
  t.l = n.filter((i) => e !== i), r === t.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.");
}, EN = (t, e, n) => tE(t.l, [e, n]);
class tb {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(e, n) {
    this.client = e, this.clock = n;
  }
}
const ty = (t, e) => t === e || t !== null && e !== null && t.client === e.client && t.clock === e.clock, hn = (t, e) => new tb(t, e), um = (t) => {
  for (const [e, n] of t.doc.share.entries())
    if (n === t)
      return e;
  throw Cl();
};
class Yb {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(e, n, r, i = 0) {
    this.type = e, this.tname = n, this.item = r, this.assoc = i;
  }
}
const ny = (t, e, n) => {
  let r = null, i = null;
  return t._item === null ? i = um(t) : r = hn(t._item.id.client, t._item.id.clock), new Yb(r, i, e, n);
}, Ox = (t, e, n = 0) => {
  let r = t._start;
  if (n < 0) {
    if (e === 0)
      return ny(t, null, n);
    e--;
  }
  for (; r !== null; ) {
    if (!r.deleted && r.countable) {
      if (r.length > e)
        return ny(t, hn(r.id.client, r.id.clock + e), n);
      e -= r.length;
    }
    if (r.right === null && n < 0)
      return ny(t, r.lastId, n);
    r = r.right;
  }
  return ny(t, null, n);
}, Vd = (t, e) => e === void 0 ? !t.deleted : e.sv.has(t.id.client) && (e.sv.get(t.id.client) || 0) > t.id.clock && !_N(e.ds, t.id), uT = (t, e) => {
  const n = Yf(t.meta, uT, Ef), r = t.doc.store;
  n.has(e) || (e.sv.forEach((i, o) => {
    i < ai(r, o) && kl(t, hn(o, i));
  }), xN(t, e.ds, (i) => {
  }), n.add(e));
};
class Noe {
  constructor() {
    this.clients = /* @__PURE__ */ new Map(), this.pendingStructs = null, this.pendingDs = null;
  }
}
const rE = (t) => {
  const e = /* @__PURE__ */ new Map();
  return t.clients.forEach((n, r) => {
    const i = n[n.length - 1];
    e.set(r, i.id.clock + i.length);
  }), e;
}, ai = (t, e) => {
  const n = t.clients.get(e);
  if (n === void 0)
    return 0;
  const r = n[n.length - 1];
  return r.id.clock + r.length;
}, CN = (t, e) => {
  let n = t.clients.get(e.id.client);
  if (n === void 0)
    n = [], t.clients.set(e.id.client, n);
  else {
    const r = n[n.length - 1];
    if (r.id.clock + r.length !== e.id.clock)
      throw Cl();
  }
  n.push(e);
}, ls = (t, e) => {
  let n = 0, r = t.length - 1, i = t[r], o = i.id.clock;
  if (o === e)
    return r;
  let a = eu(e / (o + i.length - 1) * r);
  for (; n <= r; ) {
    if (i = t[a], o = i.id.clock, o <= e) {
      if (e < o + i.length)
        return a;
      n = a + 1;
    } else
      r = a - 1;
    a = eu((n + r) / 2);
  }
  throw Cl();
}, Moe = (t, e) => {
  const n = t.clients.get(e.client);
  return n[ls(n, e.clock)];
}, Fx = (
  /** @type {function(StructStore,ID):Item} */
  Moe
), dT = (t, e, n) => {
  const r = ls(e, n), i = e[r];
  return i.id.clock < n && i instanceof Ei ? (e.splice(r + 1, 0, qN(t, i, n - i.id.clock)), r + 1) : r;
}, kl = (t, e) => {
  const n = (
    /** @type {Array<Item>} */
    t.doc.store.clients.get(e.client)
  );
  return n[dT(t, n, e.clock)];
}, H5 = (t, e, n) => {
  const r = e.clients.get(n.client), i = ls(r, n.clock), o = r[i];
  return n.clock !== o.id.clock + o.length - 1 && o.constructor !== ul && r.splice(i + 1, 0, qN(t, o, n.clock - o.id.clock + 1)), o;
}, Boe = (t, e, n) => {
  const r = (
    /** @type {Array<GC|Item>} */
    t.clients.get(e.id.client)
  );
  r[ls(r, e.id.clock)] = n;
}, kN = (t, e, n, r, i) => {
  if (r === 0)
    return;
  const o = n + r;
  let a = dT(t, e, n), s;
  do
    s = e[a++], o < s.id.clock + s.length && dT(t, e, o), i(s);
  while (a < e.length && e[a].id.clock < o);
};
class Loe {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(e, n, r) {
    this.doc = e, this.deleteSet = new Toe(), this.beforeState = rE(e.store), this.afterState = /* @__PURE__ */ new Map(), this.changed = /* @__PURE__ */ new Map(), this.changedParentTypes = /* @__PURE__ */ new Map(), this._mergeStructs = [], this.origin = n, this.meta = /* @__PURE__ */ new Map(), this.local = r, this.subdocsAdded = /* @__PURE__ */ new Set(), this.subdocsRemoved = /* @__PURE__ */ new Set(), this.subdocsLoaded = /* @__PURE__ */ new Set(), this._needFormattingCleanup = !1;
  }
}
const j5 = (t, e) => e.deleteSet.clients.size === 0 && !xie(e.afterState, (n, r) => e.beforeState.get(r) !== n) ? !1 : (SN(e.deleteSet), Foe(t, e), Eoe(t, e.deleteSet), !0), V5 = (t, e, n) => {
  const r = e._item;
  (r === null || r.id.clock < (t.beforeState.get(r.id.client) || 0) && !r.deleted) && Yf(t.changed, e, Ef).add(n);
}, nb = (t, e) => {
  let n = t[e], r = t[e - 1], i = e;
  for (; i > 0; n = r, r = t[--i - 1]) {
    if (r.deleted === n.deleted && r.constructor === n.constructor && r.mergeWith(n)) {
      n instanceof Ei && n.parentSub !== null && /** @type {AbstractType<any>} */
      n.parent._map.get(n.parentSub) === n && n.parent._map.set(
        n.parentSub,
        /** @type {Item} */
        r
      );
      continue;
    }
    break;
  }
  const o = e - i;
  return o && t.splice(e + 1 - o, o), o;
}, Poe = (t, e, n) => {
  for (const [r, i] of t.clients.entries()) {
    const o = (
      /** @type {Array<GC|Item>} */
      e.clients.get(r)
    );
    for (let a = i.length - 1; a >= 0; a--) {
      const s = i[a], l = s.clock + s.len;
      for (let c = ls(o, s.clock), u = o[c]; c < o.length && u.id.clock < l; u = o[++c]) {
        const d = o[c];
        if (s.clock + s.len <= d.id.clock)
          break;
        d instanceof Ei && d.deleted && !d.keep && n(d) && d.gc(e, !1);
      }
    }
  }
}, Woe = (t, e) => {
  t.clients.forEach((n, r) => {
    const i = (
      /** @type {Array<GC|Item>} */
      e.clients.get(r)
    );
    for (let o = n.length - 1; o >= 0; o--) {
      const a = n[o], s = cN(i.length - 1, 1 + ls(i, a.clock + a.len - 1));
      for (let l = s, c = i[l]; l > 0 && c.id.clock >= a.clock; c = i[l])
        l -= 1 + nb(i, l);
    }
  });
}, AN = (t, e) => {
  if (e < t.length) {
    const n = t[e], r = n.doc, i = r.store, o = n.deleteSet, a = n._mergeStructs;
    try {
      SN(o), n.afterState = rE(n.doc.store), r.emit("beforeObserverCalls", [n, r]);
      const s = [];
      n.changed.forEach(
        (l, c) => s.push(() => {
          (c._item === null || !c._item.deleted) && c._callObserver(n, l);
        })
      ), s.push(() => {
        n.changedParentTypes.forEach((l, c) => {
          c._dEH.l.length > 0 && (c._item === null || !c._item.deleted) && (l = l.filter(
            (u) => u.target._item === null || !u.target._item.deleted
          ), l.forEach((u) => {
            u.currentTarget = c, u._path = null;
          }), l.sort((u, d) => u.path.length - d.path.length), EN(c._dEH, l, n));
        });
      }), s.push(() => r.emit("afterTransaction", [n, r])), tE(s, []), n._needFormattingCleanup && Zoe(n);
    } finally {
      r.gc && Poe(o, i, r.gcFilter), Woe(o, i), n.afterState.forEach((u, d) => {
        const f = n.beforeState.get(d) || 0;
        if (f !== u) {
          const p = (
            /** @type {Array<GC|Item>} */
            i.clients.get(d)
          ), m = Jf(ls(p, f), 1);
          for (let g = p.length - 1; g >= m; )
            g -= 1 + nb(p, g);
        }
      });
      for (let u = a.length - 1; u >= 0; u--) {
        const { client: d, clock: f } = a[u].id, p = (
          /** @type {Array<GC|Item>} */
          i.clients.get(d)
        ), m = ls(p, f);
        m + 1 < p.length && nb(p, m + 1) > 1 || m > 0 && nb(p, m);
      }
      if (!n.local && n.afterState.get(r.clientID) !== n.beforeState.get(r.clientID) && (woe(nE, mN, "[yjs] ", gN, yN, "Changed the client-id because another client seems to be using it."), r.clientID = DN()), r.emit("afterTransactionCleanup", [n, r]), r._observers.has("update")) {
        const u = new koe();
        j5(u, n) && r.emit("update", [u.toUint8Array(), n.origin, r, n]);
      }
      if (r._observers.has("updateV2")) {
        const u = new Roe();
        j5(u, n) && r.emit("updateV2", [u.toUint8Array(), n.origin, r, n]);
      }
      const { subdocsAdded: s, subdocsLoaded: l, subdocsRemoved: c } = n;
      (s.size > 0 || c.size > 0 || l.size > 0) && (s.forEach((u) => {
        u.clientID = r.clientID, u.collectionid == null && (u.collectionid = r.collectionid), r.subdocs.add(u);
      }), c.forEach((u) => r.subdocs.delete(u)), r.emit("subdocs", [{ loaded: l, added: s, removed: c }, r, n]), c.forEach((u) => u.destroy())), t.length <= e + 1 ? (r._transactionCleanups = [], r.emit("afterAllTransactions", [r, t])) : AN(t, e + 1);
    }
  }
}, dn = (t, e, n = null, r = !0) => {
  const i = t._transactionCleanups;
  let o = !1, a = null;
  t._transaction === null && (o = !0, t._transaction = new Loe(t, n, r), i.push(t._transaction), i.length === 1 && t.emit("beforeAllTransactions", [t]), t.emit("beforeTransaction", [t._transaction, t]));
  try {
    a = e(t._transaction);
  } finally {
    if (o) {
      const s = t._transaction === i[0];
      t._transaction = null, s && AN(i, 0);
    }
  }
  return a;
}, q5 = "You must not compute changes after the event-handler fired.";
class A1 {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(e, n) {
    this.target = e, this.currentTarget = e, this.transaction = n, this._changes = null, this._keys = null, this._delta = null, this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = zoe(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(e) {
    return _N(this.transaction.deleteSet, e.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw kf(q5);
      const e = /* @__PURE__ */ new Map(), n = this.target;
      /** @type Set<string|null> */
      this.transaction.changed.get(n).forEach((i) => {
        if (i !== null) {
          const o = (
            /** @type {Item} */
            n._map.get(i)
          );
          let a, s;
          if (this.adds(o)) {
            let l = o.left;
            for (; l !== null && this.adds(l); )
              l = l.left;
            if (this.deletes(o))
              if (l !== null && this.deletes(l))
                a = "delete", s = Ex(l.content.getContent());
              else
                return;
            else
              l !== null && this.deletes(l) ? (a = "update", s = Ex(l.content.getContent())) : (a = "add", s = void 0);
          } else if (this.deletes(o))
            a = "delete", s = Ex(
              /** @type {Item} */
              o.content.getContent()
            );
          else
            return;
          e.set(i, { action: a, oldValue: s });
        }
      }), this._keys = e;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(e) {
    return e.id.clock >= (this.transaction.beforeState.get(e.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let e = this._changes;
    if (e === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw kf(q5);
      const n = this.target, r = Ef(), i = Ef(), o = [];
      if (e = {
        added: r,
        deleted: i,
        delta: o,
        keys: this.keys
      }, /** @type Set<string|null> */
      this.transaction.changed.get(n).has(null)) {
        let s = null;
        const l = () => {
          s && o.push(s);
        };
        for (let c = n._start; c !== null; c = c.right)
          c.deleted ? this.deletes(c) && !this.adds(c) && ((s === null || s.delete === void 0) && (l(), s = { delete: 0 }), s.delete += c.length, i.add(c)) : this.adds(c) ? ((s === null || s.insert === void 0) && (l(), s = { insert: [] }), s.insert = s.insert.concat(c.content.getContent()), r.add(c)) : ((s === null || s.retain === void 0) && (l(), s = { retain: 0 }), s.retain += c.length);
        s !== null && s.retain === void 0 && l();
      }
      this._changes = e;
    }
    return (
      /** @type {any} */
      e
    );
  }
}
const zoe = (t, e) => {
  const n = [];
  for (; e._item !== null && e !== t; ) {
    if (e._item.parentSub !== null)
      n.unshift(e._item.parentSub);
    else {
      let r = 0, i = (
        /** @type {AbstractType<any>} */
        e._item.parent._start
      );
      for (; i !== e._item && i !== null; )
        !i.deleted && i.countable && (r += i.length), i = i.right;
      n.unshift(r);
    }
    e = /** @type {AbstractType<any>} */
    e._item.parent;
  }
  return n;
}, vr = () => {
  xoe("Invalid access: Add Yjs type to a document before reading data.");
}, RN = 80;
let iE = 0;
class $oe {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(e, n) {
    e.marker = !0, this.p = e, this.index = n, this.timestamp = iE++;
  }
}
const Hoe = (t) => {
  t.timestamp = iE++;
}, IN = (t, e, n) => {
  t.p.marker = !1, t.p = e, e.marker = !0, t.index = n, t.timestamp = iE++;
}, joe = (t, e, n) => {
  if (t.length >= RN) {
    const r = t.reduce((i, o) => i.timestamp < o.timestamp ? i : o);
    return IN(r, e, n), r;
  } else {
    const r = new $oe(e, n);
    return t.push(r), r;
  }
}, R1 = (t, e) => {
  if (t._start === null || e === 0 || t._searchMarker === null)
    return null;
  const n = t._searchMarker.length === 0 ? null : t._searchMarker.reduce((o, a) => Qy(e - o.index) < Qy(e - a.index) ? o : a);
  let r = t._start, i = 0;
  for (n !== null && (r = n.p, i = n.index, Hoe(n)); r.right !== null && i < e; ) {
    if (!r.deleted && r.countable) {
      if (e < i + r.length)
        break;
      i += r.length;
    }
    r = r.right;
  }
  for (; r.left !== null && i > e; )
    r = r.left, !r.deleted && r.countable && (i -= r.length);
  for (; r.left !== null && r.left.id.client === r.id.client && r.left.id.clock + r.left.length === r.id.clock; )
    r = r.left, !r.deleted && r.countable && (i -= r.length);
  return n !== null && Qy(n.index - i) < /** @type {YText|YArray<any>} */
  r.parent.length / RN ? (IN(n, r, i), n) : joe(t._searchMarker, r, i);
}, dm = (t, e, n) => {
  for (let r = t.length - 1; r >= 0; r--) {
    const i = t[r];
    if (n > 0) {
      let o = i.p;
      for (o.marker = !1; o && (o.deleted || !o.countable); )
        o = o.left, o && !o.deleted && o.countable && (i.index -= o.length);
      if (o === null || o.marker === !0) {
        t.splice(r, 1);
        continue;
      }
      i.p = o, o.marker = !0;
    }
    (e < i.index || n > 0 && e === i.index) && (i.index = Jf(e, i.index + n));
  }
}, I1 = (t, e, n) => {
  const r = t, i = e.changedParentTypes;
  for (; Yf(i, t, () => []).push(n), t._item !== null; )
    t = /** @type {AbstractType<any>} */
    t._item.parent;
  EN(r._eH, n, e);
};
class cr {
  constructor() {
    this._item = null, this._map = /* @__PURE__ */ new Map(), this._start = null, this.doc = null, this._length = 0, this._eH = W5(), this._dEH = W5(), this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(e, n) {
    this.doc = e, this._item = n;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw la();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw la();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(e) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let e = this._start;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    !e.local && this._searchMarker && (this._searchMarker.length = 0);
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(e) {
    z5(this._eH, e);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(e) {
    z5(this._dEH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(e) {
    $5(this._eH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(e) {
    $5(this._dEH, e);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
}
const ON = (t, e, n) => {
  t.doc ?? vr(), e < 0 && (e = t._length + e), n < 0 && (n = t._length + n);
  let r = n - e;
  const i = [];
  let o = t._start;
  for (; o !== null && r > 0; ) {
    if (o.countable && !o.deleted) {
      const a = o.content.getContent();
      if (a.length <= e)
        e -= a.length;
      else {
        for (let s = e; s < a.length && r > 0; s++)
          i.push(a[s]), r--;
        e = 0;
      }
    }
    o = o.right;
  }
  return i;
}, FN = (t) => {
  t.doc ?? vr();
  const e = [];
  let n = t._start;
  for (; n !== null; ) {
    if (n.countable && !n.deleted) {
      const r = n.content.getContent();
      for (let i = 0; i < r.length; i++)
        e.push(r[i]);
    }
    n = n.right;
  }
  return e;
}, fm = (t, e) => {
  let n = 0, r = t._start;
  for (t.doc ?? vr(); r !== null; ) {
    if (r.countable && !r.deleted) {
      const i = r.content.getContent();
      for (let o = 0; o < i.length; o++)
        e(i[o], n++, t);
    }
    r = r.right;
  }
}, UN = (t, e) => {
  const n = [];
  return fm(t, (r, i) => {
    n.push(e(r, i, t));
  }), n;
}, Voe = (t) => {
  let e = t._start, n = null, r = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (n === null) {
        for (; e !== null && e.deleted; )
          e = e.right;
        if (e === null)
          return {
            done: !0,
            value: void 0
          };
        n = e.content.getContent(), r = 0, e = e.right;
      }
      const i = n[r++];
      return n.length <= r && (n = null), {
        done: !1,
        value: i
      };
    }
  };
}, NN = (t, e) => {
  t.doc ?? vr();
  const n = R1(t, e);
  let r = t._start;
  for (n !== null && (r = n.p, e -= n.index); r !== null; r = r.right)
    if (!r.deleted && r.countable) {
      if (e < r.length)
        return r.content.getContent()[e];
      e -= r.length;
    }
}, Jb = (t, e, n, r) => {
  let i = n;
  const o = t.doc, a = o.clientID, s = o.store, l = n === null ? e._start : n.right;
  let c = [];
  const u = () => {
    c.length > 0 && (i = new Ei(hn(a, ai(s, a)), i, i && i.lastId, l, l && l.id, e, null, new Rf(c)), i.integrate(t, 0), c = []);
  };
  r.forEach((d) => {
    if (d === null)
      c.push(d);
    else
      switch (d.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          c.push(d);
          break;
        default:
          switch (u(), d.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              i = new Ei(hn(a, ai(s, a)), i, i && i.lastId, l, l && l.id, e, null, new O1(new Uint8Array(
                /** @type {Uint8Array} */
                d
              ))), i.integrate(t, 0);
              break;
            case Vm:
              i = new Ei(hn(a, ai(s, a)), i, i && i.lastId, l, l && l.id, e, null, new F1(
                /** @type {Doc} */
                d
              )), i.integrate(t, 0);
              break;
            default:
              if (d instanceof cr)
                i = new Ei(hn(a, ai(s, a)), i, i && i.lastId, l, l && l.id, e, null, new Pl(d)), i.integrate(t, 0);
              else
                throw new Error("Unexpected content type in insert operation");
          }
      }
  }), u();
}, MN = () => kf("Length exceeded!"), BN = (t, e, n, r) => {
  if (n > e._length)
    throw MN();
  if (n === 0)
    return e._searchMarker && dm(e._searchMarker, n, r.length), Jb(t, e, null, r);
  const i = n, o = R1(e, n);
  let a = e._start;
  for (o !== null && (a = o.p, n -= o.index, n === 0 && (a = a.prev, n += a && a.countable && !a.deleted ? a.length : 0)); a !== null; a = a.right)
    if (!a.deleted && a.countable) {
      if (n <= a.length) {
        n < a.length && kl(t, hn(a.id.client, a.id.clock + n));
        break;
      }
      n -= a.length;
    }
  return e._searchMarker && dm(e._searchMarker, i, r.length), Jb(t, e, a, r);
}, qoe = (t, e, n) => {
  let i = (e._searchMarker || []).reduce((o, a) => a.index > o.index ? a : o, { index: 0, p: e._start }).p;
  if (i)
    for (; i.right; )
      i = i.right;
  return Jb(t, e, i, n);
}, LN = (t, e, n, r) => {
  if (r === 0)
    return;
  const i = n, o = r, a = R1(e, n);
  let s = e._start;
  for (a !== null && (s = a.p, n -= a.index); s !== null && n > 0; s = s.right)
    !s.deleted && s.countable && (n < s.length && kl(t, hn(s.id.client, s.id.clock + n)), n -= s.length);
  for (; r > 0 && s !== null; )
    s.deleted || (r < s.length && kl(t, hn(s.id.client, s.id.clock + r)), s.delete(t), r -= s.length), s = s.right;
  if (r > 0)
    throw MN();
  e._searchMarker && dm(
    e._searchMarker,
    i,
    -o + r
    /* in case we remove the above exception */
  );
}, Zb = (t, e, n) => {
  const r = e._map.get(n);
  r !== void 0 && r.delete(t);
}, oE = (t, e, n, r) => {
  const i = e._map.get(n) || null, o = t.doc, a = o.clientID;
  let s;
  if (r == null)
    s = new Rf([r]);
  else
    switch (r.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        s = new Rf([r]);
        break;
      case Uint8Array:
        s = new O1(
          /** @type {Uint8Array} */
          r
        );
        break;
      case Vm:
        s = new F1(
          /** @type {Doc} */
          r
        );
        break;
      default:
        if (r instanceof cr)
          s = new Pl(r);
        else
          throw new Error("Unexpected content type");
    }
  new Ei(hn(a, ai(o.store, a)), i, i && i.lastId, null, null, e, n, s).integrate(t, 0);
}, aE = (t, e) => {
  t.doc ?? vr();
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted ? n.content.getContent()[n.length - 1] : void 0;
}, PN = (t) => {
  const e = {};
  return t.doc ?? vr(), t._map.forEach((n, r) => {
    n.deleted || (e[r] = n.content.getContent()[n.length - 1]);
  }), e;
}, WN = (t, e) => {
  t.doc ?? vr();
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted;
}, Goe = (t, e) => {
  const n = {};
  return t._map.forEach((r, i) => {
    let o = r;
    for (; o !== null && (!e.sv.has(o.id.client) || o.id.clock >= (e.sv.get(o.id.client) || 0)); )
      o = o.left;
    o !== null && Vd(o, e) && (n[i] = o.content.getContent()[o.length - 1]);
  }), n;
}, ry = (t) => (t.doc ?? vr(), _oe(
  t._map.entries(),
  /** @param {any} entry */
  (e) => !e[1].deleted
));
class Koe extends A1 {
}
class Wp extends cr {
  constructor() {
    super(), this._prelimContent = [], this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(e) {
    const n = new Wp();
    return n.push(e), n;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new Wp();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const e = new Wp();
    return e.insert(0, this.toArray().map(
      (n) => n instanceof cr ? (
        /** @type {typeof el} */
        n.clone()
      ) : n
    )), e;
  }
  get length() {
    return this.doc ?? vr(), this._length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    super._callObserver(e, n), I1(this, e, new Koe(this, e));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(e, n) {
    this.doc !== null ? dn(this.doc, (r) => {
      BN(
        r,
        this,
        e,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(e) {
    this.doc !== null ? dn(this.doc, (n) => {
      qoe(
        n,
        this,
        /** @type {any} */
        e
      );
    }) : this._prelimContent.push(...e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(e, n = 1) {
    this.doc !== null ? dn(this.doc, (r) => {
      LN(r, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(e) {
    return NN(this, e);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return FN(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(e = 0, n = this.length) {
    return ON(this, e, n);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((e) => e instanceof cr ? e.toJSON() : e);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(e) {
    return UN(
      this,
      /** @type {any} */
      e
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    fm(this, e);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return Voe(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(iae);
  }
}
class Xoe extends A1 {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(e, n, r) {
    super(e, n), this.keysChanged = r;
  }
}
class Qb extends cr {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(e) {
    super(), this._prelimContent = null, e === void 0 ? this._prelimContent = /* @__PURE__ */ new Map() : this._prelimContent = new Map(e);
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this._prelimContent.forEach((r, i) => {
      this.set(i, r);
    }), this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new Qb();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const e = new Qb();
    return this.forEach((n, r) => {
      e.set(r, n instanceof cr ? (
        /** @type {typeof value} */
        n.clone()
      ) : n);
    }), e;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    I1(this, e, new Xoe(this, e, n));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    this.doc ?? vr();
    const e = {};
    return this._map.forEach((n, r) => {
      if (!n.deleted) {
        const i = n.content.getContent()[n.length - 1];
        e[r] = i instanceof cr ? i.toJSON() : i;
      }
    }), e;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...ry(this)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return Ix(
      ry(this),
      /** @param {any} v */
      (e) => e[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return Ix(
      ry(this),
      /** @param {any} v */
      (e) => e[1].content.getContent()[e[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return Ix(
      ry(this),
      /** @param {any} v */
      (e) => (
        /** @type {any} */
        [e[0], e[1].content.getContent()[e[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    this.doc ?? vr(), this._map.forEach((n, r) => {
      n.deleted || e(n.content.getContent()[n.length - 1], r, this);
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(e) {
    this.doc !== null ? dn(this.doc, (n) => {
      Zb(n, this, e);
    }) : this._prelimContent.delete(e);
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(e, n) {
    return this.doc !== null ? dn(this.doc, (r) => {
      oE(
        r,
        this,
        e,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.set(e, n), n;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(e) {
    return (
      /** @type {any} */
      aE(this, e)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(e) {
    return WN(this, e);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    this.doc !== null ? dn(this.doc, (e) => {
      this.forEach(function(n, r, i) {
        Zb(e, i, r);
      });
    }) : this._prelimContent.clear();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(oae);
  }
}
const yl = (t, e) => t === e || typeof t == "object" && typeof e == "object" && t && e && ioe(t, e);
class fT {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(e, n, r, i) {
    this.left = e, this.right = n, this.index = r, this.currentAttributes = i;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    switch (this.right === null && Cl(), this.right.content.constructor) {
      case Yn:
        this.right.deleted || Zf(
          this.currentAttributes,
          /** @type {ContentFormat} */
          this.right.content
        );
        break;
      default:
        this.right.deleted || (this.index += this.right.length);
        break;
    }
    this.left = this.right, this.right = this.right.right;
  }
}
const G5 = (t, e, n) => {
  for (; e.right !== null && n > 0; ) {
    switch (e.right.content.constructor) {
      case Yn:
        e.right.deleted || Zf(
          e.currentAttributes,
          /** @type {ContentFormat} */
          e.right.content
        );
        break;
      default:
        e.right.deleted || (n < e.right.length && kl(t, hn(e.right.id.client, e.right.id.clock + n)), e.index += e.right.length, n -= e.right.length);
        break;
    }
    e.left = e.right, e.right = e.right.right;
  }
  return e;
}, iy = (t, e, n, r) => {
  const i = /* @__PURE__ */ new Map(), o = r ? R1(e, n) : null;
  if (o) {
    const a = new fT(o.p.left, o.p, o.index, i);
    return G5(t, a, n - o.index);
  } else {
    const a = new fT(null, e._start, 0, i);
    return G5(t, a, n);
  }
}, zN = (t, e, n, r) => {
  for (; n.right !== null && (n.right.deleted === !0 || n.right.content.constructor === Yn && yl(
    r.get(
      /** @type {ContentFormat} */
      n.right.content.key
    ),
    /** @type {ContentFormat} */
    n.right.content.value
  )); )
    n.right.deleted || r.delete(
      /** @type {ContentFormat} */
      n.right.content.key
    ), n.forward();
  const i = t.doc, o = i.clientID;
  r.forEach((a, s) => {
    const l = n.left, c = n.right, u = new Ei(hn(o, ai(i.store, o)), l, l && l.lastId, c, c && c.id, e, null, new Yn(s, a));
    u.integrate(t, 0), n.right = u, n.forward();
  });
}, Zf = (t, e) => {
  const { key: n, value: r } = e;
  r === null ? t.delete(n) : t.set(n, r);
}, $N = (t, e) => {
  for (; t.right !== null; ) {
    if (!(t.right.deleted || t.right.content.constructor === Yn && yl(
      e[
        /** @type {ContentFormat} */
        t.right.content.key
      ] ?? null,
      /** @type {ContentFormat} */
      t.right.content.value
    ))) break;
    t.forward();
  }
}, HN = (t, e, n, r) => {
  const i = t.doc, o = i.clientID, a = /* @__PURE__ */ new Map();
  for (const s in r) {
    const l = r[s], c = n.currentAttributes.get(s) ?? null;
    if (!yl(c, l)) {
      a.set(s, c);
      const { left: u, right: d } = n;
      n.right = new Ei(hn(o, ai(i.store, o)), u, u && u.lastId, d, d && d.id, e, null, new Yn(s, l)), n.right.integrate(t, 0), n.forward();
    }
  }
  return a;
}, Ux = (t, e, n, r, i) => {
  n.currentAttributes.forEach((f, p) => {
    i[p] === void 0 && (i[p] = null);
  });
  const o = t.doc, a = o.clientID;
  $N(n, i);
  const s = HN(t, e, n, i), l = r.constructor === String ? new cs(
    /** @type {string} */
    r
  ) : r instanceof cr ? new Pl(r) : new Qf(r);
  let { left: c, right: u, index: d } = n;
  e._searchMarker && dm(e._searchMarker, n.index, l.getLength()), u = new Ei(hn(a, ai(o.store, a)), c, c && c.lastId, u, u && u.id, e, null, l), u.integrate(t, 0), n.right = u, n.index = d, n.forward(), zN(t, e, n, s);
}, K5 = (t, e, n, r, i) => {
  const o = t.doc, a = o.clientID;
  $N(n, i);
  const s = HN(t, e, n, i);
  e: for (; n.right !== null && (r > 0 || s.size > 0 && (n.right.deleted || n.right.content.constructor === Yn)); ) {
    if (!n.right.deleted)
      switch (n.right.content.constructor) {
        case Yn: {
          const { key: l, value: c } = (
            /** @type {ContentFormat} */
            n.right.content
          ), u = i[l];
          if (u !== void 0) {
            if (yl(u, c))
              s.delete(l);
            else {
              if (r === 0)
                break e;
              s.set(l, c);
            }
            n.right.delete(t);
          } else
            n.currentAttributes.set(l, c);
          break;
        }
        default:
          r < n.right.length && kl(t, hn(n.right.id.client, n.right.id.clock + r)), r -= n.right.length;
          break;
      }
    n.forward();
  }
  if (r > 0) {
    let l = "";
    for (; r > 0; r--)
      l += `
`;
    n.right = new Ei(hn(a, ai(o.store, a)), n.left, n.left && n.left.lastId, n.right, n.right && n.right.id, e, null, new cs(l)), n.right.integrate(t, 0), n.forward();
  }
  zN(t, e, n, s);
}, jN = (t, e, n, r, i) => {
  let o = e;
  const a = sa();
  for (; o && (!o.countable || o.deleted); ) {
    if (!o.deleted && o.content.constructor === Yn) {
      const c = (
        /** @type {ContentFormat} */
        o.content
      );
      a.set(c.key, c);
    }
    o = o.right;
  }
  let s = 0, l = !1;
  for (; e !== o; ) {
    if (n === e && (l = !0), !e.deleted) {
      const c = e.content;
      switch (c.constructor) {
        case Yn: {
          const { key: u, value: d } = (
            /** @type {ContentFormat} */
            c
          ), f = r.get(u) ?? null;
          (a.get(u) !== c || f === d) && (e.delete(t), s++, !l && (i.get(u) ?? null) === d && f !== d && (f === null ? i.delete(u) : i.set(u, f))), !l && !e.deleted && Zf(
            i,
            /** @type {ContentFormat} */
            c
          );
          break;
        }
      }
    }
    e = /** @type {Item} */
    e.right;
  }
  return s;
}, Yoe = (t, e) => {
  for (; e && e.right && (e.right.deleted || !e.right.countable); )
    e = e.right;
  const n = /* @__PURE__ */ new Set();
  for (; e && (e.deleted || !e.countable); ) {
    if (!e.deleted && e.content.constructor === Yn) {
      const r = (
        /** @type {ContentFormat} */
        e.content.key
      );
      n.has(r) ? e.delete(t) : n.add(r);
    }
    e = e.left;
  }
}, Joe = (t) => {
  let e = 0;
  return dn(
    /** @type {Doc} */
    t.doc,
    (n) => {
      let r = (
        /** @type {Item} */
        t._start
      ), i = t._start, o = sa();
      const a = aT(o);
      for (; i; ) {
        if (i.deleted === !1)
          switch (i.content.constructor) {
            case Yn:
              Zf(
                a,
                /** @type {ContentFormat} */
                i.content
              );
              break;
            default:
              e += jN(n, r, i, o, a), o = aT(a), r = i;
              break;
          }
        i = i.right;
      }
    }
  ), e;
}, Zoe = (t) => {
  const e = /* @__PURE__ */ new Set(), n = t.doc;
  for (const [r, i] of t.afterState.entries()) {
    const o = t.beforeState.get(r) || 0;
    i !== o && kN(
      t,
      /** @type {Array<Item|GC>} */
      n.store.clients.get(r),
      o,
      i,
      (a) => {
        !a.deleted && /** @type {Item} */
        a.content.constructor === Yn && a.constructor !== ul && e.add(
          /** @type {any} */
          a.parent
        );
      }
    );
  }
  dn(n, (r) => {
    xN(t, t.deleteSet, (i) => {
      if (i instanceof ul || !/** @type {YText} */
      i.parent._hasFormatting || e.has(
        /** @type {YText} */
        i.parent
      ))
        return;
      const o = (
        /** @type {YText} */
        i.parent
      );
      i.content.constructor === Yn ? e.add(o) : Yoe(r, i);
    });
    for (const i of e)
      Joe(i);
  });
}, X5 = (t, e, n) => {
  const r = n, i = aT(e.currentAttributes), o = e.right;
  for (; n > 0 && e.right !== null; ) {
    if (e.right.deleted === !1)
      switch (e.right.content.constructor) {
        case Pl:
        case Qf:
        case cs:
          n < e.right.length && kl(t, hn(e.right.id.client, e.right.id.clock + n)), n -= e.right.length, e.right.delete(t);
          break;
      }
    e.forward();
  }
  o && jN(t, o, e.right, i, e.currentAttributes);
  const a = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (e.left || e.right).parent
  );
  return a._searchMarker && dm(a._searchMarker, e.index, -r + n), e;
};
class Qoe extends A1 {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(e, n, r) {
    super(e, n), this.childListChanged = !1, this.keysChanged = /* @__PURE__ */ new Set(), r.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.keysChanged.add(i);
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const e = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = e;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const e = (
        /** @type {Doc} */
        this.target.doc
      ), n = [];
      dn(e, (r) => {
        const i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
        let a = this.target._start, s = null;
        const l = {};
        let c = "", u = 0, d = 0;
        const f = () => {
          if (s !== null) {
            let p = null;
            switch (s) {
              case "delete":
                d > 0 && (p = { delete: d }), d = 0;
                break;
              case "insert":
                (typeof c == "object" || c.length > 0) && (p = { insert: c }, i.size > 0 && (p.attributes = {}, i.forEach((m, g) => {
                  m !== null && (p.attributes[g] = m);
                }))), c = "";
                break;
              case "retain":
                u > 0 && (p = { retain: u }, toe(l) || (p.attributes = Zie({}, l))), u = 0;
                break;
            }
            p && n.push(p), s = null;
          }
        };
        for (; a !== null; ) {
          switch (a.content.constructor) {
            case Pl:
            case Qf:
              this.adds(a) ? this.deletes(a) || (f(), s = "insert", c = a.content.getContent()[0], f()) : this.deletes(a) ? (s !== "delete" && (f(), s = "delete"), d += 1) : a.deleted || (s !== "retain" && (f(), s = "retain"), u += 1);
              break;
            case cs:
              this.adds(a) ? this.deletes(a) || (s !== "insert" && (f(), s = "insert"), c += /** @type {ContentString} */
              a.content.str) : this.deletes(a) ? (s !== "delete" && (f(), s = "delete"), d += a.length) : a.deleted || (s !== "retain" && (f(), s = "retain"), u += a.length);
              break;
            case Yn: {
              const { key: p, value: m } = (
                /** @type {ContentFormat} */
                a.content
              );
              if (this.adds(a)) {
                if (!this.deletes(a)) {
                  const g = i.get(p) ?? null;
                  yl(g, m) ? m !== null && a.delete(r) : (s === "retain" && f(), yl(m, o.get(p) ?? null) ? delete l[p] : l[p] = m);
                }
              } else if (this.deletes(a)) {
                o.set(p, m);
                const g = i.get(p) ?? null;
                yl(g, m) || (s === "retain" && f(), l[p] = g);
              } else if (!a.deleted) {
                o.set(p, m);
                const g = l[p];
                g !== void 0 && (yl(g, m) ? g !== null && a.delete(r) : (s === "retain" && f(), m === null ? delete l[p] : l[p] = m));
              }
              a.deleted || (s === "insert" && f(), Zf(
                i,
                /** @type {ContentFormat} */
                a.content
              ));
              break;
            }
          }
          a = a.right;
        }
        for (f(); n.length > 0; ) {
          const p = n[n.length - 1];
          if (p.retain !== void 0 && p.attributes === void 0)
            n.pop();
          else
            break;
        }
      }), this._delta = n;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
}
class hm extends cr {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(e) {
    super(), this._pending = e !== void 0 ? [() => this.insert(0, e)] : [], this._searchMarker = [], this._hasFormatting = !1;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this.doc ?? vr(), this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n);
    try {
      this._pending.forEach((r) => r());
    } catch (r) {
      console.error(r);
    }
    this._pending = null;
  }
  _copy() {
    return new hm();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const e = new hm();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    super._callObserver(e, n);
    const r = new Qoe(this, e, n);
    I1(this, e, r), !e.local && this._hasFormatting && (e._needFormattingCleanup = !0);
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    this.doc ?? vr();
    let e = "", n = this._start;
    for (; n !== null; )
      !n.deleted && n.countable && n.content.constructor === cs && (e += /** @type {ContentString} */
      n.content.str), n = n.right;
    return e;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(e, { sanitize: n = !0 } = {}) {
    this.doc !== null ? dn(this.doc, (r) => {
      const i = new fT(null, this._start, 0, /* @__PURE__ */ new Map());
      for (let o = 0; o < e.length; o++) {
        const a = e[o];
        if (a.insert !== void 0) {
          const s = !n && typeof a.insert == "string" && o === e.length - 1 && i.right === null && a.insert.slice(-1) === `
` ? a.insert.slice(0, -1) : a.insert;
          (typeof s != "string" || s.length > 0) && Ux(r, this, i, s, a.attributes || {});
        } else a.retain !== void 0 ? K5(r, this, i, a.retain, a.attributes || {}) : a.delete !== void 0 && X5(r, i, a.delete);
      }
    }) : this._pending.push(() => this.applyDelta(e));
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(e, n, r) {
    this.doc ?? vr();
    const i = [], o = /* @__PURE__ */ new Map(), a = (
      /** @type {Doc} */
      this.doc
    );
    let s = "", l = this._start;
    function c() {
      if (s.length > 0) {
        const d = {};
        let f = !1;
        o.forEach((m, g) => {
          f = !0, d[g] = m;
        });
        const p = { insert: s };
        f && (p.attributes = d), i.push(p), s = "";
      }
    }
    const u = () => {
      for (; l !== null; ) {
        if (Vd(l, e) || n !== void 0 && Vd(l, n))
          switch (l.content.constructor) {
            case cs: {
              const d = o.get("ychange");
              e !== void 0 && !Vd(l, e) ? (d === void 0 || d.user !== l.id.client || d.type !== "removed") && (c(), o.set("ychange", r ? r("removed", l.id) : { type: "removed" })) : n !== void 0 && !Vd(l, n) ? (d === void 0 || d.user !== l.id.client || d.type !== "added") && (c(), o.set("ychange", r ? r("added", l.id) : { type: "added" })) : d !== void 0 && (c(), o.delete("ychange")), s += /** @type {ContentString} */
              l.content.str;
              break;
            }
            case Pl:
            case Qf: {
              c();
              const d = {
                insert: l.content.getContent()[0]
              };
              if (o.size > 0) {
                const f = (
                  /** @type {Object<string,any>} */
                  {}
                );
                d.attributes = f, o.forEach((p, m) => {
                  f[m] = p;
                });
              }
              i.push(d);
              break;
            }
            case Yn:
              Vd(l, e) && (c(), Zf(
                o,
                /** @type {ContentFormat} */
                l.content
              ));
              break;
          }
        l = l.right;
      }
      c();
    };
    return e || n ? dn(a, (d) => {
      e && uT(d, e), n && uT(d, n), u();
    }, "cleanup") : u(), i;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(e, n, r) {
    if (n.length <= 0)
      return;
    const i = this.doc;
    i !== null ? dn(i, (o) => {
      const a = iy(o, this, e, !r);
      r || (r = {}, a.currentAttributes.forEach((s, l) => {
        r[l] = s;
      })), Ux(o, this, a, n, r);
    }) : this._pending.push(() => this.insert(e, n, r));
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(e, n, r) {
    const i = this.doc;
    i !== null ? dn(i, (o) => {
      const a = iy(o, this, e, !r);
      Ux(o, this, a, n, r || {});
    }) : this._pending.push(() => this.insertEmbed(e, n, r || {}));
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(e, n) {
    if (n === 0)
      return;
    const r = this.doc;
    r !== null ? dn(r, (i) => {
      X5(i, iy(i, this, e, !0), n);
    }) : this._pending.push(() => this.delete(e, n));
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(e, n, r) {
    if (n === 0)
      return;
    const i = this.doc;
    i !== null ? dn(i, (o) => {
      const a = iy(o, this, e, !1);
      a.right !== null && K5(o, this, a, n, r);
    }) : this._pending.push(() => this.format(e, n, r));
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? dn(this.doc, (n) => {
      Zb(n, this, e);
    }) : this._pending.push(() => this.removeAttribute(e));
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, n) {
    this.doc !== null ? dn(this.doc, (r) => {
      oE(r, this, e, n);
    }) : this._pending.push(() => this.setAttribute(e, n));
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      aE(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return PN(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(aae);
  }
}
class Nx {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(e, n = () => !0) {
    this._filter = n, this._root = e, this._currentNode = /** @type {Item} */
    e._start, this._firstCall = !0, e.doc ?? vr();
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let e = this._currentNode, n = e && e.content && /** @type {any} */
    e.content.type;
    if (e !== null && (!this._firstCall || e.deleted || !this._filter(n)))
      do
        if (n = /** @type {any} */
        e.content.type, !e.deleted && (n.constructor === pm || n.constructor === Af) && n._start !== null)
          e = n._start;
        else
          for (; e !== null; )
            if (e.right !== null) {
              e = e.right;
              break;
            } else e.parent === this._root ? e = null : e = /** @type {AbstractType<any>} */
            e.parent._item;
      while (e !== null && (e.deleted || !this._filter(
        /** @type {ContentType} */
        e.content.type
      )));
    return this._firstCall = !1, e === null ? { value: void 0, done: !0 } : (this._currentNode = e, { value: (
      /** @type {any} */
      e.content.type
    ), done: !1 });
  }
}
class Af extends cr {
  constructor() {
    super(), this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const e = this._first;
    return e ? e.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  _copy() {
    return new Af();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const e = new Af();
    return e.insert(0, this.toArray().map((n) => n instanceof cr ? n.clone() : n)), e;
  }
  get length() {
    return this.doc ?? vr(), this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(e) {
    return new Nx(this, e);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(e) {
    e = e.toUpperCase();
    const r = new Nx(this, (i) => i.nodeName && i.nodeName.toUpperCase() === e).next();
    return r.done ? null : r.value;
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(e) {
    return e = e.toUpperCase(), Cf(new Nx(this, (n) => n.nodeName && n.nodeName.toUpperCase() === e));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    I1(this, e, new eae(this, n, e));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return UN(this, (e) => e.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n = {}, r) {
    const i = e.createDocumentFragment();
    return r !== void 0 && r._createAssociation(i, this), fm(this, (o) => {
      i.insertBefore(o.toDOM(e, n, r), null);
    }), i;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(e, n) {
    this.doc !== null ? dn(this.doc, (r) => {
      BN(r, this, e, n);
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(e, n) {
    if (this.doc !== null)
      dn(this.doc, (r) => {
        const i = e && e instanceof cr ? e._item : e;
        Jb(r, this, i, n);
      });
    else {
      const r = (
        /** @type {Array<any>} */
        this._prelimContent
      ), i = e === null ? 0 : r.findIndex((o) => o === e) + 1;
      if (i === 0 && e !== null)
        throw kf("Reference item not found");
      r.splice(i, 0, ...n);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(e, n = 1) {
    this.doc !== null ? dn(this.doc, (r) => {
      LN(r, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return FN(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(e) {
    this.insert(this.length, e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(e) {
    return NN(this, e);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(e = 0, n = this.length) {
    return ON(this, e, n);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    fm(this, e);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(lae);
  }
}
class pm extends Af {
  constructor(e = "UNDEFINED") {
    super(), this.nodeName = e, this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((r, i) => {
      this.setAttribute(i, r);
    }), this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new pm(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const e = new pm(this.nodeName), n = this.getAttributes();
    return eoe(n, (r, i) => {
      typeof r == "string" && e.setAttribute(i, r);
    }), e.insert(0, this.toArray().map((r) => r instanceof cr ? r.clone() : r)), e;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const e = this.getAttributes(), n = [], r = [];
    for (const s in e)
      r.push(s);
    r.sort();
    const i = r.length;
    for (let s = 0; s < i; s++) {
      const l = r[s];
      n.push(l + '="' + e[l] + '"');
    }
    const o = this.nodeName.toLocaleLowerCase(), a = n.length > 0 ? " " + n.join(" ") : "";
    return `<${o}${a}>${super.toString()}</${o}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? dn(this.doc, (n) => {
      Zb(n, this, e);
    }) : this._prelimAttrs.delete(e);
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, n) {
    this.doc !== null ? dn(this.doc, (r) => {
      oE(r, this, e, n);
    }) : this._prelimAttrs.set(e, n);
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      aE(this, e)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(e) {
    return (
      /** @type {any} */
      WN(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(e) {
    return (
      /** @type {any} */
      e ? Goe(this, e) : PN(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n = {}, r) {
    const i = e.createElement(this.nodeName), o = this.getAttributes();
    for (const a in o) {
      const s = o[a];
      typeof s == "string" && i.setAttribute(a, s);
    }
    return fm(this, (a) => {
      i.appendChild(a.toDOM(e, n, r));
    }), r !== void 0 && r._createAssociation(i, this), i;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(sae), e.writeKey(this.nodeName);
  }
}
class eae extends A1 {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(e, n, r) {
    super(e, r), this.childListChanged = !1, this.attributesChanged = /* @__PURE__ */ new Set(), n.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.attributesChanged.add(i);
    });
  }
}
class mm extends hm {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  _copy() {
    return new mm();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */
  clone() {
    const e = new mm();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n, r) {
    const i = e.createTextNode(this.toString());
    return r !== void 0 && r._createAssociation(i, this), i;
  }
  toString() {
    return this.toDelta().map((e) => {
      const n = [];
      for (const i in e.attributes) {
        const o = [];
        for (const a in e.attributes[i])
          o.push({ key: a, value: e.attributes[i][a] });
        o.sort((a, s) => a.key < s.key ? -1 : 1), n.push({ nodeName: i, attrs: o });
      }
      n.sort((i, o) => i.nodeName < o.nodeName ? -1 : 1);
      let r = "";
      for (let i = 0; i < n.length; i++) {
        const o = n[i];
        r += `<${o.nodeName}`;
        for (let a = 0; a < o.attrs.length; a++) {
          const s = o.attrs[a];
          r += ` ${s.key}="${s.value}"`;
        }
        r += ">";
      }
      r += e.insert;
      for (let i = n.length - 1; i >= 0; i--)
        r += `</${n[i].nodeName}>`;
      return r;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(cae);
  }
}
class VN {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(e, n) {
    this.id = e, this.length = n;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw la();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(e, n, r) {
    throw la();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    throw la();
  }
}
const tae = 0;
class ul extends VN {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    n > 0 && (this.id.clock += n, this.length -= n), CN(e.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeInfo(tae), e.writeLen(this.length - n);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, n) {
    return null;
  }
}
class O1 {
  /**
   * @param {Uint8Array} content
   */
  constructor(e) {
    this.content = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new O1(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(e) {
    throw la();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
}
class ev {
  /**
   * @param {number} len
   */
  constructor(e) {
    this.len = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new ev(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(e) {
    const n = new ev(this.len - e);
    return this.len = e, n;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.len += e.len, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    TN(e.deleteSet, n.id.client, n.id.clock, this.len), n.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeLen(this.len - n);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
}
const nae = (t, e) => new Vm({ guid: t, ...e, shouldLoad: e.shouldLoad || e.autoLoad || !1 });
class F1 {
  /**
   * @param {Doc} doc
   */
  constructor(e) {
    e._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = e;
    const n = {};
    this.opts = n, e.gc || (n.gc = !1), e.autoLoad && (n.autoLoad = !0), e.meta !== null && (n.meta = e.meta);
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new F1(nae(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(e) {
    throw la();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    this.doc._item = n, e.subdocsAdded.add(this.doc), this.doc.shouldLoad && e.subdocsLoaded.add(this.doc);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    e.subdocsAdded.has(this.doc) ? e.subdocsAdded.delete(this.doc) : e.subdocsRemoved.add(this.doc);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeString(this.doc.guid), e.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
}
class Qf {
  /**
   * @param {Object} embed
   */
  constructor(e) {
    this.embed = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new Qf(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(e) {
    throw la();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
}
class Yn {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(e, n) {
    this.key = e, this.value = n;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new Yn(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(e) {
    throw la();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(e, n) {
    const r = (
      /** @type {YText} */
      n.parent
    );
    r._searchMarker = null, r._hasFormatting = !0;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeKey(this.key), e.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
}
const rae = Xb("node_env") === "development";
class Rf {
  /**
   * @param {Array<any>} arr
   */
  constructor(e) {
    this.arr = e, rae && hN(e);
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new Rf(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(e) {
    const n = new Rf(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), n;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    const r = this.arr.length;
    e.writeLen(r - n);
    for (let i = n; i < r; i++) {
      const o = this.arr[i];
      e.writeAny(o);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
}
class cs {
  /**
   * @param {string} str
   */
  constructor(e) {
    this.str = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new cs(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(e) {
    const n = new cs(this.str.slice(e));
    this.str = this.str.slice(0, e);
    const r = this.str.charCodeAt(e - 1);
    return r >= 55296 && r <= 56319 && (this.str = this.str.slice(0, e - 1) + "�", n.str = "�" + n.str.slice(1)), n;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.str += e.str, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeString(n === 0 ? this.str : this.str.slice(n));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
}
const iae = 0, oae = 1, aae = 2, sae = 3, lae = 4, cae = 6;
class Pl {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(e) {
    this.type = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new Pl(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(e) {
    throw la();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    this.type._integrate(e.doc, n);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.deleted ? n.id.clock < (e.beforeState.get(n.id.client) || 0) && e._mergeStructs.push(n) : n.delete(e), n = n.right;
    this.type._map.forEach((r) => {
      r.deleted ? r.id.clock < (e.beforeState.get(r.id.client) || 0) && e._mergeStructs.push(r) : r.delete(e);
    }), e.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.gc(e, !0), n = n.right;
    this.type._start = null, this.type._map.forEach(
      /** @param {Item | null} item */
      (r) => {
        for (; r !== null; )
          r.gc(e, !0), r = r.left;
      }
    ), this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    this.type._write(e);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
}
const qN = (t, e, n) => {
  const { client: r, clock: i } = e.id, o = new Ei(
    hn(r, i + n),
    e,
    hn(r, i + n - 1),
    e.right,
    e.rightOrigin,
    e.parent,
    e.parentSub,
    e.content.splice(n)
  );
  return e.deleted && o.markDeleted(), e.keep && (o.keep = !0), e.redone !== null && (o.redone = hn(e.redone.client, e.redone.clock + n)), e.right = o, o.right !== null && (o.right.left = o), t._mergeStructs.push(o), o.parentSub !== null && o.right === null && o.parent._map.set(o.parentSub, o), e.length = n, o;
};
let Ei = class hT extends VN {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(e, n, r, i, o, a, s, l) {
    super(e, l.getLength()), this.origin = r, this.left = n, this.right = i, this.rightOrigin = o, this.parent = a, this.parentSub = s, this.redone = null, this.content = l, this.info = this.content.isCountable() ? R5 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(e) {
    (this.info & kx) > 0 !== e && (this.info ^= kx);
  }
  get marker() {
    return (this.info & kx) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & A5) > 0;
  }
  set keep(e) {
    this.keep !== e && (this.info ^= A5);
  }
  get countable() {
    return (this.info & R5) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & Cx) > 0;
  }
  set deleted(e) {
    this.deleted !== e && (this.info ^= Cx);
  }
  markDeleted() {
    this.info |= Cx;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, n) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= ai(n, this.origin.client))
      return this.origin.client;
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= ai(n, this.rightOrigin.client))
      return this.rightOrigin.client;
    if (this.parent && this.parent.constructor === tb && this.id.client !== this.parent.client && this.parent.clock >= ai(n, this.parent.client))
      return this.parent.client;
    if (this.origin && (this.left = H5(e, n, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = kl(e, this.rightOrigin), this.rightOrigin = this.right.id), this.left && this.left.constructor === ul || this.right && this.right.constructor === ul)
      this.parent = null;
    else if (!this.parent)
      this.left && this.left.constructor === hT && (this.parent = this.left.parent, this.parentSub = this.left.parentSub), this.right && this.right.constructor === hT && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
    else if (this.parent.constructor === tb) {
      const r = Fx(n, this.parent);
      r.constructor === ul ? this.parent = null : this.parent = /** @type {ContentType} */
      r.content.type;
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    if (n > 0 && (this.id.clock += n, this.left = H5(e, e.doc.store, hn(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(n), this.length -= n), this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let r = this.left, i;
        if (r !== null)
          i = r.right;
        else if (this.parentSub !== null)
          for (i = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; i !== null && i.left !== null; )
            i = i.left;
        else
          i = /** @type {AbstractType<any>} */
          this.parent._start;
        const o = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set();
        for (; i !== null && i !== this.right; ) {
          if (a.add(i), o.add(i), ty(this.origin, i.origin)) {
            if (i.id.client < this.id.client)
              r = i, o.clear();
            else if (ty(this.rightOrigin, i.rightOrigin))
              break;
          } else if (i.origin !== null && a.has(Fx(e.doc.store, i.origin)))
            o.has(Fx(e.doc.store, i.origin)) || (r = i, o.clear());
          else
            break;
          i = i.right;
        }
        this.left = r;
      }
      if (this.left !== null) {
        const r = this.left.right;
        this.right = r, this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null)
          for (r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; r !== null && r.left !== null; )
            r = r.left;
        else
          r = /** @type {AbstractType<any>} */
          this.parent._start, this.parent._start = this;
        this.right = r;
      }
      this.right !== null ? this.right.left = this : this.parentSub !== null && (this.parent._map.set(this.parentSub, this), this.left !== null && this.left.delete(e)), this.parentSub === null && this.countable && !this.deleted && (this.parent._length += this.length), CN(e.doc.store, this), this.content.integrate(e, this), V5(
        e,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      ), /** @type {AbstractType<any>} */
      (this.parent._item !== null && /** @type {AbstractType<any>} */
      this.parent._item.deleted || this.parentSub !== null && this.right !== null) && this.delete(e);
    } else
      new ul(this.id, this.length).integrate(e, 0);
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let e = this.right;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let e = this.left;
    for (; e !== null && e.deleted; )
      e = e.left;
    return e;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : hn(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(e) {
    if (this.constructor === e.constructor && ty(e.origin, this.lastId) && this.right === e && ty(this.rightOrigin, e.rightOrigin) && this.id.client === e.id.client && this.id.clock + this.length === e.id.clock && this.deleted === e.deleted && this.redone === null && e.redone === null && this.content.constructor === e.content.constructor && this.content.mergeWith(e.content)) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      return n && n.forEach((r) => {
        r.p === e && (r.p = this, !this.deleted && this.countable && (r.index -= this.length));
      }), e.keep && (this.keep = !0), this.right = e.right, this.right !== null && (this.right.left = this), this.length += e.length, !0;
    }
    return !1;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(e) {
    if (!this.deleted) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      this.countable && this.parentSub === null && (n._length -= this.length), this.markDeleted(), TN(e.deleteSet, this.id.client, this.id.clock, this.length), V5(e, n, this.parentSub), this.content.delete(e);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(e, n) {
    if (!this.deleted)
      throw Cl();
    this.content.gc(e), n ? Boe(e, this, new ul(this.id, this.length)) : this.content = new ev(this.length);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(e, n) {
    const r = n > 0 ? hn(this.id.client, this.id.clock + n - 1) : this.origin, i = this.rightOrigin, o = this.parentSub, a = this.content.getRef() & Eie | (r === null ? 0 : Kb) | // origin is defined
    (i === null ? 0 : uN) | // right origin is defined
    (o === null ? 0 : Die);
    if (e.writeInfo(a), r !== null && e.writeLeftID(r), i !== null && e.writeRightID(i), r === null && i === null) {
      const s = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (s._item !== void 0) {
        const l = s._item;
        if (l === null) {
          const c = um(s);
          e.writeParentInfo(!0), e.writeString(c);
        } else
          e.writeParentInfo(!1), e.writeLeftID(l.id);
      } else s.constructor === String ? (e.writeParentInfo(!0), e.writeString(s)) : s.constructor === tb ? (e.writeParentInfo(!1), e.writeLeftID(s)) : Cl();
      o !== null && e.writeString(o);
    }
    this.content.write(e, n);
  }
};
const GN = (
  /** @type {any} */
  typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}
), KN = "__ $YJS$ __";
GN[KN] === !0 && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
GN[KN] = !0;
const uae = new Nt("y-sync");
new Nt("y-undo");
new Nt("yjs-cursor");
const dae = (t, e, n) => {
  if (t === 0)
    return Ox(e, 0, -1);
  let r = e._first === null ? null : (
    /** @type {Y.ContentType} */
    e._first.content.type
  );
  for (; r !== null && e !== r; ) {
    if (r instanceof mm) {
      if (r._length >= t)
        return Ox(r, t, -1);
      if (t -= r._length, r._item !== null && r._item.next !== null)
        r = /** @type {Y.ContentType} */
        r._item.next.content.type;
      else {
        do
          r = r._item === null ? null : r._item.parent, t--;
        while (r !== e && r !== null && r._item !== null && r._item.next === null);
        r !== null && r !== e && (r = r._item === null ? null : (
          /** @type {Y.ContentType} */
          /** @type Y.Item */
          r._item.next.content.type
        ));
      }
    } else {
      const i = (
        /** @type {any} */
        (n.get(r) || { nodeSize: 0 }).nodeSize
      );
      if (r._first !== null && t < i)
        r = /** @type {Y.ContentType} */
        r._first.content.type, t--;
      else {
        if (t === 1 && r._length === 0 && i > 1)
          return new Yb(r._item === null ? null : r._item.id, r._item === null ? um(r) : null, null);
        if (t -= i, r._item !== null && r._item.next !== null)
          r = /** @type {Y.ContentType} */
          r._item.next.content.type;
        else {
          if (t === 0)
            return r = r._item === null ? r : r._item.parent, new Yb(r._item === null ? null : r._item.id, r._item === null ? um(r) : null, null);
          do
            r = /** @type {Y.Item} */
            r._item.parent, t--;
          while (r !== e && /** @type {Y.Item} */
          r._item.next === null);
          r !== e && (r = /** @type {Y.ContentType} */
          /** @type {Y.Item} */
          /** @type {Y.Item} */
          r._item.next.content.type);
        }
      }
    }
    if (r === null)
      throw Cl();
    if (t === 0 && r.constructor !== mm && r !== e)
      return fae(r._item.parent, r._item);
  }
  return Ox(e, e._length, -1);
}, fae = (t, e) => {
  let n = null, r = null;
  return t._item === null ? r = um(t) : n = hn(t._item.id.client, t._item.id.clock), new Yb(n, r, e.id);
};
function sE(t, e, n) {
  const r = [], i = t.node(0);
  n = typeof n == "number" && n >= 0 ? n : t.sameParent(e) ? Math.max(0, t.sharedDepth(e.pos) - 1) : t.sharedDepth(e.pos);
  const o = new Gp(t, e, n), a = o.depth === 0 ? 0 : i.resolve(o.start).posAtIndex(0);
  return o.parent.forEach((s, l) => {
    const c = a + l, u = c + s.nodeSize;
    if (c < o.start || c >= o.end)
      return;
    const d = new eD(i.resolve(c), i.resolve(u));
    r.push(d);
  }), r;
}
class lE {
  constructor(e, n) {
    ti(this, "anchor");
    ti(this, "head");
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new lE(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const n = e.resolve(this.anchor), r = e.resolve(this.head);
    return new Zo(n, r);
  }
}
class Zo extends dt {
  constructor(n, r, i, o = 1) {
    const { doc: a } = n, s = n === r, l = n.pos === a.content.size && r.pos === a.content.size, c = s && !l ? a.resolve(r.pos + (o > 0 ? 1 : -1)) : r, u = s && l ? a.resolve(n.pos - (o > 0 ? 1 : -1)) : n, d = sE(u.min(c), u.max(c), i);
    super(c.pos >= n.pos ? d[0].$from : d[d.length - 1].$to, c.pos >= n.pos ? d[d.length - 1].$to : d[0].$from, d);
    ti(this, "depth");
    this.depth = i;
  }
  get $to() {
    return this.ranges[this.ranges.length - 1].$to;
  }
  eq(n) {
    return n instanceof Zo && n.$from.pos === this.$from.pos && n.$to.pos === this.$to.pos;
  }
  map(n, r) {
    const i = n.resolve(r.map(this.anchor)), o = n.resolve(r.map(this.head));
    return new Zo(i, o);
  }
  toJSON() {
    return { type: "nodeRange", anchor: this.anchor, head: this.head };
  }
  get isForwards() {
    return this.head >= this.anchor;
  }
  get isBackwards() {
    return !this.isForwards;
  }
  extendBackwards() {
    const { doc: n } = this.$from;
    if (this.isForwards && this.ranges.length > 1) {
      const o = this.ranges.slice(0, -1), a = o[0].$from, s = o[o.length - 1].$to;
      return new Zo(a, s, this.depth);
    }
    const r = this.ranges[0], i = n.resolve(Math.max(0, r.$from.pos - 1));
    return new Zo(this.$anchor, i, this.depth);
  }
  extendForwards() {
    const { doc: n } = this.$from;
    if (this.isBackwards && this.ranges.length > 1) {
      const o = this.ranges.slice(1), a = o[0].$from, s = o[o.length - 1].$to;
      return new Zo(s, a, this.depth);
    }
    const r = this.ranges[this.ranges.length - 1], i = n.resolve(Math.min(n.content.size, r.$to.pos + 1));
    return new Zo(this.$anchor, i, this.depth);
  }
  static fromJSON(n, r) {
    return new Zo(n.resolve(r.anchor), n.resolve(r.head));
  }
  static create(n, r, i, o, a = 1) {
    return new this(n.resolve(r), n.resolve(i), o, a);
  }
  getBookmark() {
    return new lE(this.anchor, this.head);
  }
}
function hae(t) {
  const e = t.cloneNode(!0), n = [t, ...Array.from(t.getElementsByTagName("*"))], r = [e, ...Array.from(e.getElementsByTagName("*"))];
  return n.forEach((i, o) => {
    r[o].style.cssText = function(a) {
      let s = "";
      const l = getComputedStyle(a);
      for (let c = 0; c < l.length; c += 1)
        s += `${l[c]}:${l.getPropertyValue(l[c])};`;
      return s;
    }(i);
  }), e;
}
function oy(t, e) {
  return window.getComputedStyle(t)[e];
}
function pae(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function Y5(t) {
  t.parentNode !== null && t.parentNode !== void 0 && t.parentNode.removeChild(t);
}
const XN = (t) => {
  const { x: e, y: n, direction: r, editor: i } = t;
  let o = null, a = null, s = null, l = e;
  for (; a === null && l < window.innerWidth && l > 0; ) {
    const c = document.elementsFromPoint(l, n), u = c.findIndex((f) => f.classList.contains("ProseMirror")), d = c.slice(0, u);
    if (d.length > 0) {
      const f = d[0];
      if (o = f, s = i.view.posAtDOM(f, 0), s >= 0) {
        a = i.state.doc.nodeAt(Math.max(s - 1, 0)), (a === null || a.isText) && (a = i.state.doc.nodeAt(Math.max(s - 1, 0))), a || (a = i.state.doc.nodeAt(Math.max(s, 0)));
        break;
      }
    }
    r === "left" ? l -= 1 : l += 1;
  }
  return { resultElement: o, resultNode: a, pos: s !== null ? s : null };
};
function mae(t, e) {
  const { doc: n } = e.view.state, r = XN({ editor: e, x: t.clientX, y: t.clientY, direction: "right" });
  if (!r.resultNode || r.pos === null)
    return [];
  const i = t.clientX, o = function(u, d, f) {
    const p = parseInt(oy(u.dom, "paddingLeft"), 10), m = parseInt(oy(u.dom, "paddingRight"), 10), g = parseInt(oy(u.dom, "borderLeftWidth"), 10), b = parseInt(oy(u.dom, "borderLeftWidth"), 10), y = u.dom.getBoundingClientRect();
    return { left: pae(d, y.left + p + g, y.right - m - b), top: f };
  }(e.view, i, t.clientY), a = e.view.posAtCoords(o);
  if (!a)
    return [];
  const { pos: s } = a;
  if (!n.resolve(s).parent)
    return [];
  const l = n.resolve(r.pos), c = n.resolve(r.pos + 1);
  return sE(l, c, 0);
}
const J5 = (t, e) => {
  const n = t.resolve(e), { depth: r } = n;
  return r === 0 ? e : n.pos - n.parentOffset - 1;
}, Z5 = (t, e) => {
  const n = t.nodeAt(e), r = t.resolve(e);
  let { depth: i } = r, o = n;
  for (; i > 0; ) {
    const a = r.node(i);
    i -= 1, i === 0 && (o = a);
  }
  return o;
}, Mx = (t, e) => {
  const n = uae.getState(t);
  return n ? dae(e, n.type, n.binding.mapping) : null;
}, Q5 = (t, e) => {
  let n = e;
  for (; n && n.parentNode && n.parentNode !== t.dom; )
    n = n.parentNode;
  return n;
}, YN = new Nt("dragHandle"), gae = ({ pluginKey: t = YN, element: e, editor: n, tippyOptions: r, onNodeChange: i }) => {
  const o = document.createElement("div");
  let a = null, s = !1, l = null, c = -1;
  return e.addEventListener("dragstart", (u) => {
    const { view: d } = n;
    if (!u.dataTransfer)
      return;
    const { empty: f, $from: p, $to: m } = d.state.selection, g = mae(u, n), b = sE(p, m, 0), y = b.some((I) => g.find((le) => le.$from === I.$from && le.$to === I.$to)), w = f || !y ? g : b;
    if (!w.length)
      return;
    const { tr: x } = d.state, k = document.createElement("div"), A = w[0].$from.pos, U = w[w.length - 1].$to.pos, P = Zo.create(d.state.doc, A, U), V = P.content();
    w.forEach((I) => {
      const le = hae(d.nodeDOM(I.$from.pos));
      k.append(le);
    }), k.style.position = "absolute", k.style.top = "-10000px", document.body.append(k), u.dataTransfer.clearData(), u.dataTransfer.setDragImage(k, 0, 0), d.dragging = { slice: V, move: !0 }, x.setSelection(P), d.dispatch(x), document.addEventListener("drop", () => Y5(k), { once: !0 }), setTimeout(() => {
      e && (e.style.pointerEvents = "none");
    }, 0);
  }), e.addEventListener("dragend", () => {
    e && (e.style.pointerEvents = "auto");
  }), new Pt({
    key: typeof t == "string" ? new Nt(t) : t,
    state: {
      init: () => ({ locked: !1 }),
      apply(u, d, f, p) {
        const m = u.getMeta("lockDragHandle"), g = u.getMeta("hideDragHandle");
        if (m !== void 0 && (s = m), g && a)
          return a.hide(), s = !1, l = null, c = -1, i == null || i({ editor: n, node: null, pos: -1 }), d;
        if (u.docChanged && c !== -1 && e && a) {
          const b = u.mapping.map(c);
          b !== c && (c = b, Mx(p, c));
        }
        return d;
      }
    },
    view: (u) => {
      var d;
      return e.draggable = !0, e.style.pointerEvents = "auto", (d = n.view.dom.parentElement) === null || d === void 0 || d.appendChild(o), o.appendChild(e), o.style.pointerEvents = "none", o.style.position = "absolute", o.style.top = "0", o.style.left = "0", a = Fm(u.dom, {
        getReferenceClientRect: null,
        interactive: !0,
        trigger: "manual",
        placement: "left-start",
        hideOnClick: !1,
        duration: 100,
        zIndex: 10,
        popperOptions: {
          modifiers: [
            { name: "flip", enabled: !1 },
            { name: "preventOverflow", options: { rootBoundary: "document", mainAxis: !1 } }
          ]
        },
        ...r,
        appendTo: o,
        content: e
      }), {
        update(f, p) {
          if (!e || !a || (e.draggable = !s, u.state.doc.eq(p.doc) || c === -1))
            return;
          let m = u.nodeDOM(c);
          if (m = Q5(u, m), m === u.dom || (m == null ? void 0 : m.nodeType) !== 1)
            return;
          const g = u.posAtDOM(m, 0), b = Z5(n.state.doc, g);
          if (b !== l) {
            const y = J5(n.state.doc, g);
            l = b, c = y, Mx(u.state, c), i == null || i({ editor: n, node: l, pos: c }), a.setProps({ getReferenceClientRect: () => m.getBoundingClientRect() }), a.show();
          }
        },
        destroy() {
          a == null || a.destroy(), e && Y5(o);
        }
      };
    },
    props: {
      handleDOMEvents: {
        mouseleave: (u, d) => (s || d.target && !o.contains(d.relatedTarget) && (a == null || a.hide(), l = null, c = -1, i == null || i({ editor: n, node: null, pos: -1 })), !1),
        mousemove(u, d) {
          if (!e || !a || s)
            return !1;
          const f = XN({ x: d.clientX, y: d.clientY, direction: "right", editor: n });
          if (!f.resultElement)
            return !1;
          let p = f.resultElement;
          if (p = Q5(u, p), p === u.dom || (p == null ? void 0 : p.nodeType) !== 1)
            return !1;
          const m = u.posAtDOM(p, 0), g = Z5(n.state.doc, m);
          if (g !== l) {
            const b = J5(n.state.doc, m);
            l = g, c = b, Mx(u.state, c), i == null || i({ editor: n, node: l, pos: c }), a.setProps({ getReferenceClientRect: () => p.getBoundingClientRect() }), a.show();
          }
          return !1;
        }
      }
    }
  });
};
var Nc = /* @__PURE__ */ ((t) => (t[t.max = 7] = "max", t[t.min = 0] = "min", t[t.more = 1] = "more", t[t.less = -1] = "less", t))(Nc || {});
function yae(t, e, n) {
  return t < e ? e : t > n ? n : t;
}
function bae(t, e, n, r) {
  const { doc: i, selection: o } = t;
  if (!i || !o || !(o instanceof ot || o instanceof Ci))
    return t;
  const { from: a, to: s } = o;
  return i.nodesBetween(a, s, (l, c) => {
    const u = l.type;
    return n.includes(u.name) ? (t = pT(t, c, e), !1) : !vS(l.type.name, r.extensionManager.extensions);
  }), t;
}
function pT(t, e, n) {
  if (!t.doc)
    return t;
  const r = t.doc.nodeAt(e);
  if (!r)
    return t;
  const a = yae((r.attrs.indent || 0) + n, 0, 7);
  if (a === r.attrs.indent)
    return t;
  const s = {
    ...r.attrs,
    indent: a
  };
  return t.setNodeMarkup(e, r.type, s, r.marks);
}
function eR({ delta: t, types: e }) {
  return ({ state: n, dispatch: r, editor: i }) => {
    const { selection: o } = n;
    let { tr: a } = n;
    return a = a.setSelection(o), a = bae(a, t, e, i), a.docChanged ? (r && r(a), !0) : !1;
  };
}
function vae(t) {
  var V, I, le;
  const { pluginKey: e = YN } = t, { t: n } = Wt(), [r, i] = nt(null), [o, a] = nt(-1), s = Wr(null), l = Wr(null), [c, u] = nt(!1), d = t.editor.extensionManager.extensions.some((be) => be.name === "textAlign"), f = t.editor.extensionManager.extensions.some((be) => be.name === "indent"), p = t.editor.extensionManager.extensions.some((be) => be.name === "clear");
  Tt(() => {
    s.current && !t.editor.isDestroyed && (l.current = gae({
      editor: t.editor,
      element: s.current,
      pluginKey: "ContentItemMenu",
      tippyOptions: {
        offset: [-2, 16],
        zIndex: 99,
        moveTransition: "transform 0.15s ease-out"
      },
      onNodeChange: A
    }), t.editor.registerPlugin(l.current));
  }, [t.editor, s]);
  function m() {
    const be = t.editor.chain();
    be.setNodeSelection(o).unsetAllMarks(), (r == null ? void 0 : r.type.name) !== "paragraph" && be.setParagraph(), be.run();
  }
  function g() {
    t.editor.chain().focus().setNodeSelection(o).run(), document.execCommand("copy");
  }
  function b() {
    t.editor.commands.setNodeSelection(o);
    const { $anchor: be } = t.editor.state.selection, F = be.node(1) || t.editor.state.selection.node;
    t.editor.chain().setMeta("hideDragHandle", !0).insertContentAt(o + ((r == null ? void 0 : r.nodeSize) || 0), F.toJSON()).run();
  }
  function y(be) {
    t.editor.commands.setTextAlign(be);
  }
  function w() {
    const be = pT(t.editor.state.tr, o, 1);
    be.setMeta("hideDragHandle", !0), t.editor.view.dispatch && t.editor.view.dispatch(be);
  }
  function x() {
    const be = pT(t.editor.state.tr, o, -1);
    t.editor.view.dispatch && t.editor.view.dispatch(be);
  }
  function k() {
    t.editor.chain().setMeta("hideDragHandle", !0).setNodeSelection(o).deleteSelection().run();
  }
  function A(be) {
    be.node && i(be.node), a(be.pos);
  }
  function U() {
    var be;
    if (o !== -1) {
      const F = (r == null ? void 0 : r.nodeSize) || 0, G = o + F, C = (r == null ? void 0 : r.type.name) === "paragraph" && ((be = r == null ? void 0 : r.content) == null ? void 0 : be.size) === 0, ie = C ? o + 2 : G + 2;
      t.editor.chain().command(({ dispatch: ee, tr: Z, state: oe }) => ee ? (C ? Z.insertText("/", o, o + 1) : Z.insert(
        G,
        oe.schema.nodes.paragraph.create(null, [oe.schema.text("/")])
      ), ee(Z)) : !0).focus(ie).run();
    }
  }
  Tt(() => (c ? t.editor.commands.setMeta("lockDragHandle", !0) : t.editor.commands.setMeta("lockDragHandle", !1), () => {
    t.editor.commands.setMeta("lockDragHandle", !1);
  }), [c]), Tt(() => () => {
    l.current && (t.editor.unregisterPlugin(e), l.current = null);
  }, []), Tt(() => {
    var be;
    (be = t.editor) != null && be.isDestroyed && l.current && (t.editor.unregisterPlugin(e), l.current = null);
  }, [(V = t.editor) == null ? void 0 : V.isDestroyed]);
  const P = (be) => {
    t != null && t.disabled || u(be);
  };
  return /* @__PURE__ */ z(
    "div",
    {
      className: `drag-handle [transition-property:top,_left] richtext-ease-in-out richtext-duration-200 ${t == null ? void 0 : t.className}`,
      style: {
        opacity: t != null && t.disabled ? 0 : 1
      },
      ref: s,
      children: /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-items-center richtext-gap-0.5 [transition-property:top,_left] richtext-ease-in-out richtext-duration-200", children: [
        /* @__PURE__ */ z(
          fn,
          {
            variant: "ghost",
            size: "icon",
            className: "richtext-w-7 richtext-h-7 richtext-cursor-grab",
            disabled: t == null ? void 0 : t.disabled,
            onClick: U,
            type: "button",
            children: /* @__PURE__ */ z($t, { name: "Plus", className: "richtext-text-lg richtext-text-neutral-600 dark:richtext-text-neutral-200" })
          }
        ),
        /* @__PURE__ */ Fe(hu, { open: c, onOpenChange: P, children: [
          /* @__PURE__ */ Fe("div", { className: "richtext-relative richtext-flex richtext-flex-col", children: [
            /* @__PURE__ */ Fe(Kf, { children: [
              /* @__PURE__ */ z(Xf, { asChild: !0, disabled: t == null ? void 0 : t.disabled, children: /* @__PURE__ */ z(
                fn,
                {
                  variant: "ghost",
                  size: "icon",
                  className: "richtext-w-7 richtext-h-7 richtext-cursor-grab richtext-relative richtext-z-[1]",
                  disabled: t == null ? void 0 : t.disabled,
                  onMouseUp: (be) => {
                    be.preventDefault(), !(t != null && t.disabled) && u(!0);
                  },
                  type: "button",
                  children: /* @__PURE__ */ z($t, { name: "Grip", className: "richtext-text-sm dark:richtext-text-neutral-200 richtext-text-neutral-600" })
                }
              ) }),
              /* @__PURE__ */ z(gu, { children: n("editor.draghandle.tooltip") })
            ] }),
            /* @__PURE__ */ z(pu, { className: "richtext-absolute richtext-top-0 richtext-left-0 richtext-w-[28px] richtext-h-[28px] richtext-z-0" })
          ] }),
          /* @__PURE__ */ Fe(Bl, { className: "richtext-w-48", align: "start", side: "bottom", sideOffset: 0, children: [
            /* @__PURE__ */ Fe(
              Ko,
              {
                onClick: k,
                className: "richtext-flex richtext-gap-3 focus:richtext-text-red-500 focus:richtext-bg-red-400 hover:richtext-bg-red-400 dark:hover:richtext-text-red-500 richtext-bg-opacity-10 hover:richtext-bg-opacity-20 focus:richtext-bg-opacity-30 dark:hover:richtext-bg-opacity-20",
                children: [
                  /* @__PURE__ */ z($t, { name: "Trash2" }),
                  /* @__PURE__ */ z("span", { children: n("editor.remove") })
                ]
              }
            ),
            p ? /* @__PURE__ */ Fe(Ko, { className: "richtext-flex richtext-gap-3", onClick: m, children: [
              /* @__PURE__ */ z($t, { name: "PaintRoller" }),
              /* @__PURE__ */ z("span", { children: n("editor.clear.tooltip") })
            ] }) : null,
            /* @__PURE__ */ Fe(Ko, { className: "richtext-flex richtext-gap-3", onClick: g, children: [
              /* @__PURE__ */ z($t, { name: "Clipboard" }),
              /* @__PURE__ */ z("span", { children: n("editor.copyToClipboard") })
            ] }),
            /* @__PURE__ */ Fe(Ko, { className: "richtext-flex richtext-gap-3", onClick: b, children: [
              /* @__PURE__ */ z($t, { name: "Copy" }),
              /* @__PURE__ */ z("span", { children: n("editor.copy") })
            ] }),
            d || f ? /* @__PURE__ */ z(_1, {}) : null,
            d ? /* @__PURE__ */ Fe(H3, { children: [
              /* @__PURE__ */ Fe(VS, { className: "richtext-flex richtext-gap-3", children: [
                /* @__PURE__ */ z($t, { name: "AlignCenter" }),
                /* @__PURE__ */ z("span", { children: n("editor.textalign.tooltip") })
              ] }),
              /* @__PURE__ */ z($3, { children: /* @__PURE__ */ Fe(qS, { children: [
                /* @__PURE__ */ Fe(Ko, { className: "richtext-flex richtext-gap-3", onClick: () => y("left"), children: [
                  /* @__PURE__ */ z($t, { name: "AlignLeft" }),
                  /* @__PURE__ */ z("span", { children: n("editor.textalign.left.tooltip") })
                ] }),
                /* @__PURE__ */ Fe(Ko, { className: "richtext-flex richtext-gap-3", onClick: () => y("center"), children: [
                  /* @__PURE__ */ z($t, { name: "AlignCenter" }),
                  /* @__PURE__ */ z("span", { children: n("editor.textalign.center.tooltip") })
                ] }),
                /* @__PURE__ */ Fe(Ko, { className: "richtext-flex richtext-gap-3", onClick: () => y("right"), children: [
                  /* @__PURE__ */ z($t, { name: "AlignRight" }),
                  /* @__PURE__ */ z("span", { children: n("editor.textalign.right.tooltip") })
                ] })
              ] }) })
            ] }) : null,
            f ? /* @__PURE__ */ Fe(H3, { children: [
              /* @__PURE__ */ Fe(VS, { className: "richtext-flex richtext-gap-3", children: [
                /* @__PURE__ */ z($t, { name: "IndentIncrease" }),
                /* @__PURE__ */ z("span", { children: n("editor.indent") })
              ] }),
              /* @__PURE__ */ z($3, { children: /* @__PURE__ */ Fe(qS, { children: [
                /* @__PURE__ */ Fe(
                  Ko,
                  {
                    className: "richtext-flex richtext-gap-3",
                    onClick: w,
                    disabled: ((I = r == null ? void 0 : r.attrs) == null ? void 0 : I.indent) >= Nc.max,
                    children: [
                      /* @__PURE__ */ z($t, { name: "IndentIncrease" }),
                      /* @__PURE__ */ z("span", { children: n("editor.indent.tooltip") })
                    ]
                  }
                ),
                /* @__PURE__ */ Fe(
                  Ko,
                  {
                    className: "richtext-flex richtext-gap-3",
                    onClick: x,
                    disabled: ((le = r == null ? void 0 : r.attrs) == null ? void 0 : le.indent) <= Nc.min,
                    children: [
                      /* @__PURE__ */ z($t, { name: "IndentDecrease" }),
                      /* @__PURE__ */ z("span", { children: n("editor.outdent.tooltip") })
                    ]
                  }
                )
              ] }) })
            ] }) : null
          ] })
        ] })
      ] })
    }
  );
}
const wae = {
  maxWidth: "auto",
  zIndex: 20,
  appendTo: "parent",
  moveTransition: "transform 0.1s ease-out"
};
function xae({ item: t, disabled: e, editor: n }) {
  var i;
  const r = t.component;
  return r ? /* @__PURE__ */ z(
    r,
    {
      ...t.componentProps,
      editor: n,
      disabled: e || ((i = t == null ? void 0 : t.componentProps) == null ? void 0 : i.disabled)
    }
  ) : /* @__PURE__ */ z(pn, {});
}
function _ae(t) {
  const { t: e, lang: n } = Wt(), r = ({ editor: o }) => {
    const { selection: a } = o.view.state, { $from: s, to: l } = a;
    return s.pos === l ? !1 : a instanceof ot;
  }, i = Yt(() => t.disabled || !(t != null && t.editor) ? [] : vie(t.editor, e), [t.disabled, t.editor, n, e]);
  return /* @__PURE__ */ z(hs, { shouldShow: r, editor: t == null ? void 0 : t.editor, tippyOptions: wae, children: i != null && i.length ? /* @__PURE__ */ z("div", { className: "richtext-w-auto richtext-px-3 richtext-py-2 richtext-transition-all !richtext-border richtext-rounded-sm richtext-shadow-sm richtext-pointer-events-auto richtext-select-none richtext-border-neutral-200 dark:richtext-border-neutral-800 richtext-bg-background", children: /* @__PURE__ */ z("div", { className: "richtext-flex richtext-items-center richtext-gap-[4px] richtext-flex-nowrap richtext-whitespace-nowrap richtext-h-[26px] richtext-justify-start richtext-relative", children: i == null ? void 0 : i.map((o, a) => (o == null ? void 0 : o.type) === "divider" ? /* @__PURE__ */ z(
    aa,
    {
      orientation: "vertical",
      className: "!richtext-mx-1 !richtext-my-2 !richtext-h-[16px]"
    },
    `bubbleMenu-divider-${a}`
  ) : /* @__PURE__ */ z(
    xae,
    {
      item: o,
      disabled: t.disabled,
      editor: t.editor
    },
    `bubbleMenu-text-${a}`
  )) }) }) : /* @__PURE__ */ z(pn, {}) });
}
function Sae({ fill: t }) {
  return /* @__PURE__ */ z(
    "svg",
    {
      width: "18px",
      height: "18px",
      viewBox: "0 0 256 256",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg",
      children: /* @__PURE__ */ z("g", { id: "icon/填充色", stroke: "none", strokeWidth: 1, fill: "none", fillRule: "evenodd", children: /* @__PURE__ */ Fe("g", { id: "icon/背景颜色", children: [
        /* @__PURE__ */ z("g", { id: "编组", fill: "currentColor", children: /* @__PURE__ */ Fe(
          "g",
          {
            transform: "translate(119.502295, 137.878331) rotate(-135.000000) translate(-119.502295, -137.878331) translate(48.002295, 31.757731)",
            id: "矩形",
            children: [
              /* @__PURE__ */ z(
                "path",
                {
                  d: "M100.946943,60.8084699 L43.7469427,60.8084699 C37.2852111,60.8084699 32.0469427,66.0467383 32.0469427,72.5084699 L32.0469427,118.70847 C32.0469427,125.170201 37.2852111,130.40847 43.7469427,130.40847 L100.946943,130.40847 C107.408674,130.40847 112.646943,125.170201 112.646943,118.70847 L112.646943,72.5084699 C112.646943,66.0467383 107.408674,60.8084699 100.946943,60.8084699 Z M93.646,79.808 L93.646,111.408 L51.046,111.408 L51.046,79.808 L93.646,79.808 Z",
                  fillRule: "nonzero"
                }
              ),
              /* @__PURE__ */ z(
                "path",
                {
                  d: "M87.9366521,16.90916 L87.9194966,68.2000001 C87.9183543,69.4147389 86.9334998,70.399264 85.7187607,70.4 L56.9423078,70.4 C55.7272813,70.4 54.7423078,69.4150264 54.7423078,68.2 L54.7423078,39.4621057 C54.7423078,37.2523513 55.5736632,35.1234748 57.0711706,33.4985176 L76.4832996,12.4342613 C78.9534987,9.75382857 83.1289108,9.5834005 85.8093436,12.0535996 C87.1658473,13.303709 87.9372691,15.0644715 87.9366521,16.90916 Z",
                  fillRule: "evenodd"
                }
              ),
              /* @__PURE__ */ z(
                "path",
                {
                  d: "M131.3,111.241199 L11.7,111.241199 C5.23826843,111.241199 0,116.479467 0,122.941199 L0,200.541199 C0,207.002931 5.23826843,212.241199 11.7,212.241199 L131.3,212.241199 C137.761732,212.241199 143,207.002931 143,200.541199 L143,122.941199 C143,116.479467 137.761732,111.241199 131.3,111.241199 Z M124,130.241 L124,193.241 L19,193.241 L19,130.241 L124,130.241 Z",
                  fillRule: "nonzero"
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ z(
          "path",
          {
            d: "M51,218 L205,218 C211.075132,218 216,222.924868 216,229 C216,235.075132 211.075132,240 205,240 L51,240 C44.9248678,240 40,235.075132 40,229 C40,222.924868 44.9248678,218 51,218 Z",
            id: "矩形",
            fill: t || "#FBDE28"
          }
        )
      ] }) })
    }
  );
}
function JN(t) {
  const [e, n] = nt(void 0);
  function r(a) {
    var s;
    (s = t.action) == null || s.call(t, a);
  }
  function i() {
    var a;
    (a = t.action) == null || a.call(t, e);
  }
  const o = Et(
    k1((a) => {
      n(a);
    }, 350),
    []
  );
  return /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-items-center richtext-h-[32px]", children: [
    /* @__PURE__ */ z(
      Je,
      {
        tooltip: t == null ? void 0 : t.tooltip,
        disabled: t == null ? void 0 : t.disabled,
        action: i,
        tooltipOptions: t == null ? void 0 : t.tooltipOptions,
        shortcutKeys: t == null ? void 0 : t.shortcutKeys,
        children: /* @__PURE__ */ z("span", { className: "richtext-flex richtext-items-center richtext-justify-center richtext-text-sm", children: /* @__PURE__ */ z(Sae, { fill: e }) })
      }
    ),
    /* @__PURE__ */ z(
      x4,
      {
        selectedColor: e,
        setSelectedColor: o,
        onChange: r,
        highlight: !0,
        disabled: t == null ? void 0 : t.disabled,
        children: /* @__PURE__ */ z(fn, { variant: "ghost", size: "icon", className: "!richtext-w-3 !richtext-h-[32px]", disabled: t == null ? void 0 : t.disabled, children: /* @__PURE__ */ z($t, { className: "!richtext-w-3 !richtext-h-3 richtext-text-zinc-500", name: "MenuDown" }) })
      }
    )
  ] });
}
function Tae({ editor: t, disabled: e }) {
  var g, b, y, w, x, k, A, U, P, V, I, le, be, F, G, C, ie, ee;
  const n = ({ editor: Z }) => VU(Z.view.state, "table"), { t: r } = Wt();
  function i() {
    t.chain().focus().addColumnBefore().run();
  }
  function o() {
    t.chain().focus().addColumnAfter().run();
  }
  function a() {
    t.chain().focus().deleteColumn().run();
  }
  function s() {
    t.chain().focus().addRowBefore().run();
  }
  function l() {
    t.chain().focus().addRowAfter().run();
  }
  function c() {
    t.chain().focus().deleteRow().run();
  }
  function u() {
    t.chain().focus().mergeCells().run();
  }
  function d() {
    t == null || t.chain().focus().splitCell().run();
  }
  function f() {
    t.chain().focus().deleteTable().run();
  }
  function p(Z) {
    t.chain().focus().setTableCellBackground(Z).run();
  }
  return /* @__PURE__ */ z(
    hs,
    {
      editor: t,
      pluginKey: "table",
      shouldShow: n,
      updateDelay: 0,
      tippyOptions: {
        offset: [0, 8],
        popperOptions: {
          modifiers: [{ name: "flip", enabled: !1 }]
        },
        maxWidth: "auto",
        getReferenceClientRect: () => {
          var N;
          const {
            view: Z,
            state: {
              selection: { from: oe }
            }
          } = t, te = Z.domAtPos(oe).node;
          if (!te)
            return new DOMRect(-1e3, -1e3, 0, 0);
          const _e = (N = te == null ? void 0 : te.closest) == null ? void 0 : N.call(te, ".tableWrapper");
          return _e ? _e.getBoundingClientRect() : new DOMRect(-1e3, -1e3, 0, 0);
        },
        plugins: [AW],
        sticky: "popper"
      },
      children: e ? /* @__PURE__ */ z(pn, {}) : /* @__PURE__ */ Fe("div", { className: "richtext-min-w-32 richtext-flex richtext-flex-row richtext-h-full richtext-items-center richtext-leading-none richtext-gap-0.5 richtext-p-2 richtext-w-full richtext-bg-background richtext-rounded-lg richtext-shadow-sm !richtext-border richtext-border-border", children: [
        /* @__PURE__ */ z(
          Je,
          {
            icon: "BetweenHorizonalEnd",
            tooltip: r("editor.table.menu.insertColumnBefore"),
            action: i,
            "tooltip-options": {
              sideOffset: 15
            },
            disabled: !((b = (g = t == null ? void 0 : t.can()) == null ? void 0 : g.addColumnBefore) != null && b.call(g))
          }
        ),
        /* @__PURE__ */ z(
          Je,
          {
            icon: "BetweenHorizonalStart",
            tooltip: r("editor.table.menu.insertColumnAfter"),
            action: o,
            "tooltip-options": {
              sideOffset: 15
            },
            disabled: !((w = (y = t == null ? void 0 : t.can()) == null ? void 0 : y.addColumnAfter) != null && w.call(y))
          }
        ),
        /* @__PURE__ */ z(
          Je,
          {
            icon: "DeleteColumn",
            action: a,
            tooltip: r("editor.table.menu.deleteColumn"),
            "tooltip-options": {
              sideOffset: 15
            },
            disabled: !((k = t == null ? void 0 : (x = t.can()).deleteColumn) != null && k.call(x))
          }
        ),
        /* @__PURE__ */ z(aa, { orientation: "vertical", className: "!richtext-mx-1 !richtext-my-2 !richtext-h-[16px]" }),
        /* @__PURE__ */ z(
          Je,
          {
            icon: "BetweenVerticalEnd",
            action: s,
            tooltip: r("editor.table.menu.insertRowAbove"),
            "tooltip-options": {
              sideOffset: 15
            },
            disabled: !((U = t == null ? void 0 : (A = t.can()).addRowBefore) != null && U.call(A))
          }
        ),
        /* @__PURE__ */ z(
          Je,
          {
            icon: "BetweenVerticalStart",
            action: l,
            tooltip: r("editor.table.menu.insertRowBelow"),
            "tooltip-options": {
              sideOffset: 15
            },
            disabled: !((V = (P = t == null ? void 0 : t.can()) == null ? void 0 : P.addRowAfter) != null && V.call(P))
          }
        ),
        /* @__PURE__ */ z(
          Je,
          {
            icon: "DeleteRow",
            action: c,
            tooltip: r("editor.table.menu.deleteRow"),
            "tooltip-options": {
              sideOffset: 15
            },
            disabled: !((le = (I = t == null ? void 0 : t.can()) == null ? void 0 : I.deleteRow) != null && le.call(I))
          }
        ),
        /* @__PURE__ */ z(aa, { orientation: "vertical", className: "!richtext-mx-1 !richtext-my-2 !richtext-h-[16px]" }),
        /* @__PURE__ */ z(
          Je,
          {
            icon: "TableCellsMerge",
            action: u,
            tooltip: r("editor.table.menu.mergeCells"),
            "tooltip-options": {
              sideOffset: 15
            },
            disabled: !((F = (be = t == null ? void 0 : t.can()) == null ? void 0 : be.mergeCells) != null && F.call(be))
          }
        ),
        /* @__PURE__ */ z(
          Je,
          {
            icon: "TableCellsSplit",
            action: d,
            tooltip: r("editor.table.menu.splitCells"),
            "tooltip-options": {
              sideOffset: 15
            },
            disabled: !((C = (G = t == null ? void 0 : t.can()) == null ? void 0 : G.splitCell) != null && C.call(G))
          }
        ),
        /* @__PURE__ */ z(aa, { orientation: "vertical", className: "!richtext-mx-1 !richtext-my-2 !richtext-h-[16px]" }),
        /* @__PURE__ */ z(
          JN,
          {
            editor: t,
            tooltip: r("editor.table.menu.setCellsBgColor"),
            action: p,
            tooltipOptions: {
              sideOffset: 15
            }
          }
        ),
        /* @__PURE__ */ z(
          Je,
          {
            icon: "Trash2",
            tooltip: r("editor.table.menu.deleteTable"),
            action: f,
            "tooltip-options": {
              sideOffset: 15
            },
            disabled: !((ee = (ie = t == null ? void 0 : t.can()) == null ? void 0 : ie.deleteTable) != null && ee.call(ie))
          }
        )
      ] })
    }
  );
}
function ZN(t) {
  const { t: e } = Wt(), [n, r] = nt({
    text: "",
    link: ""
  }), [i, o] = nt(!1);
  Tt(() => {
    var s;
    if (t != null && t.editor) {
      const { href: l, target: c } = (s = t.editor) == null ? void 0 : s.getAttributes("link"), { from: u, to: d } = t.editor.state.selection, f = t.editor.state.doc.textBetween(u, d, " ");
      r({
        link: l,
        text: f
      }), o(c === "_blank");
    }
  }, [t == null ? void 0 : t.editor]);
  function a(s) {
    s.preventDefault(), s.stopPropagation(), t == null || t.onSetLink(n.link, n.text, i);
  }
  return /* @__PURE__ */ z("div", { className: "richtext-p-2 richtext-bg-white !richtext-border richtext-rounded-lg richtext-shadow-sm dark:richtext-bg-black border-neutral-200 dark:richtext-border-neutral-800", children: /* @__PURE__ */ Fe("form", { className: "richtext-flex richtext-flex-col richtext-gap-2", onSubmit: a, children: [
    /* @__PURE__ */ z(eo, { className: "mb-[6px]", children: e("editor.link.dialog.text") }),
    /* @__PURE__ */ z("div", { className: "richtext-flex richtext-w-full richtext-max-w-sm richtext-items-center richtext-gap-1.5 richtext-mb-[10px]", children: /* @__PURE__ */ z("div", { className: "richtext-relative richtext-items-center richtext-w-full richtext-max-w-sm", children: /* @__PURE__ */ z(
      Pr,
      {
        type: "text",
        value: n.text,
        required: !0,
        className: "richtext-w-80",
        placeholder: "Text",
        onChange: (s) => r({ ...n, text: s.target.value })
      }
    ) }) }),
    /* @__PURE__ */ z(eo, { className: "mb-[6px]", children: e("editor.link.dialog.link") }),
    /* @__PURE__ */ z("div", { className: "richtext-flex richtext-w-full richtext-max-w-sm richtext-items-center richtext-gap-1.5", children: /* @__PURE__ */ Fe("div", { className: "richtext-relative richtext-items-center richtext-w-full richtext-max-w-sm", children: [
      /* @__PURE__ */ z(
        Pr,
        {
          type: "url",
          value: n.link,
          required: !0,
          className: "richtext-pl-10",
          onChange: (s) => r({ ...n, link: s.target.value })
        }
      ),
      /* @__PURE__ */ z("span", { className: "richtext-absolute richtext-inset-y-0 richtext-flex richtext-items-center richtext-justify-center richtext-px-2 richtext-start-0", children: /* @__PURE__ */ z($t, { className: "richtext-size-5 richtext-text-muted-foreground", name: "Link" }) })
    ] }) }),
    /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-items-center richtext-space-x-2", children: [
      /* @__PURE__ */ z(eo, { children: e("editor.link.dialog.openInNewTab") }),
      /* @__PURE__ */ z(
        BD,
        {
          checked: i,
          onCheckedChange: (s) => {
            o(s);
          }
        }
      )
    ] }),
    /* @__PURE__ */ z(fn, { type: "submit", className: "richtext-self-end richtext-mt-2", children: e("editor.link.dialog.button.apply") })
  ] }) });
}
function Dae(t) {
  const { t: e } = Wt();
  return /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-items-center richtext-gap-2 richtext-p-2 richtext-bg-white !richtext-border richtext-rounded-lg richtext-shadow-sm dark:richtext-bg-black richtext-border-neutral-200 dark:richtext-border-neutral-800", children: [
    /* @__PURE__ */ z(
      "a",
      {
        href: t == null ? void 0 : t.link,
        target: "_blank",
        rel: "noopener noreferrer",
        className: "richtext-text-sm richtext-underline richtext-break-all",
        children: Rre(t == null ? void 0 : t.link, {
          length: 50,
          omission: "…"
        })
      }
    ),
    (t == null ? void 0 : t.link) && /* @__PURE__ */ z(aa, { orientation: "vertical", className: "!richtext-h-4" }),
    /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-flex-nowrap", children: [
      /* @__PURE__ */ z(
        Je,
        {
          icon: "Pencil",
          tooltip: e("editor.link.edit.tooltip"),
          action: () => {
            t == null || t.onEdit();
          },
          tooltipOptions: { sideOffset: 15 }
        }
      ),
      /* @__PURE__ */ z(
        Je,
        {
          icon: "Unlink",
          tooltip: e("editor.link.unlink.tooltip"),
          action: () => {
            t == null || t.onClear();
          },
          tooltipOptions: { sideOffset: 15 }
        }
      )
    ] })
  ] });
}
function Eae({ editor: t, disabled: e }) {
  const [n, r] = nt(!1), i = Yt(() => {
    const { href: l } = t.getAttributes("link");
    return l;
  }, [t]), o = Et(({ editor: l }) => l.isActive("link"), []), a = (l, c, u) => {
    t.chain().extendMarkRange("link").insertContent({
      type: "text",
      text: c,
      marks: [
        {
          type: "link",
          attrs: {
            href: l,
            target: u ? "_blank" : ""
          }
        }
      ]
    }).setLink({ href: l }).focus().run(), r(!1);
  }, s = Et(() => {
    t.chain().extendMarkRange("link").unsetLink().focus().run(), r(!1);
  }, [t]);
  return /* @__PURE__ */ z(pn, { children: /* @__PURE__ */ z(
    hs,
    {
      editor: t,
      shouldShow: o,
      tippyOptions: {
        popperOptions: {
          modifiers: [{ name: "flip", enabled: !1 }]
        },
        placement: "bottom-start",
        offset: [-2, 16],
        zIndex: 9999,
        onHidden: () => {
          r(!1);
        }
      },
      children: e ? /* @__PURE__ */ z(pn, {}) : /* @__PURE__ */ z(pn, { children: n ? /* @__PURE__ */ z(ZN, { onSetLink: a, editor: t }) : /* @__PURE__ */ z(
        Dae,
        {
          editor: t,
          onClear: s,
          onEdit: () => {
            r(!0);
          },
          link: i
        }
      ) })
    }
  ) });
}
const cE = {
  maxWidth: "auto",
  zIndex: 20,
  appendTo: "parent",
  moveTransition: "transform 0.1s ease-out"
};
function uE({ item: t, disabled: e, editor: n }) {
  var i;
  const r = t.component;
  return r ? /* @__PURE__ */ z(Xv, { children: t.type === "divider" ? /* @__PURE__ */ z(aa, { orientation: "vertical", className: "!richtext-mx-1 !richtext-my-2 !richtext-h-[16px]" }) : /* @__PURE__ */ z(
    r,
    {
      ...t.componentProps,
      editor: n,
      disabled: e || ((i = t == null ? void 0 : t.componentProps) == null ? void 0 : i.disabled)
    }
  ) }) : /* @__PURE__ */ z(pn, {});
}
function Cae(t) {
  return t.type.name === "image";
}
function kae(t) {
  return t.type.name === r7.name;
}
function Aae(t) {
  return t.type.name === "video";
}
function Rae(t) {
  const { lang: e } = Wt(), n = ({ editor: i }) => {
    const { selection: o } = i.view.state, { $from: a, to: s } = o;
    let l = !1;
    return i.view.state.doc.nodesBetween(a.pos, s, (c) => {
      if (Cae(c))
        return l = !0, !1;
    }), l;
  }, r = Yt(() => t.disabled ? [] : gie(t.editor), [t.disabled, t.editor, e]);
  return /* @__PURE__ */ z(pn, { children: /* @__PURE__ */ z(
    hs,
    {
      shouldShow: n,
      editor: t == null ? void 0 : t.editor,
      tippyOptions: cE,
      children: r != null && r.length ? /* @__PURE__ */ z("div", { className: "richtext-w-auto richtext-px-3 richtext-py-2 richtext-transition-all !richtext-border richtext-rounded-sm richtext-shadow-sm richtext-pointer-events-auto richtext-select-none richtext-border-neutral-200 dark:richtext-border-neutral-800 richtext-bg-background", children: /* @__PURE__ */ z("div", { className: "richtext-flex richtext-items-center richtext-flex-nowrap richtext-whitespace-nowrap richtext-h-[26px] richtext-justify-start richtext-relative", children: r == null ? void 0 : r.map((i, o) => /* @__PURE__ */ z(
        uE,
        {
          item: i,
          disabled: t.disabled,
          editor: t.editor
        },
        `bubbleMenu-image-${o}`
      )) }) }) : /* @__PURE__ */ z(pn, {})
    }
  ) });
}
function Iae(t) {
  const { lang: e } = Wt(), n = ({ editor: i }) => {
    const { selection: o } = i.view.state, { $from: a, to: s } = o;
    let l = !1;
    return i.view.state.doc.nodesBetween(a.pos, s, (c) => {
      if (kae(c))
        return l = !0, !1;
    }), l;
  }, r = Yt(() => t.disabled ? [] : yie(t.editor), [t.disabled, t.editor, e]);
  return /* @__PURE__ */ z(pn, { children: /* @__PURE__ */ z(
    hs,
    {
      shouldShow: n,
      editor: t == null ? void 0 : t.editor,
      tippyOptions: cE,
      children: r != null && r.length ? /* @__PURE__ */ z("div", { className: "richtext-w-auto richtext-px-3 richtext-py-2 richtext-transition-all !richtext-border richtext-rounded-sm richtext-shadow-sm richtext-pointer-events-auto richtext-select-none richtext-border-neutral-200 dark:richtext-border-neutral-800 richtext-bg-background", children: /* @__PURE__ */ z("div", { className: "richtext-flex richtext-items-center richtext-flex-nowrap richtext-whitespace-nowrap richtext-h-[26px] richtext-justify-start richtext-relative", children: r == null ? void 0 : r.map((i, o) => /* @__PURE__ */ z(
        uE,
        {
          item: i,
          disabled: t.disabled,
          editor: t.editor
        },
        `bubbleMenu-image-gif-${o}`
      )) }) }) : /* @__PURE__ */ z(pn, {})
    }
  ) });
}
function Oae(t) {
  const { lang: e } = Wt(), n = ({ editor: i }) => {
    const { selection: o } = i.view.state, { $from: a, to: s } = o;
    let l = !1;
    return i.view.state.doc.nodesBetween(a.pos, s, (c) => {
      if (Aae(c))
        return l = !0, !1;
    }), l;
  }, r = Yt(() => t.disabled ? [] : bie(t.editor), [t.editor, t.disabled, e]);
  return /* @__PURE__ */ z(pn, { children: /* @__PURE__ */ z(
    hs,
    {
      shouldShow: n,
      editor: t == null ? void 0 : t.editor,
      tippyOptions: cE,
      children: r != null && r.length ? /* @__PURE__ */ z("div", { className: "richtext-w-auto richtext-px-3 richtext-py-2 richtext-transition-all !richtext-border richtext-rounded-sm richtext-shadow-sm richtext-pointer-events-auto richtext-select-none richtext-border-neutral-200 dark:richtext-border-neutral-800 richtext-bg-background", children: /* @__PURE__ */ z("div", { className: "richtext-flex richtext-items-center richtext-flex-nowrap richtext-whitespace-nowrap richtext-h-[26px] richtext-justify-start richtext-relative", children: r == null ? void 0 : r.map((i, o) => /* @__PURE__ */ z(
        uE,
        {
          item: i,
          disabled: t.disabled,
          editor: t.editor
        },
        `bubbleMenu-video-${o}`
      )) }) }) : /* @__PURE__ */ z(pn, {})
    }
  ) });
}
function Fae({ editor: t }) {
  const { t: e } = Wt(), n = Et(() => t.isActive(bm.name), [t]), r = Et(() => zD(bm.name, t), [t]), i = Et(() => t.chain().focus().addColBefore().run(), [t]), o = Et(() => t.chain().focus().addColAfter().run(), [t]), a = Et(() => t.chain().focus().deleteCol().run(), [t]);
  return /* @__PURE__ */ z(
    hs,
    {
      pluginKey: "columns-bubble-menu",
      editor: t,
      shouldShow: n,
      tippyOptions: {
        popperOptions: {
          modifiers: [{ name: "flip", enabled: !1 }]
        },
        placement: "bottom-start",
        offset: [-2, 16],
        zIndex: 9999
        // onHidden: () => {
        //   toggleVisible(false)
        // },
      },
      children: /* @__PURE__ */ Fe("div", { className: "richtext-w-auto richtext-px-3 richtext-py-2 richtext-transition-all !richtext-border richtext-rounded-sm richtext-shadow-sm richtext-pointer-events-auto richtext-select-none richtext-border-neutral-200 dark:richtext-border-neutral-800 richtext-bg-background", children: [
        /* @__PURE__ */ z(
          Je,
          {
            action: i,
            icon: "ColumnAddLeft",
            tooltip: e("editor.table.menu.insertColumnBefore")
          }
        ),
        /* @__PURE__ */ z(
          Je,
          {
            action: o,
            icon: "ColumnAddRight",
            tooltip: e("editor.table.menu.insertColumnAfter")
          }
        ),
        /* @__PURE__ */ z(
          Je,
          {
            action: a,
            icon: "DeleteColumn",
            tooltip: e("editor.table.menu.deleteColumn")
          }
        ),
        /* @__PURE__ */ z(
          Je,
          {
            action: r,
            icon: "Trash2",
            tooltip: e("editor.table.menu.delete_column")
          }
        )
      ] })
    }
  );
}
const w2e = HV.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: Je,
        componentProps: {
          action: () => e.commands.toggleBold(),
          isActive: () => e.isActive("bold") || !1,
          disabled: !e.can().toggleBold(),
          icon: "Bold",
          shortcutKeys: ["mod", "B"],
          tooltip: n("editor.bold.tooltip")
        }
      })
    };
  }
}), Uae = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, Nae = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, Mae = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, Bae = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, Lae = li.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (t) => t.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["em", bt(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: t }) => t.setMark(this.name),
      toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      Zc({
        find: Uae,
        type: this.type
      }),
      Zc({
        find: Mae,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Dl({
        find: Nae,
        type: this.type
      }),
      Dl({
        find: Bae,
        type: this.type
      })
    ];
  }
}), x2e = Lae.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button({ editor: e, t: n }) {
        return {
          component: Je,
          componentProps: {
            action: () => e.commands.toggleItalic(),
            isActive: () => e.isActive("italic") || !1,
            disabled: !e.can().toggleItalic(),
            shortcutKeys: ["mod", "I"],
            icon: "Italic",
            tooltip: n("editor.italic.tooltip")
          }
        };
      }
    };
  }
}), Pae = li.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["u", bt(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: t }) => t.setMark(this.name),
      toggleUnderline: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetUnderline: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
}), _2e = Pae.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button({ editor: e, t: n }) {
        return {
          component: Je,
          componentProps: {
            action: () => e.commands.toggleUnderline(),
            isActive: () => e.isActive("underline") || !1,
            disabled: !e.can().toggleUnderline(),
            icon: "Underline",
            shortcutKeys: ["mod", "U"],
            tooltip: n("editor.underline.tooltip")
          }
        };
      }
    };
  }
}), Wae = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, zae = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, $ae = li.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["s", bt(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: t }) => t.setMark(this.name),
      toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      Zc({
        find: Wae,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Dl({
        find: zae,
        type: this.type
      })
    ];
  }
}), S2e = $ae.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: Je,
        componentProps: {
          action: () => e.commands.toggleStrike(),
          isActive: () => e.isActive("strike") || !1,
          disabled: !e.can().toggleStrike(),
          icon: "Strikethrough",
          shortcutKeys: ["shift", "mod", "X"],
          tooltip: n("editor.strike.tooltip")
        }
      })
    };
  }
}), Hae = new RegExp("(?<!`)`([^`]+)`(?!`)"), jae = new RegExp("(?<!`)`([^`]+)`(?!`)", "g"), Vae = li.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["code", bt(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: t }) => t.setMark(this.name),
      toggleCode: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetCode: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      Zc({
        find: Hae,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Dl({
        find: jae,
        type: this.type
      })
    ];
  }
}), T2e = Vae.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: Je,
        componentProps: {
          action: () => e.commands.toggleCode(),
          isActive: () => e.isActive("code") || !1,
          disabled: !e.can().toggleCode(),
          icon: "Code",
          shortcutKeys: ["mod", "E"],
          tooltip: n("editor.code.tooltip")
        }
      })
    };
  }
}), qae = li.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (t) => t.hasAttribute("style") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["span", bt(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state: t, commands: e }) => {
        const n = mD(t, this.type);
        return Object.entries(n).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name);
      }
    };
  }
}), Gae = St.create({
  name: "fontFamily",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontFamily: {
            default: null,
            parseHTML: (t) => t.style.fontFamily,
            renderHTML: (t) => t.fontFamily ? {
              style: `font-family: ${t.fontFamily}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontFamily: (t) => ({ chain: e }) => e().setMark("textStyle", { fontFamily: t }).run(),
      unsetFontFamily: () => ({ chain: t }) => t().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run()
    };
  }
});
function Kae(t) {
  var i, o, a;
  const { t: e, lang: n } = Wt(), r = Yt(() => {
    var c;
    const s = (c = t == null ? void 0 : t.items) == null ? void 0 : c.find((u) => u.isActive());
    return s && !s.default ? {
      ...s
    } : {
      title: t.tooltip,
      font: e("editor.fontFamily.default.tooltip"),
      isActive: () => !1,
      disabled: !1,
      action: () => t.editor.chain().focus().unsetFontFamily().run()
    };
  }, [e, n, t]);
  return /* @__PURE__ */ Fe(hu, { children: [
    /* @__PURE__ */ z(pu, { disabled: t == null ? void 0 : t.disabled, asChild: !0, children: /* @__PURE__ */ z(
      vD,
      {
        title: ((i = r == null ? void 0 : r.font) == null ? void 0 : i.length) > 7 ? `${(o = r == null ? void 0 : r.font) == null ? void 0 : o.slice(0, 6)}...` : r == null ? void 0 : r.font,
        tooltip: t == null ? void 0 : t.tooltip,
        disabled: t == null ? void 0 : t.disabled,
        icon: "MenuDown"
      }
    ) }),
    /* @__PURE__ */ z(Bl, { className: "richtext-w-full", children: (a = t == null ? void 0 : t.items) == null ? void 0 : a.map((s, l) => {
      const c = s.font === e("editor.fontFamily.default.tooltip") ? {} : { fontFamily: s.font };
      return /* @__PURE__ */ Fe(Xv, { children: [
        /* @__PURE__ */ z(mu, { checked: (r == null ? void 0 : r.font) === s.font, onClick: s.action, children: /* @__PURE__ */ z("div", { className: "richtext-h-full richtext-ml-1", style: c, children: s.font }) }),
        s.font === e("editor.fontFamily.default.tooltip") && /* @__PURE__ */ z(_1, {})
      ] }, `font-family-${l}`);
    }) })
  ] });
}
const D2e = Gae.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      fontFamilyList: CZ,
      button({ editor: e, extension: n, t: r }) {
        var c;
        const { extensions: i = [] } = e.extensionManager ?? [], o = iT(((c = n == null ? void 0 : n.options) == null ? void 0 : c.fontFamilyList) || []), a = i.find(
          (u) => u.name === "base-kit"
        ), s = o.map((u) => ({
          action: () => {
            e.chain().focus().setFontFamily(u.value).run();
          },
          isActive: () => e.isActive("textStyle", { fontFamily: u.value }) || !1,
          disabled: !e.can().setFontFamily(u.value),
          title: u.name,
          font: u.value
        }));
        a && a.options.textStyle !== !1 && s.unshift({
          action: () => e.chain().focus().unsetFontFamily().run(),
          isActive: () => !1,
          disabled: !1,
          font: r("editor.fontFamily.default.tooltip"),
          title: r("editor.fontFamily.tooltip")
        });
        const l = s.filter((u) => u.disabled).length === s.length;
        return {
          component: Kae,
          componentProps: {
            tooltip: r("editor.fontFamily.tooltip"),
            disabled: l,
            items: s,
            editor: e
          }
        };
      }
    };
  }
}), Xae = rn.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((t) => ({
      tag: `h${t}`,
      attrs: { level: t }
    }));
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, bt(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
      toggleHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((t, e) => ({
      ...t,
      [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((t) => UV({
      find: new RegExp(`^(#{1,${t}})\\s$`),
      type: this.type,
      getAttributes: {
        level: t
      }
    }));
  }
});
function Yae(t) {
  var n;
  const e = Yt(() => {
    var o;
    const r = (o = t == null ? void 0 : t.items) == null ? void 0 : o.find((a) => a.isActive());
    return r && !r.default ? {
      ...r
    } : {
      title: t.tooltip,
      level: 0,
      isActive: () => !1
    };
  }, [t]);
  return /* @__PURE__ */ Fe(hu, { children: [
    /* @__PURE__ */ z(pu, { disabled: t == null ? void 0 : t.disabled, asChild: !0, children: /* @__PURE__ */ z(
      vD,
      {
        title: e == null ? void 0 : e.title,
        tooltip: t == null ? void 0 : t.tooltip,
        disabled: t == null ? void 0 : t.disabled,
        icon: "MenuDown"
      }
    ) }),
    /* @__PURE__ */ z(Bl, { className: "richtext-w-full", children: (n = t == null ? void 0 : t.items) == null ? void 0 : n.map((r, i) => {
      var o, a;
      return /* @__PURE__ */ Fe(Xv, { children: [
        /* @__PURE__ */ Fe(
          mu,
          {
            checked: (e == null ? void 0 : e.title) === r.title,
            onClick: r.action,
            children: [
              /* @__PURE__ */ z("div", { className: `richtext-ml-1 richtext-h-full heading-${r.level}`, children: r.title }),
              !!((o = r == null ? void 0 : r.shortcutKeys) != null && o.length) && /* @__PURE__ */ z(a4, { className: "richtext-pl-4", children: (a = r == null ? void 0 : r.shortcutKeys) == null ? void 0 : a.map((s) => h1(s)).join(" ") })
            ]
          }
        ),
        r.level === 0 && /* @__PURE__ */ z(_1, {})
      ] }, `heading-k-${i}`);
    }) })
  ] });
}
const E2e = Xae.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      levels: [1, 2, 3, 4, 5, 6],
      button({ editor: e, extension: n, t: r }) {
        var c;
        const { extensions: i = [] } = e.extensionManager ?? [], o = ((c = n.options) == null ? void 0 : c.levels) || [], a = i.find(
          (u) => u.name === "base-kit"
        ), s = o.map((u) => ({
          action: () => e.commands.toggleHeading({ level: u }),
          isActive: () => e.isActive("heading", { level: u }) || !1,
          disabled: !e.can().toggleHeading({ level: u }),
          title: r(`editor.heading.h${u}.tooltip`),
          level: u,
          shortcutKeys: ["alt", "mod", `${u}`]
        }));
        a && a.options.paragraph !== !1 && s.unshift({
          action: () => e.commands.setParagraph(),
          isActive: () => e.isActive("paragraph") || !1,
          disabled: !e.can().setParagraph(),
          level: 0,
          title: r("editor.paragraph.tooltip"),
          shortcutKeys: ["alt", "mod", "0"]
        });
        const l = s.filter((u) => u.disabled).length === s.length;
        return {
          component: Yae,
          componentProps: {
            tooltip: r("editor.heading.tooltip"),
            disabled: l,
            items: s,
            editor: e
          }
        };
      }
    };
  }
}), Jae = St.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: "left"
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (t) => {
              const e = t.style.textAlign || this.options.defaultAlignment;
              return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
            },
            renderHTML: (t) => t.textAlign === this.options.defaultAlignment ? {} : { style: `text-align: ${t.textAlign}` }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (t) => ({ commands: e }) => this.options.alignments.includes(t) ? this.options.types.map((n) => e.updateAttributes(n, { textAlign: t })).every((n) => n) : !1,
      unsetTextAlign: () => ({ commands: t }) => this.options.types.map((e) => t.resetAttributes(e, "textAlign")).every((e) => e)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});
function Zae(t) {
  var n;
  const e = Yt(() => {
    var o;
    const r = (o = t == null ? void 0 : t.items) == null ? void 0 : o.find((a) => a.isActive());
    return r && !r.default ? {
      ...r,
      icon: r.icon ? r.icon : t.icon
    } : {
      title: t == null ? void 0 : t.tooltip,
      icon: t.icon,
      isActive: () => !1
    };
  }, [t]);
  return /* @__PURE__ */ Fe(Eo, { modal: !0, children: [
    /* @__PURE__ */ z(Co, { disabled: t == null ? void 0 : t.disabled, asChild: !0, children: /* @__PURE__ */ z(
      Je,
      {
        customClass: "!richtext-w-12 richtext-h-12",
        icon: t == null ? void 0 : t.icon,
        tooltip: t == null ? void 0 : t.tooltip,
        disabled: t == null ? void 0 : t.disabled,
        children: /* @__PURE__ */ z($t, { className: "richtext-w-3 richtext-h-3 richtext-ml-1 richtext-text-zinc-500", name: "MenuDown" })
      }
    ) }),
    /* @__PURE__ */ z(
      oo,
      {
        className: "richtext-min-w-4 richtext-w-full !richtext-p-[4px] richtext-flex richtext-flex-row richtext-gap-1",
        align: "start",
        side: "bottom",
        children: (n = t == null ? void 0 : t.items) == null ? void 0 : n.map((r, i) => {
          var o, a;
          return /* @__PURE__ */ Fe(Kf, { children: [
            /* @__PURE__ */ z(Xf, { asChild: !0, children: /* @__PURE__ */ z(
              zm,
              {
                size: "sm",
                onClick: r == null ? void 0 : r.action,
                className: "richtext-p-1 richtext-w-7 richtext-h-7",
                pressed: e.title === r.title,
                "data-state": e.title === r.title ? "on" : "off",
                children: (r == null ? void 0 : r.icon) && /* @__PURE__ */ z($t, { name: r.icon })
              }
            ) }),
            /* @__PURE__ */ Fe(gu, { className: "richtext-flex richtext-flex-col richtext-items-center", children: [
              /* @__PURE__ */ z("span", { children: r.title }),
              !!((o = r.shortcutKeys) != null && o.length) && /* @__PURE__ */ z("span", { children: (a = r.shortcutKeys) == null ? void 0 : a.map((s) => h1(s)).join(" ") })
            ] })
          ] }, `text-align-${i}`);
        })
      }
    )
  ] });
}
const C2e = Jae.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      types: ["heading", "paragraph", "list_item", "title"],
      button({
        editor: e,
        extension: n,
        t: r
      }) {
        var c;
        const i = ((c = n.options) == null ? void 0 : c.alignments) || [], o = {
          left: ["mod", "Shift", "L"],
          center: ["mod", "Shift", "E"],
          right: ["mod", "Shift", "R"],
          justify: ["mod", "Shift", "J"]
        }, a = {
          left: "AlignLeft",
          center: "AlignCenter",
          right: "AlignRight",
          justify: "AlignJustify"
        }, s = i.map((u) => {
          var d, f, p;
          return {
            title: r(`editor.textalign.${u}.tooltip`),
            icon: a[u],
            shortcutKeys: o[u],
            isActive: () => e.isActive({ textAlign: u }) || !1,
            action: () => {
              var m, g;
              return (g = (m = e.commands) == null ? void 0 : m.setTextAlign) == null ? void 0 : g.call(m, u);
            },
            disabled: !((p = (f = (d = e == null ? void 0 : e.can) == null ? void 0 : d.call(e)) == null ? void 0 : f.setTextAlign) != null && p.call(f, u))
          };
        }), l = s.filter((u) => u.disabled).length === s.length;
        return {
          component: Zae,
          componentProps: {
            icon: "AlignJustify",
            tooltip: r("editor.textalign.tooltip"),
            disabled: l,
            items: s
          }
        };
      }
    };
  }
});
function Qae(t) {
  var r;
  const { t: e } = Wt(), n = Yt(() => {
    const i = (t.items || []).find((a) => a.isActive());
    return i || {
      title: e("editor.fontSize.default.tooltip"),
      isActive: () => !1
    };
  }, [t]);
  return /* @__PURE__ */ Fe(hu, { children: [
    /* @__PURE__ */ z(pu, { disabled: t == null ? void 0 : t.disabled, asChild: !0, children: /* @__PURE__ */ z(
      vD,
      {
        title: n == null ? void 0 : n.title,
        tooltip: `${t == null ? void 0 : t.tooltip}`,
        disabled: t == null ? void 0 : t.disabled,
        icon: "MenuDown"
      }
    ) }),
    /* @__PURE__ */ z(Bl, { className: "richtext-w-32 richtext-overflow-y-auto richtext-max-h-96", children: (r = t == null ? void 0 : t.items) == null ? void 0 : r.map((i, o) => /* @__PURE__ */ z(
      mu,
      {
        checked: n.title === i.title,
        onClick: i.action,
        children: /* @__PURE__ */ z("div", { className: "richtext-h-full richtext-ml-1", children: i.title })
      },
      `font-size-${o}`
    )) })
  ] });
}
const k2e = St.create({
  name: "fontSize",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      types: ["textStyle"],
      fontSizes: [...kZ],
      button({ editor: e, extension: n, t: r }) {
        var l;
        const i = iT(((l = n.options) == null ? void 0 : l.fontSizes) || Y3), o = iT([Y3])[0], a = i.map((c) => ({
          title: c.value === o.value ? r("editor.fontSize.default.tooltip") : String(c.name),
          isActive: () => {
            const { fontSize: u } = e.getAttributes("textStyle");
            return c.value === o.value && u === void 0 ? !0 : e.isActive({ fontSize: String(c.value) }) || !1;
          },
          action: () => {
            if (c.value === o.value) {
              e.commands.unsetFontSize();
              return;
            }
            e.commands.setFontSize(String(c.value));
          },
          disabled: !e.can().setFontSize(String(c.value)),
          divider: c.value === o.value || !1,
          default: c.value === o.value || !1
        })), s = a.filter((c) => c.disabled).length === a.length;
        return {
          component: Qae,
          componentProps: {
            editor: e,
            tooltip: r("editor.fontSize.tooltip"),
            disabled: s,
            items: a,
            maxHeight: 280
          }
        };
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontSize: {
            default: null,
            parseHTML: (t) => t.style.fontSize.replaceAll(/["']+/g, ""),
            renderHTML: (t) => t.fontSize ? {
              style: `font-size: ${t.fontSize}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontSize: (t) => ({ chain: e }) => e().setMark("textStyle", { fontSize: t }).run(),
      unsetFontSize: () => ({ chain: t }) => t().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run()
    };
  }
}), ese = St.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (t) => {
              var e;
              return (e = t.style.color) === null || e === void 0 ? void 0 : e.replace(/['"]+/g, "");
            },
            renderHTML: (t) => t.color ? {
              style: `color: ${t.color}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (t) => ({ chain: e }) => e().setMark("textStyle", { color: t }).run(),
      unsetColor: () => ({ chain: t }) => t().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
    };
  }
});
function tse({ fill: t }) {
  return /* @__PURE__ */ z(
    "svg",
    {
      width: "18px",
      height: "18px",
      viewBox: "0 0 240 240",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg",
      children: /* @__PURE__ */ z("g", { stroke: "none", strokeWidth: 1, fill: "none", fillRule: "evenodd", children: /* @__PURE__ */ z("g", { transform: "translate(0.000000, 0.500000)", children: /* @__PURE__ */ Fe("g", { transform: "translate(39.000000, 17.353553)", children: [
        /* @__PURE__ */ z(
          "path",
          {
            d: "M11,201.146447 L167,201.146447 C173.075132,201.146447 178,206.071314 178,212.146447 C178,218.221579 173.075132,223.146447 167,223.146447 L11,223.146447 C4.92486775,223.146447 7.43989126e-16,218.221579 0,212.146447 C-7.43989126e-16,206.071314 4.92486775,201.146447 11,201.146447 Z",
            id: "矩形",
            fill: t || "#DF2A3F",
            fillRule: "evenodd"
          }
        ),
        /* @__PURE__ */ z(
          "path",
          {
            d: "M72.3425855,16.8295583 C75.799482,7.50883712 86.1577877,2.75526801 95.4785089,6.21216449 C100.284516,7.99463061 104.096358,11.7387855 105.968745,16.4968188 L106.112518,16.8745422 L159.385152,161.694068 C161.291848,166.877345 158.635655,172.624903 153.452378,174.531599 C148.358469,176.405421 142.719567,173.872338 140.716873,168.864661 L140.614848,168.598825 L89.211,28.86 L37.3759214,168.623816 C35.4885354,173.712715 29.8981043,176.351047 24.7909589,174.617647 L24.5226307,174.522368 C19.4337312,172.634982 16.7953993,167.044551 18.5287999,161.937406 L18.6240786,161.669077 L72.3425855,16.8295583 Z",
            id: "路径-21",
            fill: "currentColor",
            fillRule: "nonzero"
          }
        ),
        /* @__PURE__ */ z(
          "path",
          {
            d: "M121,103.146447 C126.522847,103.146447 131,107.623599 131,113.146447 C131,118.575687 126.673329,122.994378 121.279905,123.142605 L121,123.146447 L55,123.146447 C49.4771525,123.146447 45,118.669294 45,113.146447 C45,107.717207 49.3266708,103.298515 54.7200952,103.150288 L55,103.146447 L121,103.146447 Z",
            id: "路径-22",
            fill: "currentColor",
            fillRule: "nonzero"
          }
        )
      ] }) }) })
    }
  );
}
function nse(t) {
  const [e, n] = nt(void 0);
  function r(a) {
    var s;
    (s = t.action) == null || s.call(t, a);
  }
  function i() {
    var a;
    (a = t.action) == null || a.call(t, e);
  }
  const o = Et(
    k1((a) => {
      n(a);
    }, 350),
    []
  );
  return /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-items-center richtext-h-[32px]", children: [
    /* @__PURE__ */ z(Je, { tooltip: t == null ? void 0 : t.tooltip, disabled: t == null ? void 0 : t.disabled, action: i, children: /* @__PURE__ */ z("span", { className: "richtext-flex richtext-items-center richtext-justify-center richtext-text-sm", children: /* @__PURE__ */ z(tse, { fill: e }) }) }),
    /* @__PURE__ */ z(
      x4,
      {
        selectedColor: e,
        setSelectedColor: o,
        onChange: r,
        disabled: t == null ? void 0 : t.disabled,
        colors: t == null ? void 0 : t.colors,
        defaultColor: t == null ? void 0 : t.defaultColor,
        children: /* @__PURE__ */ z(fn, { variant: "ghost", size: "icon", className: "r!ichtext-h-[32px] !richtext-w-3", disabled: t == null ? void 0 : t.disabled, children: /* @__PURE__ */ z($t, { className: "!richtext-w-3 !richtext-h-3 richtext-text-zinc-500", name: "MenuDown" }) })
      }
    )
  ] });
}
const A2e = ese.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button({ editor: e, t: n, extension: r }) {
        return {
          component: nse,
          componentProps: {
            colors: r.options.colors,
            defaultColor: r.options.defaultColor,
            action: (i) => {
              i === void 0 && e.chain().focus().unsetColor().run(), typeof i == "string" && e.chain().focus().setColor(i).run();
            },
            isActive: () => {
              const { color: i } = e.getAttributes("textStyle");
              return i && e.isActive({ color: i }) || !1;
            },
            editor: e,
            disabled: !e.can().setColor(""),
            tooltip: n("editor.color.tooltip")
          }
        };
      }
    };
  }
}), rse = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/, ise = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g, ose = li.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: !1,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return this.options.multicolor ? {
      color: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-color") || t.style.backgroundColor,
        renderHTML: (t) => t.color ? {
          "data-color": t.color,
          style: `background-color: ${t.color}; color: inherit`
        } : {}
      }
    } : {};
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["mark", bt(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setHighlight: (t) => ({ commands: e }) => e.setMark(this.name, t),
      toggleHighlight: (t) => ({ commands: e }) => e.toggleMark(this.name, t),
      unsetHighlight: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      Zc({
        find: rse,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Dl({
        find: ise,
        type: this.type
      })
    ];
  }
}), R2e = ose.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      multicolor: !0,
      button: ({ editor: e, t: n }) => ({
        component: JN,
        componentProps: {
          action: (r) => {
            typeof r == "string" && e.chain().focus().setHighlight({ color: r }).run(), r === void 0 && e.chain().focus().unsetHighlight().run();
          },
          editor: e,
          isActive: () => e.isActive("highlight") || !1,
          disabled: !e.can().setHighlight(),
          shortcutKeys: ["⇧", "mod", "H"],
          tooltip: n("editor.highlight.tooltip")
        }
      })
    };
  }
}), ase = "listItem", tR = "textStyle", nR = /^\s*([-+*])\s$/, sse = rn.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", bt(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ase, this.editor.getAttributes(tR)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let t = wf({
      find: nR,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = wf({
      find: nR,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(tR),
      editor: this.editor
    })), [
      t
    ];
  }
}), I2e = sse.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: Je,
        componentProps: {
          action: () => e.commands.toggleBulletList(),
          isActive: () => e.isActive("bulletList") || !1,
          disabled: !1,
          shortcutKeys: ["shift", "mod", "8"],
          icon: "List",
          tooltip: n("editor.bulletlist.tooltip")
        }
      })
    };
  }
}), O2e = rn.create({
  name: "clear",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: Je,
        componentProps: {
          action: () => e.chain().focus().clearNodes().unsetAllMarks().run(),
          disabled: !e.can().chain().focus().clearNodes().unsetAllMarks().run(),
          icon: "Eraser",
          tooltip: n("editor.clear.tooltip")
        }
      })
    };
  }
}), lse = "listItem", rR = "textStyle", iR = /^(\d+)\.\s$/, cse = rn.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (t) => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: void 0,
        parseHTML: (t) => t.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { start: e, ...n } = t;
    return e === 1 ? ["ol", bt(this.options.HTMLAttributes, n), 0] : ["ol", bt(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(lse, this.editor.getAttributes(rR)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let t = wf({
      find: iR,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = wf({
      find: iR,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(rR) }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
      editor: this.editor
    })), [
      t
    ];
  }
}), F2e = cse.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: Je,
        componentProps: {
          action: () => e.commands.toggleOrderedList(),
          isActive: () => e.isActive("orderedList") || !1,
          disabled: !1,
          icon: "ListOrdered",
          shortcutKeys: ["mod", "shift", "7"],
          tooltip: n("editor.orderedlist.tooltip")
        }
      })
    };
  }
}), use = /^\s*(\[([( |x])?\])\s$/, dse = rn.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: !1,
      HTMLAttributes: {},
      taskListTypeName: "taskList"
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: !0,
  addAttributes() {
    return {
      checked: {
        default: !1,
        keepOnSplit: !1,
        parseHTML: (t) => {
          const e = t.getAttribute("data-checked");
          return e === "" || e === "true";
        },
        renderHTML: (t) => ({
          "data-checked": t.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "li",
      bt(this.options.HTMLAttributes, e, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: t.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  addKeyboardShortcuts() {
    const t = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    return this.options.nested ? {
      ...t,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    } : t;
  },
  addNodeView() {
    return ({ node: t, HTMLAttributes: e, getPos: n, editor: r }) => {
      const i = document.createElement("li"), o = document.createElement("label"), a = document.createElement("span"), s = document.createElement("input"), l = document.createElement("div");
      return o.contentEditable = "false", s.type = "checkbox", s.addEventListener("mousedown", (c) => c.preventDefault()), s.addEventListener("change", (c) => {
        if (!r.isEditable && !this.options.onReadOnlyChecked) {
          s.checked = !s.checked;
          return;
        }
        const { checked: u } = c.target;
        r.isEditable && typeof n == "function" && r.chain().focus(void 0, { scrollIntoView: !1 }).command(({ tr: d }) => {
          const f = n();
          if (typeof f != "number")
            return !1;
          const p = d.doc.nodeAt(f);
          return d.setNodeMarkup(f, void 0, {
            ...p == null ? void 0 : p.attrs,
            checked: u
          }), !0;
        }).run(), !r.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(t, u) || (s.checked = !s.checked));
      }), Object.entries(this.options.HTMLAttributes).forEach(([c, u]) => {
        i.setAttribute(c, u);
      }), i.dataset.checked = t.attrs.checked, t.attrs.checked && s.setAttribute("checked", "checked"), o.append(s, a), i.append(o, l), Object.entries(e).forEach(([c, u]) => {
        i.setAttribute(c, u);
      }), {
        dom: i,
        contentDOM: l,
        update: (c) => c.type !== this.type ? !1 : (i.dataset.checked = c.attrs.checked, c.attrs.checked ? s.setAttribute("checked", "checked") : s.removeAttribute("checked"), !0)
      };
    };
  },
  addInputRules() {
    return [
      wf({
        find: use,
        type: this.type,
        getAttributes: (t) => ({
          checked: t[t.length - 1] === "x"
        })
      })
    ];
  }
}), fse = rn.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", bt(this.options.HTMLAttributes, t, { "data-type": this.name }), 0];
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: t }) => t.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
}), U2e = fse.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      HTMLAttributes: {
        class: "task-list"
      },
      taskItem: {
        HTMLAttributes: {
          class: "task-list-item"
        }
      },
      button: ({ editor: e, t: n }) => ({
        component: Je,
        componentProps: {
          action: () => e.commands.toggleTaskList(),
          isActive: () => e.isActive("taskList") || !1,
          disabled: !1,
          icon: "ListTodo",
          shortcutKeys: ["shift", "mod", "9"],
          tooltip: n("editor.tasklist.tooltip")
        }
      })
    };
  },
  addExtensions() {
    return [dse.configure(this.options.taskItem)];
  }
}), hse = /^\s*>\s$/, pse = rn.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["blockquote", bt(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: t }) => t.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: t }) => t.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: t }) => t.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wf({
        find: hse,
        type: this.type
      })
    ];
  }
}), N2e = pse.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      HTMLAttributes: {
        class: "blockquote"
      },
      button: ({ editor: e, t: n }) => ({
        component: Je,
        componentProps: {
          action: () => e.commands.toggleBlockquote(),
          isActive: () => e.isActive("blockquote") || !1,
          disabled: !e.can().toggleBlockquote(),
          icon: "TextQuote",
          shortcutKeys: ["shift", "mod", "B"],
          tooltip: n("editor.blockquote.tooltip")
        }
      })
    };
  }
}), mse = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", gse = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", If = (t, e) => {
  for (const n in e)
    t[n] = e[n];
  return t;
}, mT = "numeric", gT = "ascii", yT = "alpha", rb = "asciinumeric", ay = "alphanumeric", bT = "domain", QN = "emoji", yse = "scheme", bse = "slashscheme", oR = "whitespace";
function vse(t, e) {
  return t in e || (e[t] = []), e[t];
}
function Mc(t, e, n) {
  e[mT] && (e[rb] = !0, e[ay] = !0), e[gT] && (e[rb] = !0, e[yT] = !0), e[rb] && (e[ay] = !0), e[yT] && (e[ay] = !0), e[ay] && (e[bT] = !0), e[QN] && (e[bT] = !0);
  for (const r in e) {
    const i = vse(r, n);
    i.indexOf(t) < 0 && i.push(t);
  }
}
function wse(t, e) {
  const n = {};
  for (const r in e)
    e[r].indexOf(t) >= 0 && (n[r] = !0);
  return n;
}
function ii(t) {
  t === void 0 && (t = null), this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
ii.groups = {};
ii.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this, n = e.j[t];
    if (n)
      return n;
    for (let r = 0; r < e.jr.length; r++) {
      const i = e.jr[r][0], o = e.jr[r][1];
      if (o && i.test(t))
        return o;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e) {
    return e === void 0 && (e = !1), e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, n, r) {
    for (let i = 0; i < t.length; i++)
      this.tt(t[i], e, n, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, n, r) {
    r = r || ii.groups;
    let i;
    return e && e.j ? i = e : (i = new ii(e), n && r && Mc(e, n, r)), this.jr.push([t, i]), i;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, n, r) {
    let i = this;
    const o = t.length;
    if (!o)
      return i;
    for (let a = 0; a < o - 1; a++)
      i = i.tt(t[a]);
    return i.tt(t[o - 1], e, n, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, n, r) {
    r = r || ii.groups;
    const i = this;
    if (e && e.j)
      return i.j[t] = e, e;
    const o = e;
    let a, s = i.go(t);
    if (s ? (a = new ii(), If(a.j, s.j), a.jr.push.apply(a.jr, s.jr), a.jd = s.jd, a.t = s.t) : a = new ii(), o) {
      if (r)
        if (a.t && typeof a.t == "string") {
          const l = If(wse(a.t, r), n);
          Mc(o, l, r);
        } else n && Mc(o, n, r);
      a.t = o;
    }
    return i.j[t] = a, a;
  }
};
const xt = (t, e, n, r, i) => t.ta(e, n, r, i), ji = (t, e, n, r, i) => t.tr(e, n, r, i), aR = (t, e, n, r, i) => t.ts(e, n, r, i), Ge = (t, e, n, r, i) => t.tt(e, n, r, i), Ka = "WORD", vT = "UWORD", gm = "LOCALHOST", wT = "TLD", xT = "UTLD", ib = "SCHEME", qd = "SLASH_SCHEME", dE = "NUM", eM = "WS", fE = "NL", zp = "OPENBRACE", $p = "CLOSEBRACE", tv = "OPENBRACKET", nv = "CLOSEBRACKET", rv = "OPENPAREN", iv = "CLOSEPAREN", ov = "OPENANGLEBRACKET", av = "CLOSEANGLEBRACKET", sv = "FULLWIDTHLEFTPAREN", lv = "FULLWIDTHRIGHTPAREN", cv = "LEFTCORNERBRACKET", uv = "RIGHTCORNERBRACKET", dv = "LEFTWHITECORNERBRACKET", fv = "RIGHTWHITECORNERBRACKET", hv = "FULLWIDTHLESSTHAN", pv = "FULLWIDTHGREATERTHAN", mv = "AMPERSAND", gv = "APOSTROPHE", yv = "ASTERISK", al = "AT", bv = "BACKSLASH", vv = "BACKTICK", wv = "CARET", dl = "COLON", hE = "COMMA", xv = "DOLLAR", Xo = "DOT", _v = "EQUALS", pE = "EXCLAMATION", Yo = "HYPHEN", Sv = "PERCENT", Tv = "PIPE", Dv = "PLUS", Ev = "POUND", Cv = "QUERY", mE = "QUOTE", gE = "SEMI", Jo = "SLASH", Hp = "TILDE", kv = "UNDERSCORE", tM = "EMOJI", Av = "SYM";
var nM = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD: Ka,
  UWORD: vT,
  LOCALHOST: gm,
  TLD: wT,
  UTLD: xT,
  SCHEME: ib,
  SLASH_SCHEME: qd,
  NUM: dE,
  WS: eM,
  NL: fE,
  OPENBRACE: zp,
  CLOSEBRACE: $p,
  OPENBRACKET: tv,
  CLOSEBRACKET: nv,
  OPENPAREN: rv,
  CLOSEPAREN: iv,
  OPENANGLEBRACKET: ov,
  CLOSEANGLEBRACKET: av,
  FULLWIDTHLEFTPAREN: sv,
  FULLWIDTHRIGHTPAREN: lv,
  LEFTCORNERBRACKET: cv,
  RIGHTCORNERBRACKET: uv,
  LEFTWHITECORNERBRACKET: dv,
  RIGHTWHITECORNERBRACKET: fv,
  FULLWIDTHLESSTHAN: hv,
  FULLWIDTHGREATERTHAN: pv,
  AMPERSAND: mv,
  APOSTROPHE: gv,
  ASTERISK: yv,
  AT: al,
  BACKSLASH: bv,
  BACKTICK: vv,
  CARET: wv,
  COLON: dl,
  COMMA: hE,
  DOLLAR: xv,
  DOT: Xo,
  EQUALS: _v,
  EXCLAMATION: pE,
  HYPHEN: Yo,
  PERCENT: Sv,
  PIPE: Tv,
  PLUS: Dv,
  POUND: Ev,
  QUERY: Cv,
  QUOTE: mE,
  SEMI: gE,
  SLASH: Jo,
  TILDE: Hp,
  UNDERSCORE: kv,
  EMOJI: tM,
  SYM: Av
});
const kd = /[a-z]/, Bx = new RegExp("\\p{L}", "u"), Lx = new RegExp("\\p{Emoji}", "u"), Px = /\d/, sR = /\s/, lR = `
`, xse = "️", _se = "‍";
let sy = null, ly = null;
function Sse(t) {
  t === void 0 && (t = []);
  const e = {};
  ii.groups = e;
  const n = new ii();
  sy == null && (sy = cR(mse)), ly == null && (ly = cR(gse)), Ge(n, "'", gv), Ge(n, "{", zp), Ge(n, "}", $p), Ge(n, "[", tv), Ge(n, "]", nv), Ge(n, "(", rv), Ge(n, ")", iv), Ge(n, "<", ov), Ge(n, ">", av), Ge(n, "（", sv), Ge(n, "）", lv), Ge(n, "「", cv), Ge(n, "」", uv), Ge(n, "『", dv), Ge(n, "』", fv), Ge(n, "＜", hv), Ge(n, "＞", pv), Ge(n, "&", mv), Ge(n, "*", yv), Ge(n, "@", al), Ge(n, "`", vv), Ge(n, "^", wv), Ge(n, ":", dl), Ge(n, ",", hE), Ge(n, "$", xv), Ge(n, ".", Xo), Ge(n, "=", _v), Ge(n, "!", pE), Ge(n, "-", Yo), Ge(n, "%", Sv), Ge(n, "|", Tv), Ge(n, "+", Dv), Ge(n, "#", Ev), Ge(n, "?", Cv), Ge(n, '"', mE), Ge(n, "/", Jo), Ge(n, ";", gE), Ge(n, "~", Hp), Ge(n, "_", kv), Ge(n, "\\", bv);
  const r = ji(n, Px, dE, {
    [mT]: !0
  });
  ji(r, Px, r);
  const i = ji(n, kd, Ka, {
    [gT]: !0
  });
  ji(i, kd, i);
  const o = ji(n, Bx, vT, {
    [yT]: !0
  });
  ji(o, kd), ji(o, Bx, o);
  const a = ji(n, sR, eM, {
    [oR]: !0
  });
  Ge(n, lR, fE, {
    [oR]: !0
  }), Ge(a, lR), ji(a, sR, a);
  const s = ji(n, Lx, tM, {
    [QN]: !0
  });
  ji(s, Lx, s), Ge(s, xse, s);
  const l = Ge(s, _se);
  ji(l, Lx, s);
  const c = [[kd, i]], u = [[kd, null], [Bx, o]];
  for (let d = 0; d < sy.length; d++)
    Zs(n, sy[d], wT, Ka, c);
  for (let d = 0; d < ly.length; d++)
    Zs(n, ly[d], xT, vT, u);
  Mc(wT, {
    tld: !0,
    ascii: !0
  }, e), Mc(xT, {
    utld: !0,
    alpha: !0
  }, e), Zs(n, "file", ib, Ka, c), Zs(n, "mailto", ib, Ka, c), Zs(n, "http", qd, Ka, c), Zs(n, "https", qd, Ka, c), Zs(n, "ftp", qd, Ka, c), Zs(n, "ftps", qd, Ka, c), Mc(ib, {
    scheme: !0,
    ascii: !0
  }, e), Mc(qd, {
    slashscheme: !0,
    ascii: !0
  }, e), t = t.sort((d, f) => d[0] > f[0] ? 1 : -1);
  for (let d = 0; d < t.length; d++) {
    const f = t[d][0], m = t[d][1] ? {
      [yse]: !0
    } : {
      [bse]: !0
    };
    f.indexOf("-") >= 0 ? m[bT] = !0 : kd.test(f) ? Px.test(f) ? m[rb] = !0 : m[gT] = !0 : m[mT] = !0, aR(n, f, f, m);
  }
  return aR(n, "localhost", gm, {
    ascii: !0
  }), n.jd = new ii(Av), {
    start: n,
    tokens: If({
      groups: e
    }, nM)
  };
}
function Tse(t, e) {
  const n = Dse(e.replace(/[A-Z]/g, (s) => s.toLowerCase())), r = n.length, i = [];
  let o = 0, a = 0;
  for (; a < r; ) {
    let s = t, l = null, c = 0, u = null, d = -1, f = -1;
    for (; a < r && (l = s.go(n[a])); )
      s = l, s.accepts() ? (d = 0, f = 0, u = s) : d >= 0 && (d += n[a].length, f++), c += n[a].length, o += n[a].length, a++;
    o -= d, a -= f, c -= d, i.push({
      t: u.t,
      // token type/name
      v: e.slice(o - c, o),
      // string value
      s: o - c,
      // start index
      e: o
      // end index (excluding)
    });
  }
  return i;
}
function Dse(t) {
  const e = [], n = t.length;
  let r = 0;
  for (; r < n; ) {
    let i = t.charCodeAt(r), o, a = i < 55296 || i > 56319 || r + 1 === n || (o = t.charCodeAt(r + 1)) < 56320 || o > 57343 ? t[r] : t.slice(r, r + 2);
    e.push(a), r += a.length;
  }
  return e;
}
function Zs(t, e, n, r, i) {
  let o;
  const a = e.length;
  for (let s = 0; s < a - 1; s++) {
    const l = e[s];
    t.j[l] ? o = t.j[l] : (o = new ii(r), o.jr = i.slice(), t.j[l] = o), t = o;
  }
  return o = new ii(n), o.jr = i.slice(), t.j[e[a - 1]] = o, o;
}
function cR(t) {
  const e = [], n = [];
  let r = 0, i = "0123456789";
  for (; r < t.length; ) {
    let o = 0;
    for (; i.indexOf(t[r + o]) >= 0; )
      o++;
    if (o > 0) {
      e.push(n.join(""));
      for (let a = parseInt(t.substring(r, r + o), 10); a > 0; a--)
        n.pop();
      r += o;
    } else
      n.push(t[r]), r++;
  }
  return e;
}
const ym = {
  defaultProtocol: "http",
  events: null,
  format: uR,
  formatHref: uR,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function yE(t, e) {
  e === void 0 && (e = null);
  let n = If({}, ym);
  t && (n = If(n, t instanceof yE ? t.o : t));
  const r = n.ignoreTags, i = [];
  for (let o = 0; o < r.length; o++)
    i.push(r[o].toUpperCase());
  this.o = n, e && (this.defaultRender = e), this.ignoreTags = i;
}
yE.prototype = {
  o: ym,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, n) {
    const r = e != null;
    let i = this.o[t];
    return i && (typeof i == "object" ? (i = n.t in i ? i[n.t] : ym[t], typeof i == "function" && r && (i = i(e, n))) : typeof i == "function" && r && (i = i(e, n.t, n)), i);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, n) {
    let r = this.o[t];
    return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  }
};
function uR(t) {
  return t;
}
function rM(t, e) {
  this.t = "token", this.v = t, this.tk = e;
}
rM.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
  */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(), n = t.get("truncate", e, this), r = t.get("format", e, this);
    return n && r.length > n ? r.substring(0, n) + "…" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t) {
    return t === void 0 && (t = ym.defaultProtocol), {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this, n = this.toHref(t.get("defaultProtocol")), r = t.get("formatHref", n, this), i = t.get("tagName", n, e), o = this.toFormattedString(t), a = {}, s = t.get("className", n, e), l = t.get("target", n, e), c = t.get("rel", n, e), u = t.getObj("attributes", n, e), d = t.getObj("events", n, e);
    return a.href = r, s && (a.class = s), l && (a.target = l), c && (a.rel = c), u && If(a, u), {
      tagName: i,
      attributes: a,
      content: o,
      eventListeners: d
    };
  }
};
function U1(t, e) {
  class n extends rM {
    constructor(i, o) {
      super(i, o), this.t = t;
    }
  }
  for (const r in e)
    n.prototype[r] = e[r];
  return n.t = t, n;
}
const dR = U1("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), fR = U1("text"), Ese = U1("nl"), cy = U1("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t) {
    return t === void 0 && (t = ym.defaultProtocol), this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== gm && t[1].t === dl;
  }
}), Vi = (t) => new ii(t);
function Cse(t) {
  let {
    groups: e
  } = t;
  const n = e.domain.concat([mv, yv, al, bv, vv, wv, xv, _v, Yo, dE, Sv, Tv, Dv, Ev, Jo, Av, Hp, kv]), r = [gv, dl, hE, Xo, pE, Cv, mE, gE, ov, av, zp, $p, nv, tv, rv, iv, sv, lv, cv, uv, dv, fv, hv, pv], i = [mv, gv, yv, bv, vv, wv, xv, _v, Yo, zp, $p, Sv, Tv, Dv, Ev, Cv, Jo, Av, Hp, kv], o = Vi(), a = Ge(o, Hp);
  xt(a, i, a), xt(a, e.domain, a);
  const s = Vi(), l = Vi(), c = Vi();
  xt(o, e.domain, s), xt(o, e.scheme, l), xt(o, e.slashscheme, c), xt(s, i, a), xt(s, e.domain, s);
  const u = Ge(s, al);
  Ge(a, al, u), Ge(l, al, u), Ge(c, al, u);
  const d = Ge(a, Xo);
  xt(d, i, a), xt(d, e.domain, a);
  const f = Vi();
  xt(u, e.domain, f), xt(f, e.domain, f);
  const p = Ge(f, Xo);
  xt(p, e.domain, f);
  const m = Vi(dR);
  xt(p, e.tld, m), xt(p, e.utld, m), Ge(u, gm, m);
  const g = Ge(f, Yo);
  xt(g, e.domain, f), xt(m, e.domain, f), Ge(m, Xo, p), Ge(m, Yo, g);
  const b = Ge(m, dl);
  xt(b, e.numeric, dR);
  const y = Ge(s, Yo), w = Ge(s, Xo);
  xt(y, e.domain, s), xt(w, i, a), xt(w, e.domain, s);
  const x = Vi(cy);
  xt(w, e.tld, x), xt(w, e.utld, x), xt(x, e.domain, s), xt(x, i, a), Ge(x, Xo, w), Ge(x, Yo, y), Ge(x, al, u);
  const k = Ge(x, dl), A = Vi(cy);
  xt(k, e.numeric, A);
  const U = Vi(cy), P = Vi();
  xt(U, n, U), xt(U, r, P), xt(P, n, U), xt(P, r, P), Ge(x, Jo, U), Ge(A, Jo, U);
  const V = Ge(l, dl), I = Ge(c, dl), le = Ge(I, Jo), be = Ge(le, Jo);
  xt(l, e.domain, s), Ge(l, Xo, w), Ge(l, Yo, y), xt(c, e.domain, s), Ge(c, Xo, w), Ge(c, Yo, y), xt(V, e.domain, U), Ge(V, Jo, U), xt(be, e.domain, U), xt(be, n, U), Ge(be, Jo, U);
  const F = [
    [zp, $p],
    // {}
    [tv, nv],
    // []
    [rv, iv],
    // ()
    [ov, av],
    // <>
    [sv, lv],
    // （）
    [cv, uv],
    // 「」
    [dv, fv],
    // 『』
    [hv, pv]
    // ＜＞
  ];
  for (let G = 0; G < F.length; G++) {
    const [C, ie] = F[G], ee = Ge(U, C);
    Ge(P, C, ee), Ge(ee, ie, U);
    const Z = Vi(cy);
    xt(ee, n, Z);
    const oe = Vi();
    xt(ee, r), xt(Z, n, Z), xt(Z, r, oe), xt(oe, n, Z), xt(oe, r, oe), Ge(Z, ie, U), Ge(oe, ie, U);
  }
  return Ge(o, gm, x), Ge(o, fE, Ese), {
    start: o,
    tokens: nM
  };
}
function kse(t, e, n) {
  let r = n.length, i = 0, o = [], a = [];
  for (; i < r; ) {
    let s = t, l = null, c = null, u = 0, d = null, f = -1;
    for (; i < r && !(l = s.go(n[i].t)); )
      a.push(n[i++]);
    for (; i < r && (c = l || s.go(n[i].t)); )
      l = null, s = c, s.accepts() ? (f = 0, d = s) : f >= 0 && f++, i++, u++;
    if (f < 0)
      i -= u, i < r && (a.push(n[i]), i++);
    else {
      a.length > 0 && (o.push(Wx(fR, e, a)), a = []), i -= f, u -= f;
      const p = d.t, m = n.slice(i - u, i);
      o.push(Wx(p, e, m));
    }
  }
  return a.length > 0 && o.push(Wx(fR, e, a)), o;
}
function Wx(t, e, n) {
  const r = n[0].s, i = n[n.length - 1].e, o = e.slice(r, i);
  return new t(o, n);
}
const Ase = typeof console < "u" && console && console.warn || (() => {
}), Rse = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", bn = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function Ise() {
  ii.groups = {}, bn.scanner = null, bn.parser = null, bn.tokenQueue = [], bn.pluginQueue = [], bn.customSchemes = [], bn.initialized = !1;
}
function hR(t, e) {
  if (e === void 0 && (e = !1), bn.initialized && Ase(`linkifyjs: already initialized - will not register custom scheme "${t}" ${Rse}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  bn.customSchemes.push([t, e]);
}
function Ose() {
  bn.scanner = Sse(bn.customSchemes);
  for (let t = 0; t < bn.tokenQueue.length; t++)
    bn.tokenQueue[t][1]({
      scanner: bn.scanner
    });
  bn.parser = Cse(bn.scanner.tokens);
  for (let t = 0; t < bn.pluginQueue.length; t++)
    bn.pluginQueue[t][1]({
      scanner: bn.scanner,
      parser: bn.parser
    });
  bn.initialized = !0;
}
function iM(t) {
  return bn.initialized || Ose(), kse(bn.parser.start, t, Tse(bn.scanner.start, t));
}
function oM(t, e, n) {
  if (e === void 0 && (e = null), n === void 0 && (n = null), e && typeof e == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    n = e, e = null;
  }
  const r = new yE(n), i = iM(t), o = [];
  for (let a = 0; a < i.length; a++) {
    const s = i[a];
    s.isLink && (!e || s.t === e) && r.check(s) && o.push(s.toFormattedObject(r));
  }
  return o;
}
function Fse(t) {
  return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1;
}
function Use(t) {
  return new Pt({
    key: new Nt("autolink"),
    appendTransaction: (e, n, r) => {
      const i = e.some((c) => c.docChanged) && !n.doc.eq(r.doc), o = e.some((c) => c.getMeta("preventAutolink"));
      if (!i || o)
        return;
      const { tr: a } = r, s = Xj(n.doc, [...e]);
      if (nV(s).forEach(({ newRange: c }) => {
        const u = Jj(r.doc, c, (p) => p.isTextblock);
        let d, f;
        if (u.length > 1 ? (d = u[0], f = r.doc.textBetween(d.pos, d.pos + d.node.nodeSize, void 0, " ")) : u.length && r.doc.textBetween(c.from, c.to, " ", " ").endsWith(" ") && (d = u[0], f = r.doc.textBetween(d.pos, c.to, void 0, " ")), d && f) {
          const p = f.split(" ").filter((y) => y !== "");
          if (p.length <= 0)
            return !1;
          const m = p[p.length - 1], g = d.pos + f.lastIndexOf(m);
          if (!m)
            return !1;
          const b = iM(m).map((y) => y.toObject(t.defaultProtocol));
          if (!Fse(b))
            return !1;
          b.filter((y) => y.isLink).map((y) => ({
            ...y,
            from: g + y.start + 1,
            to: g + y.end + 1
          })).filter((y) => r.schema.marks.code ? !r.doc.rangeHasMark(y.from, y.to, r.schema.marks.code) : !0).filter((y) => t.validate(y.value)).filter((y) => t.shouldAutoLink(y.value)).forEach((y) => {
            gD(y.from, y.to, r.doc).some((w) => w.mark.type === t.type) || a.addMark(y.from, y.to, t.type.create({
              href: y.href
            }));
          });
        }
      }), !!a.steps.length)
        return a;
    }
  });
}
function Nse(t) {
  return new Pt({
    key: new Nt("handleClickLink"),
    props: {
      handleClick: (e, n, r) => {
        var i, o;
        if (r.button !== 0 || !e.editable)
          return !1;
        let a = r.target;
        const s = [];
        for (; a.nodeName !== "DIV"; )
          s.push(a), a = a.parentNode;
        if (!s.find((f) => f.nodeName === "A"))
          return !1;
        const l = jU(e.state, t.type.name), c = r.target, u = (i = c == null ? void 0 : c.href) !== null && i !== void 0 ? i : l.href, d = (o = c == null ? void 0 : c.target) !== null && o !== void 0 ? o : l.target;
        return c && u ? (window.open(u, d), !0) : !1;
      }
    }
  });
}
function Mse(t) {
  return new Pt({
    key: new Nt("handlePasteLink"),
    props: {
      handlePaste: (e, n, r) => {
        const { state: i } = e, { selection: o } = i, { empty: a } = o;
        if (a)
          return !1;
        let s = "";
        r.content.forEach((c) => {
          s += c.textContent;
        });
        const l = oM(s, { defaultProtocol: t.defaultProtocol }).find((c) => c.isLink && c.value === s);
        return !s || !l ? !1 : (t.editor.commands.setMark(t.type, {
          href: l.href
        }), !0);
      }
    }
  });
}
const Bse = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function lp(t, e) {
  const n = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ];
  return e && e.forEach((r) => {
    const i = typeof r == "string" ? r : r.scheme;
    i && n.push(i);
  }), !t || t.replace(Bse, "").match(new RegExp(
    // eslint-disable-next-line no-useless-escape
    `^(?:(?:${n.join("|")}):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))`,
    "i"
  ));
}
const Lse = li.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        hR(t);
        return;
      }
      hR(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    Ise();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (t, e) => !!lp(t, e.protocols),
      validate: (t) => !!t,
      shouldAutoLink: (t) => !!t
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(t) {
          return t.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (t) => {
          const e = t.getAttribute("href");
          return !e || !this.options.isAllowedUri(e, {
            defaultValidate: (n) => !!lp(n, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return this.options.isAllowedUri(t.href, {
      defaultValidate: (e) => !!lp(e, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", bt(this.options.HTMLAttributes, t), 0] : [
      "a",
      bt(this.options.HTMLAttributes, { ...t, href: "" }),
      0
    ];
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: e }) => e().setMark(this.name, t).setMeta("preventAutolink", !0).run(),
      toggleLink: (t) => ({ chain: e }) => e().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run(),
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Dl({
        find: (t) => {
          const e = [];
          if (t) {
            const { protocols: n, defaultProtocol: r } = this.options, i = oM(t).filter((o) => o.isLink && this.options.isAllowedUri(o.value, {
              defaultValidate: (a) => !!lp(a, n),
              protocols: n,
              defaultProtocol: r
            }));
            i.length && i.forEach((o) => e.push({
              text: o.value,
              data: {
                href: o.href
              },
              index: o.start
            }));
          }
          return e;
        },
        type: this.type,
        getAttributes: (t) => {
          var e;
          return {
            href: (e = t.data) === null || e === void 0 ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [], { protocols: e, defaultProtocol: n } = this.options;
    return this.options.autolink && t.push(Use({
      type: this.type,
      defaultProtocol: this.options.defaultProtocol,
      validate: (r) => this.options.isAllowedUri(r, {
        defaultValidate: (i) => !!lp(i, e),
        protocols: e,
        defaultProtocol: n
      }),
      shouldAutoLink: this.options.shouldAutoLink
    })), this.options.openOnClick === !0 && t.push(Nse({
      type: this.type
    })), this.options.linkOnPaste && t.push(Mse({
      editor: this.editor,
      defaultProtocol: this.options.defaultProtocol,
      type: this.type
    })), t;
  }
});
function Pse(t) {
  const [e, n] = nt(!1);
  function r(i, o, a) {
    t.action && (t.action({ link: i, text: o, openInNewTab: a }), n(!1));
  }
  return /* @__PURE__ */ Fe(Eo, { modal: !0, open: e, onOpenChange: n, children: [
    /* @__PURE__ */ z(Co, { disabled: t == null ? void 0 : t.disabled, asChild: !0, children: /* @__PURE__ */ z(
      Je,
      {
        tooltip: t == null ? void 0 : t.tooltip,
        isActive: t == null ? void 0 : t.isActive,
        disabled: t == null ? void 0 : t.disabled,
        children: /* @__PURE__ */ z($t, { name: t == null ? void 0 : t.icon })
      }
    ) }),
    /* @__PURE__ */ z(oo, { hideWhenDetached: !0, className: "richtext-w-full", align: "start", side: "bottom", children: /* @__PURE__ */ z(ZN, { editor: t.editor, onSetLink: r }) })
  ] });
}
const M2e = Lse.extend({
  inclusive: !1,
  parseHTML() {
    return [
      {
        tag: 'a[href]:not([data-type="button"]):not([href *= "javascript:" i])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "a",
      bt(this.options.HTMLAttributes, t, {
        class: "link"
      }),
      0
    ];
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      openOnClick: !0,
      button: ({ editor: e, t: n }) => ({
        component: Pse,
        componentProps: {
          editor: e,
          action: (r) => {
            const { link: i, text: o, openInNewTab: a } = r;
            e.chain().extendMarkRange("link").insertContent({
              type: "text",
              text: o,
              marks: [
                {
                  type: "link",
                  attrs: {
                    href: i,
                    target: a ? "_blank" : ""
                  }
                }
              ]
            }).setLink({ href: i }).focus().run();
          },
          id: "linkk",
          isActive: () => e.isActive("link") || !1,
          disabled: !e.can().setLink({ href: "" }),
          icon: "Link",
          tooltip: n("editor.link.tooltip")
        }
      })
    };
  },
  addProseMirrorPlugins() {
    return [
      new Pt({
        props: {
          handleClick: (t, e) => {
            const { schema: n, doc: r, tr: i } = t.state, o = c1(r.resolve(e), n.marks.link);
            if (!o)
              return !1;
            const a = r.resolve(o.from), s = r.resolve(o.to), l = i.setSelection(new ot(a, s));
            t.dispatch(l);
          }
        }
      })
    ];
  }
}), Wse = rn.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["hr", bt(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: t, state: e }) => {
        const { selection: n } = e, { $from: r, $to: i } = n, o = t();
        return r.parentOffset === 0 ? o.insertContentAt({
          from: Math.max(r.pos - 1, 0),
          to: i.pos
        }, {
          type: this.name
        }) : qU(n) ? o.insertContentAt(i.pos, {
          type: this.name
        }) : o.insertContent({ type: this.name }), o.command(({ tr: a, dispatch: s }) => {
          var l;
          if (s) {
            const { $to: c } = a.selection, u = c.end();
            if (c.nodeAfter)
              c.nodeAfter.isTextblock ? a.setSelection(ot.create(a.doc, c.pos + 1)) : c.nodeAfter.isBlock ? a.setSelection(st.create(a.doc, c.pos)) : a.setSelection(ot.create(a.doc, c.pos));
            else {
              const d = (l = c.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
              d && (a.insert(u, d), a.setSelection(ot.create(a.doc, u + 1)));
            }
            a.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      yD({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), B2e = Wse.extend({
  renderHTML() {
    return [
      "div",
      bt(this.options.HTMLAttributes, {
        "data-type": this.name
      }),
      ["hr"]
    ];
  },
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: Je,
        componentProps: {
          action: () => e.commands.setHorizontalRule(),
          disabled: !e.can().setHorizontalRule(),
          icon: "Minus",
          shortcutKeys: ["mod", "alt", "S"],
          tooltip: n("editor.horizontalrule.tooltip")
        }
      })
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-s": () => this.editor.commands.setHorizontalRule()
    };
  }
});
var Rv = 200, Kn = function() {
};
Kn.prototype.append = function(e) {
  return e.length ? (e = Kn.from(e), !this.length && e || e.length < Rv && this.leafAppend(e) || this.length < Rv && e.leafPrepend(this) || this.appendInner(e)) : this;
};
Kn.prototype.prepend = function(e) {
  return e.length ? Kn.from(e).append(this) : this;
};
Kn.prototype.appendInner = function(e) {
  return new zse(this, e);
};
Kn.prototype.slice = function(e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? Kn.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
};
Kn.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
Kn.prototype.forEach = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0);
};
Kn.prototype.map = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(o, a) {
    return i.push(e(o, a));
  }, n, r), i;
};
Kn.from = function(e) {
  return e instanceof Kn ? e : e && e.length ? new aM(e) : Kn.empty;
};
var aM = /* @__PURE__ */ function(t) {
  function e(r) {
    t.call(this), this.values = r;
  }
  t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(i, o) {
    return i == 0 && o == this.length ? this : new e(this.values.slice(i, o));
  }, e.prototype.getInner = function(i) {
    return this.values[i];
  }, e.prototype.forEachInner = function(i, o, a, s) {
    for (var l = o; l < a; l++)
      if (i(this.values[l], s + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(i, o, a, s) {
    for (var l = o - 1; l >= a; l--)
      if (i(this.values[l], s + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(i) {
    if (this.length + i.length <= Rv)
      return new e(this.values.concat(i.flatten()));
  }, e.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= Rv)
      return new e(i.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, n), e;
}(Kn);
Kn.empty = new aM([]);
var zse = /* @__PURE__ */ function(t) {
  function e(n, r) {
    t.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1;
  }
  return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, i, o, a) {
    var s = this.left.length;
    if (i < s && this.left.forEachInner(r, i, Math.min(o, s), a) === !1 || o > s && this.right.forEachInner(r, Math.max(i - s, 0), Math.min(this.length, o) - s, a + s) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, o, a) {
    var s = this.left.length;
    if (i > s && this.right.forEachInvertedInner(r, i - s, Math.max(o, s) - s, a + s) === !1 || o < s && this.left.forEachInvertedInner(r, Math.min(i, s), o, a) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var o = this.left.length;
    return i <= o ? this.left.slice(r, i) : r >= o ? this.right.slice(r - o, i - o) : this.left.slice(r, o).append(this.right.slice(0, i - o));
  }, e.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new e(this.left, i);
  }, e.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new e(i, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
}(Kn);
const $se = 500;
class wo {
  constructor(e, n) {
    this.items = e, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, n) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, o;
    n && (i = this.remapping(r, this.items.length), o = i.maps.length);
    let a = e.tr, s, l, c = [], u = [];
    return this.items.forEach((d, f) => {
      if (!d.step) {
        i || (i = this.remapping(r, f + 1), o = i.maps.length), o--, u.push(d);
        return;
      }
      if (i) {
        u.push(new Qs(d.map));
        let p = d.step.map(i.slice(o)), m;
        p && a.maybeStep(p).doc && (m = a.mapping.maps[a.mapping.maps.length - 1], c.push(new Qs(m, void 0, void 0, c.length + u.length))), o--, m && i.appendMap(m, o);
      } else
        a.maybeStep(d.step);
      if (d.selection)
        return s = i ? d.selection.map(i.slice(o)) : d.selection, l = new wo(this.items.slice(0, r).append(u.reverse().concat(c)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: a, selection: s };
  }
  // Create a new branch with the given transform added.
  addTransform(e, n, r, i) {
    let o = [], a = this.eventCount, s = this.items, l = !i && s.length ? s.get(s.length - 1) : null;
    for (let u = 0; u < e.steps.length; u++) {
      let d = e.steps[u].invert(e.docs[u]), f = new Qs(e.mapping.maps[u], d, n), p;
      (p = l && l.merge(f)) && (f = p, u ? o.pop() : s = s.slice(0, s.length - 1)), o.push(f), n && (a++, n = void 0), i || (l = f);
    }
    let c = a - r.depth;
    return c > jse && (s = Hse(s, c), a -= c), new wo(s.append(o), a);
  }
  remapping(e, n) {
    let r = new Qd();
    return this.items.forEach((i, o) => {
      let a = i.mirrorOffset != null && o - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, a);
    }, e, n), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new wo(this.items.append(e.map((n) => new Qs(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, n) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - n), o = e.mapping, a = e.steps.length, s = this.eventCount;
    this.items.forEach((f) => {
      f.selection && s--;
    }, i);
    let l = n;
    this.items.forEach((f) => {
      let p = o.getMirror(--l);
      if (p == null)
        return;
      a = Math.min(a, p);
      let m = o.maps[p];
      if (f.step) {
        let g = e.steps[p].invert(e.docs[p]), b = f.selection && f.selection.map(o.slice(l + 1, p));
        b && s++, r.push(new Qs(m, g, b));
      } else
        r.push(new Qs(m));
    }, i);
    let c = [];
    for (let f = n; f < a; f++)
      c.push(new Qs(o.maps[f]));
    let u = this.items.slice(0, i).append(c).append(r), d = new wo(u, s);
    return d.emptyItemCount() > $se && (d = d.compress(this.items.length - r.length)), d;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((n) => {
      n.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let n = this.remapping(0, e), r = n.maps.length, i = [], o = 0;
    return this.items.forEach((a, s) => {
      if (s >= e)
        i.push(a), a.selection && o++;
      else if (a.step) {
        let l = a.step.map(n.slice(r)), c = l && l.getMap();
        if (r--, c && n.appendMap(c, r), l) {
          let u = a.selection && a.selection.map(n.slice(r));
          u && o++;
          let d = new Qs(c.invert(), l, u), f, p = i.length - 1;
          (f = i.length && i[p].merge(d)) ? i[p] = f : i.push(d);
        }
      } else a.map && r--;
    }, this.items.length, 0), new wo(Kn.from(i.reverse()), o);
  }
}
wo.empty = new wo(Kn.empty, 0);
function Hse(t, e) {
  let n;
  return t.forEach((r, i) => {
    if (r.selection && e-- == 0)
      return n = i, !1;
  }), t.slice(n);
}
let Qs = class sM {
  constructor(e, n, r, i) {
    this.map = e, this.step = n, this.selection = r, this.mirrorOffset = i;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n)
        return new sM(n.getMap().invert(), n, this.selection);
    }
  }
};
class sl {
  constructor(e, n, r, i, o) {
    this.done = e, this.undone = n, this.prevRanges = r, this.prevTime = i, this.prevComposition = o;
  }
}
const jse = 20;
function Vse(t, e, n, r) {
  let i = n.getMeta(Vc), o;
  if (i)
    return i.historyState;
  n.getMeta(Kse) && (t = new sl(t.done, t.undone, null, 0, -1));
  let a = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return t;
  if (a && a.getMeta(Vc))
    return a.getMeta(Vc).redo ? new sl(t.done.addTransform(n, void 0, r, ob(e)), t.undone, pR(n.mapping.maps), t.prevTime, t.prevComposition) : new sl(t.done, t.undone.addTransform(n, void 0, r, ob(e)), null, t.prevTime, t.prevComposition);
  if (n.getMeta("addToHistory") !== !1 && !(a && a.getMeta("addToHistory") === !1)) {
    let s = n.getMeta("composition"), l = t.prevTime == 0 || !a && t.prevComposition != s && (t.prevTime < (n.time || 0) - r.newGroupDelay || !qse(n, t.prevRanges)), c = a ? zx(t.prevRanges, n.mapping) : pR(n.mapping.maps);
    return new sl(t.done.addTransform(n, l ? e.selection.getBookmark() : void 0, r, ob(e)), wo.empty, c, n.time, s ?? t.prevComposition);
  } else return (o = n.getMeta("rebased")) ? new sl(t.done.rebased(n, o), t.undone.rebased(n, o), zx(t.prevRanges, n.mapping), t.prevTime, t.prevComposition) : new sl(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), zx(t.prevRanges, n.mapping), t.prevTime, t.prevComposition);
}
function qse(t, e) {
  if (!e)
    return !1;
  if (!t.docChanged)
    return !0;
  let n = !1;
  return t.mapping.maps[0].forEach((r, i) => {
    for (let o = 0; o < e.length; o += 2)
      r <= e[o + 1] && i >= e[o] && (n = !0);
  }), n;
}
function pR(t) {
  let e = [];
  for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
    t[n].forEach((r, i, o, a) => e.push(o, a));
  return e;
}
function zx(t, e) {
  if (!t)
    return null;
  let n = [];
  for (let r = 0; r < t.length; r += 2) {
    let i = e.map(t[r], 1), o = e.map(t[r + 1], -1);
    i <= o && n.push(i, o);
  }
  return n;
}
function Gse(t, e, n) {
  let r = ob(e), i = Vc.get(e).spec.config, o = (n ? t.undone : t.done).popEvent(e, r);
  if (!o)
    return null;
  let a = o.selection.resolve(o.transform.doc), s = (n ? t.done : t.undone).addTransform(o.transform, e.selection.getBookmark(), i, r), l = new sl(n ? s : o.remaining, n ? o.remaining : s, null, 0, -1);
  return o.transform.setSelection(a).setMeta(Vc, { redo: n, historyState: l });
}
let $x = !1, mR = null;
function ob(t) {
  let e = t.plugins;
  if (mR != e) {
    $x = !1, mR = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        $x = !0;
        break;
      }
  }
  return $x;
}
const Vc = new Nt("history"), Kse = new Nt("closeHistory");
function Xse(t = {}) {
  return t = {
    depth: t.depth || 100,
    newGroupDelay: t.newGroupDelay || 500
  }, new Pt({
    key: Vc,
    state: {
      init() {
        return new sl(wo.empty, wo.empty, null, 0, -1);
      },
      apply(e, n, r) {
        return Vse(n, r, e, t);
      }
    },
    config: t,
    props: {
      handleDOMEvents: {
        beforeinput(e, n) {
          let r = n.inputType, i = r == "historyUndo" ? cM : r == "historyRedo" ? uM : null;
          return i ? (n.preventDefault(), i(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function lM(t, e) {
  return (n, r) => {
    let i = Vc.getState(n);
    if (!i || (t ? i.undone : i.done).eventCount == 0)
      return !1;
    if (r) {
      let o = Gse(i, n, t);
      o && r(e ? o.scrollIntoView() : o);
    }
    return !0;
  };
}
const cM = lM(!1, !0), uM = lM(!0, !0), Yse = St.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: t, dispatch: e }) => cM(t, e),
      redo: () => ({ state: t, dispatch: e }) => uM(t, e)
    };
  },
  addProseMirrorPlugins() {
    return [
      Xse(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
});
function Jse(t) {
  var c;
  const {
    icon: e = void 0,
    // title = undefined,
    tooltip: n = void 0,
    // disabled = false,
    customClass: r = "",
    // color = undefined,
    // loading = false,
    // shortcutKeys = undefined,
    tooltipOptions: i = {},
    action: o = void 0,
    isActive: a = void 0,
    children: s
  } = t, l = Hm[e];
  return /* @__PURE__ */ Fe(Kf, { children: [
    /* @__PURE__ */ z(Xf, { asChild: !0, children: /* @__PURE__ */ Fe(
      zm,
      {
        size: "sm",
        className: `richtext-w-[32px] richtext-h-[32px] ${r}`,
        disabled: a == null ? void 0 : a(),
        onClick: o,
        children: [
          l && /* @__PURE__ */ z(l, { className: "richtext-w-4 richtext-h-4" }),
          s && /* @__PURE__ */ z(pn, { children: s })
        ]
      }
    ) }),
    n && /* @__PURE__ */ z(gu, { ...i, children: /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-flex-col richtext-items-center richtext-text-center richtext-max-w-24", children: [
      /* @__PURE__ */ z("div", { children: n }),
      !!((c = t == null ? void 0 : t.shortcutKeys) != null && c.length) && /* @__PURE__ */ z("span", { children: p1(t == null ? void 0 : t.shortcutKeys) })
    ] }) })
  ] });
}
const Zse = ["undo", "redo"], L2e = Yse.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      depth: 100,
      newGroupDelay: 500,
      button: ({ editor: e, t: n }) => Zse.map((r) => ({
        component: Jse,
        componentProps: {
          action: () => {
            r === "undo" && e.chain().focus().undo().run(), r === "redo" && e.chain().focus().redo().run();
          },
          shortcutKeys: r === "undo" ? ["mod", "Z"] : ["shift", "mod", "Z"],
          disabled: r === "undo" ? !e.can().undo() : !e.can().redo(),
          isActive: () => r === "undo" ? !e.can().undo() : !e.can().redo(),
          icon: r === "undo" ? "Undo2" : "Redo2",
          tooltip: n(`editor.${r}.tooltip`)
        }
      }))
    };
  }
}), Qse = St.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (t) => t.length,
      wordCounter: (t) => t.split(" ").filter((e) => e !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (t) => {
      const e = (t == null ? void 0 : t.node) || this.editor.state.doc;
      if (((t == null ? void 0 : t.mode) || this.options.mode) === "textSize") {
        const r = e.textBetween(0, e.content.size, void 0, " ");
        return this.options.textCounter(r);
      }
      return e.nodeSize;
    }, this.storage.words = (t) => {
      const e = (t == null ? void 0 : t.node) || this.editor.state.doc, n = e.textBetween(0, e.content.size, " ", " ");
      return this.options.wordCounter(n);
    };
  },
  addProseMirrorPlugins() {
    let t = !1;
    return [
      new Pt({
        key: new Nt("characterCount"),
        appendTransaction: (e, n, r) => {
          if (t)
            return;
          const i = this.options.limit;
          if (i == null || i === 0) {
            t = !0;
            return;
          }
          const o = this.storage.characters({ node: r.doc });
          if (o > i) {
            const a = o - i, s = 0, l = a;
            console.warn(`[CharacterCount] Initial content exceeded limit of ${i} characters. Content was automatically trimmed.`);
            const c = r.tr.deleteRange(s, l);
            return t = !0, c;
          }
          t = !0;
        },
        filterTransaction: (e, n) => {
          const r = this.options.limit;
          if (!e.docChanged || r === 0 || r === null || r === void 0)
            return !0;
          const i = this.storage.characters({ node: n.doc }), o = this.storage.characters({ node: e.doc });
          if (o <= r || i > r && o > r && o <= i)
            return !0;
          if (i > r && o > r && o > i || !e.getMeta("paste"))
            return !1;
          const s = e.selection.$head.pos, l = o - r, c = s - l, u = s;
          return e.deleteRange(c, u), !(this.storage.characters({ node: e.doc }) > r);
        }
      })
    ];
  }
});
function ele(t = {}) {
  return new Pt({
    view(e) {
      return new tle(e, t);
    }
  });
}
class tle {
  constructor(e, n) {
    var r;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = n.width) !== null && r !== void 0 ? r : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((i) => {
      let o = (a) => {
        this[i](a);
      };
      return e.dom.addEventListener(i, o), { name: i, handler: o };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
  }
  update(e, n) {
    this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, r;
    if (n) {
      let s = e.nodeBefore, l = e.nodeAfter;
      if (s || l) {
        let c = this.editorView.nodeDOM(this.cursorPos - (s ? s.nodeSize : 0));
        if (c) {
          let u = c.getBoundingClientRect(), d = s ? u.bottom : u.top;
          s && l && (d = (d + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), r = { left: u.left, right: u.right, top: d - this.width / 2, bottom: d + this.width / 2 };
        }
      }
    }
    if (!r) {
      let s = this.editorView.coordsAtPos(this.cursorPos);
      r = { left: s.left - this.width / 2, right: s.left + this.width / 2, top: s.top, bottom: s.bottom };
    }
    let i = this.editorView.dom.offsetParent;
    this.element || (this.element = i.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let o, a;
    if (!i || i == document.body && getComputedStyle(i).position == "static")
      o = -pageXOffset, a = -pageYOffset;
    else {
      let s = i.getBoundingClientRect();
      o = s.left - i.scrollLeft, a = s.top - i.scrollTop;
    }
    this.element.style.left = r.left - o + "px", this.element.style.top = r.top - a + "px", this.element.style.width = r.right - r.left + "px", this.element.style.height = r.bottom - r.top + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), i = r && r.type.spec.disableDropCursor, o = typeof i == "function" ? i(this.editorView, n, e) : i;
    if (n && !o) {
      let a = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let s = WF(this.editorView.state.doc, a, this.editorView.dragging.slice);
        s != null && (a = s);
      }
      this.setCursor(a), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
  }
}
const nle = St.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      ele(this.options)
    ];
  }
}), rle = St.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new Pt({
        key: new Nt("focus"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const { isEditable: n, isFocused: r } = this.editor, { anchor: i } = e, o = [];
            if (!n || !r)
              return Bt.create(t, []);
            let a = 0;
            this.options.mode === "deepest" && t.descendants((l, c) => {
              if (l.isText)
                return;
              if (!(i >= c && i <= c + l.nodeSize - 1))
                return !1;
              a += 1;
            });
            let s = 0;
            return t.descendants((l, c) => {
              if (l.isText || !(i >= c && i <= c + l.nodeSize - 1))
                return !1;
              if (s += 1, this.options.mode === "deepest" && a - s > 0 || this.options.mode === "shallowest" && s > 1)
                return this.options.mode === "deepest";
              o.push(vn.node(c, c + l.nodeSize, {
                class: this.options.className
              }));
            }), Bt.create(t, o);
          }
        }
      })
    ];
  }
});
class Tn extends dt {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    return Tn.valid(r) ? new Tn(r) : dt.near(r);
  }
  content() {
    return Xe.empty;
  }
  eq(e) {
    return e instanceof Tn && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new Tn(e.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new bE(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !ile(e) || !ole(e))
      return !1;
    let r = n.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = n.contentMatchAt(e.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, n, r = !1) {
    e: for (; ; ) {
      if (!r && Tn.valid(e))
        return e;
      let i = e.pos, o = null;
      for (let a = e.depth; ; a--) {
        let s = e.node(a);
        if (n > 0 ? e.indexAfter(a) < s.childCount : e.index(a) > 0) {
          o = s.child(n > 0 ? e.indexAfter(a) : e.index(a) - 1);
          break;
        } else if (a == 0)
          return null;
        i += n;
        let l = e.doc.resolve(i);
        if (Tn.valid(l))
          return l;
      }
      for (; ; ) {
        let a = n > 0 ? o.firstChild : o.lastChild;
        if (!a) {
          if (o.isAtom && !o.isText && !st.isSelectable(o)) {
            e = e.doc.resolve(i + o.nodeSize * n), r = !1;
            continue e;
          }
          break;
        }
        o = a, i += n;
        let s = e.doc.resolve(i);
        if (Tn.valid(s))
          return s;
      }
      return null;
    }
  }
}
Tn.prototype.visible = !1;
Tn.findFrom = Tn.findGapCursorFrom;
dt.jsonID("gapcursor", Tn);
class bE {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new bE(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return Tn.valid(n) ? new Tn(n) : dt.near(n);
  }
}
function ile(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e), r = t.node(e);
    if (n == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function ole(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e), r = t.node(e);
    if (n == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function ale() {
  return new Pt({
    props: {
      decorations: ule,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && Tn.valid(n) ? new Tn(n) : null;
      },
      handleClick: lle,
      handleKeyDown: sle,
      handleDOMEvents: { beforeinput: cle }
    }
  });
}
const sle = cD({
  ArrowLeft: uy("horiz", -1),
  ArrowRight: uy("horiz", 1),
  ArrowUp: uy("vert", -1),
  ArrowDown: uy("vert", 1)
});
function uy(t, e) {
  const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, i, o) {
    let a = r.selection, s = e > 0 ? a.$to : a.$from, l = a.empty;
    if (a instanceof ot) {
      if (!o.endOfTextblock(n) || s.depth == 0)
        return !1;
      l = !1, s = r.doc.resolve(e > 0 ? s.after() : s.before());
    }
    let c = Tn.findGapCursorFrom(s, e, l);
    return c ? (i && i(r.tr.setSelection(new Tn(c))), !0) : !1;
  };
}
function lle(t, e, n) {
  if (!t || !t.editable)
    return !1;
  let r = t.state.doc.resolve(e);
  if (!Tn.valid(r))
    return !1;
  let i = t.posAtCoords({ left: n.clientX, top: n.clientY });
  return i && i.inside > -1 && st.isSelectable(t.state.doc.nodeAt(i.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new Tn(r))), !0);
}
function cle(t, e) {
  if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof Tn))
    return !1;
  let { $from: n } = t.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = ze.empty;
  for (let a = r.length - 1; a >= 0; a--)
    i = ze.from(r[a].createAndFill(null, i));
  let o = t.state.tr.replace(n.pos, n.pos, new Xe(i, 0, 0));
  return o.setSelection(ot.near(o.doc.resolve(n.pos + 1))), t.dispatch(o), !1;
}
function ule(t) {
  if (!(t.selection instanceof Tn))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Bt.create(t.doc, [vn.widget(t.selection.head, e, { key: "gapcursor" })]);
}
const dle = St.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      ale()
    ];
  },
  extendNodeSchema(t) {
    var e;
    const n = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      allowGapCursor: (e = yt(tt(t, "allowGapCursor", n))) !== null && e !== void 0 ? e : null
    };
  }
}), fle = rn.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["br", bt(this.options.HTMLAttributes, t)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: t, chain: e, state: n, editor: r }) => t.first([
        () => t.exitCode(),
        () => t.command(() => {
          const { selection: i, storedMarks: o } = n;
          if (i.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: a } = this.options, { splittableMarks: s } = r.extensionManager, l = o || i.$to.parentOffset && i.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: c, dispatch: u }) => {
            if (u && l && a) {
              const d = l.filter((f) => s.includes(f.type.name));
              c.ensureMarks(d);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), hle = rn.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", bt(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), ple = rn.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["p", bt(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: t }) => t.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), mle = St.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something …",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    return [
      new Pt({
        key: new Nt("placeholder"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const n = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: r } = e, i = [];
            if (!n)
              return null;
            const o = this.editor.isEmpty;
            return t.descendants((a, s) => {
              const l = r >= s && r <= s + a.nodeSize, c = !a.isLeaf && f1(a);
              if ((l || !this.options.showOnlyCurrent) && c) {
                const u = [this.options.emptyNodeClass];
                o && u.push(this.options.emptyEditorClass);
                const d = vn.node(s, s + a.nodeSize, {
                  class: u.join(" "),
                  "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: a,
                    pos: s,
                    hasAnchor: l
                  }) : this.options.placeholder
                });
                i.push(d);
              }
              return this.options.includeChildren;
            }), Bt.create(t, i);
          }
        }
      })
    ];
  }
}), gle = rn.create({
  name: "text",
  group: "inline"
}), yle = rn.create({
  name: "doc",
  topNode: !0,
  content: "block+"
}), ble = yle.extend({
  content: "(block|columns)+"
  // echo editor is a block editor
});
function vle(t, e, n = null) {
  return n ? t.createChecked({ index: e }, n) : t.createAndFill({ index: e });
}
function wle(t) {
  if (t.cached.columnsNodeTypes)
    return t.cached.columnsNodeTypes;
  const e = {
    columns: t.nodes.columns,
    column: t.nodes.column
  };
  return t.cached.columnsNodeTypes = e, e;
}
function xle(t, e, n = null) {
  const r = wle(t), i = [];
  for (let o = 0; o < e; o += 1) {
    const a = vle(r.column, o, n);
    a && i.push(a);
  }
  return r.columns.createChecked({ cols: e }, i);
}
function Hx({
  state: t,
  dispatch: e,
  type: n
}) {
  const r = Jc((o) => o.type.name === bm.name)(t.selection), i = Jc((o) => o.type.name === vE.name)(t.selection);
  if (e && r && i) {
    const o = r.node, a = i.node.attrs.index, s = o.toJSON();
    let l = a;
    n === "delete" ? (l = a - 1, s.content.splice(a, 1)) : (l = n === "addBefore" ? a : a + 1, s.content.splice(l, 0, {
      type: "column",
      attrs: {
        index: a
      },
      content: [
        {
          type: "paragraph"
        }
      ]
    })), s.attrs.cols = s.content.length, s.content.forEach((f, p) => {
      f.attrs.index = p;
    });
    const c = ns.fromJSON(t.schema, s);
    let u = r.pos;
    c.content.forEach((f, p, m) => {
      m < l && (u += f.nodeSize);
    });
    const d = t.tr.setTime(Date.now());
    d.replaceWith(r.pos, r.pos + r.node.nodeSize, c).setSelection(
      ot.near(d.doc.resolve(u))
    ), e(d);
  }
  return !0;
}
function gR({ state: t, dispatch: e, type: n }) {
  const r = Jc((o) => o.type.name === bm.name)(t.selection), i = Jc((o) => o.type.name === vE.name)(t.selection);
  if (e && r && i) {
    const o = r.node, a = i.node.attrs.index;
    let s = 0;
    n === "before" ? s = (a - 1 + o.attrs.cols) % o.attrs.cols : s = (a + 1) % o.attrs.cols;
    let l = r.pos;
    o.content.forEach((u, d, f) => {
      f < s && (l += u.nodeSize);
    });
    const c = t.tr.setTime(Date.now());
    return c.setSelection(ot.near(c.doc.resolve(l))), e(c), !0;
  }
  return !1;
}
const _le = 200, bm = rn.create({
  name: "columns",
  group: "block",
  defining: !0,
  isolating: !0,
  allowGapCursor: !1,
  content: "column{1,}",
  priority: _le,
  addOptions() {
    return {
      HTMLAttributes: {
        class: "columns"
      }
    };
  },
  addAttributes() {
    return {
      cols: {
        default: 2,
        parseHTML: (t) => t.getAttribute("cols")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "div[class=grid]"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["div", bt(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      insertColumns: (t) => ({ tr: e, dispatch: n, editor: r }) => {
        const i = xle(r.schema, t && t.cols || 3);
        if (n) {
          const o = e.selection.anchor + 1;
          e.replaceSelectionWith(i).scrollIntoView().setSelection(ot.near(e.doc.resolve(o)));
        }
        return !0;
      },
      addColBefore: () => ({ dispatch: t, state: e }) => Hx({ dispatch: t, state: e, type: "addBefore" }),
      addColAfter: () => ({ dispatch: t, state: e }) => Hx({ dispatch: t, state: e, type: "addAfter" }),
      deleteCol: () => ({ dispatch: t, state: e }) => Hx({ dispatch: t, state: e, type: "delete" })
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-G": () => this.editor.commands.insertColumns(),
      Tab: () => gR({
        state: this.editor.state,
        dispatch: this.editor.view.dispatch,
        type: "after"
      }),
      "Shift-Tab": () => gR({
        state: this.editor.state,
        dispatch: this.editor.view.dispatch,
        type: "before"
      })
    };
  }
}), vE = rn.create({
  name: "column",
  content: "block+",
  isolating: !0,
  addOptions() {
    return {
      HTMLAttributes: {
        class: "column"
      }
    };
  },
  addAttributes() {
    return {
      index: {
        default: 0,
        parseHTML: (t) => t.getAttribute("index")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "div[class=column]"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["div", bt(this.options.HTMLAttributes, t), 0];
  }
}), P2e = St.create({
  name: "columnActionButton",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: Je,
        componentProps: {
          action: () => {
            e.chain().focus().insertColumns({ cols: 2 }).run();
          },
          icon: "Columns",
          tooltip: n("editor.columns.tooltip")
        }
      })
    };
  }
}), Sle = St.create({
  name: "selection",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new Pt({
        key: new Nt("selection"),
        props: {
          decorations(e) {
            return e.selection.empty || t.isFocused === !0 ? null : Bt.create(e.doc, [
              vn.inline(e.selection.from, e.selection.to, {
                class: "selection"
              })
            ]);
          }
        }
      })
    ];
  }
});
function Tle(t) {
  const { t: e } = Wt(), n = Yt(() => [
    {
      name: "paragraph",
      label: e("editor.paragraph.tooltip"),
      iconName: "Heading1",
      isActive: () => t.editor.isActive("paragraph") && !t.editor.isActive("orderedList") && !t.editor.isActive("bulletList") && !t.editor.isActive("taskList"),
      action: () => t.editor.chain().focus().clearNodes().run()
    },
    {
      name: "heading1",
      label: e("editor.heading.h1.tooltip"),
      isActive: () => t.editor.isActive("heading", { level: 1 }),
      iconName: "Heading1",
      action: () => t.editor.chain().focus().clearNodes().toggleHeading({ level: 1 }).run()
    },
    {
      name: "heading2",
      label: e("editor.heading.h2.tooltip"),
      isActive: () => t.editor.isActive("heading", { level: 2 }),
      iconName: "Heading2",
      action: () => t.editor.chain().focus().clearNodes().toggleHeading({ level: 2 }).run()
    },
    {
      name: "heading3",
      label: e("editor.heading.h3.tooltip"),
      isActive: () => t.editor.isActive("heading", { level: 3 }),
      iconName: "Heading3",
      action: () => t.editor.chain().focus().clearNodes().toggleHeading({ level: 3 }).run()
    },
    {
      name: "bulletList",
      label: e("editor.bulletlist.tooltip"),
      isActive: () => t.editor.isActive("bulletList"),
      iconName: "List",
      action: () => t.editor.chain().focus().clearNodes().toggleBulletList().run()
    },
    {
      name: "numberedList",
      label: e("editor.orderedlist.tooltip"),
      isActive: () => t.editor.isActive("orderedList"),
      iconName: "ListOrdered",
      action: () => t.editor.chain().focus().clearNodes().toggleOrderedList().run()
    },
    {
      name: "taskList",
      label: e("editor.tasklist.tooltip"),
      isActive: () => t.editor.isActive("taskList"),
      iconName: "ListTodo",
      action: () => t.editor.chain().focus().clearNodes().toggleTaskList().run()
    },
    {
      name: "blockquote",
      label: e("editor.blockquote.tooltip"),
      isActive: () => t.editor.isActive("blockquote"),
      iconName: "TextQuote",
      action: () => t.editor.chain().focus().clearNodes().toggleBlockquote().run()
    }
  ], [t.editor, e]), r = Yt(() => n.filter((i) => i.isActive()).pop() ?? {
    label: "Empty"
  }, [n]);
  return /* @__PURE__ */ Fe(hu, { children: [
    /* @__PURE__ */ z(pu, { asChild: !0, children: /* @__PURE__ */ Fe(fn, { variant: "ghost", className: "richtext-h-[32px] richtext-flex richtext-gap-1 richtext-px-1.5", children: [
      /* @__PURE__ */ Fe("span", { className: "richtext-text-sm richtext-font-normal richtext-whitespace-nowrap", children: [
        " ",
        r == null ? void 0 : r.label
      ] }),
      /* @__PURE__ */ z(uF, { className: "richtext-w-4 richtext-h-4" })
    ] }) }),
    /* @__PURE__ */ z(Bl, { hideWhenDetached: !0, className: "richtext-w-full richtext-p-1", align: "start", sideOffset: 5, children: n.map((i, o) => {
      var s;
      const a = Hm[i.iconName];
      return /* @__PURE__ */ z(
        mu,
        {
          checked: ((s = i.isActive) == null ? void 0 : s.call(i)) || !1,
          onClick: () => i.action(),
          className: "richtext-cursor-pointer",
          children: /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-items-center richtext-gap-2 richtext-px-2", children: [
            /* @__PURE__ */ z(a, { className: "richtext-w-3 richtext-h3" }),
            /* @__PURE__ */ Fe("span", { children: [
              " ",
              i.label
            ] })
          ] })
        },
        `text-bubble-${o}`
      );
    }) })
  ] });
}
const Dle = St.create({
  name: "text-bubble",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      toolbar: !1,
      button: () => ({
        component: Tle,
        componentProps: {}
      })
    };
  }
});
function yR({ types: t, node: e }) {
  return Array.isArray(t) && t.includes(e.type) || e.type === t;
}
const Ele = St.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: "paragraph",
      notAfter: ["paragraph"]
    };
  },
  addProseMirrorPlugins() {
    const t = new Nt(this.name), e = Object.entries(this.editor.schema.nodes).map(([, n]) => n).filter((n) => this.options.notAfter.includes(n.name));
    return [
      new Pt({
        key: t,
        appendTransaction: (n, r, i) => {
          const { doc: o, tr: a, schema: s } = i, l = t.getState(i), c = o.content.size, u = s.nodes[this.options.node];
          if (l)
            return a.insert(c, u.create());
        },
        state: {
          init: (n, r) => {
            const i = r.tr.doc.lastChild;
            return !yR({ node: i, types: e });
          },
          apply: (n, r) => {
            if (!n.docChanged)
              return r;
            const i = n.doc.lastChild;
            return !yR({ node: i, types: e });
          }
        }
      })
    ];
  }
}), W2e = St.create({
  name: "base-kit",
  addExtensions() {
    const t = [];
    return this.options.document !== !1 && t.push(ble.configure()), this.options.placeholder !== !1 && t.push(
      mle.configure({
        placeholder: ({ node: e, pos: n, editor: r }) => {
          var i, o, a, s;
          return ((i = e == null ? void 0 : e.type) == null ? void 0 : i.name) === "columns" || ((o = e == null ? void 0 : e.content) == null ? void 0 : o.size) !== 0 ? "" : ((a = e == null ? void 0 : e.type) == null ? void 0 : a.name) === "heading" ? `${sn.t(`editor.heading.h${e.attrs.level}.tooltip`)}` : ((s = e == null ? void 0 : e.type) == null ? void 0 : s.name) === "table" ? "" : r.extensionManager.extensions.some((l) => l.name === "slashCommand") ? sn.t("editor.slash") : sn.t("editor.content");
        },
        ...this.options.placeholder
      })
    ), this.options.focus !== !1 && t.push(
      rle.configure({
        className: "focus",
        ...this.options.focus
      })
    ), this.options.text !== !1 && t.push(gle.configure()), this.options.textBubble !== !1 && t.push(Dle.configure()), this.options.gapcursor !== !1 && t.push(dle.configure()), this.options.dropcursor !== !1 && t.push(
      nle.configure({
        ...this.options.dropcursor,
        width: 2,
        class: "ProseMirror-dropcursor border-black"
      })
    ), this.options.characterCount !== !1 && t.push(Qse.configure(this.options.characterCount)), this.options.paragraph !== !1 && t.push(ple.configure(this.options.paragraph)), this.options.hardBreak !== !1 && t.push(fle.configure(this.options.hardBreak)), this.options.listItem !== !1 && t.push(hle.configure(this.options.listItem)), this.options.textStyle !== !1 && t.push(qae.configure(this.options.textStyle)), this.options.trailingNode !== !1 && t.push(Ele.configure(this.options.trailingNode)), this.options.selection !== !1 && t.push(Sle), this.options.multiColumn !== !1 && (t.push(vE), t.push(bm)), t;
  }
}), dM = li.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "sub" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sub", bt(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSubscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSubscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
}), fM = li.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "super" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sup", bt(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSuperscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSuperscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
}), z2e = St.create({
  name: "subAndSuperScript",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, extension: n, t: r }) => {
        const i = n.options.subscript, o = n.options.superscript, a = {
          component: Je,
          componentProps: {
            action: () => e.commands.toggleSubscript(),
            isActive: () => e.isActive("subscript") || !1,
            disabled: !e.can().toggleSubscript(),
            icon: "Subscript",
            tooltip: r("editor.subscript.tooltip")
          }
        }, s = {
          component: Je,
          componentProps: {
            action: () => e.commands.toggleSuperscript(),
            isActive: () => e.isActive("superscript") || !1,
            disabled: !e.can().toggleSuperscript(),
            icon: "Superscript",
            tooltip: r("editor.superscript.tooltip")
          }
        }, l = [];
        return i !== !1 && l.push(a), o !== !1 && l.push(s), l;
      }
    };
  },
  addExtensions() {
    const t = [];
    return this.options.subscript !== !1 && t.push(dM.configure(this.options.subscript)), this.options.superscript !== !1 && t.push(fM.configure(this.options.superscript)), t;
  }
});
function Cle(t) {
  var n;
  const e = Yt(() => {
    var o;
    const r = (o = t == null ? void 0 : t.items) == null ? void 0 : o.find((a) => a.isActive());
    return r && !r.default ? {
      ...r,
      icon: r != null && r.icon ? r == null ? void 0 : r.icon : t == null ? void 0 : t.icon
    } : {
      title: t.tooltip,
      icon: t.icon,
      isActive: () => !1
    };
  }, [t]);
  return /* @__PURE__ */ Fe(hu, { children: [
    /* @__PURE__ */ z(pu, { disabled: t == null ? void 0 : t.disabled, asChild: !0, children: /* @__PURE__ */ z(
      Je,
      {
        customClass: "!richtext-w-12 richtext-h-12",
        icon: t == null ? void 0 : t.icon,
        tooltip: t == null ? void 0 : t.tooltip,
        disabled: t == null ? void 0 : t.disabled,
        children: /* @__PURE__ */ z(aN, { className: "richtext-w-3 richtext-h-3 richtext-text-gray-500" })
      }
    ) }),
    /* @__PURE__ */ z(Bl, { className: "w-full", children: (n = t == null ? void 0 : t.items) == null ? void 0 : n.map((r, i) => /* @__PURE__ */ Fe(
      mu,
      {
        checked: e.title === r.title,
        onClick: r.action,
        className: "richtext-flex richtext-items-center richtext-gap-3",
        children: [
          /* @__PURE__ */ z($t, { name: r == null ? void 0 : r.icon }),
          /* @__PURE__ */ z("span", { className: "richtext-ml-1", children: r.title }),
          !!(r != null && r.shortcutKeys) && /* @__PURE__ */ z("span", { className: "richtext-ml-auto richtext-text-xs richtext-tracking-widest richtext-opacity-60", children: p1(r.shortcutKeys) })
        ]
      },
      `more-mark-${i}`
    )) })
  ] });
}
const $2e = St.create({
  name: "moreMark",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button({ editor: e, extension: n, t: r }) {
        const i = n.options.subscript, o = n.options.superscript, a = {
          action: () => e.commands.toggleSubscript(),
          isActive: () => e.isActive("subscript") || !1,
          disabled: !e.can().toggleSubscript(),
          icon: "Subscript",
          title: r("editor.subscript.tooltip"),
          shortcutKeys: ["mod", "."]
        }, s = {
          action: () => e.commands.toggleSuperscript(),
          isActive: () => e.isActive("superscript") || !1,
          disabled: !e.can().toggleSuperscript(),
          icon: "Superscript",
          title: r("editor.superscript.tooltip"),
          shortcutKeys: ["mod", ","]
        }, l = [];
        return i !== !1 && l.push(a), o !== !1 && l.push(s), {
          component: Cle,
          componentProps: {
            icon: "Type",
            tooltip: r("editor.moremark"),
            disabled: !e.isEditable,
            items: l
          }
        };
      }
    };
  },
  addExtensions() {
    const t = [];
    return this.options.subscript !== !1 && t.push(dM.configure(this.options.subscript)), this.options.superscript !== !1 && t.push(fM.configure(this.options.superscript)), t;
  }
}), H2e = St.create({
  name: "indent",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      types: ["paragraph", "heading", "blockquote"],
      minIndent: Nc.min,
      maxIndent: Nc.max,
      button({ editor: e, t: n }) {
        return [
          {
            component: Je,
            componentProps: {
              action: () => {
                e.commands.indent();
              },
              shortcutKeys: ["Tab"],
              icon: "IndentIncrease",
              tooltip: n("editor.indent.tooltip")
            }
          },
          {
            component: Je,
            componentProps: {
              action: () => {
                e.commands.outdent();
              },
              shortcutKeys: ["Shift", "Tab"],
              icon: "IndentDecrease",
              tooltip: n("editor.outdent.tooltip")
            }
          }
        ];
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          indent: {
            default: 0,
            parseHTML: (t) => {
              const e = t.dataset.indent;
              return (e ? Number.parseInt(e, 10) : 0) || 0;
            },
            renderHTML: (t) => t.indent ? { "data-indent": t.indent } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      indent: () => eR({
        delta: Nc.more,
        types: this.options.types
      }),
      outdent: () => eR({
        delta: Nc.less,
        types: this.options.types
      })
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.indent(),
      "Shift-Tab": () => this.editor.commands.outdent()
    };
  }
});
function kle(t) {
  return Number.parseFloat(t.replace("%", "")) / 100;
}
function Ale(t) {
  const { t: e } = Wt(), [n, r] = nt("default");
  function i(a) {
    a === "default" ? t.editor.commands.unsetLineHeight() : t.editor.commands.setLineHeight(a), r(a);
  }
  const o = Yt(() => {
    const l = t.editor.extensionManager.extensions.find(
      (c) => c.name === "lineHeight"
    ).options.lineHeights.map((c) => ({
      label: kle(c),
      value: c
    }));
    return l.unshift({
      label: e("editor.default"),
      value: "default"
    }), l;
  }, [t]);
  return /* @__PURE__ */ Fe(hu, { children: [
    /* @__PURE__ */ z(pu, { disabled: t == null ? void 0 : t.disabled, asChild: !0, children: /* @__PURE__ */ z(
      Je,
      {
        customClass: "!richtext-w-12 richtext-h-12",
        icon: "LineHeight",
        tooltip: t == null ? void 0 : t.tooltip,
        disabled: t == null ? void 0 : t.disabled,
        children: /* @__PURE__ */ z($t, { className: "richtext-w-3 richtext-h-3 richtext-ml-1 richtext-text-zinc-500", name: "MenuDown" })
      }
    ) }),
    /* @__PURE__ */ z(Bl, { className: "richtext-min-w-24", children: o == null ? void 0 : o.map((a, s) => /* @__PURE__ */ z(
      mu,
      {
        checked: a.value === n,
        onClick: () => i(a.value),
        children: a.label
      },
      `lineHeight-${s}`
    )) })
  ] });
}
const Rle = ["paragraph", "heading", "list_item", "todo_item"];
function Ile(t, e) {
  const { selection: n, doc: r } = t;
  if (!n || !r || !(n instanceof ot || n instanceof Ci))
    return t;
  const { from: i, to: o } = n, a = [], s = e && e !== y4 ? e : null;
  if (r.nodesBetween(i, o, (l, c) => {
    const u = l.type;
    return Rle.includes(u.name) ? ((l.attrs.lineHeight || null) !== s && a.push({
      node: l,
      pos: c,
      nodeType: u
    }), u.name !== "list_item" && u.name !== "todo_item") : !0;
  }), a.length === 0)
    return t;
  for (const l of a) {
    const { node: c, pos: u, nodeType: d } = l;
    let { attrs: f } = c;
    f = {
      ...f,
      lineHeight: s
    }, t = t.setNodeMarkup(u, d, f, c.marks);
  }
  return t;
}
function Ole(t) {
  return ({ state: e, dispatch: n }) => {
    const { selection: r } = e;
    let { tr: i } = e;
    return i = i.setSelection(r), i = Ile(i, t), i.docChanged ? (n && n(i), !0) : !1;
  };
}
const j2e = St.create({
  name: "lineHeight",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      types: ["paragraph", "heading", "list_item", "todo_item"],
      lineHeights: AZ,
      defaultHeight: y4,
      button({ editor: e, t: n }) {
        return {
          component: Ale,
          componentProps: {
            editor: e,
            tooltip: n("editor.lineheight.tooltip")
          }
        };
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          lineHeight: {
            default: null,
            parseHTML: (t) => t.style.lineHeight || this.options.defaultHeight,
            renderHTML: (t) => t.lineHeight === this.options.defaultHeight || !t.lineHeight ? {} : { style: `line-height: ${t.lineHeight}` }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setLineHeight: (t) => Ole(t),
      unsetLineHeight: () => ({ commands: t }) => this.options.types.every((e) => t.resetAttributes(e, "lineHeight"))
    };
  }
});
function Fle(t) {
  var e;
  const { char: n, allowSpaces: r, allowedPrefixes: i, startOfLine: o, $position: a } = t, s = BV(n), l = new RegExp(`\\s${s}$`), c = o ? "^" : "", u = r ? new RegExp(`${c}${s}.*?(?=\\s${s}|$)`, "gm") : new RegExp(`${c}(?:^)?${s}[^\\s${s}]*`, "gm"), d = ((e = a.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && a.nodeBefore.text;
  if (!d)
    return null;
  const f = a.pos - d.length, p = Array.from(d.matchAll(u)).pop();
  if (!p || p.input === void 0 || p.index === void 0)
    return null;
  const m = p.input.slice(Math.max(0, p.index - 1), p.index), g = new RegExp(`^[${i == null ? void 0 : i.join("")}\0]?$`).test(m);
  if (i !== null && !g)
    return null;
  const b = f + p.index;
  let y = b + p[0].length;
  return r && l.test(d.slice(y - 1, y + 1)) && (p[0] += " ", y += 1), b < a.pos && y >= a.pos ? {
    range: {
      from: b,
      to: y
    },
    query: p[0].slice(n.length),
    text: p[0]
  } : null;
}
const Ule = new Nt("suggestion");
function wE({ pluginKey: t = Ule, editor: e, char: n = "@", allowSpaces: r = !1, allowedPrefixes: i = [" "], startOfLine: o = !1, decorationTag: a = "span", decorationClass: s = "suggestion", command: l = () => null, items: c = () => [], render: u = () => ({}), allow: d = () => !0, findSuggestionMatch: f = Fle }) {
  let p;
  const m = u == null ? void 0 : u(), g = new Pt({
    key: t,
    view() {
      return {
        update: async (b, y) => {
          var w, x, k, A, U, P, V;
          const I = (w = this.key) === null || w === void 0 ? void 0 : w.getState(y), le = (x = this.key) === null || x === void 0 ? void 0 : x.getState(b.state), be = I.active && le.active && I.range.from !== le.range.from, F = !I.active && le.active, G = I.active && !le.active, C = !F && !G && I.query !== le.query, ie = F || be && C, ee = C || be, Z = G || be && C;
          if (!ie && !ee && !Z)
            return;
          const oe = Z && !ie ? I : le, te = b.dom.querySelector(`[data-decoration-id="${oe.decorationId}"]`);
          p = {
            editor: e,
            range: oe.range,
            query: oe.query,
            text: oe.text,
            items: [],
            command: (_e) => l({
              editor: e,
              range: oe.range,
              props: _e
            }),
            decorationNode: te,
            // virtual node for popper.js or tippy.js
            // this can be used for building popups without a DOM node
            clientRect: te ? () => {
              var _e;
              const { decorationId: q } = (_e = this.key) === null || _e === void 0 ? void 0 : _e.getState(e.state), N = b.dom.querySelector(`[data-decoration-id="${q}"]`);
              return (N == null ? void 0 : N.getBoundingClientRect()) || null;
            } : null
          }, ie && ((k = m == null ? void 0 : m.onBeforeStart) === null || k === void 0 || k.call(m, p)), ee && ((A = m == null ? void 0 : m.onBeforeUpdate) === null || A === void 0 || A.call(m, p)), (ee || ie) && (p.items = await c({
            editor: e,
            query: oe.query
          })), Z && ((U = m == null ? void 0 : m.onExit) === null || U === void 0 || U.call(m, p)), ee && ((P = m == null ? void 0 : m.onUpdate) === null || P === void 0 || P.call(m, p)), ie && ((V = m == null ? void 0 : m.onStart) === null || V === void 0 || V.call(m, p));
        },
        destroy: () => {
          var b;
          p && ((b = m == null ? void 0 : m.onExit) === null || b === void 0 || b.call(m, p));
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        return {
          active: !1,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: !1
        };
      },
      // Apply changes to the plugin state from a view transaction.
      apply(b, y, w, x) {
        const { isEditable: k } = e, { composing: A } = e.view, { selection: U } = b, { empty: P, from: V } = U, I = { ...y };
        if (I.composing = A, k && (P || e.view.composing)) {
          (V < y.range.from || V > y.range.to) && !A && !y.composing && (I.active = !1);
          const le = f({
            char: n,
            allowSpaces: r,
            allowedPrefixes: i,
            startOfLine: o,
            $position: U.$from
          }), be = `id_${Math.floor(Math.random() * 4294967295)}`;
          le && d({
            editor: e,
            state: x,
            range: le.range,
            isActive: y.active
          }) ? (I.active = !0, I.decorationId = y.decorationId ? y.decorationId : be, I.range = le.range, I.query = le.query, I.text = le.text) : I.active = !1;
        } else
          I.active = !1;
        return I.active || (I.decorationId = null, I.range = { from: 0, to: 0 }, I.query = null, I.text = null), I;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(b, y) {
        var w;
        const { active: x, range: k } = g.getState(b.state);
        return x && ((w = m == null ? void 0 : m.onKeyDown) === null || w === void 0 ? void 0 : w.call(m, { view: b, event: y, range: k })) || !1;
      },
      // Setup decorator on the currently active suggestion.
      decorations(b) {
        const { active: y, range: w, decorationId: x } = g.getState(b);
        return y ? Bt.create(b.doc, [
          vn.inline(w.from, w.to, {
            nodeName: a,
            class: s,
            "data-decoration-id": x
          })
        ]) : null;
      }
    }
  });
  return g;
}
const hM = $m(!1);
function Nle() {
  return PD(hM);
}
const Gd = {
  setOpen: (t) => {
    hM.set(t);
  }
}, pM = $m(!1);
function Mle() {
  return PD(pM);
}
const Sp = {
  setOpen: (t) => {
    pM.set(t);
  }
};
function Ble(t) {
  const e = [
    {
      name: "format",
      title: sn.t("editor.slash.format"),
      commands: []
    },
    {
      name: "insert",
      title: sn.t("editor.slash.insert"),
      commands: []
    }
  ];
  return t.forEach((n) => {
    n.name.toLowerCase() === "heading" && n.options.levels.forEach((r) => {
      e[0].commands.push({
        name: `heading${r}`,
        label: sn.t(`editor.heading.h${r}.tooltip`),
        aliases: [`h${r}`, "bt", `bt${r}`],
        iconName: `Heading${r}`,
        action: ({ editor: i, range: o }) => {
          i.chain().focus().deleteRange(o).setHeading({ level: r }).run();
        }
      });
    }), n.name.toLowerCase() === "bulletlist" && e[0].commands.push({
      name: "bulletList",
      label: sn.t("editor.bulletlist.tooltip"),
      aliases: ["ul", "yxlb"],
      iconName: "List",
      action: ({ editor: r, range: i }) => {
        r.chain().focus().deleteRange(i).toggleBulletList().run();
      }
    }), n.name.toLowerCase() === "orderedlist" && e[0].commands.push({
      name: "numberedList",
      label: sn.t("editor.orderedlist.tooltip"),
      aliases: ["ol", "yxlb"],
      iconName: "ListOrdered",
      action: ({ editor: r, range: i }) => {
        r.chain().focus().deleteRange(i).toggleOrderedList().run();
      }
    }), n.name.toLowerCase() === "tasklist" && e[0].commands.push({
      name: "taskList",
      label: sn.t("editor.tasklist.tooltip"),
      iconName: "ListTodo",
      description: "Task list with todo items",
      aliases: ["todo"],
      action: ({ editor: r, range: i }) => {
        r.chain().focus().deleteRange(i).toggleTaskList().run();
      }
    }), n.name.toLowerCase() === "blockquote" && e[0].commands.push({
      name: "blockquote",
      label: sn.t("editor.blockquote.tooltip"),
      description: "插入引入格式",
      aliases: ["yr"],
      iconName: "TextQuote",
      action: ({ editor: r, range: i }) => {
        r.chain().focus().deleteRange(i).setBlockquote().run();
      }
    }), n.name.toLowerCase() === "image" && e[1].commands.push({
      name: "image",
      label: sn.t("editor.image.tooltip"),
      iconName: "ImageUp",
      description: "Insert a image",
      aliases: ["image", "tp", "tupian"],
      shouldBeHidden: (r) => r.isActive("columns"),
      action: ({ editor: r, range: i }) => {
        r.chain().focus().deleteRange(i).run(), Gd.setOpen(!0);
      }
    }), n.name.toLowerCase() === "video" && e[1].commands.push({
      name: "video",
      label: sn.t("editor.video.tooltip"),
      iconName: "Video",
      description: "Insert a video",
      aliases: ["video", "sp", "shipin"],
      shouldBeHidden: (r) => r.isActive("columns"),
      action: ({ editor: r, range: i }) => {
        r.chain().focus().deleteRange(i).run(), Sp.setOpen(!0);
      }
    }), n.name.toLowerCase() === "table" && e[1].commands.push({
      name: "table",
      label: sn.t("editor.table.tooltip"),
      iconName: "Table",
      description: "Insert a table",
      aliases: ["table", "bg", "biaoge", "biao"],
      shouldBeHidden: (r) => r.isActive("columns"),
      action: ({ editor: r, range: i }) => {
        r.chain().focus().deleteRange(i).insertTable({ rows: 3, cols: 3, withHeaderRow: !1 }).run();
      }
    }), n.name.toLowerCase() === "horizontalrule" && e[1].commands.push({
      name: "horizontalRule",
      label: sn.t("editor.horizontalrule.tooltip"),
      iconName: "Minus",
      description: "Insert a horizontal divider",
      aliases: ["hr", "fgx", "fg"],
      action: ({ editor: r, range: i }) => {
        r.chain().focus().deleteRange(i).setHorizontalRule().run();
      }
    }), n.name.toLowerCase() === "columns" && e[1].commands.push({
      name: "columns",
      label: sn.t("editor.columns.tooltip"),
      iconName: "Columns2",
      description: "Add two column content",
      action: ({ editor: r }) => {
        r.chain().focus().insertColumns({ cols: 2 }).run();
      }
    });
  }), e;
}
function Lle(t, e) {
  var b, y;
  const [n, r] = nt(0), [i, o] = nt(0), a = Wr(null), { t: s } = Wt(), l = Wr([]);
  Kv(e, () => ({
    onKeyDown: c
  })), Tt(() => {
    if (!a.current)
      return;
    const w = i * 1e3 + n, x = l.current[w];
    x && x.scrollIntoView({
      behavior: "smooth",
      block: "nearest"
    });
  }, [n, i]);
  function c({ event: w }) {
    return w.key === "ArrowUp" ? (u(), !0) : w.key === "ArrowDown" ? (d(), !0) : w.key === "Enter" ? (f(), !0) : !1;
  }
  function u() {
    var k;
    if (t.items.length === 0)
      return !1;
    let w = n - 1, x = i;
    w < 0 && (x = i - 1, w = ((k = t.items[x]) == null ? void 0 : k.commands.length) - 1 || 0), x < 0 && (x = t.items.length - 1, w = t.items[x].commands.length - 1), r(w), o(x);
  }
  function d() {
    if (t.items.length === 0)
      return !1;
    const w = t.items[i].commands;
    let x = n + 1, k = i;
    w.length - 1 < x && (x = 0, k = i + 1), t.items.length - 1 < k && (k = 0), r(x), o(k);
  }
  function f() {
    if (t.items.length === 0 || i === -1 || n === -1)
      return !1;
    p(i, n);
  }
  function p(w, x) {
    const k = t.items[w].commands[x];
    t.command(k);
  }
  function m(w, x) {
    p(w, x);
  }
  function g(w, x, k) {
    l.current[w * 1e3 + x] = k;
  }
  return /* @__PURE__ */ z(
    "div",
    {
      className: "!richtext-bg-white richtext-rounded-lg dark:!richtext-bg-black richtext-shadow-sm !richtext-border !richtext-border-neutral-200 dark:!richtext-border-neutral-800 !richtext-text-black richtext-max-h-[min(80vh,24rem)] richtext-overflow-auto richtext-flex-wrap richtext-mb-8 richtext-p-1",
      ref: a,
      children: (b = t == null ? void 0 : t.items) != null && b.length ? /* @__PURE__ */ z("div", { className: "richtext-grid richtext-grid-cols-1 richtext-gap-0.5 richtext-min-w-48", children: (y = t == null ? void 0 : t.items) == null ? void 0 : y.map((w, x) => /* @__PURE__ */ Fe(Xv, { children: [
        /* @__PURE__ */ z("div", { className: "!richtext-text-neutral-500 richtext-text-[0.65rem] richtext-col-[1/-1] richtext-mx-2 richtext-mt-2 richtext-font-semibold richtext-tracking-wider richtext-select-none richtext-uppercase first:richtext-mt-0.5", children: w.title }),
        w.commands.map((k, A) => /* @__PURE__ */ Fe(
          "button",
          {
            className: Ct("richtext-flex richtext-items-center richtext-gap-3 richtext-px-2 richtext-py-1.5 richtext-text-sm !richtext-text-neutral-800 dark:!richtext-text-neutral-200 richtext-text-left richtext-w-full richtext-rounded-sm richtext-outline-none richtext-transition-colors !richtext-bg-transparent hover:!richtext-bg-accent ", {
              "slash-command-active": i === x && n === A
            }),
            ref: (U) => g(x, A, U),
            onClick: () => m(x, A),
            children: [
              k.iconUrl && /* @__PURE__ */ z("img", { className: "richtext-w-6 richtext-h-6", src: k.iconUrl, alt: "" }),
              k.iconName && /* @__PURE__ */ z($t, { name: k.iconName, className: "!richtext-mr-1 !richtext-text-lg" }),
              k.label
            ]
          },
          `command-${A}`
        ))
      ] }, `slash-${w.title}`)) }) : /* @__PURE__ */ z("div", { className: "richtext-p-3", children: /* @__PURE__ */ z("span", { className: "richtext-text-xs richtext-text-gray-800 dark:richtext-text-gray-100", children: s("editor.slash.empty") }) })
    }
  );
}
const Ple = Om(Lle), Dc = "slashCommand";
let Kt;
const V2e = St.create({
  name: Dc,
  priority: 200,
  onCreate() {
    Kt = Fm("body", {
      interactive: !0,
      trigger: "manual",
      placement: "bottom-start",
      theme: "slash-command",
      maxWidth: "16rem",
      offset: [16, 8],
      popperOptions: {
        strategy: "fixed",
        modifiers: [
          {
            name: "flip",
            enabled: !1
          }
        ]
      }
    });
  },
  addProseMirrorPlugins() {
    return [
      wE({
        editor: this.editor,
        char: "/",
        allowSpaces: !0,
        startOfLine: !0,
        pluginKey: new Nt(Dc),
        allow: ({ state: t, range: e }) => {
          var c, u, d;
          const n = t.doc.resolve(e.from), r = n.depth === 1, i = n.parent.type.name === "paragraph", o = ((c = n.parent.textContent) == null ? void 0 : c.charAt(0)) === "/", a = this.editor.isActive("column"), s = (d = n.parent.textContent) == null ? void 0 : d.slice(
            Math.max(0, (u = n.parent.textContent) == null ? void 0 : u.indexOf("/"))
          ), l = !(s != null && s.endsWith("  "));
          return (r && i && o || a && i && o) && l;
        },
        command: ({ editor: t, range: e, props: n }) => {
          const { view: r } = t;
          n.action({ editor: t, range: e }), r.focus();
        },
        items: ({ query: t, editor: e }) => Ble(e.extensionManager.extensions).map((a) => ({
          ...a,
          commands: a.commands.filter((s) => {
            const l = s.label.toLowerCase().trim(), c = t.toLowerCase().trim();
            if (s.aliases) {
              const u = s.aliases.map((p) => p.toLowerCase().trim()), d = l.match(c), f = u.some((p) => p.match(c));
              return d || f;
            }
            return l.match(c);
          }).filter(
            (s) => s.shouldBeHidden ? !s.shouldBeHidden(this.editor) : !0
          )
        })).filter((a) => a.commands.length > 0).map((a) => ({
          ...a,
          commands: a.commands.map((s) => ({
            ...s,
            isEnabled: !0
          }))
        })),
        render: () => {
          let t, e = null;
          return {
            onStart: (n) => {
              var o;
              t = new g1(Ple, {
                props: n,
                editor: n.editor
              });
              const { view: r } = n.editor, i = () => {
                if (!n.clientRect)
                  return n.editor.storage[Dc].rect;
                const a = n.clientRect();
                if (!a)
                  return n.editor.storage[Dc].rect;
                let s = a.y;
                if (a.top + t.element.offsetHeight + 40 > window.innerHeight) {
                  const l = a.top + t.element.offsetHeight - window.innerHeight + 40;
                  s = a.y - l;
                }
                return new DOMRect(a.x, s, a.width, a.height);
              };
              e = () => {
                Kt == null || Kt[0].setProps({
                  getReferenceClientRect: i
                });
              }, (o = r.dom.parentElement) == null || o.addEventListener("scroll", e), Kt == null || Kt[0].setProps({
                getReferenceClientRect: i,
                appendTo: () => document.body,
                content: t.element
              }), Kt == null || Kt[0].show();
            },
            onUpdate(n) {
              var a;
              t.updateProps(n);
              const { view: r } = n.editor, i = () => {
                if (!n.clientRect)
                  return n.editor.storage[Dc].rect;
                const s = n.clientRect();
                return s ? new DOMRect(s.x, s.y, s.width, s.height) : n.editor.storage[Dc].rect;
              }, o = () => {
                Kt == null || Kt[0].setProps({
                  getReferenceClientRect: i
                });
              };
              (a = r.dom.parentElement) == null || a.addEventListener("scroll", o), n.editor.storage[Dc].rect = n.clientRect ? i() : {
                width: 0,
                height: 0,
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
              }, Kt == null || Kt[0].setProps({
                getReferenceClientRect: i
              });
            },
            onKeyDown(n) {
              var r;
              return n.event.key === "Escape" ? (Kt == null || Kt[0].hide(), !0) : (Kt != null && Kt[0].state.isShown || Kt == null || Kt[0].show(), (r = t.ref) == null ? void 0 : r.onKeyDown(n));
            },
            onExit(n) {
              var r;
              if (Kt == null || Kt[0].hide(), e) {
                const { view: i } = n.editor;
                (r = i.dom.parentElement) == null || r.removeEventListener("scroll", e);
              }
              t.destroy();
            }
          };
        }
      })
    ];
  },
  addStorage() {
    return {
      rect: {
        width: 0,
        height: 0,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      }
    };
  }
}), Wle = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, mM = rn.create({
  name: "image",
  addOptions() {
    return {
      inline: !1,
      allowBase64: !1,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: !0,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["img", bt(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setImage: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  addInputRules() {
    return [
      yD({
        find: Wle,
        type: this.type,
        getAttributes: (t) => {
          const [, , e, n, r] = t;
          return { src: n, alt: e, title: r };
        }
      })
    ];
  }
}), dy = {
  TOP_LEFT: "tl",
  TOP_RIGHT: "tr",
  BOTTOM_LEFT: "bl",
  BOTTOM_RIGHT: "br"
};
function zle(t) {
  var P, V;
  const [e, n] = nt({
    width: zb,
    height: zb
  }), [r, i] = nt({
    width: 0,
    height: 0
  }), [o] = nt([
    dy.TOP_LEFT,
    dy.TOP_RIGHT,
    dy.BOTTOM_LEFT,
    dy.BOTTOM_RIGHT
  ]), [a, s] = nt(!1), [l, c] = nt({
    x: 0,
    y: 0,
    w: 0,
    h: 0,
    dir: ""
  }), { align: u, inline: d } = (P = t == null ? void 0 : t.node) == null ? void 0 : P.attrs, f = Yt(() => {
    var te;
    const { src: I, alt: le, width: be, height: F, flipX: G, flipY: C } = (te = t == null ? void 0 : t.node) == null ? void 0 : te.attrs, ie = Gb(be) ? `${be}px` : be, ee = Gb(F) ? `${F}px` : F, Z = [];
    G && Z.push("rotateX(180deg)"), C && Z.push("rotateY(180deg)");
    const oe = Z.join(" ");
    return {
      src: I || void 0,
      alt: le || void 0,
      style: {
        width: ie || void 0,
        height: ee || void 0,
        transform: oe || "none"
      }
    };
  }, [(V = t == null ? void 0 : t.node) == null ? void 0 : V.attrs]), p = Yt(() => {
    const {
      style: { width: I }
    } = f;
    return { width: I === "100%" ? I : void 0 };
  }, [f]);
  function m(I) {
    i({
      width: I.target.width,
      height: I.target.height
    });
  }
  function g() {
    const { editor: I, getPos: le } = t;
    I.commands.setNodeSelection(le());
  }
  const b = Et(
    am(() => {
      const { editor: I } = t, { width: le } = getComputedStyle(I.view.dom);
      n((be) => ({
        ...be,
        width: Number.parseInt(le, 10)
      }));
    }, $b),
    [t == null ? void 0 : t.editor]
  );
  function y(I, le) {
    I.preventDefault(), I.stopPropagation();
    const be = r.width, F = r.height, G = be / F;
    let C = Number(t.node.attrs.width), ie = Number(t.node.attrs.height);
    const ee = e.width;
    C && !ie ? (C = C > ee ? ee : C, ie = Math.round(C / G)) : ie && !C ? (C = Math.round(ie * G), C = C > ee ? ee : C) : !C && !ie ? (C = be > ee ? ee : be, ie = Math.round(C / G)) : C = C > ee ? ee : C, jp(() => {
      s(!0), c({
        x: I.clientX,
        y: I.clientY,
        w: C,
        h: ie,
        dir: le
      });
    });
  }
  const w = Et(
    am((I) => {
      if (I.preventDefault(), I.stopPropagation(), !a)
        return;
      const { x: le, w: be, dir: F } = l, G = (I.clientX - le) * (/l/.test(F) ? -1 : 1), C = H4(be + G, g4, e.width);
      t.updateAttributes({
        width: C,
        height: null
      });
    }, $b),
    [a, l, e, t.updateAttributes]
  ), x = Et(
    (I) => {
      I.preventDefault(), I.stopPropagation(), a && (jp(() => {
        c({
          x: 0,
          y: 0,
          w: 0,
          h: 0,
          dir: ""
        }), s(!1);
      }), g());
    },
    [a, g]
  ), k = Et(() => {
    document == null || document.addEventListener("mousemove", w, !0), document == null || document.addEventListener("mouseup", x, !0);
  }, [w, x]), A = Et(() => {
    document == null || document.removeEventListener("mousemove", w, !0), document == null || document.removeEventListener("mouseup", x, !0);
  }, [w, x]);
  Tt(() => (a ? k() : A(), () => {
    A();
  }), [a, k, A]);
  const U = Yt(() => new ResizeObserver(() => b()), [b]);
  return Tt(() => (U.observe(t.editor.view.dom), () => {
    U.disconnect();
  }), [t.editor.view.dom, U]), /* @__PURE__ */ z(
    xl,
    {
      className: "image-view",
      style: { ...p, textAlign: u, display: d ? "inline" : "block" },
      as: d ? "span" : "div",
      children: /* @__PURE__ */ Fe(
        "div",
        {
          draggable: "true",
          "data-drag-handle": !0,
          className: `image-view__body ${t != null && t.selected ? "image-view__body--focused" : ""} ${a ? "image-view__body--resizing" : ""}`,
          style: p,
          children: [
            /* @__PURE__ */ z(
              "img",
              {
                src: f.src,
                alt: f.alt,
                style: f.style,
                height: "auto",
                className: "image-view__body__image block",
                onLoad: m,
                onClick: g
              }
            ),
            (t == null ? void 0 : t.editor.view.editable) && ((t == null ? void 0 : t.selected) || a) && /* @__PURE__ */ z("div", { className: "image-resizer", children: o == null ? void 0 : o.map((I) => /* @__PURE__ */ z(
              "span",
              {
                className: `image-resizer__handler image-resizer__handler--${I}`,
                onMouseDown: (le) => y(le, I)
              },
              `image-dir-${I}`
            )) })
          ]
        }
      )
    }
  );
}
function $le(t) {
  return t.replace(/^.*\/|\..+$/g, "");
}
function Hle(t) {
  return t.split(".").pop();
}
function gM(t) {
  return t < 1024 ? `${t} Byte` : t < 1024 * 1024 ? `${(t / 1024).toFixed(2)} KB` : `${(t / 1024 / 1024).toFixed(2)} MB`;
}
function jle(t) {
  return t ? t === "application/pdf" ? "pdf" : t.startsWith("application/") && [".document", "word"].some((e) => t.includes(e)) ? "word" : t.startsWith("application/") && ["presentation"].some((e) => t.includes(e)) ? "excel" : t.startsWith("application/") && ["sheet"].some((e) => t.includes(e)) ? "ppt" : t.startsWith("image") ? "image" : t.startsWith("audio") ? "audio" : t.startsWith("video") ? "video" : "file" : "file";
}
function Vle(t) {
  return new Promise((e) => {
    const n = new FileReader();
    n.addEventListener(
      "load",
      () => {
        e({
          alt: t.name,
          src: n.result
        });
      },
      !1
    ), n.readAsDataURL(t);
  });
}
function qle(t, e) {
  const n = t.split(","), r = n[0].match(/:(.*?);/)[1], i = atob(n[n.length - 1]);
  let o = i.length;
  const a = new Uint8Array(o);
  for (; o--; )
    a[o] = i.charCodeAt(o);
  return new File([a], e, { type: r });
}
function Gle({ editor: t, imageInline: e, onClose: n }) {
  const { t: r } = Wt(), [i, o] = nt(!1), a = Lt.useRef(null), [s, l] = Lt.useState(), [c, u] = Lt.useState(""), d = Wr(null), [f, p] = nt({
    src: "",
    file: null
  });
  function m(x) {
    if (a.current && x.width && x.height) {
      const k = g(a.current, x);
      u(k);
    }
  }
  function g(x, k) {
    const A = document.createElement("canvas"), U = x.naturalWidth / x.width, P = x.naturalHeight / x.height;
    A.width = k.width * U, A.height = k.height * P;
    const V = A.getContext("2d");
    return V && (V.imageSmoothingEnabled = !1, V.drawImage(
      x,
      k.x * U,
      k.y * P,
      k.width * U,
      k.height * P,
      0,
      0,
      k.width * U,
      k.height * P
    )), A.toDataURL("image/png", 1);
  }
  async function b() {
    var x, k;
    try {
      const A = await qle(c, ((x = f == null ? void 0 : f.file) == null ? void 0 : x.name) || "image.png"), U = (k = t.extensionManager.extensions.find(
        (V) => V.name === "image"
      )) == null ? void 0 : k.options;
      let P = "";
      U.upload ? P = await U.upload(A) : P = URL.createObjectURL(A), t.chain().focus().setImageInline({ src: P, inline: e }).run(), o(!1), p({
        src: "",
        file: null
      }), n();
    } catch (A) {
      console.log("Error cropping image", A);
    }
  }
  function y(x) {
    var k;
    x.preventDefault(), (k = d.current) == null || k.click();
  }
  const w = async (x) => {
    var P;
    const k = (P = x == null ? void 0 : x.target) == null ? void 0 : P.files;
    if (!t || t.isDestroyed || k.length === 0)
      return;
    const A = k[0], U = await Vle(A);
    o(!0), p({
      src: U.src,
      file: A
    });
  };
  return /* @__PURE__ */ Fe(pn, { children: [
    /* @__PURE__ */ z(fn, { className: "richtext-w-full richtext-mt-1", size: "sm", onClick: y, children: r("editor.image.dialog.tab.uploadCrop") }),
    /* @__PURE__ */ Fe(v1, { open: i, children: [
      /* @__PURE__ */ z(w1, {}),
      /* @__PURE__ */ Fe(Pm, { children: [
        /* @__PURE__ */ z(Wm, { children: r("editor.image.dialog.tab.uploadCrop") }),
        /* @__PURE__ */ z("div", { children: f.src && /* @__PURE__ */ z(
          LW,
          {
            crop: s,
            onChange: (x) => l(x),
            onComplete: (x) => m(x),
            className: "richtext-w-full",
            children: /* @__PURE__ */ z(
              "img",
              {
                ref: a,
                alt: "Crop me",
                src: f.src
              }
            )
          }
        ) }),
        /* @__PURE__ */ Fe(MD, { children: [
          /* @__PURE__ */ Fe(
            fn,
            {
              onClick: () => {
                o(!1), p({
                  src: "",
                  file: null
                });
              },
              children: [
                r("editor.imageUpload.cancel"),
                /* @__PURE__ */ z($t, { name: "Trash2", className: "richtext-ml-[4px]" })
              ]
            }
          ),
          /* @__PURE__ */ Fe(fn, { className: "richtext-w-fit", onClick: b, children: [
            r("editor.imageUpload.crop"),
            /* @__PURE__ */ z($t, { name: "Crop", className: "richtext-ml-[4px]" })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ z(
      "input",
      {
        type: "file",
        accept: "image/*",
        ref: d,
        multiple: !0,
        style: {
          display: "none"
        },
        onChange: w
      }
    )
  ] });
}
function Kle(t) {
  const { t: e } = Wt(), n = Nle(), [r, i] = nt(""), o = Wr(null), [a, s] = nt(!1), l = Yt(() => {
    var p;
    return (p = t.editor.extensionManager.extensions.find(
      (m) => m.name === nce.name
    )) == null ? void 0 : p.options;
  }, [t.editor]);
  async function c(f) {
    var b;
    const p = (b = f == null ? void 0 : f.target) == null ? void 0 : b.files;
    if (!t.editor || t.editor.isDestroyed || p.length === 0)
      return;
    const m = p[0];
    let g = "";
    l.upload ? g = await l.upload(m) : g = URL.createObjectURL(m), t.editor.chain().focus().setImageInline({ src: g, inline: a }).run(), Gd.setOpen(!1), s(!1);
  }
  function u(f) {
    f.preventDefault(), f.stopPropagation(), t.editor.chain().focus().setImageInline({ src: r, inline: a }).run(), Gd.setOpen(!1), s(!1);
  }
  function d(f) {
    var p;
    f.preventDefault(), (p = o.current) == null || p.click();
  }
  return /* @__PURE__ */ Fe(v1, { open: n, onOpenChange: Gd.setOpen, children: [
    /* @__PURE__ */ z(w1, { asChild: !0, children: /* @__PURE__ */ z(
      Je,
      {
        icon: t.icon,
        action: () => Gd.setOpen(!0),
        tooltip: t.tooltip
      }
    ) }),
    /* @__PURE__ */ Fe(Pm, { children: [
      /* @__PURE__ */ z(Wm, { children: e("editor.image.dialog.title") }),
      /* @__PURE__ */ Fe(
        LD,
        {
          defaultValue: l.resourceImage === "both" || l.resourceImage === "upload" ? "upload" : "link",
          activationMode: "manual",
          children: [
            /* @__PURE__ */ Fe(S1, { className: "richtext-grid richtext-w-full richtext-grid-cols-2", children: [
              l.resourceImage === "both" || l.resourceImage === "upload" ? /* @__PURE__ */ z(Tf, { value: "upload", children: e("editor.image.dialog.tab.upload") }) : /* @__PURE__ */ z(pn, {}),
              l.resourceImage === "both" || l.resourceImage === "link" ? /* @__PURE__ */ z(Tf, { value: "link", children: e("editor.image.dialog.tab.url") }) : /* @__PURE__ */ z(pn, {})
            ] }),
            /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-items-center richtext-gap-[4px] richtext-my-[10px]", children: [
              /* @__PURE__ */ z(
                h4,
                {
                  checked: a,
                  onCheckedChange: (f) => {
                    s(f);
                  }
                }
              ),
              /* @__PURE__ */ z(eo, { children: e("editor.link.dialog.inline") })
            ] }),
            /* @__PURE__ */ Fe(Df, { value: "upload", children: [
              /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-items-center richtext-gap-[10px]", children: [
                /* @__PURE__ */ z(fn, { className: "richtext-w-full richtext-mt-1", size: "sm", onClick: d, children: e("editor.image.dialog.tab.upload") }),
                /* @__PURE__ */ z(
                  Gle,
                  {
                    editor: t.editor,
                    imageInline: a,
                    onClose: () => Gd.setOpen(!1)
                  }
                )
              ] }),
              /* @__PURE__ */ z(
                "input",
                {
                  type: "file",
                  accept: "image/*",
                  ref: o,
                  multiple: !0,
                  style: {
                    display: "none"
                  },
                  onChange: c
                }
              )
            ] }),
            /* @__PURE__ */ z(Df, { value: "link", children: /* @__PURE__ */ z("form", { onSubmit: u, children: /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-items-center richtext-gap-2", children: [
              /* @__PURE__ */ z(
                Pr,
                {
                  type: "url",
                  autoFocus: !0,
                  value: r,
                  onChange: (f) => i(f.target.value),
                  required: !0,
                  placeholder: e("editor.image.dialog.placeholder")
                }
              ),
              /* @__PURE__ */ z(fn, { type: "submit", children: e("editor.image.dialog.button.apply") })
            ] }) }) })
          ]
        }
      )
    ] })
  ] });
}
const cf = new Nt("upload-image");
function Xle() {
  return new Pt({
    key: cf,
    state: {
      init() {
        return Bt.empty;
      },
      apply(t, e) {
        e = e.map(t.mapping, t.doc);
        const n = t.getMeta(cf);
        if (n != null && n.add)
          for (const { id: r, pos: i, src: o } of n.add) {
            const a = Yle(o), s = vn.widget(i, a, { id: r });
            e = e.add(t.doc, [s]);
          }
        else if (n != null && n.remove)
          for (const r of n.remove)
            e = e.remove(e.find(void 0, void 0, (i) => i.id === r));
        return e;
      }
    },
    props: {
      decorations(t) {
        return this.getState(t);
      }
    }
  });
}
function Yle(t) {
  const e = document.createElement("div"), n = document.createElement("img");
  return n.setAttribute("class", "opacity-50"), n.src = t, n.addEventListener("load", () => {
    e.setAttribute("class", "img-placeholder");
  }), e.append(n), e;
}
function Jle(t, e) {
  var i;
  const r = cf.getState(t).find(void 0, void 0, (o) => o.id === e);
  return r.length > 0 ? (i = r[0]) == null ? void 0 : i.from : null;
}
function Zle({ validateFn: t, onUpload: e, postUpload: n }) {
  return (r, i, o) => {
    for (const a of r) {
      if (t && !t(a))
        continue;
      const s = Date.now().toString(), l = i.state.tr;
      l.selection.empty || l.deleteSelection();
      const c = URL.createObjectURL(a);
      l.setMeta(cf, {
        add: [{ id: s, pos: o, src: c }]
      }), i.dispatch(l), e(a).then(
        async (u) => {
          var y;
          n && typeof u == "string" && (u = await n(u));
          const { schema: d } = i.state;
          let f = Jle(i.state, s);
          if (f === null)
            return;
          const p = typeof u == "object" ? c : u, m = (y = d.nodes.image) == null ? void 0 : y.create({ src: p });
          if (!m)
            return;
          const { doc: g } = i.state;
          f > g.content.size && (f = g.content.size - 1);
          const b = i.state.tr.replaceWith(f, f, m).setMeta(cf, { remove: [s] });
          i.dispatch(b);
        },
        () => {
          const u = i.state.tr.delete(o, o).setMeta(cf, { remove: [s] });
          i.dispatch(u);
        }
      );
    }
  };
}
function Qle(t, e, n) {
  var i;
  const r = [...((i = e.clipboardData) == null ? void 0 : i.files) || []];
  if (r.length > 0) {
    e.preventDefault();
    const o = t.state.selection.from;
    return n(r, t, o + 1), !0;
  }
  return !1;
}
function ece(t, e, n, r) {
  var o;
  const i = [...((o = e.dataTransfer) == null ? void 0 : o.files) || []];
  if (!n && i.length > 0) {
    e.preventDefault();
    const a = t.posAtCoords({
      left: e.clientX,
      top: e.clientY
    });
    if (a)
      return r(i, t, a.pos + 1), !0;
  }
  return !1;
}
const tce = {
  acceptMimes: ["image/jpeg", "image/gif", "image/png", "image/jpg"],
  maxSize: 1024 * 1024 * 5,
  // 5MB
  resourceImage: "both"
}, nce = mM.extend({
  group: "inline",
  inline: !0,
  defining: !0,
  draggable: !0,
  selectable: !0,
  addOptions() {
    var t;
    return {
      ...tce,
      ...(t = this.parent) == null ? void 0 : t.call(this),
      upload: () => Promise.reject("Image Upload Function"),
      button: ({
        editor: e,
        extension: n,
        t: r
      }) => {
        var i, o;
        return {
          component: Kle,
          componentProps: {
            action: () => {
            },
            upload: n.options.upload,
            /* If setImage is not available(when Image Component is not imported), the button is disabled */
            disabled: !((o = (i = e.can()).setImage) != null && o.call(i, {})),
            icon: "ImageUp",
            tooltip: r("editor.image.tooltip"),
            editor: e
          }
        };
      }
    };
  },
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      flipX: {
        default: !1
      },
      flipY: {
        default: !1
      },
      width: {
        default: null,
        parseHTML: (e) => {
          const n = e.style.width || e.getAttribute("width") || null;
          return n ? Number.parseInt(n, 10) : null;
        },
        renderHTML: (e) => ({
          width: e.width
        })
      },
      align: {
        default: "center",
        parseHTML: (e) => e.getAttribute("align"),
        renderHTML: (e) => ({
          align: e.align
        })
      },
      inline: {
        default: !1,
        parseHTML: (e) => !!e.getAttribute("inline"),
        renderHTML: (e) => ({
          inline: e.inline
        })
      }
    };
  },
  addNodeView() {
    return Vf(zle);
  },
  addCommands() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      setImageInline: (e) => ({ commands: n }) => n.insertContent({
        type: this.name,
        attrs: e
      }),
      updateImage: (e) => ({ commands: n }) => n.updateAttributes(this.name, e),
      setAlignImage: (e) => ({ commands: n }) => n.updateAttributes(this.name, { align: e })
    };
  },
  renderHTML({ HTMLAttributes: t }) {
    const { flipX: e, flipY: n, align: r, inline: i } = t, o = e || n ? `transform: rotateX(${e ? "180" : "0"}deg) rotateY(${n ? "180" : "0"}deg);` : "", a = r ? `text-align: ${r};` : "";
    return [
      i ? "span" : "div",
      {
        style: a,
        class: "image"
      },
      [
        "img",
        bt(
          {
            height: "auto",
            style: o
          },
          this.options.HTMLAttributes,
          t
        )
      ]
    ];
  },
  parseHTML() {
    return [
      {
        tag: "span.image img",
        getAttrs: (t) => {
          var o;
          const e = t == null ? void 0 : t.parentElement, n = t == null ? void 0 : t.getAttribute("width"), r = (t == null ? void 0 : t.getAttribute("flipx")) || !1, i = (t == null ? void 0 : t.getAttribute("flipy")) || !1;
          return {
            src: t == null ? void 0 : t.getAttribute("src"),
            alt: t == null ? void 0 : t.getAttribute("alt"),
            caption: t == null ? void 0 : t.getAttribute("caption"),
            width: n ? Number.parseInt(n, 10) : null,
            align: (t == null ? void 0 : t.getAttribute("align")) || ((o = e == null ? void 0 : e.style) == null ? void 0 : o.textAlign) || null,
            inline: (t == null ? void 0 : t.getAttribute("inline")) || !1,
            flipX: r === "true",
            flipY: i === "true"
          };
        }
      },
      {
        tag: "div[class=image]",
        getAttrs: (t) => {
          const e = t.querySelector("img"), n = e == null ? void 0 : e.getAttribute("width"), r = (e == null ? void 0 : e.getAttribute("flipx")) || !1, i = (e == null ? void 0 : e.getAttribute("flipy")) || !1;
          return {
            src: e == null ? void 0 : e.getAttribute("src"),
            alt: e == null ? void 0 : e.getAttribute("alt"),
            caption: e == null ? void 0 : e.getAttribute("caption"),
            width: n ? Number.parseInt(n, 10) : null,
            align: (e == null ? void 0 : e.getAttribute("align")) || t.style.textAlign || null,
            inline: (e == null ? void 0 : e.getAttribute("inline")) || !1,
            flipX: r === "true",
            flipY: i === "true"
          };
        }
      }
    ];
  },
  addProseMirrorPlugins() {
    const e = Zle({
      validateFn: (n) => !(!this.options.acceptMimes.includes(n.type) || n.size > this.options.maxSize),
      onUpload: this.options.upload
      // postUpload: this.options.postUpload,
    });
    return [
      new Pt({
        props: {
          handlePaste: (n, r) => !r.clipboardData || [...r.clipboardData.files || []].some((o) => o.type === "text/html") ? !1 : Qle(n, r, e),
          handleDrop: (n, r, i, o) => (!(r instanceof DragEvent) || !r.dataTransfer || ece(n, r, o, e), !1)
        }
      }),
      Xle()
    ];
  }
});
function rce(t) {
  return /\.(?:mp4|webm|ogg|mov)$/i.test(t);
}
function ice(t) {
  const { t: e } = Wt(), [n, r] = nt(""), i = Wr(null), o = Mle(), [a, s] = nt(""), l = Yt(() => {
    var p;
    return (p = t.editor.extensionManager.extensions.find(
      (m) => m.name === ace.name
    )) == null ? void 0 : p.options;
  }, [t.editor]);
  async function c(f) {
    var b;
    const p = (b = f == null ? void 0 : f.target) == null ? void 0 : b.files;
    if (!t.editor || t.editor.isDestroyed || p.length === 0)
      return;
    const m = p[0];
    let g = "";
    l.upload ? g = await l.upload(m) : g = URL.createObjectURL(m), t.editor.chain().setVideo({
      src: g,
      width: "100%"
    }).focus().run(), Sp.setOpen(!1);
  }
  function u(f) {
    f.preventDefault(), f.stopPropagation(), n && (t.editor.chain().setVideo({
      src: n,
      width: "100%"
    }).focus().run(), Sp.setOpen(!1));
  }
  function d(f) {
    var p;
    f.preventDefault(), (p = i.current) == null || p.click();
  }
  return /* @__PURE__ */ Fe(v1, { open: o, onOpenChange: Sp.setOpen, children: [
    /* @__PURE__ */ z(w1, { asChild: !0, children: /* @__PURE__ */ z(
      Je,
      {
        icon: t.icon,
        action: () => Sp.setOpen(!0),
        tooltip: t.tooltip
      }
    ) }),
    /* @__PURE__ */ Fe(Pm, { children: [
      /* @__PURE__ */ z(Wm, { children: e("editor.video.dialog.title") }),
      /* @__PURE__ */ Fe(
        LD,
        {
          defaultValue: (l == null ? void 0 : l.resourceVideo) === "both" || (l == null ? void 0 : l.resourceVideo) === "upload" ? "upload" : "link",
          activationMode: "manual",
          children: [
            /* @__PURE__ */ Fe(S1, { className: "richtext-grid richtext-w-full richtext-grid-cols-2", children: [
              ((l == null ? void 0 : l.resourceVideo) === "both" || (l == null ? void 0 : l.resourceVideo) === "upload") && /* @__PURE__ */ z(Tf, { value: "upload", children: e("editor.video.dialog.tab.upload") }),
              ((l == null ? void 0 : l.resourceVideo) === "both" || (l == null ? void 0 : l.resourceVideo) === "link") && /* @__PURE__ */ z(Tf, { value: "link", children: e("editor.video.dialog.link") })
            ] }),
            /* @__PURE__ */ Fe(Df, { value: "upload", children: [
              /* @__PURE__ */ z("div", { className: "richtext-flex richtext-items-center richtext-gap-[10px]", children: /* @__PURE__ */ z(fn, { className: "richtext-w-full richtext-mt-1", size: "sm", onClick: d, children: e("editor.video.dialog.tab.upload") }) }),
              /* @__PURE__ */ z(
                "input",
                {
                  type: "file",
                  accept: "video/*",
                  ref: i,
                  multiple: !0,
                  style: {
                    display: "none"
                  },
                  onChange: c
                }
              )
            ] }),
            /* @__PURE__ */ Fe(Df, { value: "link", children: [
              /* @__PURE__ */ z("form", { onSubmit: u, children: /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-items-center richtext-gap-2", children: [
                /* @__PURE__ */ z(
                  Pr,
                  {
                    type: "url",
                    autoFocus: !0,
                    value: n,
                    onChange: (f) => {
                      const p = f.target.value;
                      if (!rce(p)) {
                        s("Invalid video URL"), r("");
                        return;
                      }
                      s(""), r(p);
                    },
                    required: !0,
                    placeholder: e("editor.video.dialog.placeholder")
                  }
                ),
                /* @__PURE__ */ z(fn, { type: "submit", children: e("editor.video.dialog.button.apply") })
              ] }) }),
              a && /* @__PURE__ */ z("div", { className: "richtext-text-red-500 richtext-my-[5px]", children: a })
            ] })
          ]
        }
      )
    ] })
  ] });
}
function oce(t) {
  return t = t.replace("https://youtu.be/", "https://www.youtube.com/watch?v=").replace("watch?v=", "embed/"), t = t.replace("https://vimeo.com/", "https://player.vimeo.com/video/"), /^https?:\/\/www.bilibili.com\/video\/.*/i.test(t) && (t = t.replace(/\?.*$/, "").replace("https://www.bilibili.com/video/", "https://player.bilibili.com/player.html?bvid=")), t.includes("drive.google.com") && (t = t.replace("/view", "/preview")), t;
}
const ace = rn.create({
  name: "video",
  group: "block",
  atom: !0,
  draggable: !0,
  addOptions() {
    return {
      divider: !1,
      spacer: !1,
      allowFullscreen: !0,
      upload: void 0,
      frameborder: !1,
      resourceVideo: "both",
      width: Hb["size-medium"],
      HTMLAttributes: {
        class: "iframe-wrapper",
        style: "display: flex;justify-content: center;"
      },
      button: ({ editor: t, t: e }) => {
        var n, r;
        return {
          component: ice,
          componentProps: {
            action: () => {
            },
            isActive: () => t.isActive("video") || !1,
            /* If setVideo is not available(when Video Component is not imported), the button is disabled */
            disabled: !((r = (n = t.can()).setVideo) != null && r.call(n, {})),
            icon: "Video",
            tooltip: e("editor.video.tooltip"),
            editor: t
          }
        };
      }
    };
  },
  addAttributes() {
    return {
      src: {
        default: null,
        renderHTML: ({ src: t }) => ({
          src: t ? oce(t) : null
        })
      },
      width: {
        default: this.options.width,
        renderHTML: ({ width: t }) => ({
          width: Lre(t)
        })
      },
      frameborder: {
        default: this.options.frameborder ? 1 : 0,
        parseHTML: () => this.options.frameborder ? 1 : 0
      },
      allowfullscreen: {
        default: this.options.allowFullscreen,
        parseHTML: () => this.options.allowFullscreen
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "div[data-video] iframe"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { width: e = "100%" } = t ?? {}, n = {
      ...t,
      width: "100%",
      height: "100%"
    }, r = `position: relative;overflow: hidden;display: flex;flex: 1;max-width: ${e};`, i = `flex: 1;padding-bottom: ${9 / 16 * 100}%;`, s = ["div", { style: r }, ["div", { style: i }], ["iframe", n]];
    return ["div", {
      ...this.options.HTMLAttributes,
      "data-video": ""
    }, s];
  },
  addCommands() {
    return {
      setVideo: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      }),
      updateVideo: (t) => ({ commands: e }) => e.updateAttributes(this.name, t)
    };
  }
}), sce = rn.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [
      { tag: "tr" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["tr", bt(this.options.HTMLAttributes, t), 0];
  }
});
var _T, ST;
if (typeof WeakMap < "u") {
  let t = /* @__PURE__ */ new WeakMap();
  _T = (e) => t.get(e), ST = (e, n) => (t.set(e, n), n);
} else {
  const t = [];
  let n = 0;
  _T = (r) => {
    for (let i = 0; i < t.length; i += 2)
      if (t[i] == r)
        return t[i + 1];
  }, ST = (r, i) => (n == 10 && (n = 0), t[n++] = r, t[n++] = i);
}
var Dn = class {
  constructor(t, e, n, r) {
    this.width = t, this.height = e, this.map = n, this.problems = r;
  }
  // Find the dimensions of the cell at the given position.
  findCell(t) {
    for (let e = 0; e < this.map.length; e++) {
      const n = this.map[e];
      if (n != t)
        continue;
      const r = e % this.width, i = e / this.width | 0;
      let o = r + 1, a = i + 1;
      for (let s = 1; o < this.width && this.map[e + s] == n; s++)
        o++;
      for (let s = 1; a < this.height && this.map[e + this.width * s] == n; s++)
        a++;
      return { left: r, top: i, right: o, bottom: a };
    }
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(t) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == t)
        return e % this.width;
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(t, e, n) {
    const { left: r, right: i, top: o, bottom: a } = this.findCell(t);
    return e == "horiz" ? (n < 0 ? r == 0 : i == this.width) ? null : this.map[o * this.width + (n < 0 ? r - 1 : i)] : (n < 0 ? o == 0 : a == this.height) ? null : this.map[r + this.width * (n < 0 ? o - 1 : a)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(t, e) {
    const {
      left: n,
      right: r,
      top: i,
      bottom: o
    } = this.findCell(t), {
      left: a,
      right: s,
      top: l,
      bottom: c
    } = this.findCell(e);
    return {
      left: Math.min(n, a),
      top: Math.min(i, l),
      right: Math.max(r, s),
      bottom: Math.max(o, c)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(t) {
    const e = [], n = {};
    for (let r = t.top; r < t.bottom; r++)
      for (let i = t.left; i < t.right; i++) {
        const o = r * this.width + i, a = this.map[o];
        n[a] || (n[a] = !0, !(i == t.left && i && this.map[o - 1] == a || r == t.top && r && this.map[o - this.width] == a) && e.push(a));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(t, e, n) {
    for (let r = 0, i = 0; ; r++) {
      const o = i + n.child(r).nodeSize;
      if (r == t) {
        let a = e + t * this.width;
        const s = (t + 1) * this.width;
        for (; a < s && this.map[a] < i; )
          a++;
        return a == s ? o - 1 : this.map[a];
      }
      i = o;
    }
  }
  // Find the table map for the given table node.
  static get(t) {
    return _T(t) || ST(t, lce(t));
  }
};
function lce(t) {
  if (t.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + t.type.name);
  const e = cce(t), n = t.childCount, r = [];
  let i = 0, o = null;
  const a = [];
  for (let c = 0, u = e * n; c < u; c++)
    r[c] = 0;
  for (let c = 0, u = 0; c < n; c++) {
    const d = t.child(c);
    u++;
    for (let m = 0; ; m++) {
      for (; i < r.length && r[i] != 0; )
        i++;
      if (m == d.childCount)
        break;
      const g = d.child(m), { colspan: b, rowspan: y, colwidth: w } = g.attrs;
      for (let x = 0; x < y; x++) {
        if (x + c >= n) {
          (o || (o = [])).push({
            type: "overlong_rowspan",
            pos: u,
            n: y - x
          });
          break;
        }
        const k = i + x * e;
        for (let A = 0; A < b; A++) {
          r[k + A] == 0 ? r[k + A] = u : (o || (o = [])).push({
            type: "collision",
            row: c,
            pos: u,
            n: b - A
          });
          const U = w && w[A];
          if (U) {
            const P = (k + A) % e * 2, V = a[P];
            V == null || V != U && a[P + 1] == 1 ? (a[P] = U, a[P + 1] = 1) : V == U && a[P + 1]++;
          }
        }
      }
      i += b, u += g.nodeSize;
    }
    const f = (c + 1) * e;
    let p = 0;
    for (; i < f; )
      r[i++] == 0 && p++;
    p && (o || (o = [])).push({ type: "missing", row: c, n: p }), u++;
  }
  const s = new Dn(e, n, r, o);
  let l = !1;
  for (let c = 0; !l && c < a.length; c += 2)
    a[c] != null && a[c + 1] < n && (l = !0);
  return l && uce(s, a, t), s;
}
function cce(t) {
  let e = -1, n = !1;
  for (let r = 0; r < t.childCount; r++) {
    const i = t.child(r);
    let o = 0;
    if (n)
      for (let a = 0; a < r; a++) {
        const s = t.child(a);
        for (let l = 0; l < s.childCount; l++) {
          const c = s.child(l);
          a + c.attrs.rowspan > r && (o += c.attrs.colspan);
        }
      }
    for (let a = 0; a < i.childCount; a++) {
      const s = i.child(a);
      o += s.attrs.colspan, s.attrs.rowspan > 1 && (n = !0);
    }
    e == -1 ? e = o : e != o && (e = Math.max(e, o));
  }
  return e;
}
function uce(t, e, n) {
  t.problems || (t.problems = []);
  const r = {};
  for (let i = 0; i < t.map.length; i++) {
    const o = t.map[i];
    if (r[o])
      continue;
    r[o] = !0;
    const a = n.nodeAt(o);
    if (!a)
      throw new RangeError(`No cell with offset ${o} found`);
    let s = null;
    const l = a.attrs;
    for (let c = 0; c < l.colspan; c++) {
      const u = (i + c) % t.width, d = e[u * 2];
      d != null && (!l.colwidth || l.colwidth[c] != d) && ((s || (s = dce(l)))[c] = d);
    }
    s && t.problems.unshift({
      type: "colwidth mismatch",
      pos: o,
      colwidth: s
    });
  }
}
function dce(t) {
  if (t.colwidth)
    return t.colwidth.slice();
  const e = [];
  for (let n = 0; n < t.colspan; n++)
    e.push(0);
  return e;
}
function Sr(t) {
  let e = t.cached.tableNodeTypes;
  if (!e) {
    e = t.cached.tableNodeTypes = {};
    for (const n in t.nodes) {
      const r = t.nodes[n], i = r.spec.tableRole;
      i && (e[i] = r);
    }
  }
  return e;
}
var fl = new Nt("selectingCells");
function eh(t) {
  for (let e = t.depth - 1; e > 0; e--)
    if (t.node(e).type.spec.tableRole == "row")
      return t.node(0).resolve(t.before(e + 1));
  return null;
}
function fce(t) {
  for (let e = t.depth; e > 0; e--) {
    const n = t.node(e).type.spec.tableRole;
    if (n === "cell" || n === "header_cell")
      return t.node(e);
  }
  return null;
}
function ko(t) {
  const e = t.selection.$head;
  for (let n = e.depth; n > 0; n--)
    if (e.node(n).type.spec.tableRole == "row")
      return !0;
  return !1;
}
function N1(t) {
  const e = t.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const n = eh(e.$head) || hce(e.$head);
  if (n)
    return n;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function hce(t) {
  for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return t.doc.resolve(n);
  }
  for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return t.doc.resolve(n - e.nodeSize);
  }
}
function TT(t) {
  return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function pce(t) {
  return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
}
function xE(t, e) {
  return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function yM(t, e, n) {
  const r = t.node(-1), i = Dn.get(r), o = t.start(-1), a = i.nextCell(t.pos - o, e, n);
  return a == null ? null : t.node(0).resolve(o + a);
}
function tu(t, e, n = 1) {
  const r = { ...t, colspan: t.colspan - n };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, n), r.colwidth.some((i) => i > 0) || (r.colwidth = null)), r;
}
function bM(t, e, n = 1) {
  const r = { ...t, colspan: t.colspan + n };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let i = 0; i < n; i++)
      r.colwidth.splice(e, 0, 0);
  }
  return r;
}
function mce(t, e, n) {
  const r = Sr(e.type.schema).header_cell;
  for (let i = 0; i < t.height; i++)
    if (e.nodeAt(t.map[n + i * t.width]).type != r)
      return !1;
  return !0;
}
var nn = class Xa extends dt {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, n = e) {
    const r = e.node(-1), i = Dn.get(r), o = e.start(-1), a = i.rectBetween(
      e.pos - o,
      n.pos - o
    ), s = e.node(0), l = i.cellsInRect(a).filter((u) => u != n.pos - o);
    l.unshift(n.pos - o);
    const c = l.map((u) => {
      const d = r.nodeAt(u);
      if (!d)
        throw RangeError(`No cell with offset ${u} found`);
      const f = o + u + 1;
      return new eD(
        s.resolve(f),
        s.resolve(f + d.content.size)
      );
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = n;
  }
  map(e, n) {
    const r = e.resolve(n.map(this.$anchorCell.pos)), i = e.resolve(n.map(this.$headCell.pos));
    if (TT(r) && TT(i) && xE(r, i)) {
      const o = this.$anchorCell.node(-1) != r.node(-1);
      return o && this.isRowSelection() ? Xa.rowSelection(r, i) : o && this.isColSelection() ? Xa.colSelection(r, i) : new Xa(r, i);
    }
    return ot.between(r, i);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), n = Dn.get(e), r = this.$anchorCell.start(-1), i = n.rectBetween(
      this.$anchorCell.pos - r,
      this.$headCell.pos - r
    ), o = {}, a = [];
    for (let l = i.top; l < i.bottom; l++) {
      const c = [];
      for (let u = l * n.width + i.left, d = i.left; d < i.right; d++, u++) {
        const f = n.map[u];
        if (o[f])
          continue;
        o[f] = !0;
        const p = n.findCell(f);
        let m = e.nodeAt(f);
        if (!m)
          throw RangeError(`No cell with offset ${f} found`);
        const g = i.left - p.left, b = p.right - i.right;
        if (g > 0 || b > 0) {
          let y = m.attrs;
          if (g > 0 && (y = tu(y, 0, g)), b > 0 && (y = tu(
            y,
            y.colspan - b,
            b
          )), p.left < i.left) {
            if (m = m.type.createAndFill(y), !m)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(y)}`
              );
          } else
            m = m.type.create(y, m.content);
        }
        if (p.top < i.top || p.bottom > i.bottom) {
          const y = {
            ...m.attrs,
            rowspan: Math.min(p.bottom, i.bottom) - Math.max(p.top, i.top)
          };
          p.top < i.top ? m = m.type.createAndFill(y) : m = m.type.create(y, m.content);
        }
        c.push(m);
      }
      a.push(e.child(l).copy(ze.from(c)));
    }
    const s = this.isColSelection() && this.isRowSelection() ? e : a;
    return new Xe(ze.from(s), 1, 1);
  }
  replace(e, n = Xe.empty) {
    const r = e.steps.length, i = this.ranges;
    for (let a = 0; a < i.length; a++) {
      const { $from: s, $to: l } = i[a], c = e.mapping.slice(r);
      e.replace(
        c.map(s.pos),
        c.map(l.pos),
        a ? Xe.empty : n
      );
    }
    const o = dt.findFrom(
      e.doc.resolve(e.mapping.slice(r).map(this.to)),
      -1
    );
    o && e.setSelection(o);
  }
  replaceWith(e, n) {
    this.replace(e, new Xe(ze.from(n), 0, 0));
  }
  forEachCell(e) {
    const n = this.$anchorCell.node(-1), r = Dn.get(n), i = this.$anchorCell.start(-1), o = r.cellsInRect(
      r.rectBetween(
        this.$anchorCell.pos - i,
        this.$headCell.pos - i
      )
    );
    for (let a = 0; a < o.length; a++)
      e(n.nodeAt(o[a]), i + o[a]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), n = this.$headCell.index(-1);
    if (Math.min(e, n) > 0)
      return !1;
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, i = n + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, i) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, n = e) {
    const r = e.node(-1), i = Dn.get(r), o = e.start(-1), a = i.findCell(e.pos - o), s = i.findCell(n.pos - o), l = e.node(0);
    return a.top <= s.top ? (a.top > 0 && (e = l.resolve(o + i.map[a.left])), s.bottom < i.height && (n = l.resolve(
      o + i.map[i.width * (i.height - 1) + s.right - 1]
    ))) : (s.top > 0 && (n = l.resolve(o + i.map[s.left])), a.bottom < i.height && (e = l.resolve(
      o + i.map[i.width * (i.height - 1) + a.right - 1]
    ))), new Xa(e, n);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), n = Dn.get(e), r = this.$anchorCell.start(-1), i = n.colCount(this.$anchorCell.pos - r), o = n.colCount(this.$headCell.pos - r);
    if (Math.min(i, o) > 0)
      return !1;
    const a = i + this.$anchorCell.nodeAfter.attrs.colspan, s = o + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(a, s) == n.width;
  }
  eq(e) {
    return e instanceof Xa && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, n = e) {
    const r = e.node(-1), i = Dn.get(r), o = e.start(-1), a = i.findCell(e.pos - o), s = i.findCell(n.pos - o), l = e.node(0);
    return a.left <= s.left ? (a.left > 0 && (e = l.resolve(
      o + i.map[a.top * i.width]
    )), s.right < i.width && (n = l.resolve(
      o + i.map[i.width * (s.top + 1) - 1]
    ))) : (s.left > 0 && (n = l.resolve(o + i.map[s.top * i.width])), a.right < i.width && (e = l.resolve(
      o + i.map[i.width * (a.top + 1) - 1]
    ))), new Xa(e, n);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, n) {
    return new Xa(e.resolve(n.anchor), e.resolve(n.head));
  }
  static create(e, n, r = n) {
    return new Xa(e.resolve(n), e.resolve(r));
  }
  getBookmark() {
    return new gce(this.$anchorCell.pos, this.$headCell.pos);
  }
};
nn.prototype.visible = !1;
dt.jsonID("cell", nn);
var gce = class vM {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new vM(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const n = e.resolve(this.anchor), r = e.resolve(this.head);
    return n.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && r.index() < r.parent.childCount && xE(n, r) ? new nn(n, r) : dt.near(r, 1);
  }
};
function yce(t) {
  if (!(t.selection instanceof nn))
    return null;
  const e = [];
  return t.selection.forEachCell((n, r) => {
    e.push(
      vn.node(r, r + n.nodeSize, { class: "selectedCell" })
    );
  }), Bt.create(t.doc, e);
}
function bce({ $from: t, $to: e }) {
  if (t.pos == e.pos || t.pos < e.pos - 6)
    return !1;
  let n = t.pos, r = e.pos, i = t.depth;
  for (; i >= 0 && !(t.after(i + 1) < t.end(i)); i--, n++)
    ;
  for (let o = e.depth; o >= 0 && !(e.before(o + 1) > e.start(o)); o--, r--)
    ;
  return n == r && /row|table/.test(t.node(i).type.spec.tableRole);
}
function vce({ $from: t, $to: e }) {
  let n, r;
  for (let i = t.depth; i > 0; i--) {
    const o = t.node(i);
    if (o.type.spec.tableRole === "cell" || o.type.spec.tableRole === "header_cell") {
      n = o;
      break;
    }
  }
  for (let i = e.depth; i > 0; i--) {
    const o = e.node(i);
    if (o.type.spec.tableRole === "cell" || o.type.spec.tableRole === "header_cell") {
      r = o;
      break;
    }
  }
  return n !== r && e.parentOffset === 0;
}
function wce(t, e, n) {
  const r = (e || t).selection, i = (e || t).doc;
  let o, a;
  if (r instanceof st && (a = r.node.type.spec.tableRole)) {
    if (a == "cell" || a == "header_cell")
      o = nn.create(i, r.from);
    else if (a == "row") {
      const s = i.resolve(r.from + 1);
      o = nn.rowSelection(s, s);
    } else if (!n) {
      const s = Dn.get(r.node), l = r.from + 1, c = l + s.map[s.width * s.height - 1];
      o = nn.create(i, l + 1, c);
    }
  } else r instanceof ot && bce(r) ? o = ot.create(i, r.from) : r instanceof ot && vce(r) && (o = ot.create(i, r.$from.start(), r.$from.end()));
  return o && (e || (e = t.tr)).setSelection(o), e;
}
var xce = new Nt("fix-tables");
function wM(t, e, n, r) {
  const i = t.childCount, o = e.childCount;
  e:
    for (let a = 0, s = 0; a < o; a++) {
      const l = e.child(a);
      for (let c = s, u = Math.min(i, a + 3); c < u; c++)
        if (t.child(c) == l) {
          s = c + 1, n += l.nodeSize;
          continue e;
        }
      r(l, n), s < i && t.child(s).sameMarkup(l) ? wM(t.child(s), l, n + 1, r) : l.nodesBetween(0, l.content.size, r, n + 1), n += l.nodeSize;
    }
}
function xM(t, e) {
  let n;
  const r = (i, o) => {
    i.type.spec.tableRole == "table" && (n = _ce(t, i, o, n));
  };
  return e ? e.doc != t.doc && wM(e.doc, t.doc, 0, r) : t.doc.descendants(r), n;
}
function _ce(t, e, n, r) {
  const i = Dn.get(e);
  if (!i.problems)
    return r;
  r || (r = t.tr);
  const o = [];
  for (let l = 0; l < i.height; l++)
    o.push(0);
  for (let l = 0; l < i.problems.length; l++) {
    const c = i.problems[l];
    if (c.type == "collision") {
      const u = e.nodeAt(c.pos);
      if (!u)
        continue;
      const d = u.attrs;
      for (let f = 0; f < d.rowspan; f++)
        o[c.row + f] += c.n;
      r.setNodeMarkup(
        r.mapping.map(n + 1 + c.pos),
        null,
        tu(d, d.colspan - c.n, c.n)
      );
    } else if (c.type == "missing")
      o[c.row] += c.n;
    else if (c.type == "overlong_rowspan") {
      const u = e.nodeAt(c.pos);
      if (!u)
        continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
        ...u.attrs,
        rowspan: u.attrs.rowspan - c.n
      });
    } else if (c.type == "colwidth mismatch") {
      const u = e.nodeAt(c.pos);
      if (!u)
        continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
        ...u.attrs,
        colwidth: c.colwidth
      });
    }
  }
  let a, s;
  for (let l = 0; l < o.length; l++)
    o[l] && (a == null && (a = l), s = l);
  for (let l = 0, c = n + 1; l < i.height; l++) {
    const u = e.child(l), d = c + u.nodeSize, f = o[l];
    if (f > 0) {
      let p = "cell";
      u.firstChild && (p = u.firstChild.type.spec.tableRole);
      const m = [];
      for (let b = 0; b < f; b++) {
        const y = Sr(t.schema)[p].createAndFill();
        y && m.push(y);
      }
      const g = (l == 0 || a == l - 1) && s == l ? c + 1 : d - 1;
      r.insert(r.mapping.map(g), m);
    }
    c = d;
  }
  return r.setMeta(xce, { fixTables: !0 });
}
function va(t) {
  const e = t.selection, n = N1(t), r = n.node(-1), i = n.start(-1), o = Dn.get(r);
  return { ...e instanceof nn ? o.rectBetween(
    e.$anchorCell.pos - i,
    e.$headCell.pos - i
  ) : o.findCell(n.pos - i), tableStart: i, map: o, table: r };
}
function _M(t, { map: e, tableStart: n, table: r }, i) {
  let o = i > 0 ? -1 : 0;
  mce(e, r, i + o) && (o = i == 0 || i == e.width ? null : 0);
  for (let a = 0; a < e.height; a++) {
    const s = a * e.width + i;
    if (i > 0 && i < e.width && e.map[s - 1] == e.map[s]) {
      const l = e.map[s], c = r.nodeAt(l);
      t.setNodeMarkup(
        t.mapping.map(n + l),
        null,
        bM(c.attrs, i - e.colCount(l))
      ), a += c.attrs.rowspan - 1;
    } else {
      const l = o == null ? Sr(r.type.schema).cell : r.nodeAt(e.map[s + o]).type, c = e.positionAt(a, i, r);
      t.insert(t.mapping.map(n + c), l.createAndFill());
    }
  }
  return t;
}
function Sce(t, e) {
  if (!ko(t))
    return !1;
  if (e) {
    const n = va(t);
    e(_M(t.tr, n, n.left));
  }
  return !0;
}
function Tce(t, e) {
  if (!ko(t))
    return !1;
  if (e) {
    const n = va(t);
    e(_M(t.tr, n, n.right));
  }
  return !0;
}
function Dce(t, { map: e, table: n, tableStart: r }, i) {
  const o = t.mapping.maps.length;
  for (let a = 0; a < e.height; ) {
    const s = a * e.width + i, l = e.map[s], c = n.nodeAt(l), u = c.attrs;
    if (i > 0 && e.map[s - 1] == l || i < e.width - 1 && e.map[s + 1] == l)
      t.setNodeMarkup(
        t.mapping.slice(o).map(r + l),
        null,
        tu(u, i - e.colCount(l))
      );
    else {
      const d = t.mapping.slice(o).map(r + l);
      t.delete(d, d + c.nodeSize);
    }
    a += u.rowspan;
  }
}
function Ece(t, e) {
  if (!ko(t))
    return !1;
  if (e) {
    const n = va(t), r = t.tr;
    if (n.left == 0 && n.right == n.map.width)
      return !1;
    for (let i = n.right - 1; Dce(r, n, i), i != n.left; i--) {
      const o = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!o)
        throw RangeError("No table found");
      n.table = o, n.map = Dn.get(o);
    }
    e(r);
  }
  return !0;
}
function Cce(t, e, n) {
  var r;
  const i = Sr(e.type.schema).header_cell;
  for (let o = 0; o < t.width; o++)
    if (((r = e.nodeAt(t.map[o + n * t.width])) == null ? void 0 : r.type) != i)
      return !1;
  return !0;
}
function SM(t, { map: e, tableStart: n, table: r }, i) {
  var o;
  let a = n;
  for (let c = 0; c < i; c++)
    a += r.child(c).nodeSize;
  const s = [];
  let l = i > 0 ? -1 : 0;
  Cce(e, r, i + l) && (l = i == 0 || i == e.height ? null : 0);
  for (let c = 0, u = e.width * i; c < e.width; c++, u++)
    if (i > 0 && i < e.height && e.map[u] == e.map[u - e.width]) {
      const d = e.map[u], f = r.nodeAt(d).attrs;
      t.setNodeMarkup(n + d, null, {
        ...f,
        rowspan: f.rowspan + 1
      }), c += f.colspan - 1;
    } else {
      const d = l == null ? Sr(r.type.schema).cell : (o = r.nodeAt(e.map[u + l * e.width])) == null ? void 0 : o.type, f = d == null ? void 0 : d.createAndFill();
      f && s.push(f);
    }
  return t.insert(a, Sr(r.type.schema).row.create(null, s)), t;
}
function kce(t, e) {
  if (!ko(t))
    return !1;
  if (e) {
    const n = va(t);
    e(SM(t.tr, n, n.top));
  }
  return !0;
}
function Ace(t, e) {
  if (!ko(t))
    return !1;
  if (e) {
    const n = va(t);
    e(SM(t.tr, n, n.bottom));
  }
  return !0;
}
function Rce(t, { map: e, table: n, tableStart: r }, i) {
  let o = 0;
  for (let c = 0; c < i; c++)
    o += n.child(c).nodeSize;
  const a = o + n.child(i).nodeSize, s = t.mapping.maps.length;
  t.delete(o + r, a + r);
  const l = /* @__PURE__ */ new Set();
  for (let c = 0, u = i * e.width; c < e.width; c++, u++) {
    const d = e.map[u];
    if (!l.has(d)) {
      if (l.add(d), i > 0 && d == e.map[u - e.width]) {
        const f = n.nodeAt(d).attrs;
        t.setNodeMarkup(t.mapping.slice(s).map(d + r), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), c += f.colspan - 1;
      } else if (i < e.height && d == e.map[u + e.width]) {
        const f = n.nodeAt(d), p = f.attrs, m = f.type.create(
          { ...p, rowspan: f.attrs.rowspan - 1 },
          f.content
        ), g = e.positionAt(i + 1, c, n);
        t.insert(t.mapping.slice(s).map(r + g), m), c += p.colspan - 1;
      }
    }
  }
}
function Ice(t, e) {
  if (!ko(t))
    return !1;
  if (e) {
    const n = va(t), r = t.tr;
    if (n.top == 0 && n.bottom == n.map.height)
      return !1;
    for (let i = n.bottom - 1; Rce(r, n, i), i != n.top; i--) {
      const o = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!o)
        throw RangeError("No table found");
      n.table = o, n.map = Dn.get(n.table);
    }
    e(r);
  }
  return !0;
}
function bR(t) {
  const e = t.content;
  return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function Oce({ width: t, height: e, map: n }, r) {
  let i = r.top * t + r.left, o = i, a = (r.bottom - 1) * t + r.left, s = i + (r.right - r.left - 1);
  for (let l = r.top; l < r.bottom; l++) {
    if (r.left > 0 && n[o] == n[o - 1] || r.right < t && n[s] == n[s + 1])
      return !0;
    o += t, s += t;
  }
  for (let l = r.left; l < r.right; l++) {
    if (r.top > 0 && n[i] == n[i - t] || r.bottom < e && n[a] == n[a + t])
      return !0;
    i++, a++;
  }
  return !1;
}
function vR(t, e) {
  const n = t.selection;
  if (!(n instanceof nn) || n.$anchorCell.pos == n.$headCell.pos)
    return !1;
  const r = va(t), { map: i } = r;
  if (Oce(i, r))
    return !1;
  if (e) {
    const o = t.tr, a = {};
    let s = ze.empty, l, c;
    for (let u = r.top; u < r.bottom; u++)
      for (let d = r.left; d < r.right; d++) {
        const f = i.map[u * i.width + d], p = r.table.nodeAt(f);
        if (!(a[f] || !p))
          if (a[f] = !0, l == null)
            l = f, c = p;
          else {
            bR(p) || (s = s.append(p.content));
            const m = o.mapping.map(f + r.tableStart);
            o.delete(m, m + p.nodeSize);
          }
      }
    if (l == null || c == null)
      return !0;
    if (o.setNodeMarkup(l + r.tableStart, null, {
      ...bM(
        c.attrs,
        c.attrs.colspan,
        r.right - r.left - c.attrs.colspan
      ),
      rowspan: r.bottom - r.top
    }), s.size) {
      const u = l + 1 + c.content.size, d = bR(c) ? l + 1 : u;
      o.replaceWith(d + r.tableStart, u + r.tableStart, s);
    }
    o.setSelection(
      new nn(o.doc.resolve(l + r.tableStart))
    ), e(o);
  }
  return !0;
}
function wR(t, e) {
  const n = Sr(t.schema);
  return Fce(({ node: r }) => n[r.type.spec.tableRole])(t, e);
}
function Fce(t) {
  return (e, n) => {
    var r;
    const i = e.selection;
    let o, a;
    if (i instanceof nn) {
      if (i.$anchorCell.pos != i.$headCell.pos)
        return !1;
      o = i.$anchorCell.nodeAfter, a = i.$anchorCell.pos;
    } else {
      if (o = fce(i.$from), !o)
        return !1;
      a = (r = eh(i.$from)) == null ? void 0 : r.pos;
    }
    if (o == null || a == null || o.attrs.colspan == 1 && o.attrs.rowspan == 1)
      return !1;
    if (n) {
      let s = o.attrs;
      const l = [], c = s.colwidth;
      s.rowspan > 1 && (s = { ...s, rowspan: 1 }), s.colspan > 1 && (s = { ...s, colspan: 1 });
      const u = va(e), d = e.tr;
      for (let p = 0; p < u.right - u.left; p++)
        l.push(
          c ? {
            ...s,
            colwidth: c && c[p] ? [c[p]] : null
          } : s
        );
      let f;
      for (let p = u.top; p < u.bottom; p++) {
        let m = u.map.positionAt(p, u.left, u.table);
        p == u.top && (m += o.nodeSize);
        for (let g = u.left, b = 0; g < u.right; g++, b++)
          g == u.left && p == u.top || d.insert(
            f = d.mapping.map(m + u.tableStart, 1),
            t({ node: o, row: p, col: g }).createAndFill(l[b])
          );
      }
      d.setNodeMarkup(
        a,
        t({ node: o, row: u.top, col: u.left }),
        l[0]
      ), i instanceof nn && d.setSelection(
        new nn(
          d.doc.resolve(i.$anchorCell.pos),
          f ? d.doc.resolve(f) : void 0
        )
      ), n(d);
    }
    return !0;
  };
}
function Uce(t, e) {
  return function(n, r) {
    if (!ko(n))
      return !1;
    const i = N1(n);
    if (i.nodeAfter.attrs[t] === e)
      return !1;
    if (r) {
      const o = n.tr;
      n.selection instanceof nn ? n.selection.forEachCell((a, s) => {
        a.attrs[t] !== e && o.setNodeMarkup(s, null, {
          ...a.attrs,
          [t]: e
        });
      }) : o.setNodeMarkup(i.pos, null, {
        ...i.nodeAfter.attrs,
        [t]: e
      }), r(o);
    }
    return !0;
  };
}
function Nce(t) {
  return function(e, n) {
    if (!ko(e))
      return !1;
    if (n) {
      const r = Sr(e.schema), i = va(e), o = e.tr, a = i.map.cellsInRect(
        t == "column" ? {
          left: i.left,
          top: 0,
          right: i.right,
          bottom: i.map.height
        } : t == "row" ? {
          left: 0,
          top: i.top,
          right: i.map.width,
          bottom: i.bottom
        } : i
      ), s = a.map((l) => i.table.nodeAt(l));
      for (let l = 0; l < a.length; l++)
        s[l].type == r.header_cell && o.setNodeMarkup(
          i.tableStart + a[l],
          r.cell,
          s[l].attrs
        );
      if (o.steps.length == 0)
        for (let l = 0; l < a.length; l++)
          o.setNodeMarkup(
            i.tableStart + a[l],
            r.header_cell,
            s[l].attrs
          );
      n(o);
    }
    return !0;
  };
}
function xR(t, e, n) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: t == "row" ? e.map.width : 1,
    bottom: t == "column" ? e.map.height : 1
  });
  for (let i = 0; i < r.length; i++) {
    const o = e.table.nodeAt(r[i]);
    if (o && o.type !== n.header_cell)
      return !1;
  }
  return !0;
}
function vm(t, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? Nce(t) : function(n, r) {
    if (!ko(n))
      return !1;
    if (r) {
      const i = Sr(n.schema), o = va(n), a = n.tr, s = xR("row", o, i), l = xR(
        "column",
        o,
        i
      ), u = (t === "column" ? s : t === "row" ? l : !1) ? 1 : 0, d = t == "column" ? {
        left: 0,
        top: u,
        right: 1,
        bottom: o.map.height
      } : t == "row" ? {
        left: u,
        top: 0,
        right: o.map.width,
        bottom: 1
      } : o, f = t == "column" ? l ? i.cell : i.header_cell : t == "row" ? s ? i.cell : i.header_cell : i.cell;
      o.map.cellsInRect(d).forEach((p) => {
        const m = p + o.tableStart, g = a.doc.nodeAt(m);
        g && a.setNodeMarkup(m, f, g.attrs);
      }), r(a);
    }
    return !0;
  };
}
vm("row", {
  useDeprecatedLogic: !0
});
vm("column", {
  useDeprecatedLogic: !0
});
var Mce = vm("cell", {
  useDeprecatedLogic: !0
});
function Bce(t, e) {
  if (e < 0) {
    const n = t.nodeBefore;
    if (n)
      return t.pos - n.nodeSize;
    for (let r = t.index(-1) - 1, i = t.before(); r >= 0; r--) {
      const o = t.node(-1).child(r), a = o.lastChild;
      if (a)
        return i - 1 - a.nodeSize;
      i -= o.nodeSize;
    }
  } else {
    if (t.index() < t.parent.childCount - 1)
      return t.pos + t.nodeAfter.nodeSize;
    const n = t.node(-1);
    for (let r = t.indexAfter(-1), i = t.after(); r < n.childCount; r++) {
      const o = n.child(r);
      if (o.childCount)
        return i + 1;
      i += o.nodeSize;
    }
  }
  return null;
}
function _R(t) {
  return function(e, n) {
    if (!ko(e))
      return !1;
    const r = Bce(N1(e), t);
    if (r == null)
      return !1;
    if (n) {
      const i = e.doc.resolve(r);
      n(
        e.tr.setSelection(ot.between(i, pce(i))).scrollIntoView()
      );
    }
    return !0;
  };
}
function Lce(t, e) {
  const n = t.selection.$anchor;
  for (let r = n.depth; r > 0; r--)
    if (n.node(r).type.spec.tableRole == "table")
      return e && e(
        t.tr.delete(n.before(r), n.after(r)).scrollIntoView()
      ), !0;
  return !1;
}
function fy(t, e) {
  const n = t.selection;
  if (!(n instanceof nn))
    return !1;
  if (e) {
    const r = t.tr, i = Sr(t.schema).cell.createAndFill().content;
    n.forEachCell((o, a) => {
      o.content.eq(i) || r.replace(
        r.mapping.map(a + 1),
        r.mapping.map(a + o.nodeSize - 1),
        new Xe(i, 0, 0)
      );
    }), r.docChanged && e(r);
  }
  return !0;
}
function Pce(t) {
  if (!t.size)
    return null;
  let { content: e, openStart: n, openEnd: r } = t;
  for (; e.childCount == 1 && (n > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
    n--, r--, e = e.child(0).content;
  const i = e.child(0), o = i.type.spec.tableRole, a = i.type.schema, s = [];
  if (o == "row")
    for (let l = 0; l < e.childCount; l++) {
      let c = e.child(l).content;
      const u = l ? 0 : Math.max(0, n - 1), d = l < e.childCount - 1 ? 0 : Math.max(0, r - 1);
      (u || d) && (c = DT(
        Sr(a).row,
        new Xe(c, u, d)
      ).content), s.push(c);
    }
  else if (o == "cell" || o == "header_cell")
    s.push(
      n || r ? DT(
        Sr(a).row,
        new Xe(e, n, r)
      ).content : e
    );
  else
    return null;
  return Wce(a, s);
}
function Wce(t, e) {
  const n = [];
  for (let i = 0; i < e.length; i++) {
    const o = e[i];
    for (let a = o.childCount - 1; a >= 0; a--) {
      const { rowspan: s, colspan: l } = o.child(a).attrs;
      for (let c = i; c < i + s; c++)
        n[c] = (n[c] || 0) + l;
    }
  }
  let r = 0;
  for (let i = 0; i < n.length; i++)
    r = Math.max(r, n[i]);
  for (let i = 0; i < n.length; i++)
    if (i >= e.length && e.push(ze.empty), n[i] < r) {
      const o = Sr(t).cell.createAndFill(), a = [];
      for (let s = n[i]; s < r; s++)
        a.push(o);
      e[i] = e[i].append(ze.from(a));
    }
  return { height: e.length, width: r, rows: e };
}
function DT(t, e) {
  const n = t.createAndFill();
  return new QT(n).replace(0, n.content.size, e).doc;
}
function zce({ width: t, height: e, rows: n }, r, i) {
  if (t != r) {
    const o = [], a = [];
    for (let s = 0; s < n.length; s++) {
      const l = n[s], c = [];
      for (let u = o[s] || 0, d = 0; u < r; d++) {
        let f = l.child(d % l.childCount);
        u + f.attrs.colspan > r && (f = f.type.createChecked(
          tu(
            f.attrs,
            f.attrs.colspan,
            u + f.attrs.colspan - r
          ),
          f.content
        )), c.push(f), u += f.attrs.colspan;
        for (let p = 1; p < f.attrs.rowspan; p++)
          o[s + p] = (o[s + p] || 0) + f.attrs.colspan;
      }
      a.push(ze.from(c));
    }
    n = a, t = r;
  }
  if (e != i) {
    const o = [];
    for (let a = 0, s = 0; a < i; a++, s++) {
      const l = [], c = n[s % e];
      for (let u = 0; u < c.childCount; u++) {
        let d = c.child(u);
        a + d.attrs.rowspan > i && (d = d.type.create(
          {
            ...d.attrs,
            rowspan: Math.max(1, i - d.attrs.rowspan)
          },
          d.content
        )), l.push(d);
      }
      o.push(ze.from(l));
    }
    n = o, e = i;
  }
  return { width: t, height: e, rows: n };
}
function $ce(t, e, n, r, i, o, a) {
  const s = t.doc.type.schema, l = Sr(s);
  let c, u;
  if (i > e.width)
    for (let d = 0, f = 0; d < e.height; d++) {
      const p = n.child(d);
      f += p.nodeSize;
      const m = [];
      let g;
      p.lastChild == null || p.lastChild.type == l.cell ? g = c || (c = l.cell.createAndFill()) : g = u || (u = l.header_cell.createAndFill());
      for (let b = e.width; b < i; b++)
        m.push(g);
      t.insert(t.mapping.slice(a).map(f - 1 + r), m);
    }
  if (o > e.height) {
    const d = [];
    for (let m = 0, g = (e.height - 1) * e.width; m < Math.max(e.width, i); m++) {
      const b = m >= e.width ? !1 : n.nodeAt(e.map[g + m]).type == l.header_cell;
      d.push(
        b ? u || (u = l.header_cell.createAndFill()) : c || (c = l.cell.createAndFill())
      );
    }
    const f = l.row.create(null, ze.from(d)), p = [];
    for (let m = e.height; m < o; m++)
      p.push(f);
    t.insert(t.mapping.slice(a).map(r + n.nodeSize - 2), p);
  }
  return !!(c || u);
}
function SR(t, e, n, r, i, o, a, s) {
  if (a == 0 || a == e.height)
    return !1;
  let l = !1;
  for (let c = i; c < o; c++) {
    const u = a * e.width + c, d = e.map[u];
    if (e.map[u - e.width] == d) {
      l = !0;
      const f = n.nodeAt(d), { top: p, left: m } = e.findCell(d);
      t.setNodeMarkup(t.mapping.slice(s).map(d + r), null, {
        ...f.attrs,
        rowspan: a - p
      }), t.insert(
        t.mapping.slice(s).map(e.positionAt(a, m, n)),
        f.type.createAndFill({
          ...f.attrs,
          rowspan: p + f.attrs.rowspan - a
        })
      ), c += f.attrs.colspan - 1;
    }
  }
  return l;
}
function TR(t, e, n, r, i, o, a, s) {
  if (a == 0 || a == e.width)
    return !1;
  let l = !1;
  for (let c = i; c < o; c++) {
    const u = c * e.width + a, d = e.map[u];
    if (e.map[u - 1] == d) {
      l = !0;
      const f = n.nodeAt(d), p = e.colCount(d), m = t.mapping.slice(s).map(d + r);
      t.setNodeMarkup(
        m,
        null,
        tu(
          f.attrs,
          a - p,
          f.attrs.colspan - (a - p)
        )
      ), t.insert(
        m + f.nodeSize,
        f.type.createAndFill(
          tu(f.attrs, 0, a - p)
        )
      ), c += f.attrs.rowspan - 1;
    }
  }
  return l;
}
function DR(t, e, n, r, i) {
  let o = n ? t.doc.nodeAt(n - 1) : t.doc;
  if (!o)
    throw new Error("No table found");
  let a = Dn.get(o);
  const { top: s, left: l } = r, c = l + i.width, u = s + i.height, d = t.tr;
  let f = 0;
  function p() {
    if (o = n ? d.doc.nodeAt(n - 1) : d.doc, !o)
      throw new Error("No table found");
    a = Dn.get(o), f = d.mapping.maps.length;
  }
  $ce(d, a, o, n, c, u, f) && p(), SR(d, a, o, n, l, c, s, f) && p(), SR(d, a, o, n, l, c, u, f) && p(), TR(d, a, o, n, s, u, l, f) && p(), TR(d, a, o, n, s, u, c, f) && p();
  for (let m = s; m < u; m++) {
    const g = a.positionAt(m, l, o), b = a.positionAt(m, c, o);
    d.replace(
      d.mapping.slice(f).map(g + n),
      d.mapping.slice(f).map(b + n),
      new Xe(i.rows[m - s], 0, 0)
    );
  }
  p(), d.setSelection(
    new nn(
      d.doc.resolve(n + a.positionAt(s, l, o)),
      d.doc.resolve(n + a.positionAt(u - 1, c - 1, o))
    )
  ), e(d);
}
var Hce = cD({
  ArrowLeft: hy("horiz", -1),
  ArrowRight: hy("horiz", 1),
  ArrowUp: hy("vert", -1),
  ArrowDown: hy("vert", 1),
  "Shift-ArrowLeft": py("horiz", -1),
  "Shift-ArrowRight": py("horiz", 1),
  "Shift-ArrowUp": py("vert", -1),
  "Shift-ArrowDown": py("vert", 1),
  Backspace: fy,
  "Mod-Backspace": fy,
  Delete: fy,
  "Mod-Delete": fy
});
function ab(t, e, n) {
  return n.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function hy(t, e) {
  return (n, r, i) => {
    if (!i)
      return !1;
    const o = n.selection;
    if (o instanceof nn)
      return ab(
        n,
        r,
        dt.near(o.$headCell, e)
      );
    if (t != "horiz" && !o.empty)
      return !1;
    const a = TM(i, t, e);
    if (a == null)
      return !1;
    if (t == "horiz")
      return ab(
        n,
        r,
        dt.near(n.doc.resolve(o.head + e), e)
      );
    {
      const s = n.doc.resolve(a), l = yM(s, t, e);
      let c;
      return l ? c = dt.near(l, 1) : e < 0 ? c = dt.near(n.doc.resolve(s.before(-1)), -1) : c = dt.near(n.doc.resolve(s.after(-1)), 1), ab(n, r, c);
    }
  };
}
function py(t, e) {
  return (n, r, i) => {
    if (!i)
      return !1;
    const o = n.selection;
    let a;
    if (o instanceof nn)
      a = o;
    else {
      const l = TM(i, t, e);
      if (l == null)
        return !1;
      a = new nn(n.doc.resolve(l));
    }
    const s = yM(a.$headCell, t, e);
    return s ? ab(
      n,
      r,
      new nn(a.$anchorCell, s)
    ) : !1;
  };
}
function jce(t, e) {
  const n = t.state.doc, r = eh(n.resolve(e));
  return r ? (t.dispatch(t.state.tr.setSelection(new nn(r))), !0) : !1;
}
function Vce(t, e, n) {
  if (!ko(t.state))
    return !1;
  let r = Pce(n);
  const i = t.state.selection;
  if (i instanceof nn) {
    r || (r = {
      width: 1,
      height: 1,
      rows: [
        ze.from(
          DT(Sr(t.state.schema).cell, n)
        )
      ]
    });
    const o = i.$anchorCell.node(-1), a = i.$anchorCell.start(-1), s = Dn.get(o).rectBetween(
      i.$anchorCell.pos - a,
      i.$headCell.pos - a
    );
    return r = zce(r, s.right - s.left, s.bottom - s.top), DR(t.state, t.dispatch, a, s, r), !0;
  } else if (r) {
    const o = N1(t.state), a = o.start(-1);
    return DR(
      t.state,
      t.dispatch,
      a,
      Dn.get(o.node(-1)).findCell(o.pos - a),
      r
    ), !0;
  } else
    return !1;
}
function qce(t, e) {
  var n;
  if (e.ctrlKey || e.metaKey)
    return;
  const r = ER(t, e.target);
  let i;
  if (e.shiftKey && t.state.selection instanceof nn)
    o(t.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && r && (i = eh(t.state.selection.$anchor)) != null && ((n = jx(t, e)) == null ? void 0 : n.pos) != i.pos)
    o(i, e), e.preventDefault();
  else if (!r)
    return;
  function o(l, c) {
    let u = jx(t, c);
    const d = fl.getState(t.state) == null;
    if (!u || !xE(l, u))
      if (d)
        u = l;
      else
        return;
    const f = new nn(l, u);
    if (d || !t.state.selection.eq(f)) {
      const p = t.state.tr.setSelection(f);
      d && p.setMeta(fl, l.pos), t.dispatch(p);
    }
  }
  function a() {
    t.root.removeEventListener("mouseup", a), t.root.removeEventListener("dragstart", a), t.root.removeEventListener("mousemove", s), fl.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(fl, -1));
  }
  function s(l) {
    const c = l, u = fl.getState(t.state);
    let d;
    if (u != null)
      d = t.state.doc.resolve(u);
    else if (ER(t, c.target) != r && (d = jx(t, e), !d))
      return a();
    d && o(d, c);
  }
  t.root.addEventListener("mouseup", a), t.root.addEventListener("dragstart", a), t.root.addEventListener("mousemove", s);
}
function TM(t, e, n) {
  if (!(t.state.selection instanceof ot))
    return null;
  const { $head: r } = t.state.selection;
  for (let i = r.depth - 1; i >= 0; i--) {
    const o = r.node(i);
    if ((n < 0 ? r.index(i) : r.indexAfter(i)) != (n < 0 ? 0 : o.childCount))
      return null;
    if (o.type.spec.tableRole == "cell" || o.type.spec.tableRole == "header_cell") {
      const s = r.before(i), l = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
      return t.endOfTextblock(l) ? s : null;
    }
  }
  return null;
}
function ER(t, e) {
  for (; e && e != t.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function jx(t, e) {
  const n = t.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return n && n ? eh(t.state.doc.resolve(n.pos)) : null;
}
var Gce = class {
  constructor(e, n) {
    this.node = e, this.defaultCellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
      "--default-cell-min-width",
      `${n}px`
    ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), ET(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type != this.node.type ? !1 : (this.node = e, ET(
      e,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    ), !0);
  }
  ignoreMutation(e) {
    return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
  }
};
function ET(t, e, n, r, i, o) {
  var a;
  let s = 0, l = !0, c = e.firstChild;
  const u = t.firstChild;
  if (u) {
    for (let d = 0, f = 0; d < u.childCount; d++) {
      const { colspan: p, colwidth: m } = u.child(d).attrs;
      for (let g = 0; g < p; g++, f++) {
        const b = i == f ? o : m && m[g], y = b ? b + "px" : "";
        if (s += b || r, b || (l = !1), c)
          c.style.width != y && (c.style.width = y), c = c.nextSibling;
        else {
          const w = document.createElement("col");
          w.style.width = y, e.appendChild(w);
        }
      }
    }
    for (; c; ) {
      const d = c.nextSibling;
      (a = c.parentNode) == null || a.removeChild(c), c = d;
    }
    l ? (n.style.width = s + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = s + "px");
  }
}
var Di = new Nt(
  "tableColumnResizing"
);
function Kce({
  handleWidth: t = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: n = 100,
  View: r = Gce,
  lastColumnResizable: i = !0
} = {}) {
  const o = new Pt({
    key: Di,
    state: {
      init(a, s) {
        var l, c;
        const u = (c = (l = o.spec) == null ? void 0 : l.props) == null ? void 0 : c.nodeViews, d = Sr(s.schema).table.name;
        return r && u && (u[d] = (f, p) => new r(f, n, p)), new Xce(-1, !1);
      },
      apply(a, s) {
        return s.apply(a);
      }
    },
    props: {
      attributes: (a) => {
        const s = Di.getState(a);
        return s && s.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (a, s) => {
          Yce(a, s, t, i);
        },
        mouseleave: (a) => {
          Jce(a);
        },
        mousedown: (a, s) => {
          Zce(a, s, e, n);
        }
      },
      decorations: (a) => {
        const s = Di.getState(a);
        if (s && s.activeHandle > -1)
          return rue(a, s.activeHandle);
      },
      nodeViews: {}
    }
  });
  return o;
}
var Xce = class sb {
  constructor(e, n) {
    this.activeHandle = e, this.dragging = n;
  }
  apply(e) {
    const n = this, r = e.getMeta(Di);
    if (r && r.setHandle != null)
      return new sb(r.setHandle, !1);
    if (r && r.setDragging !== void 0)
      return new sb(n.activeHandle, r.setDragging);
    if (n.activeHandle > -1 && e.docChanged) {
      let i = e.mapping.map(n.activeHandle, -1);
      return TT(e.doc.resolve(i)) || (i = -1), new sb(i, n.dragging);
    }
    return n;
  }
};
function Yce(t, e, n, r) {
  const i = Di.getState(t.state);
  if (i && !i.dragging) {
    const o = eue(e.target);
    let a = -1;
    if (o) {
      const { left: s, right: l } = o.getBoundingClientRect();
      e.clientX - s <= n ? a = CR(t, e, "left", n) : l - e.clientX <= n && (a = CR(t, e, "right", n));
    }
    if (a != i.activeHandle) {
      if (!r && a !== -1) {
        const s = t.state.doc.resolve(a), l = s.node(-1), c = Dn.get(l), u = s.start(-1);
        if (c.colCount(s.pos - u) + s.nodeAfter.attrs.colspan - 1 == c.width - 1)
          return;
      }
      DM(t, a);
    }
  }
}
function Jce(t) {
  const e = Di.getState(t.state);
  e && e.activeHandle > -1 && !e.dragging && DM(t, -1);
}
function Zce(t, e, n, r) {
  var i;
  const o = (i = t.dom.ownerDocument.defaultView) != null ? i : window, a = Di.getState(t.state);
  if (!a || a.activeHandle == -1 || a.dragging)
    return !1;
  const s = t.state.doc.nodeAt(a.activeHandle), l = Qce(t, a.activeHandle, s.attrs);
  t.dispatch(
    t.state.tr.setMeta(Di, {
      setDragging: { startX: e.clientX, startWidth: l }
    })
  );
  function c(d) {
    o.removeEventListener("mouseup", c), o.removeEventListener("mousemove", u);
    const f = Di.getState(t.state);
    f != null && f.dragging && (tue(
      t,
      f.activeHandle,
      kR(f.dragging, d, n)
    ), t.dispatch(
      t.state.tr.setMeta(Di, { setDragging: null })
    ));
  }
  function u(d) {
    if (!d.which)
      return c(d);
    const f = Di.getState(t.state);
    if (f && f.dragging) {
      const p = kR(f.dragging, d, n);
      AR(
        t,
        f.activeHandle,
        p,
        r
      );
    }
  }
  return AR(
    t,
    a.activeHandle,
    l,
    r
  ), o.addEventListener("mouseup", c), o.addEventListener("mousemove", u), e.preventDefault(), !0;
}
function Qce(t, e, { colspan: n, colwidth: r }) {
  const i = r && r[r.length - 1];
  if (i)
    return i;
  const o = t.domAtPos(e);
  let s = o.node.childNodes[o.offset].offsetWidth, l = n;
  if (r)
    for (let c = 0; c < n; c++)
      r[c] && (s -= r[c], l--);
  return s / l;
}
function eue(t) {
  for (; t && t.nodeName != "TD" && t.nodeName != "TH"; )
    t = t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode;
  return t;
}
function CR(t, e, n, r) {
  const i = n == "right" ? -r : r, o = t.posAtCoords({
    left: e.clientX + i,
    top: e.clientY
  });
  if (!o)
    return -1;
  const { pos: a } = o, s = eh(t.state.doc.resolve(a));
  if (!s)
    return -1;
  if (n == "right")
    return s.pos;
  const l = Dn.get(s.node(-1)), c = s.start(-1), u = l.map.indexOf(s.pos - c);
  return u % l.width == 0 ? -1 : c + l.map[u - 1];
}
function kR(t, e, n) {
  const r = e.clientX - t.startX;
  return Math.max(n, t.startWidth + r);
}
function DM(t, e) {
  t.dispatch(
    t.state.tr.setMeta(Di, { setHandle: e })
  );
}
function tue(t, e, n) {
  const r = t.state.doc.resolve(e), i = r.node(-1), o = Dn.get(i), a = r.start(-1), s = o.colCount(r.pos - a) + r.nodeAfter.attrs.colspan - 1, l = t.state.tr;
  for (let c = 0; c < o.height; c++) {
    const u = c * o.width + s;
    if (c && o.map[u] == o.map[u - o.width])
      continue;
    const d = o.map[u], f = i.nodeAt(d).attrs, p = f.colspan == 1 ? 0 : s - o.colCount(d);
    if (f.colwidth && f.colwidth[p] == n)
      continue;
    const m = f.colwidth ? f.colwidth.slice() : nue(f.colspan);
    m[p] = n, l.setNodeMarkup(a + d, null, { ...f, colwidth: m });
  }
  l.docChanged && t.dispatch(l);
}
function AR(t, e, n, r) {
  const i = t.state.doc.resolve(e), o = i.node(-1), a = i.start(-1), s = Dn.get(o).colCount(i.pos - a) + i.nodeAfter.attrs.colspan - 1;
  let l = t.domAtPos(i.start(-1)).node;
  for (; l && l.nodeName != "TABLE"; )
    l = l.parentNode;
  l && ET(
    o,
    l.firstChild,
    l,
    r,
    s,
    n
  );
}
function nue(t) {
  return Array(t).fill(0);
}
function rue(t, e) {
  var n;
  const r = [], i = t.doc.resolve(e), o = i.node(-1);
  if (!o)
    return Bt.empty;
  const a = Dn.get(o), s = i.start(-1), l = a.colCount(i.pos - s) + i.nodeAfter.attrs.colspan - 1;
  for (let c = 0; c < a.height; c++) {
    const u = l + c * a.width;
    if ((l == a.width - 1 || a.map[u] != a.map[u + 1]) && (c == 0 || a.map[u] != a.map[u - a.width])) {
      const d = a.map[u], f = s + d + o.nodeAt(d).nodeSize - 1, p = document.createElement("div");
      p.className = "column-resize-handle", (n = Di.getState(t)) != null && n.dragging && r.push(
        vn.node(
          s + d,
          s + d + o.nodeAt(d).nodeSize,
          {
            class: "column-resize-dragging"
          }
        )
      ), r.push(vn.widget(f, p));
    }
  }
  return Bt.create(t.doc, r);
}
function iue({
  allowTableNodeSelection: t = !1
} = {}) {
  return new Pt({
    key: fl,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, n) {
        const r = e.getMeta(fl);
        if (r != null)
          return r == -1 ? null : r;
        if (n == null || !e.docChanged)
          return n;
        const { deleted: i, pos: o } = e.mapping.mapResult(n);
        return i ? null : o;
      }
    },
    props: {
      decorations: yce,
      handleDOMEvents: {
        mousedown: qce
      },
      createSelectionBetween(e) {
        return fl.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: jce,
      handleKeyDown: Hce,
      handlePaste: Vce
    },
    appendTransaction(e, n, r) {
      return wce(
        r,
        xM(r, n),
        t
      );
    }
  });
}
function CT(t, e) {
  return e ? ["width", `${Math.max(e, t)}px`] : ["min-width", `${t}px`];
}
function RR(t, e, n, r, i, o) {
  var a;
  let s = 0, l = !0, c = e.firstChild;
  const u = t.firstChild;
  if (u !== null)
    for (let d = 0, f = 0; d < u.childCount; d += 1) {
      const { colspan: p, colwidth: m } = u.child(d).attrs;
      for (let g = 0; g < p; g += 1, f += 1) {
        const b = i === f ? o : m && m[g], y = b ? `${b}px` : "";
        if (s += b || r, b || (l = !1), c) {
          if (c.style.width !== y) {
            const [w, x] = CT(r, b);
            c.style.setProperty(w, x);
          }
          c = c.nextSibling;
        } else {
          const w = document.createElement("col"), [x, k] = CT(r, b);
          w.style.setProperty(x, k), e.appendChild(w);
        }
      }
    }
  for (; c; ) {
    const d = c.nextSibling;
    (a = c.parentNode) === null || a === void 0 || a.removeChild(c), c = d;
  }
  l ? (n.style.width = `${s}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${s}px`);
}
class oue {
  constructor(e, n) {
    this.node = e, this.cellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), RR(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type !== this.node.type ? !1 : (this.node = e, RR(e, this.colgroup, this.table, this.cellMinWidth), !0);
  }
  ignoreMutation(e) {
    return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target));
  }
}
function aue(t, e, n, r) {
  let i = 0, o = !0;
  const a = [], s = t.firstChild;
  if (!s)
    return {};
  for (let d = 0, f = 0; d < s.childCount; d += 1) {
    const { colspan: p, colwidth: m } = s.child(d).attrs;
    for (let g = 0; g < p; g += 1, f += 1) {
      const b = n === f ? r : m && m[g];
      i += b || e, b || (o = !1);
      const [y, w] = CT(e, b);
      a.push([
        "col",
        { style: `${y}: ${w}` }
      ]);
    }
  }
  const l = o ? `${i}px` : "", c = o ? "" : `${i}px`;
  return { colgroup: ["colgroup", {}, ...a], tableWidth: l, tableMinWidth: c };
}
function IR(t, e) {
  return t.createAndFill();
}
function sue(t) {
  if (t.cached.tableNodeTypes)
    return t.cached.tableNodeTypes;
  const e = {};
  return Object.keys(t.nodes).forEach((n) => {
    const r = t.nodes[n];
    r.spec.tableRole && (e[r.spec.tableRole] = r);
  }), t.cached.tableNodeTypes = e, e;
}
function lue(t, e, n, r, i) {
  const o = sue(t), a = [], s = [];
  for (let c = 0; c < n; c += 1) {
    const u = IR(o.cell);
    if (u && s.push(u), r) {
      const d = IR(o.header_cell);
      d && a.push(d);
    }
  }
  const l = [];
  for (let c = 0; c < e; c += 1)
    l.push(o.row.createChecked(null, r && c === 0 ? a : s));
  return o.table.createChecked(null, l);
}
function cue(t) {
  return t instanceof nn;
}
const my = ({ editor: t }) => {
  const { selection: e } = t.state;
  if (!cue(e))
    return !1;
  let n = 0;
  const r = HU(e.ranges[0].$from, (o) => o.type.name === "table");
  return r == null || r.node.descendants((o) => {
    if (o.type.name === "table")
      return !1;
    ["tableCell", "tableHeader"].includes(o.type.name) && (n += 1);
  }), n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1;
}, uue = rn.create({
  name: "table",
  // @ts-ignore
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: !1,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: oue,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: !0,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const { colgroup: n, tableWidth: r, tableMinWidth: i } = aue(t, this.options.cellMinWidth);
    return [
      "table",
      bt(this.options.HTMLAttributes, e, {
        style: r ? `width: ${r}` : `min-width: ${i}`
      }),
      n,
      ["tbody", 0]
    ];
  },
  addCommands() {
    return {
      insertTable: ({ rows: t = 3, cols: e = 3, withHeaderRow: n = !0 } = {}) => ({ tr: r, dispatch: i, editor: o }) => {
        const a = lue(o.schema, t, e, n);
        if (i) {
          const s = r.selection.from + 1;
          r.replaceSelectionWith(a).scrollIntoView().setSelection(ot.near(r.doc.resolve(s)));
        }
        return !0;
      },
      addColumnBefore: () => ({ state: t, dispatch: e }) => Sce(t, e),
      addColumnAfter: () => ({ state: t, dispatch: e }) => Tce(t, e),
      deleteColumn: () => ({ state: t, dispatch: e }) => Ece(t, e),
      addRowBefore: () => ({ state: t, dispatch: e }) => kce(t, e),
      addRowAfter: () => ({ state: t, dispatch: e }) => Ace(t, e),
      deleteRow: () => ({ state: t, dispatch: e }) => Ice(t, e),
      deleteTable: () => ({ state: t, dispatch: e }) => Lce(t, e),
      mergeCells: () => ({ state: t, dispatch: e }) => vR(t, e),
      splitCell: () => ({ state: t, dispatch: e }) => wR(t, e),
      toggleHeaderColumn: () => ({ state: t, dispatch: e }) => vm("column")(t, e),
      toggleHeaderRow: () => ({ state: t, dispatch: e }) => vm("row")(t, e),
      toggleHeaderCell: () => ({ state: t, dispatch: e }) => Mce(t, e),
      mergeOrSplit: () => ({ state: t, dispatch: e }) => vR(t, e) ? !0 : wR(t, e),
      setCellAttribute: (t, e) => ({ state: n, dispatch: r }) => Uce(t, e)(n, r),
      goToNextCell: () => ({ state: t, dispatch: e }) => _R(1)(t, e),
      goToPreviousCell: () => ({ state: t, dispatch: e }) => _R(-1)(t, e),
      fixTables: () => ({ state: t, dispatch: e }) => (e && xM(t), !0),
      setCellSelection: (t) => ({ tr: e, dispatch: n }) => {
        if (n) {
          const r = nn.create(e.doc, t.anchorCell, t.headCell);
          e.setSelection(r);
        }
        return !0;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: my,
      "Mod-Backspace": my,
      Delete: my,
      "Mod-Delete": my
    };
  },
  addProseMirrorPlugins() {
    return [
      ...this.options.resizable && this.editor.isEditable ? [
        Kce({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          defaultCellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      iue({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(t) {
    const e = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      tableRole: yt(tt(t, "tableRole", e))
    };
  }
}), due = rn.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "td" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["td", bt(this.options.HTMLAttributes, t), 0];
  }
}), fue = rn.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: !0,
  parseHTML() {
    return [
      { tag: "th" }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["th", bt(this.options.HTMLAttributes, t), 0];
  }
});
function hue(t, e, n) {
  if (!t.doc)
    return t;
  const r = t.doc.nodeAt(e);
  if (!r || n === r.attrs.backgroundColor)
    return t;
  const i = {
    ...r.attrs,
    backgroundColor: n
  };
  return t.setNodeMarkup(e, r.type, i, r.marks);
}
function pue(t, e, n) {
  const { doc: r, selection: i } = t;
  return !r || !i || !(i instanceof nn) || i.forEachCell((o, a) => {
    t = hue(t, a, n);
  }), t;
}
function OR(t, e) {
  return ({ tr: n, state: r, dispatch: i }) => {
    const { selection: o } = r;
    return n = n.setSelection(o), n = pue(n, e, t), n.docChanged ? (i == null || i(n), !0) : !1;
  };
}
const mue = St.create({
  name: "tableCellBackground",
  addOptions() {
    return {
      types: ["tableCell"],
      HTMLAttributes: {}
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          backgroundColor: {
            parseHTML: (t) => t.style.backgroundColor || "",
            renderHTML: (t) => !t.backgroundColor || t.backgroundColor === "" ? {} : {
              style: `background-color: ${t.backgroundColor}`
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTableCellBackground: (t) => OR(t, this.options),
      unsetTableCellBackground: () => OR("", this.options)
    };
  }
}), gue = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i, yue = /CrOS/, bue = /android|ipad|playbook|silk/i;
function FR(t = {}) {
  let e = t.ua || typeof navigator < "u" && navigator.userAgent;
  return e && typeof e == "object" && e.headers && typeof e.headers["user-agent"] == "string" && (e = e.headers["user-agent"]), typeof e != "string" ? !1 : !!(gue.test(e) && !yue.test(e) || t.tablet && bue.test(e) || t.tablet && t.featureDetect && navigator && navigator.maxTouchPoints > 1 && e.includes("Macintosh") && e.includes("Safari"));
}
const UR = (t) => Array.from({ length: t }).map((e, n) => n + 1);
function vue(t) {
  var u;
  const [e, n] = nt(!0), [r, i] = nt({
    rows: FR() ? Zg : Jg,
    cols: FR() ? Zg : Jg
  }), [o, a] = nt({
    rows: Qg,
    cols: Qg
  });
  function s(d, f) {
    d === r.rows && i((p) => ({
      ...p,
      rows: Math.min(d + 1, Zg)
    })), f === r.cols && i((p) => ({
      ...p,
      cols: Math.min(f + 1, Zg)
    })), a({
      rows: d,
      cols: f
    });
  }
  function l(d, f) {
    t == null || t.createTable({ rows: d, cols: f, withHeaderRow: e }), c();
  }
  function c() {
    n(!1), i({
      rows: Jg,
      cols: Jg
    }), a({
      rows: Qg,
      cols: Qg
    });
  }
  return /* @__PURE__ */ Fe(Eo, { modal: !0, children: [
    /* @__PURE__ */ z(Co, { asChild: !0, children: t == null ? void 0 : t.children }),
    /* @__PURE__ */ z(oo, { className: "richtext-w-full !richtext-p-2", align: "start", side: "bottom", children: /* @__PURE__ */ Fe("div", { className: "richtext-p-0 table-grid-size-editor", children: [
      /* @__PURE__ */ z("div", { className: "richtext-flex richtext-flex-col richtext-flex-wrap richtext-justify-between richtext-gap-1", children: (u = UR(r == null ? void 0 : r.rows)) == null ? void 0 : u.map((d) => {
        var f;
        return /* @__PURE__ */ z("div", { className: "richtext-flex richtext-gap-1", children: (f = UR(r == null ? void 0 : r.cols)) == null ? void 0 : f.map((p) => /* @__PURE__ */ z(
          "div",
          {
            className: `richtext-cursor-pointer richtext-border-border ${p <= o.cols && d <= o.rows && "!richtext-bg-foreground tableCellActive"}`,
            onMouseOver: () => s(d, p),
            onMouseDown: () => l(d, p),
            children: /* @__PURE__ */ z("div", { className: "richtext-w-4 richtext-h-4 richtext-p-1 !richtext-border richtext-rounded-[2px] richtext-box-border richtext-border-solid !richtext-border-border" })
          },
          `c-${p}`
        )) }, `r-${d}`);
      }) }),
      /* @__PURE__ */ Fe("div", { className: "richtext-mt-2 richtext-text-sm richtext-text-center richtext-text-zinc-600", children: [
        o.rows,
        " ",
        "x",
        o.cols
      ] })
    ] }) })
  ] });
}
function wue(t) {
  function e(n) {
    t.disabled || t.editor.chain().focus().insertTable({ ...n, withHeaderRow: !1 }).run();
  }
  return /* @__PURE__ */ z(vue, { createTable: e, children: /* @__PURE__ */ z(
    Je,
    {
      icon: t == null ? void 0 : t.icon,
      tooltip: t == null ? void 0 : t.tooltip,
      disabled: t == null ? void 0 : t.disabled,
      color: t == null ? void 0 : t.color,
      action: t == null ? void 0 : t.action,
      isActive: t == null ? void 0 : t.isActive
    }
  ) });
}
const G2e = uue.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      resizable: !0,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1,
      button: ({ editor: e, t: n }) => ({
        component: wue,
        componentProps: {
          disabled: e.isActive("table") || !1,
          icon: "Table",
          tooltip: n("editor.table.tooltip"),
          editor: e
        }
      })
    };
  },
  addExtensions() {
    return [
      sce.configure(this.options.tableRow),
      fue.configure(this.options.tableHeader),
      due.configure(this.options.tableCell),
      mue.configure(this.options.tableCellBackground)
    ];
  }
}), K2e = St.create({
  name: "painter",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: Je,
        componentProps: {
          action: () => {
            e.commands.setPainter(e == null ? void 0 : e.state.selection.$head.marks());
          },
          icon: "PaintRoller",
          tooltip: n("editor.format")
        }
      })
    };
  },
  addCommands() {
    return {
      setPainter: (t) => ({
        view: {
          dispatch: e,
          state: { tr: n },
          dom: r
        }
      }) => {
        const a = `url("data:image/svg+xml;utf8,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="#000" d="M9 22v-6H4V7q0-1.65 1.175-2.825T8 3h12v13h-5v6zM6 10h12V5h-1v4h-2V5h-1v2h-2V5H8q-.825 0-1.412.588T6 7zm0 4h12v-2H6zm0 0v-2z"/></svg>')}"), auto`;
        return r.style.cursor = a, e(n.setMeta("painterAction", { type: "start", marks: t })), !0;
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      new Pt({
        key: new Nt("format-painter"),
        state: {
          init: () => [],
          apply: (t, e) => {
            const n = t.getMeta("painterAction");
            return n && n.type === "start" ? e = n.marks : n && n.type === "end" && (e = []), e;
          }
        },
        props: {
          handleDOMEvents: {
            mousedown(t, e) {
              const n = this.getState(t.state);
              if (!n || n.length === 0)
                return t.dom.style.cursor = "", !1;
              const r = () => {
                document.removeEventListener("mouseup", r);
                let {
                  dispatch: i,
                  state: { tr: o, selection: a },
                  dom: s
                } = t;
                s.style.cursor = "", o = o.removeMark(a.from, a.to);
                for (const l of n)
                  l.type.name !== "link" && (o = o.addMark(a.from, a.to, l));
                i(o.setMeta("painterAction", { type: "end" }));
              };
              return document.addEventListener("mouseup", r), !0;
            }
          }
        }
      })
    ];
  }
});
function xue({ editor: t, ...e }) {
  const { t: n } = Wt(), [r, i] = nt(-1), [o, a] = nt([]), [s, l] = nt(""), [c, u] = nt(""), [d, f] = nt(!1), [p, m] = nt(!1);
  return Tt(() => {
    d || (l(""), u(""), i(-1), a([]), t.commands.setSearchTerm(""), t.commands.setReplaceTerm(""));
  }, [t, d]), Tt(() => {
    d && t && t.commands && t.commands.setSearchTerm && t.commands.setSearchTerm(s);
  }, [d, s, t]), Tt(() => {
    d && t && t.commands && t.commands.setReplaceTerm && t.commands.setReplaceTerm(c);
  }, [d, c, t]), Tt(() => {
    if (!t)
      return;
    const g = t.extensionManager.extensions.find((y) => y.name === Eue.name);
    if (!g)
      return;
    const b = () => {
      if (!d)
        return;
      const y = g ? g.storage.currentIndex : -1, w = g ? g.storage.results : [];
      i((x) => x !== y ? y : x), a((x) => r4(x, w) ? x : w);
    };
    return window.addEventListener(kT, b), () => {
      g && window.removeEventListener(kT, b);
    };
  }, [d, t]), /* @__PURE__ */ Fe(
    Eo,
    {
      open: d,
      onOpenChange: f,
      children: [
        /* @__PURE__ */ z(
          Co,
          {
            disabled: e == null ? void 0 : e.disabled,
            asChild: !0,
            children: /* @__PURE__ */ z(
              Je,
              {
                tooltip: e == null ? void 0 : e.tooltip,
                isActive: e == null ? void 0 : e.isActive,
                disabled: e == null ? void 0 : e.disabled,
                children: /* @__PURE__ */ z($t, { name: e == null ? void 0 : e.icon })
              }
            )
          }
        ),
        /* @__PURE__ */ Fe(
          oo,
          {
            hideWhenDetached: !0,
            className: "richtext-w-full",
            align: "start",
            side: "bottom",
            children: [
              /* @__PURE__ */ Fe("div", { className: "richtext-mb-[6px] richtext-flex richtext-items-center richtext-justify-between", children: [
                /* @__PURE__ */ z(eo, { children: n("editor.search.dialog.text") }),
                /* @__PURE__ */ z("span", { className: "richtext-font-semibold", children: o.length ? `${r + 1}/${o.length}` : "0/0" })
              ] }),
              /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-w-full richtext-max-w-sm richtext-items-center richtext-gap-1.5 richtext-mb-[10px]", children: [
                /* @__PURE__ */ z(
                  Pr,
                  {
                    type: "text",
                    required: !0,
                    className: "richtext-w-full",
                    placeholder: "Text",
                    autoFocus: !0,
                    value: s,
                    onChange: (g) => l(g.target.value)
                  }
                ),
                /* @__PURE__ */ z(fn, { disabled: !o.length, className: "richtext-flex-1", onClick: t.commands.goToPrevSearchResult, children: /* @__PURE__ */ z($t, { name: "ChevronUp" }) }),
                /* @__PURE__ */ z(fn, { disabled: !o.length, className: "richtext-flex-1", onClick: t.commands.goToNextSearchResult, children: /* @__PURE__ */ z($t, { name: "ChevronDown" }) })
              ] }),
              /* @__PURE__ */ z(eo, { className: "richtext-mb-[6px]", children: n("editor.replace.dialog.text") }),
              /* @__PURE__ */ z("div", { className: "richtext-flex richtext-w-full richtext-max-w-sm richtext-items-center richtext-gap-1.5 richtext-mb-[5px]", children: /* @__PURE__ */ z("div", { className: "richtext-relative richtext-items-center richtext-w-full richtext-max-w-sm", children: /* @__PURE__ */ z(
                Pr,
                {
                  type: "text",
                  required: !0,
                  className: "richtext-w-80",
                  placeholder: "Text",
                  value: c,
                  onChange: (g) => u(g.target.value)
                }
              ) }) }),
              /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-items-center richtext-space-x-2 richtext-mb-[10px]", children: [
                /* @__PURE__ */ z(
                  BD,
                  {
                    checked: p,
                    onCheckedChange: (g) => {
                      m(g), t.commands.setCaseSensitive(g);
                    }
                  }
                ),
                /* @__PURE__ */ z(eo, { children: n("editor.replace.caseSensitive") })
              ] }),
              /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-items-center richtext-gap-[10px]", children: [
                /* @__PURE__ */ z(fn, { disabled: !o.length, className: "richtext-flex-1", onClick: t.commands.replace, children: n("editor.replace.dialog.text") }),
                /* @__PURE__ */ z(fn, { disabled: !o.length, className: "richtext-flex-1", onClick: t.commands.replaceAll, children: n("editor.replaceAll.dialog.text") })
              ] })
            ]
          }
        )
      ]
    }
  );
}
const cp = (t, e) => e(t.tr);
function _ue(t, e, n) {
  return RegExp(e ? t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&") : t, n ? "gu" : "gui");
}
function Sue(t, e, n) {
  const r = [];
  let i = [];
  const o = [];
  let a = 0;
  if (!e)
    return { decorationsToReturn: [], results: [] };
  t == null || t.descendants((s, l) => {
    s.isText ? i[a] ? i[a] = {
      text: i[a].text + s.text,
      pos: i[a].pos
    } : i[a] = {
      text: `${s.text}`,
      pos: l
    } : a += 1;
  }), i = i.filter(Boolean);
  for (let s = 0; s < i.length; s += 1) {
    const { text: l, pos: c } = i[s], u = [...l.matchAll(e)];
    for (let d = 0; d < u.length; d += 1) {
      const f = u[d];
      if (f[0] === "")
        break;
      f.index !== void 0 && o.push({
        from: c + f.index,
        to: c + f.index + f[0].length
      });
    }
  }
  for (let s = 0; s < o.length; s += 1) {
    const l = o[s];
    r.push(vn.inline(l.from, l.to, { class: n }));
  }
  return {
    decorationsToReturn: r,
    results: o
  };
}
function NR(t, e, { state: n, dispatch: r }) {
  if (!e[0])
    return;
  const { from: o, to: a } = e[0];
  r && r(n.tr.insertText(t, o, a));
}
function Tue(t, e, n, r) {
  const i = e + 1;
  if (!r[i])
    return null;
  const { from: o, to: a } = r[e], s = a - o - t.length + n, { from: l, to: c } = r[i];
  return r[i] = {
    to: c - s,
    from: l - s
  }, [s, r];
}
function Due(t, e, { tr: n, dispatch: r }) {
  let i = 0, o = e.slice();
  if (!o.length)
    return !1;
  for (let a = 0; a < o.length; a += 1) {
    const { from: s, to: l } = o[a];
    n.insertText(t, s, l);
    const c = Tue(t, a, i, o);
    c && (i = c[0], o = c[1]);
  }
  return r(n), !0;
}
function MR({ view: t, tr: e, searchResults: n, searchResultCurrentClass: r, gotoIndex: i }) {
  const o = n[i];
  if (o) {
    const a = e.setMeta("directDecoration", {
      fromPos: o.from,
      toPos: o.to,
      attrs: { class: r }
    });
    return t == null || t.dispatch(a), setTimeout(() => {
      const s = window.document.querySelector(`.${r}`);
      s && XT(s, { behavior: "smooth", scrollMode: "if-needed" });
    }, 0), !0;
  }
  return !1;
}
const kT = "ON_SEARCH_RESULTS", Ad = new CustomEvent(kT), Eue = St.create({
  name: "search",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      searchTerm: "",
      replaceTerm: "",
      results: [],
      currentIndex: 0,
      searchResultClass: "search-result",
      searchResultCurrentClass: "search-result-current",
      caseSensitive: !1,
      disableRegex: !1,
      onChange: () => {
      },
      button: ({ editor: e, t: n }) => ({
        component: xue,
        componentProps: {
          action: () => {
          },
          icon: "SearchAndReplace",
          tooltip: n("editor.searchAndReplace.tooltip"),
          isActive: () => !1,
          disabled: !1,
          editor: e
        }
      })
    };
  },
  addStorage() {
    return {
      results: [],
      currentIndex: -1
    };
  },
  addCommands() {
    return {
      setSearchTerm: (t) => ({ state: e, dispatch: n }) => (this.options.searchTerm = t, this.storage.results = [], this.storage.currentIndex = 0, window.dispatchEvent(Ad), cp(e, n), !1),
      setReplaceTerm: (t) => ({ state: e, dispatch: n }) => (this.options.replaceTerm = t, cp(e, n), !1),
      setCaseSensitive: (t) => ({ state: e, dispatch: n }) => (this.options.caseSensitive = t, cp(e, n), !1),
      replace: () => ({ state: t, dispatch: e }) => {
        const { replaceTerm: n } = this.options, { currentIndex: r, results: i } = this.storage, o = i[r];
        return o ? (NR(n, [o], { state: t, dispatch: e }), this.storage.results.splice(r, 1)) : (NR(n, i, { state: t, dispatch: e }), this.storage.results.shift()), window.dispatchEvent(Ad), cp(t, e), !1;
      },
      replaceAll: () => ({ state: t, tr: e, dispatch: n }) => {
        const { replaceTerm: r } = this.options, { results: i } = this.storage;
        return Due(r, i, { tr: e, dispatch: n }), this.storage.currentIndex = -1, this.storage.results = [], window.dispatchEvent(Ad), cp(t, n), !1;
      },
      goToPrevSearchResult: () => ({ view: t, tr: e }) => {
        const { searchResultCurrentClass: n } = this.options, { currentIndex: r, results: i } = this.storage, o = (r + i.length - 1) % i.length;
        return this.storage.currentIndex = o, window.dispatchEvent(Ad), MR({
          view: t,
          tr: e,
          searchResults: i,
          searchResultCurrentClass: n,
          gotoIndex: o
        });
      },
      goToNextSearchResult: () => ({ view: t, tr: e }) => {
        const { searchResultCurrentClass: n } = this.options, { currentIndex: r, results: i } = this.storage, o = (r + 1) % i.length;
        return this.storage.currentIndex = o, this.options.onChange && this.options.onChange(), window.dispatchEvent(Ad), MR({
          view: t,
          tr: e,
          searchResults: i,
          searchResultCurrentClass: n,
          gotoIndex: o
        });
      }
    };
  },
  addProseMirrorPlugins() {
    const t = this;
    return [
      new Pt({
        key: new Nt("search"),
        state: {
          init() {
            return Bt.empty;
          },
          apply(e) {
            const { doc: n, docChanged: r } = e, { searchTerm: i, searchResultClass: o, searchResultCurrentClass: a, disableRegex: s, caseSensitive: l } = t.options;
            if (r || i) {
              const { decorationsToReturn: c, results: u } = Sue(
                n,
                _ue(i, s, l),
                o
              );
              if (t.storage.results = u, t.storage.currentIndex > u.length - 1 && (t.storage.currentIndex = 0), window.dispatchEvent(Ad), e.getMeta("directDecoration")) {
                const { fromPos: d, toPos: f, attrs: p } = e.getMeta("directDecoration");
                c.push(vn.inline(d, f, p));
              } else
                u.length && (c[0] = vn.inline(u[0].from, u[0].to, {
                  class: a
                }));
              return Bt.create(n, c);
            }
            return Bt.empty;
          }
        },
        props: {
          decorations(e) {
            return this.getState(e);
          }
        }
      })
    ];
  }
}), Of = {
  100: "💯",
  1234: "🔢",
  grinning: "😀",
  smiley: "😃",
  smile: "😄",
  grin: "😁",
  laughing: "😆",
  satisfied: "😆",
  sweat_smile: "😅",
  rofl: "🤣",
  joy: "😂",
  slightly_smiling_face: "🙂",
  upside_down_face: "🙃",
  wink: "😉",
  blush: "😊",
  innocent: "😇",
  smiling_face_with_three_hearts: "🥰",
  heart_eyes: "😍",
  star_struck: "🤩",
  kissing_heart: "😘",
  kissing: "😗",
  relaxed: "☺️",
  kissing_closed_eyes: "😚",
  kissing_smiling_eyes: "😙",
  smiling_face_with_tear: "🥲",
  yum: "😋",
  stuck_out_tongue: "😛",
  stuck_out_tongue_winking_eye: "😜",
  zany_face: "🤪",
  stuck_out_tongue_closed_eyes: "😝",
  money_mouth_face: "🤑",
  hugs: "🤗",
  hand_over_mouth: "🤭",
  shushing_face: "🤫",
  thinking: "🤔",
  zipper_mouth_face: "🤐",
  raised_eyebrow: "🤨",
  neutral_face: "😐",
  expressionless: "😑",
  no_mouth: "😶",
  smirk: "😏",
  unamused: "😒",
  roll_eyes: "🙄",
  grimacing: "😬",
  lying_face: "🤥",
  relieved: "😌",
  pensive: "😔",
  sleepy: "😪",
  drooling_face: "🤤",
  sleeping: "😴",
  mask: "😷",
  face_with_thermometer: "🤒",
  face_with_head_bandage: "🤕",
  nauseated_face: "🤢",
  vomiting_face: "🤮",
  sneezing_face: "🤧",
  hot_face: "🥵",
  cold_face: "🥶",
  woozy_face: "🥴",
  dizzy_face: "😵",
  exploding_head: "🤯",
  cowboy_hat_face: "🤠",
  partying_face: "🥳",
  disguised_face: "🥸",
  sunglasses: "😎",
  nerd_face: "🤓",
  monocle_face: "🧐",
  confused: "😕",
  worried: "😟",
  slightly_frowning_face: "🙁",
  frowning_face: "☹️",
  open_mouth: "😮",
  hushed: "😯",
  astonished: "😲",
  flushed: "😳",
  pleading_face: "🥺",
  frowning: "😦",
  anguished: "😧",
  fearful: "😨",
  cold_sweat: "😰",
  disappointed_relieved: "😥",
  cry: "😢",
  sob: "😭",
  scream: "😱",
  confounded: "😖",
  persevere: "😣",
  disappointed: "😞",
  sweat: "😓",
  weary: "😩",
  tired_face: "😫",
  yawning_face: "🥱",
  triumph: "😤",
  rage: "😡",
  pout: "😡",
  angry: "😠",
  cursing_face: "🤬",
  smiling_imp: "😈",
  imp: "👿",
  skull: "💀",
  skull_and_crossbones: "☠️",
  hankey: "💩",
  poop: "💩",
  shit: "💩",
  clown_face: "🤡",
  japanese_ogre: "👹",
  japanese_goblin: "👺",
  ghost: "👻",
  alien: "👽",
  space_invader: "👾",
  robot: "🤖",
  smiley_cat: "😺",
  smile_cat: "😸",
  joy_cat: "😹",
  heart_eyes_cat: "😻",
  smirk_cat: "😼",
  kissing_cat: "😽",
  scream_cat: "🙀",
  crying_cat_face: "😿",
  pouting_cat: "😾",
  see_no_evil: "🙈",
  hear_no_evil: "🙉",
  speak_no_evil: "🙊",
  kiss: "💋",
  love_letter: "💌",
  cupid: "💘",
  gift_heart: "💝",
  sparkling_heart: "💖",
  heartpulse: "💗",
  heartbeat: "💓",
  revolving_hearts: "💞",
  two_hearts: "💕",
  heart_decoration: "💟",
  heavy_heart_exclamation: "❣️",
  broken_heart: "💔",
  heart: "❤️",
  orange_heart: "🧡",
  yellow_heart: "💛",
  green_heart: "💚",
  blue_heart: "💙",
  purple_heart: "💜",
  brown_heart: "🤎",
  black_heart: "🖤",
  white_heart: "🤍",
  anger: "💢",
  boom: "💥",
  collision: "💥",
  dizzy: "💫",
  sweat_drops: "💦",
  dash: "💨",
  hole: "🕳️",
  bomb: "💣",
  speech_balloon: "💬",
  eye_speech_bubble: "👁️‍🗨️",
  left_speech_bubble: "🗨️",
  right_anger_bubble: "🗯️",
  thought_balloon: "💭",
  zzz: "💤",
  wave: "👋",
  raised_back_of_hand: "🤚",
  raised_hand_with_fingers_splayed: "🖐️",
  hand: "✋",
  raised_hand: "✋",
  vulcan_salute: "🖖",
  ok_hand: "👌",
  pinched_fingers: "🤌",
  pinching_hand: "🤏",
  v: "✌️",
  crossed_fingers: "🤞",
  love_you_gesture: "🤟",
  metal: "🤘",
  call_me_hand: "🤙",
  point_left: "👈",
  point_right: "👉",
  point_up_2: "👆",
  middle_finger: "🖕",
  fu: "🖕",
  point_down: "👇",
  point_up: "☝️",
  "+1": "👍",
  thumbsup: "👍",
  "-1": "👎",
  thumbsdown: "👎",
  fist_raised: "✊",
  fist: "✊",
  fist_oncoming: "👊",
  facepunch: "👊",
  punch: "👊",
  fist_left: "🤛",
  fist_right: "🤜",
  clap: "👏",
  raised_hands: "🙌",
  open_hands: "👐",
  palms_up_together: "🤲",
  handshake: "🤝",
  pray: "🙏",
  writing_hand: "✍️",
  nail_care: "💅",
  selfie: "🤳",
  muscle: "💪",
  mechanical_arm: "🦾",
  mechanical_leg: "🦿",
  leg: "🦵",
  foot: "🦶",
  ear: "👂",
  ear_with_hearing_aid: "🦻",
  nose: "👃",
  brain: "🧠",
  anatomical_heart: "🫀",
  lungs: "🫁",
  tooth: "🦷",
  bone: "🦴",
  eyes: "👀",
  eye: "👁️",
  tongue: "👅",
  lips: "👄",
  baby: "👶",
  child: "🧒",
  boy: "👦",
  girl: "👧",
  adult: "🧑",
  blond_haired_person: "👱",
  man: "👨",
  bearded_person: "🧔",
  red_haired_man: "👨‍🦰",
  curly_haired_man: "👨‍🦱",
  white_haired_man: "👨‍🦳",
  bald_man: "👨‍🦲",
  woman: "👩",
  red_haired_woman: "👩‍🦰",
  person_red_hair: "🧑‍🦰",
  curly_haired_woman: "👩‍🦱",
  person_curly_hair: "🧑‍🦱",
  white_haired_woman: "👩‍🦳",
  person_white_hair: "🧑‍🦳",
  bald_woman: "👩‍🦲",
  person_bald: "🧑‍🦲",
  blond_haired_woman: "👱‍♀️",
  blonde_woman: "👱‍♀️",
  blond_haired_man: "👱‍♂️",
  older_adult: "🧓",
  older_man: "👴",
  older_woman: "👵",
  frowning_person: "🙍",
  frowning_man: "🙍‍♂️",
  frowning_woman: "🙍‍♀️",
  pouting_face: "🙎",
  pouting_man: "🙎‍♂️",
  pouting_woman: "🙎‍♀️",
  no_good: "🙅",
  no_good_man: "🙅‍♂️",
  ng_man: "🙅‍♂️",
  no_good_woman: "🙅‍♀️",
  ng_woman: "🙅‍♀️",
  ok_person: "🙆",
  ok_man: "🙆‍♂️",
  ok_woman: "🙆‍♀️",
  tipping_hand_person: "💁",
  information_desk_person: "💁",
  tipping_hand_man: "💁‍♂️",
  sassy_man: "💁‍♂️",
  tipping_hand_woman: "💁‍♀️",
  sassy_woman: "💁‍♀️",
  raising_hand: "🙋",
  raising_hand_man: "🙋‍♂️",
  raising_hand_woman: "🙋‍♀️",
  deaf_person: "🧏",
  deaf_man: "🧏‍♂️",
  deaf_woman: "🧏‍♀️",
  bow: "🙇",
  bowing_man: "🙇‍♂️",
  bowing_woman: "🙇‍♀️",
  facepalm: "🤦",
  man_facepalming: "🤦‍♂️",
  woman_facepalming: "🤦‍♀️",
  shrug: "🤷",
  man_shrugging: "🤷‍♂️",
  woman_shrugging: "🤷‍♀️",
  health_worker: "🧑‍⚕️",
  man_health_worker: "👨‍⚕️",
  woman_health_worker: "👩‍⚕️",
  student: "🧑‍🎓",
  man_student: "👨‍🎓",
  woman_student: "👩‍🎓",
  teacher: "🧑‍🏫",
  man_teacher: "👨‍🏫",
  woman_teacher: "👩‍🏫",
  judge: "🧑‍⚖️",
  man_judge: "👨‍⚖️",
  woman_judge: "👩‍⚖️",
  farmer: "🧑‍🌾",
  man_farmer: "👨‍🌾",
  woman_farmer: "👩‍🌾",
  cook: "🧑‍🍳",
  man_cook: "👨‍🍳",
  woman_cook: "👩‍🍳",
  mechanic: "🧑‍🔧",
  man_mechanic: "👨‍🔧",
  woman_mechanic: "👩‍🔧",
  factory_worker: "🧑‍🏭",
  man_factory_worker: "👨‍🏭",
  woman_factory_worker: "👩‍🏭",
  office_worker: "🧑‍💼",
  man_office_worker: "👨‍💼",
  woman_office_worker: "👩‍💼",
  scientist: "🧑‍🔬",
  man_scientist: "👨‍🔬",
  woman_scientist: "👩‍🔬",
  technologist: "🧑‍💻",
  man_technologist: "👨‍💻",
  woman_technologist: "👩‍💻",
  singer: "🧑‍🎤",
  man_singer: "👨‍🎤",
  woman_singer: "👩‍🎤",
  artist: "🧑‍🎨",
  man_artist: "👨‍🎨",
  woman_artist: "👩‍🎨",
  pilot: "🧑‍✈️",
  man_pilot: "👨‍✈️",
  woman_pilot: "👩‍✈️",
  astronaut: "🧑‍🚀",
  man_astronaut: "👨‍🚀",
  woman_astronaut: "👩‍🚀",
  firefighter: "🧑‍🚒",
  man_firefighter: "👨‍🚒",
  woman_firefighter: "👩‍🚒",
  police_officer: "👮",
  cop: "👮",
  policeman: "👮‍♂️",
  policewoman: "👮‍♀️",
  detective: "🕵️",
  male_detective: "🕵️‍♂️",
  female_detective: "🕵️‍♀️",
  guard: "💂",
  guardsman: "💂‍♂️",
  guardswoman: "💂‍♀️",
  ninja: "🥷",
  construction_worker: "👷",
  construction_worker_man: "👷‍♂️",
  construction_worker_woman: "👷‍♀️",
  prince: "🤴",
  princess: "👸",
  person_with_turban: "👳",
  man_with_turban: "👳‍♂️",
  woman_with_turban: "👳‍♀️",
  man_with_gua_pi_mao: "👲",
  woman_with_headscarf: "🧕",
  person_in_tuxedo: "🤵",
  man_in_tuxedo: "🤵‍♂️",
  woman_in_tuxedo: "🤵‍♀️",
  person_with_veil: "👰",
  man_with_veil: "👰‍♂️",
  woman_with_veil: "👰‍♀️",
  bride_with_veil: "👰‍♀️",
  pregnant_woman: "🤰",
  breast_feeding: "🤱",
  woman_feeding_baby: "👩‍🍼",
  man_feeding_baby: "👨‍🍼",
  person_feeding_baby: "🧑‍🍼",
  angel: "👼",
  santa: "🎅",
  mrs_claus: "🤶",
  mx_claus: "🧑‍🎄",
  superhero: "🦸",
  superhero_man: "🦸‍♂️",
  superhero_woman: "🦸‍♀️",
  supervillain: "🦹",
  supervillain_man: "🦹‍♂️",
  supervillain_woman: "🦹‍♀️",
  mage: "🧙",
  mage_man: "🧙‍♂️",
  mage_woman: "🧙‍♀️",
  fairy: "🧚",
  fairy_man: "🧚‍♂️",
  fairy_woman: "🧚‍♀️",
  vampire: "🧛",
  vampire_man: "🧛‍♂️",
  vampire_woman: "🧛‍♀️",
  merperson: "🧜",
  merman: "🧜‍♂️",
  elf: "🧝",
  elf_man: "🧝‍♂️",
  elf_woman: "🧝‍♀️",
  genie: "🧞",
  genie_man: "🧞‍♂️",
  genie_woman: "🧞‍♀️",
  zombie: "🧟",
  zombie_man: "🧟‍♂️",
  zombie_woman: "🧟‍♀️",
  massage: "💆",
  massage_man: "💆‍♂️",
  massage_woman: "💆‍♀️",
  haircut: "💇",
  haircut_man: "💇‍♂️",
  haircut_woman: "💇‍♀️",
  walking: "🚶",
  walking_man: "🚶‍♂️",
  walking_woman: "🚶‍♀️",
  standing_person: "🧍",
  standing_man: "🧍‍♂️",
  standing_woman: "🧍‍♀️",
  kneeling_person: "🧎",
  kneeling_man: "🧎‍♂️",
  kneeling_woman: "🧎‍♀️",
  person_with_probing_cane: "🧑‍🦯",
  man_with_probing_cane: "👨‍🦯",
  woman_with_probing_cane: "👩‍🦯",
  person_in_motorized_wheelchair: "🧑‍🦼",
  man_in_motorized_wheelchair: "👨‍🦼",
  woman_in_motorized_wheelchair: "👩‍🦼",
  person_in_manual_wheelchair: "🧑‍🦽",
  man_in_manual_wheelchair: "👨‍🦽",
  woman_in_manual_wheelchair: "👩‍🦽",
  runner: "🏃",
  running: "🏃",
  running_man: "🏃‍♂️",
  running_woman: "🏃‍♀️",
  woman_dancing: "💃",
  dancer: "💃",
  man_dancing: "🕺",
  business_suit_levitating: "🕴️",
  dancers: "👯",
  dancing_men: "👯‍♂️",
  dancing_women: "👯‍♀️",
  sauna_person: "🧖",
  sauna_man: "🧖‍♂️",
  sauna_woman: "🧖‍♀️",
  climbing: "🧗",
  climbing_man: "🧗‍♂️",
  climbing_woman: "🧗‍♀️",
  person_fencing: "🤺",
  horse_racing: "🏇",
  skier: "⛷️",
  snowboarder: "🏂",
  golfing: "🏌️",
  golfing_man: "🏌️‍♂️",
  golfing_woman: "🏌️‍♀️",
  surfer: "🏄",
  surfing_man: "🏄‍♂️",
  surfing_woman: "🏄‍♀️",
  rowboat: "🚣",
  rowing_man: "🚣‍♂️",
  rowing_woman: "🚣‍♀️",
  swimmer: "🏊",
  swimming_man: "🏊‍♂️",
  swimming_woman: "🏊‍♀️",
  bouncing_ball_person: "⛹️",
  bouncing_ball_man: "⛹️‍♂️",
  basketball_man: "⛹️‍♂️",
  bouncing_ball_woman: "⛹️‍♀️",
  basketball_woman: "⛹️‍♀️",
  weight_lifting: "🏋️",
  weight_lifting_man: "🏋️‍♂️",
  weight_lifting_woman: "🏋️‍♀️",
  bicyclist: "🚴",
  biking_man: "🚴‍♂️",
  biking_woman: "🚴‍♀️",
  mountain_bicyclist: "🚵",
  mountain_biking_man: "🚵‍♂️",
  mountain_biking_woman: "🚵‍♀️",
  cartwheeling: "🤸",
  man_cartwheeling: "🤸‍♂️",
  woman_cartwheeling: "🤸‍♀️",
  wrestling: "🤼",
  men_wrestling: "🤼‍♂️",
  women_wrestling: "🤼‍♀️",
  water_polo: "🤽",
  man_playing_water_polo: "🤽‍♂️",
  woman_playing_water_polo: "🤽‍♀️",
  handball_person: "🤾",
  man_playing_handball: "🤾‍♂️",
  woman_playing_handball: "🤾‍♀️",
  juggling_person: "🤹",
  man_juggling: "🤹‍♂️",
  woman_juggling: "🤹‍♀️",
  lotus_position: "🧘",
  lotus_position_man: "🧘‍♂️",
  lotus_position_woman: "🧘‍♀️",
  bath: "🛀",
  sleeping_bed: "🛌",
  people_holding_hands: "🧑‍🤝‍🧑",
  two_women_holding_hands: "👭",
  couple: "👫",
  two_men_holding_hands: "👬",
  couplekiss: "💏",
  couplekiss_man_woman: "👩‍❤️‍💋‍👨",
  couplekiss_man_man: "👨‍❤️‍💋‍👨",
  couplekiss_woman_woman: "👩‍❤️‍💋‍👩",
  couple_with_heart: "💑",
  couple_with_heart_woman_man: "👩‍❤️‍👨",
  couple_with_heart_man_man: "👨‍❤️‍👨",
  couple_with_heart_woman_woman: "👩‍❤️‍👩",
  family: "👪",
  family_man_woman_boy: "👨‍👩‍👦",
  family_man_woman_girl: "👨‍👩‍👧",
  family_man_woman_girl_boy: "👨‍👩‍👧‍👦",
  family_man_woman_boy_boy: "👨‍👩‍👦‍👦",
  family_man_woman_girl_girl: "👨‍👩‍👧‍👧",
  family_man_man_boy: "👨‍👨‍👦",
  family_man_man_girl: "👨‍👨‍👧",
  family_man_man_girl_boy: "👨‍👨‍👧‍👦",
  family_man_man_boy_boy: "👨‍👨‍👦‍👦",
  family_man_man_girl_girl: "👨‍👨‍👧‍👧",
  family_woman_woman_boy: "👩‍👩‍👦",
  family_woman_woman_girl: "👩‍👩‍👧",
  family_woman_woman_girl_boy: "👩‍👩‍👧‍👦",
  family_woman_woman_boy_boy: "👩‍👩‍👦‍👦",
  family_woman_woman_girl_girl: "👩‍👩‍👧‍👧",
  family_man_boy: "👨‍👦",
  family_man_boy_boy: "👨‍👦‍👦",
  family_man_girl: "👨‍👧",
  family_man_girl_boy: "👨‍👧‍👦",
  family_man_girl_girl: "👨‍👧‍👧",
  family_woman_boy: "👩‍👦",
  family_woman_boy_boy: "👩‍👦‍👦",
  family_woman_girl: "👩‍👧",
  family_woman_girl_boy: "👩‍👧‍👦",
  family_woman_girl_girl: "👩‍👧‍👧",
  speaking_head: "🗣️",
  bust_in_silhouette: "👤",
  busts_in_silhouette: "👥",
  people_hugging: "🫂",
  footprints: "👣",
  monkey_face: "🐵",
  monkey: "🐒",
  gorilla: "🦍",
  orangutan: "🦧",
  dog: "🐶",
  dog2: "🐕",
  guide_dog: "🦮",
  service_dog: "🐕‍🦺",
  poodle: "🐩",
  wolf: "🐺",
  fox_face: "🦊",
  raccoon: "🦝",
  cat: "🐱",
  cat2: "🐈",
  black_cat: "🐈‍⬛",
  lion: "🦁",
  tiger: "🐯",
  tiger2: "🐅",
  leopard: "🐆",
  horse: "🐴",
  racehorse: "🐎",
  unicorn: "🦄",
  zebra: "🦓",
  deer: "🦌",
  bison: "🦬",
  cow: "🐮",
  ox: "🐂",
  water_buffalo: "🐃",
  cow2: "🐄",
  pig: "🐷",
  pig2: "🐖",
  boar: "🐗",
  pig_nose: "🐽",
  ram: "🐏",
  sheep: "🐑",
  goat: "🐐",
  dromedary_camel: "🐪",
  camel: "🐫",
  llama: "🦙",
  giraffe: "🦒",
  elephant: "🐘",
  mammoth: "🦣",
  rhinoceros: "🦏",
  hippopotamus: "🦛",
  mouse: "🐭",
  mouse2: "🐁",
  rat: "🐀",
  hamster: "🐹",
  rabbit: "🐰",
  rabbit2: "🐇",
  chipmunk: "🐿️",
  beaver: "🦫",
  hedgehog: "🦔",
  bat: "🦇",
  bear: "🐻",
  polar_bear: "🐻‍❄️",
  koala: "🐨",
  panda_face: "🐼",
  sloth: "🦥",
  otter: "🦦",
  skunk: "🦨",
  kangaroo: "🦘",
  badger: "🦡",
  feet: "🐾",
  paw_prints: "🐾",
  turkey: "🦃",
  chicken: "🐔",
  rooster: "🐓",
  hatching_chick: "🐣",
  baby_chick: "🐤",
  hatched_chick: "🐥",
  bird: "🐦",
  penguin: "🐧",
  dove: "🕊️",
  eagle: "🦅",
  duck: "🦆",
  swan: "🦢",
  owl: "🦉",
  dodo: "🦤",
  feather: "🪶",
  flamingo: "🦩",
  peacock: "🦚",
  parrot: "🦜",
  frog: "🐸",
  crocodile: "🐊",
  turtle: "🐢",
  lizard: "🦎",
  snake: "🐍",
  dragon_face: "🐲",
  dragon: "🐉",
  sauropod: "🦕",
  "t-rex": "🦖",
  whale: "🐳",
  whale2: "🐋",
  dolphin: "🐬",
  flipper: "🐬",
  seal: "🦭",
  fish: "🐟",
  tropical_fish: "🐠",
  blowfish: "🐡",
  shark: "🦈",
  octopus: "🐙",
  shell: "🐚",
  snail: "🐌",
  butterfly: "🦋",
  bug: "🐛",
  ant: "🐜",
  bee: "🐝",
  honeybee: "🐝",
  beetle: "🪲",
  lady_beetle: "🐞",
  cricket: "🦗",
  cockroach: "🪳",
  spider: "🕷️",
  spider_web: "🕸️",
  scorpion: "🦂",
  mosquito: "🦟",
  fly: "🪰",
  worm: "🪱",
  microbe: "🦠",
  bouquet: "💐",
  cherry_blossom: "🌸",
  white_flower: "💮",
  rosette: "🏵️",
  rose: "🌹",
  wilted_flower: "🥀",
  hibiscus: "🌺",
  sunflower: "🌻",
  blossom: "🌼",
  tulip: "🌷",
  seedling: "🌱",
  potted_plant: "🪴",
  evergreen_tree: "🌲",
  deciduous_tree: "🌳",
  palm_tree: "🌴",
  cactus: "🌵",
  ear_of_rice: "🌾",
  herb: "🌿",
  shamrock: "☘️",
  four_leaf_clover: "🍀",
  maple_leaf: "🍁",
  fallen_leaf: "🍂",
  leaves: "🍃",
  grapes: "🍇",
  melon: "🍈",
  watermelon: "🍉",
  tangerine: "🍊",
  orange: "🍊",
  mandarin: "🍊",
  lemon: "🍋",
  banana: "🍌",
  pineapple: "🍍",
  mango: "🥭",
  apple: "🍎",
  green_apple: "🍏",
  pear: "🍐",
  peach: "🍑",
  cherries: "🍒",
  strawberry: "🍓",
  blueberries: "🫐",
  kiwi_fruit: "🥝",
  tomato: "🍅",
  olive: "🫒",
  coconut: "🥥",
  avocado: "🥑",
  eggplant: "🍆",
  potato: "🥔",
  carrot: "🥕",
  corn: "🌽",
  hot_pepper: "🌶️",
  bell_pepper: "🫑",
  cucumber: "🥒",
  leafy_green: "🥬",
  broccoli: "🥦",
  garlic: "🧄",
  onion: "🧅",
  mushroom: "🍄",
  peanuts: "🥜",
  chestnut: "🌰",
  bread: "🍞",
  croissant: "🥐",
  baguette_bread: "🥖",
  flatbread: "🫓",
  pretzel: "🥨",
  bagel: "🥯",
  pancakes: "🥞",
  waffle: "🧇",
  cheese: "🧀",
  meat_on_bone: "🍖",
  poultry_leg: "🍗",
  cut_of_meat: "🥩",
  bacon: "🥓",
  hamburger: "🍔",
  fries: "🍟",
  pizza: "🍕",
  hotdog: "🌭",
  sandwich: "🥪",
  taco: "🌮",
  burrito: "🌯",
  tamale: "🫔",
  stuffed_flatbread: "🥙",
  falafel: "🧆",
  egg: "🥚",
  fried_egg: "🍳",
  shallow_pan_of_food: "🥘",
  stew: "🍲",
  fondue: "🫕",
  bowl_with_spoon: "🥣",
  green_salad: "🥗",
  popcorn: "🍿",
  butter: "🧈",
  salt: "🧂",
  canned_food: "🥫",
  bento: "🍱",
  rice_cracker: "🍘",
  rice_ball: "🍙",
  rice: "🍚",
  curry: "🍛",
  ramen: "🍜",
  spaghetti: "🍝",
  sweet_potato: "🍠",
  oden: "🍢",
  sushi: "🍣",
  fried_shrimp: "🍤",
  fish_cake: "🍥",
  moon_cake: "🥮",
  dango: "🍡",
  dumpling: "🥟",
  fortune_cookie: "🥠",
  takeout_box: "🥡",
  crab: "🦀",
  lobster: "🦞",
  shrimp: "🦐",
  squid: "🦑",
  oyster: "🦪",
  icecream: "🍦",
  shaved_ice: "🍧",
  ice_cream: "🍨",
  doughnut: "🍩",
  cookie: "🍪",
  birthday: "🎂",
  cake: "🍰",
  cupcake: "🧁",
  pie: "🥧",
  chocolate_bar: "🍫",
  candy: "🍬",
  lollipop: "🍭",
  custard: "🍮",
  honey_pot: "🍯",
  baby_bottle: "🍼",
  milk_glass: "🥛",
  coffee: "☕",
  teapot: "🫖",
  tea: "🍵",
  sake: "🍶",
  champagne: "🍾",
  wine_glass: "🍷",
  cocktail: "🍸",
  tropical_drink: "🍹",
  beer: "🍺",
  beers: "🍻",
  clinking_glasses: "🥂",
  tumbler_glass: "🥃",
  cup_with_straw: "🥤",
  bubble_tea: "🧋",
  beverage_box: "🧃",
  mate: "🧉",
  ice_cube: "🧊",
  chopsticks: "🥢",
  plate_with_cutlery: "🍽️",
  fork_and_knife: "🍴",
  spoon: "🥄",
  hocho: "🔪",
  knife: "🔪",
  amphora: "🏺",
  earth_africa: "🌍",
  earth_americas: "🌎",
  earth_asia: "🌏",
  globe_with_meridians: "🌐",
  world_map: "🗺️",
  japan: "🗾",
  compass: "🧭",
  mountain_snow: "🏔️",
  mountain: "⛰️",
  volcano: "🌋",
  mount_fuji: "🗻",
  camping: "🏕️",
  beach_umbrella: "🏖️",
  desert: "🏜️",
  desert_island: "🏝️",
  national_park: "🏞️",
  stadium: "🏟️",
  classical_building: "🏛️",
  building_construction: "🏗️",
  bricks: "🧱",
  rock: "🪨",
  wood: "🪵",
  hut: "🛖",
  houses: "🏘️",
  derelict_house: "🏚️",
  house: "🏠",
  house_with_garden: "🏡",
  office: "🏢",
  post_office: "🏣",
  european_post_office: "🏤",
  hospital: "🏥",
  bank: "🏦",
  hotel: "🏨",
  love_hotel: "🏩",
  convenience_store: "🏪",
  school: "🏫",
  department_store: "🏬",
  factory: "🏭",
  japanese_castle: "🏯",
  european_castle: "🏰",
  wedding: "💒",
  tokyo_tower: "🗼",
  statue_of_liberty: "🗽",
  church: "⛪",
  mosque: "🕌",
  hindu_temple: "🛕",
  synagogue: "🕍",
  shinto_shrine: "⛩️",
  kaaba: "🕋",
  fountain: "⛲",
  tent: "⛺",
  foggy: "🌁",
  night_with_stars: "🌃",
  cityscape: "🏙️",
  sunrise_over_mountains: "🌄",
  sunrise: "🌅",
  city_sunset: "🌆",
  city_sunrise: "🌇",
  bridge_at_night: "🌉",
  hotsprings: "♨️",
  carousel_horse: "🎠",
  ferris_wheel: "🎡",
  roller_coaster: "🎢",
  barber: "💈",
  circus_tent: "🎪",
  steam_locomotive: "🚂",
  railway_car: "🚃",
  bullettrain_side: "🚄",
  bullettrain_front: "🚅",
  train2: "🚆",
  metro: "🚇",
  light_rail: "🚈",
  station: "🚉",
  tram: "🚊",
  monorail: "🚝",
  mountain_railway: "🚞",
  train: "🚋",
  bus: "🚌",
  oncoming_bus: "🚍",
  trolleybus: "🚎",
  minibus: "🚐",
  ambulance: "🚑",
  fire_engine: "🚒",
  police_car: "🚓",
  oncoming_police_car: "🚔",
  taxi: "🚕",
  oncoming_taxi: "🚖",
  car: "🚗",
  red_car: "🚗",
  oncoming_automobile: "🚘",
  blue_car: "🚙",
  pickup_truck: "🛻",
  truck: "🚚",
  articulated_lorry: "🚛",
  tractor: "🚜",
  racing_car: "🏎️",
  motorcycle: "🏍️",
  motor_scooter: "🛵",
  manual_wheelchair: "🦽",
  motorized_wheelchair: "🦼",
  auto_rickshaw: "🛺",
  bike: "🚲",
  kick_scooter: "🛴",
  skateboard: "🛹",
  roller_skate: "🛼",
  busstop: "🚏",
  motorway: "🛣️",
  railway_track: "🛤️",
  oil_drum: "🛢️",
  fuelpump: "⛽",
  rotating_light: "🚨",
  traffic_light: "🚥",
  vertical_traffic_light: "🚦",
  stop_sign: "🛑",
  construction: "🚧",
  anchor: "⚓",
  boat: "⛵",
  sailboat: "⛵",
  canoe: "🛶",
  speedboat: "🚤",
  passenger_ship: "🛳️",
  ferry: "⛴️",
  motor_boat: "🛥️",
  ship: "🚢",
  airplane: "✈️",
  small_airplane: "🛩️",
  flight_departure: "🛫",
  flight_arrival: "🛬",
  parachute: "🪂",
  seat: "💺",
  helicopter: "🚁",
  suspension_railway: "🚟",
  mountain_cableway: "🚠",
  aerial_tramway: "🚡",
  artificial_satellite: "🛰️",
  rocket: "🚀",
  flying_saucer: "🛸",
  bellhop_bell: "🛎️",
  luggage: "🧳",
  hourglass: "⌛",
  hourglass_flowing_sand: "⏳",
  watch: "⌚",
  alarm_clock: "⏰",
  stopwatch: "⏱️",
  timer_clock: "⏲️",
  mantelpiece_clock: "🕰️",
  clock12: "🕛",
  clock1230: "🕧",
  clock1: "🕐",
  clock130: "🕜",
  clock2: "🕑",
  clock230: "🕝",
  clock3: "🕒",
  clock330: "🕞",
  clock4: "🕓",
  clock430: "🕟",
  clock5: "🕔",
  clock530: "🕠",
  clock6: "🕕",
  clock630: "🕡",
  clock7: "🕖",
  clock730: "🕢",
  clock8: "🕗",
  clock830: "🕣",
  clock9: "🕘",
  clock930: "🕤",
  clock10: "🕙",
  clock1030: "🕥",
  clock11: "🕚",
  clock1130: "🕦",
  new_moon: "🌑",
  waxing_crescent_moon: "🌒",
  first_quarter_moon: "🌓",
  moon: "🌔",
  waxing_gibbous_moon: "🌔",
  full_moon: "🌕",
  waning_gibbous_moon: "🌖",
  last_quarter_moon: "🌗",
  waning_crescent_moon: "🌘",
  crescent_moon: "🌙",
  new_moon_with_face: "🌚",
  first_quarter_moon_with_face: "🌛",
  last_quarter_moon_with_face: "🌜",
  thermometer: "🌡️",
  sunny: "☀️",
  full_moon_with_face: "🌝",
  sun_with_face: "🌞",
  ringed_planet: "🪐",
  star: "⭐",
  star2: "🌟",
  stars: "🌠",
  milky_way: "🌌",
  cloud: "☁️",
  partly_sunny: "⛅",
  cloud_with_lightning_and_rain: "⛈️",
  sun_behind_small_cloud: "🌤️",
  sun_behind_large_cloud: "🌥️",
  sun_behind_rain_cloud: "🌦️",
  cloud_with_rain: "🌧️",
  cloud_with_snow: "🌨️",
  cloud_with_lightning: "🌩️",
  tornado: "🌪️",
  fog: "🌫️",
  wind_face: "🌬️",
  cyclone: "🌀",
  rainbow: "🌈",
  closed_umbrella: "🌂",
  open_umbrella: "☂️",
  umbrella: "☔",
  parasol_on_ground: "⛱️",
  zap: "⚡",
  snowflake: "❄️",
  snowman_with_snow: "☃️",
  snowman: "⛄",
  comet: "☄️",
  fire: "🔥",
  droplet: "💧",
  ocean: "🌊",
  jack_o_lantern: "🎃",
  christmas_tree: "🎄",
  fireworks: "🎆",
  sparkler: "🎇",
  firecracker: "🧨",
  sparkles: "✨",
  balloon: "🎈",
  tada: "🎉",
  confetti_ball: "🎊",
  tanabata_tree: "🎋",
  bamboo: "🎍",
  dolls: "🎎",
  flags: "🎏",
  wind_chime: "🎐",
  rice_scene: "🎑",
  red_envelope: "🧧",
  ribbon: "🎀",
  gift: "🎁",
  reminder_ribbon: "🎗️",
  tickets: "🎟️",
  ticket: "🎫",
  medal_military: "🎖️",
  trophy: "🏆",
  medal_sports: "🏅",
  "1st_place_medal": "🥇",
  "2nd_place_medal": "🥈",
  "3rd_place_medal": "🥉",
  soccer: "⚽",
  baseball: "⚾",
  softball: "🥎",
  basketball: "🏀",
  volleyball: "🏐",
  football: "🏈",
  rugby_football: "🏉",
  tennis: "🎾",
  flying_disc: "🥏",
  bowling: "🎳",
  cricket_game: "🏏",
  field_hockey: "🏑",
  ice_hockey: "🏒",
  lacrosse: "🥍",
  ping_pong: "🏓",
  badminton: "🏸",
  boxing_glove: "🥊",
  martial_arts_uniform: "🥋",
  goal_net: "🥅",
  golf: "⛳",
  ice_skate: "⛸️",
  fishing_pole_and_fish: "🎣",
  diving_mask: "🤿",
  running_shirt_with_sash: "🎽",
  ski: "🎿",
  sled: "🛷",
  curling_stone: "🥌",
  dart: "🎯",
  yo_yo: "🪀",
  kite: "🪁",
  "8ball": "🎱",
  crystal_ball: "🔮",
  magic_wand: "🪄",
  nazar_amulet: "🧿",
  video_game: "🎮",
  joystick: "🕹️",
  slot_machine: "🎰",
  game_die: "🎲",
  jigsaw: "🧩",
  teddy_bear: "🧸",
  pinata: "🪅",
  nesting_dolls: "🪆",
  spades: "♠️",
  hearts: "♥️",
  diamonds: "♦️",
  clubs: "♣️",
  chess_pawn: "♟️",
  black_joker: "🃏",
  mahjong: "🀄",
  flower_playing_cards: "🎴",
  performing_arts: "🎭",
  framed_picture: "🖼️",
  art: "🎨",
  thread: "🧵",
  sewing_needle: "🪡",
  yarn: "🧶",
  knot: "🪢",
  eyeglasses: "👓",
  dark_sunglasses: "🕶️",
  goggles: "🥽",
  lab_coat: "🥼",
  safety_vest: "🦺",
  necktie: "👔",
  shirt: "👕",
  tshirt: "👕",
  jeans: "👖",
  scarf: "🧣",
  gloves: "🧤",
  coat: "🧥",
  socks: "🧦",
  dress: "👗",
  kimono: "👘",
  sari: "🥻",
  one_piece_swimsuit: "🩱",
  swim_brief: "🩲",
  shorts: "🩳",
  bikini: "👙",
  womans_clothes: "👚",
  purse: "👛",
  handbag: "👜",
  pouch: "👝",
  shopping: "🛍️",
  school_satchel: "🎒",
  thong_sandal: "🩴",
  mans_shoe: "👞",
  shoe: "👞",
  athletic_shoe: "👟",
  hiking_boot: "🥾",
  flat_shoe: "🥿",
  high_heel: "👠",
  sandal: "👡",
  ballet_shoes: "🩰",
  boot: "👢",
  crown: "👑",
  womans_hat: "👒",
  tophat: "🎩",
  mortar_board: "🎓",
  billed_cap: "🧢",
  military_helmet: "🪖",
  rescue_worker_helmet: "⛑️",
  prayer_beads: "📿",
  lipstick: "💄",
  ring: "💍",
  gem: "💎",
  mute: "🔇",
  speaker: "🔈",
  sound: "🔉",
  loud_sound: "🔊",
  loudspeaker: "📢",
  mega: "📣",
  postal_horn: "📯",
  bell: "🔔",
  no_bell: "🔕",
  musical_score: "🎼",
  musical_note: "🎵",
  notes: "🎶",
  studio_microphone: "🎙️",
  level_slider: "🎚️",
  control_knobs: "🎛️",
  microphone: "🎤",
  headphones: "🎧",
  radio: "📻",
  saxophone: "🎷",
  accordion: "🪗",
  guitar: "🎸",
  musical_keyboard: "🎹",
  trumpet: "🎺",
  violin: "🎻",
  banjo: "🪕",
  drum: "🥁",
  long_drum: "🪘",
  iphone: "📱",
  calling: "📲",
  phone: "☎️",
  telephone: "☎️",
  telephone_receiver: "📞",
  pager: "📟",
  fax: "📠",
  battery: "🔋",
  electric_plug: "🔌",
  computer: "💻",
  desktop_computer: "🖥️",
  printer: "🖨️",
  keyboard: "⌨️",
  computer_mouse: "🖱️",
  trackball: "🖲️",
  minidisc: "💽",
  floppy_disk: "💾",
  cd: "💿",
  dvd: "📀",
  abacus: "🧮",
  movie_camera: "🎥",
  film_strip: "🎞️",
  film_projector: "📽️",
  clapper: "🎬",
  tv: "📺",
  camera: "📷",
  camera_flash: "📸",
  video_camera: "📹",
  vhs: "📼",
  mag: "🔍",
  mag_right: "🔎",
  candle: "🕯️",
  bulb: "💡",
  flashlight: "🔦",
  izakaya_lantern: "🏮",
  lantern: "🏮",
  diya_lamp: "🪔",
  notebook_with_decorative_cover: "📔",
  closed_book: "📕",
  book: "📖",
  open_book: "📖",
  green_book: "📗",
  blue_book: "📘",
  orange_book: "📙",
  books: "📚",
  notebook: "📓",
  ledger: "📒",
  page_with_curl: "📃",
  scroll: "📜",
  page_facing_up: "📄",
  newspaper: "📰",
  newspaper_roll: "🗞️",
  bookmark_tabs: "📑",
  bookmark: "🔖",
  label: "🏷️",
  moneybag: "💰",
  coin: "🪙",
  yen: "💴",
  dollar: "💵",
  euro: "💶",
  pound: "💷",
  money_with_wings: "💸",
  credit_card: "💳",
  receipt: "🧾",
  chart: "💹",
  envelope: "✉️",
  email: "📧",
  "e-mail": "📧",
  incoming_envelope: "📨",
  envelope_with_arrow: "📩",
  outbox_tray: "📤",
  inbox_tray: "📥",
  package: "📦",
  mailbox: "📫",
  mailbox_closed: "📪",
  mailbox_with_mail: "📬",
  mailbox_with_no_mail: "📭",
  postbox: "📮",
  ballot_box: "🗳️",
  pencil2: "✏️",
  black_nib: "✒️",
  fountain_pen: "🖋️",
  pen: "🖊️",
  paintbrush: "🖌️",
  crayon: "🖍️",
  memo: "📝",
  pencil: "📝",
  briefcase: "💼",
  file_folder: "📁",
  open_file_folder: "📂",
  card_index_dividers: "🗂️",
  date: "📅",
  calendar: "📆",
  spiral_notepad: "🗒️",
  spiral_calendar: "🗓️",
  card_index: "📇",
  chart_with_upwards_trend: "📈",
  chart_with_downwards_trend: "📉",
  bar_chart: "📊",
  clipboard: "📋",
  pushpin: "📌",
  round_pushpin: "📍",
  paperclip: "📎",
  paperclips: "🖇️",
  straight_ruler: "📏",
  triangular_ruler: "📐",
  scissors: "✂️",
  card_file_box: "🗃️",
  file_cabinet: "🗄️",
  wastebasket: "🗑️",
  lock: "🔒",
  unlock: "🔓",
  lock_with_ink_pen: "🔏",
  closed_lock_with_key: "🔐",
  key: "🔑",
  old_key: "🗝️",
  hammer: "🔨",
  axe: "🪓",
  pick: "⛏️",
  hammer_and_pick: "⚒️",
  hammer_and_wrench: "🛠️",
  dagger: "🗡️",
  crossed_swords: "⚔️",
  gun: "🔫",
  boomerang: "🪃",
  bow_and_arrow: "🏹",
  shield: "🛡️",
  carpentry_saw: "🪚",
  wrench: "🔧",
  screwdriver: "🪛",
  nut_and_bolt: "🔩",
  gear: "⚙️",
  clamp: "🗜️",
  balance_scale: "⚖️",
  probing_cane: "🦯",
  link: "🔗",
  chains: "⛓️",
  hook: "🪝",
  toolbox: "🧰",
  magnet: "🧲",
  ladder: "🪜",
  alembic: "⚗️",
  test_tube: "🧪",
  petri_dish: "🧫",
  dna: "🧬",
  microscope: "🔬",
  telescope: "🔭",
  satellite: "📡",
  syringe: "💉",
  drop_of_blood: "🩸",
  pill: "💊",
  adhesive_bandage: "🩹",
  stethoscope: "🩺",
  door: "🚪",
  elevator: "🛗",
  mirror: "🪞",
  window: "🪟",
  bed: "🛏️",
  couch_and_lamp: "🛋️",
  chair: "🪑",
  toilet: "🚽",
  plunger: "🪠",
  shower: "🚿",
  bathtub: "🛁",
  mouse_trap: "🪤",
  razor: "🪒",
  lotion_bottle: "🧴",
  safety_pin: "🧷",
  broom: "🧹",
  basket: "🧺",
  roll_of_paper: "🧻",
  bucket: "🪣",
  soap: "🧼",
  toothbrush: "🪥",
  sponge: "🧽",
  fire_extinguisher: "🧯",
  shopping_cart: "🛒",
  smoking: "🚬",
  coffin: "⚰️",
  headstone: "🪦",
  funeral_urn: "⚱️",
  moyai: "🗿",
  placard: "🪧",
  atm: "🏧",
  put_litter_in_its_place: "🚮",
  potable_water: "🚰",
  wheelchair: "♿",
  mens: "🚹",
  womens: "🚺",
  restroom: "🚻",
  baby_symbol: "🚼",
  wc: "🚾",
  passport_control: "🛂",
  customs: "🛃",
  baggage_claim: "🛄",
  left_luggage: "🛅",
  warning: "⚠️",
  children_crossing: "🚸",
  no_entry: "⛔",
  no_entry_sign: "🚫",
  no_bicycles: "🚳",
  no_smoking: "🚭",
  do_not_litter: "🚯",
  "non-potable_water": "🚱",
  no_pedestrians: "🚷",
  no_mobile_phones: "📵",
  underage: "🔞",
  radioactive: "☢️",
  biohazard: "☣️",
  arrow_up: "⬆️",
  arrow_upper_right: "↗️",
  arrow_right: "➡️",
  arrow_lower_right: "↘️",
  arrow_down: "⬇️",
  arrow_lower_left: "↙️",
  arrow_left: "⬅️",
  arrow_upper_left: "↖️",
  arrow_up_down: "↕️",
  left_right_arrow: "↔️",
  leftwards_arrow_with_hook: "↩️",
  arrow_right_hook: "↪️",
  arrow_heading_up: "⤴️",
  arrow_heading_down: "⤵️",
  arrows_clockwise: "🔃",
  arrows_counterclockwise: "🔄",
  back: "🔙",
  end: "🔚",
  on: "🔛",
  soon: "🔜",
  top: "🔝",
  place_of_worship: "🛐",
  atom_symbol: "⚛️",
  om: "🕉️",
  star_of_david: "✡️",
  wheel_of_dharma: "☸️",
  yin_yang: "☯️",
  latin_cross: "✝️",
  orthodox_cross: "☦️",
  star_and_crescent: "☪️",
  peace_symbol: "☮️",
  menorah: "🕎",
  six_pointed_star: "🔯",
  aries: "♈",
  taurus: "♉",
  gemini: "♊",
  cancer: "♋",
  leo: "♌",
  virgo: "♍",
  libra: "♎",
  scorpius: "♏",
  sagittarius: "♐",
  capricorn: "♑",
  aquarius: "♒",
  pisces: "♓",
  ophiuchus: "⛎",
  twisted_rightwards_arrows: "🔀",
  repeat: "🔁",
  repeat_one: "🔂",
  arrow_forward: "▶️",
  fast_forward: "⏩",
  next_track_button: "⏭️",
  play_or_pause_button: "⏯️",
  arrow_backward: "◀️",
  rewind: "⏪",
  previous_track_button: "⏮️",
  arrow_up_small: "🔼",
  arrow_double_up: "⏫",
  arrow_down_small: "🔽",
  arrow_double_down: "⏬",
  pause_button: "⏸️",
  stop_button: "⏹️",
  record_button: "⏺️",
  eject_button: "⏏️",
  cinema: "🎦",
  low_brightness: "🔅",
  high_brightness: "🔆",
  signal_strength: "📶",
  vibration_mode: "📳",
  mobile_phone_off: "📴",
  female_sign: "♀️",
  male_sign: "♂️",
  transgender_symbol: "⚧️",
  heavy_multiplication_x: "✖️",
  heavy_plus_sign: "➕",
  heavy_minus_sign: "➖",
  heavy_division_sign: "➗",
  infinity: "♾️",
  bangbang: "‼️",
  interrobang: "⁉️",
  question: "❓",
  grey_question: "❔",
  grey_exclamation: "❕",
  exclamation: "❗",
  heavy_exclamation_mark: "❗",
  wavy_dash: "〰️",
  currency_exchange: "💱",
  heavy_dollar_sign: "💲",
  medical_symbol: "⚕️",
  recycle: "♻️",
  fleur_de_lis: "⚜️",
  trident: "🔱",
  name_badge: "📛",
  beginner: "🔰",
  o: "⭕",
  white_check_mark: "✅",
  ballot_box_with_check: "☑️",
  heavy_check_mark: "✔️",
  x: "❌",
  negative_squared_cross_mark: "❎",
  curly_loop: "➰",
  loop: "➿",
  part_alternation_mark: "〽️",
  eight_spoked_asterisk: "✳️",
  eight_pointed_black_star: "✴️",
  sparkle: "❇️",
  copyright: "©️",
  registered: "®️",
  tm: "™️",
  hash: "#️⃣",
  asterisk: "*️⃣",
  zero: "0️⃣",
  one: "1️⃣",
  two: "2️⃣",
  three: "3️⃣",
  four: "4️⃣",
  five: "5️⃣",
  six: "6️⃣",
  seven: "7️⃣",
  eight: "8️⃣",
  nine: "9️⃣",
  keycap_ten: "🔟",
  capital_abcd: "🔠",
  abcd: "🔡",
  symbols: "🔣",
  abc: "🔤",
  a: "🅰️",
  ab: "🆎",
  b: "🅱️",
  cl: "🆑",
  cool: "🆒",
  free: "🆓",
  information_source: "ℹ️",
  id: "🆔",
  m: "Ⓜ️",
  new: "🆕",
  ng: "🆖",
  o2: "🅾️",
  ok: "🆗",
  parking: "🅿️",
  sos: "🆘",
  up: "🆙",
  vs: "🆚",
  koko: "🈁",
  sa: "🈂️",
  ideograph_advantage: "🉐",
  accept: "🉑",
  congratulations: "㊗️",
  secret: "㊙️",
  u6e80: "🈵",
  red_circle: "🔴",
  orange_circle: "🟠",
  yellow_circle: "🟡",
  green_circle: "🟢",
  large_blue_circle: "🔵",
  purple_circle: "🟣",
  brown_circle: "🟤",
  black_circle: "⚫",
  white_circle: "⚪",
  red_square: "🟥",
  orange_square: "🟧",
  yellow_square: "🟨",
  green_square: "🟩",
  blue_square: "🟦",
  purple_square: "🟪",
  brown_square: "🟫",
  black_large_square: "⬛",
  white_large_square: "⬜",
  black_medium_square: "◼️",
  white_medium_square: "◻️",
  black_medium_small_square: "◾",
  white_medium_small_square: "◽",
  black_small_square: "▪️",
  white_small_square: "▫️",
  large_orange_diamond: "🔶",
  large_blue_diamond: "🔷",
  small_orange_diamond: "🔸",
  small_blue_diamond: "🔹",
  small_red_triangle: "🔺",
  small_red_triangle_down: "🔻",
  diamond_shape_with_a_dot_inside: "💠",
  radio_button: "🔘",
  white_square_button: "🔳",
  black_square_button: "🔲",
  checkered_flag: "🏁",
  triangular_flag_on_post: "🚩",
  crossed_flags: "🎌",
  black_flag: "🏴",
  white_flag: "🏳️",
  rainbow_flag: "🏳️‍🌈",
  transgender_flag: "🏳️‍⚧️",
  pirate_flag: "🏴‍☠️",
  ascension_island: "🇦🇨",
  andorra: "🇦🇩",
  united_arab_emirates: "🇦🇪",
  afghanistan: "🇦🇫",
  antigua_barbuda: "🇦🇬",
  anguilla: "🇦🇮",
  albania: "🇦🇱",
  armenia: "🇦🇲",
  angola: "🇦🇴",
  antarctica: "🇦🇶",
  argentina: "🇦🇷",
  american_samoa: "🇦🇸",
  austria: "🇦🇹",
  australia: "🇦🇺",
  aruba: "🇦🇼",
  aland_islands: "🇦🇽",
  azerbaijan: "🇦🇿",
  bosnia_herzegovina: "🇧🇦",
  barbados: "🇧🇧",
  bangladesh: "🇧🇩",
  belgium: "🇧🇪",
  burkina_faso: "🇧🇫",
  bulgaria: "🇧🇬",
  bahrain: "🇧🇭",
  burundi: "🇧🇮",
  benin: "🇧🇯",
  st_barthelemy: "🇧🇱",
  bermuda: "🇧🇲",
  brunei: "🇧🇳",
  bolivia: "🇧🇴",
  caribbean_netherlands: "🇧🇶",
  brazil: "🇧🇷",
  bahamas: "🇧🇸",
  bhutan: "🇧🇹",
  bouvet_island: "🇧🇻",
  botswana: "🇧🇼",
  belarus: "🇧🇾",
  belize: "🇧🇿",
  canada: "🇨🇦",
  cocos_islands: "🇨🇨",
  congo_kinshasa: "🇨🇩",
  central_african_republic: "🇨🇫",
  congo_brazzaville: "🇨🇬",
  switzerland: "🇨🇭",
  cote_divoire: "🇨🇮",
  cook_islands: "🇨🇰",
  chile: "🇨🇱",
  cameroon: "🇨🇲",
  cn: "🇨🇳",
  colombia: "🇨🇴",
  clipperton_island: "🇨🇵",
  costa_rica: "🇨🇷",
  cuba: "🇨🇺",
  cape_verde: "🇨🇻",
  curacao: "🇨🇼",
  christmas_island: "🇨🇽",
  cyprus: "🇨🇾",
  czech_republic: "🇨🇿",
  de: "🇩🇪",
  diego_garcia: "🇩🇬",
  djibouti: "🇩🇯",
  denmark: "🇩🇰",
  dominica: "🇩🇲",
  dominican_republic: "🇩🇴",
  algeria: "🇩🇿",
  ceuta_melilla: "🇪🇦",
  ecuador: "🇪🇨",
  estonia: "🇪🇪",
  egypt: "🇪🇬",
  western_sahara: "🇪🇭",
  eritrea: "🇪🇷",
  es: "🇪🇸",
  ethiopia: "🇪🇹",
  eu: "🇪🇺",
  european_union: "🇪🇺",
  finland: "🇫🇮",
  fiji: "🇫🇯",
  falkland_islands: "🇫🇰",
  micronesia: "🇫🇲",
  faroe_islands: "🇫🇴",
  fr: "🇫🇷",
  gabon: "🇬🇦",
  gb: "🇬🇧",
  uk: "🇬🇧",
  grenada: "🇬🇩",
  georgia: "🇬🇪",
  french_guiana: "🇬🇫",
  guernsey: "🇬🇬",
  ghana: "🇬🇭",
  gibraltar: "🇬🇮",
  greenland: "🇬🇱",
  gambia: "🇬🇲",
  guinea: "🇬🇳",
  guadeloupe: "🇬🇵",
  equatorial_guinea: "🇬🇶",
  greece: "🇬🇷",
  south_georgia_south_sandwich_islands: "🇬🇸",
  guatemala: "🇬🇹",
  guam: "🇬🇺",
  guinea_bissau: "🇬🇼",
  guyana: "🇬🇾",
  hong_kong: "🇭🇰",
  heard_mcdonald_islands: "🇭🇲",
  honduras: "🇭🇳",
  croatia: "🇭🇷",
  haiti: "🇭🇹",
  hungary: "🇭🇺",
  canary_islands: "🇮🇨",
  indonesia: "🇮🇩",
  ireland: "🇮🇪",
  israel: "🇮🇱",
  isle_of_man: "🇮🇲",
  india: "🇮🇳",
  british_indian_ocean_territory: "🇮🇴",
  iraq: "🇮🇶",
  iran: "🇮🇷",
  iceland: "🇮🇸",
  it: "🇮🇹",
  jersey: "🇯🇪",
  jamaica: "🇯🇲",
  jordan: "🇯🇴",
  jp: "🇯🇵",
  kenya: "🇰🇪",
  kyrgyzstan: "🇰🇬",
  cambodia: "🇰🇭",
  kiribati: "🇰🇮",
  comoros: "🇰🇲",
  st_kitts_nevis: "🇰🇳",
  north_korea: "🇰🇵",
  kr: "🇰🇷",
  kuwait: "🇰🇼",
  cayman_islands: "🇰🇾",
  kazakhstan: "🇰🇿",
  laos: "🇱🇦",
  lebanon: "🇱🇧",
  st_lucia: "🇱🇨",
  liechtenstein: "🇱🇮",
  sri_lanka: "🇱🇰",
  liberia: "🇱🇷",
  lesotho: "🇱🇸",
  lithuania: "🇱🇹",
  luxembourg: "🇱🇺",
  latvia: "🇱🇻",
  libya: "🇱🇾",
  morocco: "🇲🇦",
  monaco: "🇲🇨",
  moldova: "🇲🇩",
  montenegro: "🇲🇪",
  st_martin: "🇲🇫",
  madagascar: "🇲🇬",
  marshall_islands: "🇲🇭",
  macedonia: "🇲🇰",
  mali: "🇲🇱",
  myanmar: "🇲🇲",
  mongolia: "🇲🇳",
  macau: "🇲🇴",
  northern_mariana_islands: "🇲🇵",
  martinique: "🇲🇶",
  mauritania: "🇲🇷",
  montserrat: "🇲🇸",
  malta: "🇲🇹",
  mauritius: "🇲🇺",
  maldives: "🇲🇻",
  malawi: "🇲🇼",
  mexico: "🇲🇽",
  malaysia: "🇲🇾",
  mozambique: "🇲🇿",
  namibia: "🇳🇦",
  new_caledonia: "🇳🇨",
  niger: "🇳🇪",
  norfolk_island: "🇳🇫",
  nigeria: "🇳🇬",
  nicaragua: "🇳🇮",
  netherlands: "🇳🇱",
  norway: "🇳🇴",
  nepal: "🇳🇵",
  nauru: "🇳🇷",
  niue: "🇳🇺",
  new_zealand: "🇳🇿",
  oman: "🇴🇲",
  panama: "🇵🇦",
  peru: "🇵🇪",
  french_polynesia: "🇵🇫",
  papua_new_guinea: "🇵🇬",
  philippines: "🇵🇭",
  pakistan: "🇵🇰",
  poland: "🇵🇱",
  st_pierre_miquelon: "🇵🇲",
  pitcairn_islands: "🇵🇳",
  puerto_rico: "🇵🇷",
  palestinian_territories: "🇵🇸",
  portugal: "🇵🇹",
  palau: "🇵🇼",
  paraguay: "🇵🇾",
  qatar: "🇶🇦",
  reunion: "🇷🇪",
  romania: "🇷🇴",
  serbia: "🇷🇸",
  ru: "🇷🇺",
  rwanda: "🇷🇼",
  saudi_arabia: "🇸🇦",
  solomon_islands: "🇸🇧",
  seychelles: "🇸🇨",
  sudan: "🇸🇩",
  sweden: "🇸🇪",
  singapore: "🇸🇬",
  st_helena: "🇸🇭",
  slovenia: "🇸🇮",
  svalbard_jan_mayen: "🇸🇯",
  slovakia: "🇸🇰",
  sierra_leone: "🇸🇱",
  san_marino: "🇸🇲",
  senegal: "🇸🇳",
  somalia: "🇸🇴",
  suriname: "🇸🇷",
  south_sudan: "🇸🇸",
  sao_tome_principe: "🇸🇹",
  el_salvador: "🇸🇻",
  sint_maarten: "🇸🇽",
  syria: "🇸🇾",
  swaziland: "🇸🇿",
  tristan_da_cunha: "🇹🇦",
  turks_caicos_islands: "🇹🇨",
  chad: "🇹🇩",
  french_southern_territories: "🇹🇫",
  togo: "🇹🇬",
  thailand: "🇹🇭",
  tajikistan: "🇹🇯",
  tokelau: "🇹🇰",
  timor_leste: "🇹🇱",
  turkmenistan: "🇹🇲",
  tunisia: "🇹🇳",
  tonga: "🇹🇴",
  tr: "🇹🇷",
  trinidad_tobago: "🇹🇹",
  tuvalu: "🇹🇻",
  taiwan: "🇹🇼",
  tanzania: "🇹🇿",
  ukraine: "🇺🇦",
  uganda: "🇺🇬",
  us_outlying_islands: "🇺🇲",
  united_nations: "🇺🇳",
  us: "🇺🇸",
  uruguay: "🇺🇾",
  uzbekistan: "🇺🇿",
  vatican_city: "🇻🇦",
  st_vincent_grenadines: "🇻🇨",
  venezuela: "🇻🇪",
  british_virgin_islands: "🇻🇬",
  us_virgin_islands: "🇻🇮",
  vietnam: "🇻🇳",
  vanuatu: "🇻🇺",
  wallis_futuna: "🇼🇫",
  samoa: "🇼🇸",
  kosovo: "🇽🇰",
  yemen: "🇾🇪",
  mayotte: "🇾🇹",
  south_africa: "🇿🇦",
  zambia: "🇿🇲",
  zimbabwe: "🇿🇼",
  england: "🏴󠁧󠁢󠁥󠁮󠁧󠁿",
  scotland: "🏴󠁧󠁢󠁳󠁣󠁴󠁿",
  wales: "🏴󠁧󠁢󠁷󠁬󠁳󠁿"
};
Object.keys(Of).reduce((t, e) => {
  const n = Of[e];
  return t[n] = e, t;
}, {});
const Cue = Object.keys(Of).map((t) => t);
Object.keys(Of).map((t) => Of[t]);
function kue(t) {
  return Cue.filter((e) => e.startsWith(t)).map((e) => ({
    name: e,
    emoji: Of[e]
  }));
}
const EM = Om((t, e) => {
  const n = Wr(), [r, i] = nt(0), { t: o } = Wt(), a = (u) => {
    const d = t.items[u];
    d && t.command(d);
  }, s = () => {
    i((r + t.items.length - 1) % t.items.length);
  }, l = () => {
    i((r + 1) % t.items.length);
  }, c = () => {
    a(r);
  };
  return Tt(() => i(0), [t.items]), Tt(() => {
    if (Number.isNaN(r + 1))
      return;
    const u = n.current.querySelector(`span:nth-of-type(${r + 1})`);
    u && XT(u, { behavior: "smooth", scrollMode: "if-needed" });
  }, [r]), Kv(e, () => ({
    onKeyDown: ({ event: u }) => u.key === "ArrowUp" ? (s(), !0) : u.key === "ArrowDown" ? (l(), !0) : u.key === "Enter" ? (c(), !0) : !1
  })), /* @__PURE__ */ z("div", { className: "richtext-w-[200px] richtext-max-h-[320px] richtext-overflow-x-hidden richtext-overflow-y-auto richtext-rounded-sm !richtext-border richtext-bg-popover richtext-p-1 richtext-text-popover-foreground richtext-shadow-md richtext-outline-none", children: /* @__PURE__ */ z("div", { ref: n, children: t.items.length ? t.items.map((u, d) => /* @__PURE__ */ Fe(
    "span",
    {
      className: xo(" richtext-flex richtext-relative  richtext-cursor-default richtext-select-none richtext-items-center richtext-rounded-sm richtext-px-2 richtext-py-1.5 richtext-text-sm richtext-outline-none richtext-transition-colors focus:richtext-bg-accent focus:richtext-text-accent-foreground  hover:richtext-bg-accent", d === r ? "bg-accent" : ""),
      onClick: () => a(d),
      children: [
        u.fallbackImage ? /* @__PURE__ */ z("img", { src: u.fallbackImage, className: "richtext-w-[1em] richtext-h-[1em]" }) : u.emoji,
        ":",
        u.name,
        ":"
      ]
    },
    `emoji-list-code-${d}`
  )) : /* @__PURE__ */ z("div", { className: "richtext-flex richtext-relative  richtext-cursor-default richtext-select-none richtext-items-center richtext-rounded-sm richtext-px-2 richtext-py-1.5 richtext-text-sm richtext-outline-none richtext-transition-colors", children: /* @__PURE__ */ z("span", { children: o("no_result_found") }) }) }) });
});
EM.displayName = "EmojiList";
const Aue = [
  "😀",
  "😃",
  "😄",
  "😁",
  "😆",
  "😅",
  "😂",
  "🤣",
  "🥲",
  "😊",
  "😇",
  "🙂",
  "🙃",
  "😉",
  "😌",
  "😍",
  "🥰",
  "😘",
  "😗",
  "😙",
  "😚",
  "😋",
  "😛",
  "😝",
  "😜",
  "🤪",
  "🤨",
  "🧐",
  "🤓",
  "😎",
  "🥸",
  "🤩",
  "🥳",
  "😏",
  "😒",
  "😞",
  "😔",
  "😟",
  "😕",
  "🙁",
  "😣",
  "😖",
  "😫",
  "😩",
  "🥺",
  "😢",
  "😭",
  "😤",
  "😠",
  "😡",
  "🤬",
  "🤯",
  "😳",
  "🥵",
  "🥶",
  "😱",
  "😨",
  "😰",
  "😥",
  "😓",
  "🤗",
  "🤔",
  "🤭",
  "🤫",
  "🤥",
  "😶",
  "😐",
  "😑",
  "😬",
  "🙄",
  "😯",
  "😦",
  "😧",
  "😮",
  "😲",
  "🥱",
  "😴",
  "🤤",
  "😪",
  "😵",
  "🤐",
  "🥴",
  "🤢",
  "🤮",
  "🤧",
  "😷",
  "🤒",
  "🤕",
  "🤑",
  "🤠",
  "😈",
  "👿",
  "👹",
  "👺",
  "🤡",
  "💩",
  "👻",
  "💀",
  "☠️",
  "👽",
  "👾",
  "🤖",
  "🎃",
  "😺",
  "😸",
  "😹",
  "😻",
  "😼",
  "😽",
  "🙀",
  "😿",
  "😾",
  "👋",
  "🤚",
  "🖐",
  "✋",
  "🖖",
  "👌",
  "🤌",
  "🤏",
  "✌️",
  "🤞",
  "🤟",
  "🤘",
  "🤙",
  "👈",
  "👉",
  "👆",
  "🖕",
  "👇",
  "☝️",
  "👍",
  "👎",
  "✊",
  "👊",
  "🤛",
  "🤜",
  "👏",
  "🙌",
  "👐",
  "🤲",
  "🤝",
  "🙏",
  "✍️",
  "💅",
  "🤳",
  "💪",
  "🦾",
  "🦵",
  "🦿",
  "🦶",
  "👣",
  "👂",
  "🦻",
  "👃",
  "🫀",
  "🫁",
  "🧠",
  "🦷",
  "🦴",
  "👀",
  "👁",
  "👅",
  "👄",
  "💋",
  "🩸",
  "💋",
  "💌",
  "💘",
  "💝",
  "💖",
  "💗",
  "💓",
  "💞",
  "💕",
  "💟",
  "❣️",
  "❣",
  "💔",
  "❤️‍🔥",
  "❤‍🔥",
  "❤️‍🩹",
  "❤‍🩹",
  "❤️",
  "❤",
  "🧡",
  "💛",
  "💚",
  "💙",
  "💜",
  "🤎",
  "🖤",
  "🤍",
  "💯",
  "💢",
  "💥",
  "💫",
  "💦",
  "💨",
  "🕳️",
  "🕳",
  "💣",
  "💬",
  "👁️‍🗨️",
  "👁‍🗨️",
  "👁️‍🗨",
  "👁‍🗨",
  "🗨️",
  "🗨",
  "🗯️",
  "🗯",
  "💭",
  "💤"
], Rue = [
  "🏧",
  "🚮",
  "🚰",
  "♿",
  "🚹",
  "🚺",
  "🚻",
  "🚼",
  "🚾",
  "🛂",
  "🛃",
  "🛄",
  "🛅",
  "⚠️",
  "⚠",
  "🚸",
  "⛔",
  "🚫",
  "🚳",
  "🚭",
  "🚯",
  "🚱",
  "🚷",
  "📵",
  "🔞",
  "☢️",
  "☢",
  "☣️",
  "☣",
  "⬆️",
  "⬆",
  "↗️",
  "↗",
  "➡️",
  "➡",
  "↘️",
  "↘",
  "⬇️",
  "⬇",
  "↙️",
  "↙",
  "⬅️",
  "⬅",
  "↖️",
  "↖",
  "↕️",
  "↕",
  "↔️",
  "↔",
  "↩️",
  "↩",
  "↪️",
  "↪",
  "⤴️",
  "⤴",
  "⤵️",
  "⤵",
  "🔃",
  "🔄",
  "🔙",
  "🔚",
  "🔛",
  "🔜",
  "🔝",
  "🛐",
  "⚛️",
  "⚛",
  "🕉️",
  "🕉",
  "✡️",
  "✡",
  "☸️",
  "☸",
  "☯️",
  "☯",
  "✝️",
  "✝",
  "☦️",
  "☦",
  "☪️",
  "☪",
  "☮️",
  "☮",
  "🕎",
  "🔯",
  "♈",
  "♉",
  "♊",
  "♋",
  "♌",
  "♍",
  "♎",
  "♏",
  "♐",
  "♑",
  "♒",
  "♓",
  "⛎",
  "🔀",
  "🔁",
  "🔂",
  "▶️",
  "▶",
  "⏩",
  "⏭️",
  "⏭",
  "⏯️",
  "⏯",
  "◀️",
  "◀",
  "⏪",
  "⏮️",
  "⏮",
  "🔼",
  "⏫",
  "🔽",
  "⏬",
  "⏸️",
  "⏸",
  "⏹️",
  "⏹",
  "⏺️",
  "⏺",
  "⏏️",
  "⏏",
  "🎦",
  "🔅",
  "🔆",
  "📶",
  "📳",
  "📴",
  "♀️",
  "♀",
  "♂️",
  "♂",
  "⚧️",
  "⚧",
  "✖️",
  "✖",
  "➕",
  "➖",
  "➗",
  "♾️",
  "♾",
  "‼️",
  "‼",
  "⁉️",
  "⁉",
  "❓",
  "❔",
  "❕",
  "❗",
  "〰️",
  "〰",
  "💱",
  "💲",
  "⚕️",
  "⚕",
  "♻️",
  "♻",
  "⚜️",
  "⚜",
  "🔱",
  "📛",
  "🔰",
  "⭕",
  "✅",
  "☑️",
  "☑",
  "✔️",
  "✔",
  "❌",
  "❎",
  "➰",
  "➿",
  "〽️",
  "〽",
  "✳️",
  "✳",
  "✴️",
  "✴",
  "❇️",
  "❇",
  "©️",
  "©",
  "®️",
  "®",
  "™️",
  "™",
  "#️⃣",
  "#⃣",
  "*️⃣",
  "*⃣",
  "0️⃣",
  "0⃣",
  "1️⃣",
  "1⃣",
  "2️⃣",
  "2⃣",
  "3️⃣",
  "3⃣",
  "4️⃣",
  "4⃣",
  "5️⃣",
  "5⃣",
  "6️⃣",
  "6⃣",
  "7️⃣",
  "7⃣",
  "8️⃣",
  "8⃣",
  "9️⃣",
  "9⃣",
  "🔟",
  "🔠",
  "🔡",
  "🔢",
  "🔣",
  "🔤",
  "🅰️",
  "🅰",
  "🆎",
  "🅱️",
  "🅱",
  "🆑",
  "🆒",
  "🆓",
  "ℹ️",
  "ℹ",
  "🆔",
  "Ⓜ️",
  "Ⓜ",
  "🆕",
  "🆖",
  "🅾️",
  "🅾",
  "🆗",
  "🅿️",
  "🅿",
  "🆘",
  "🆙",
  "🆚",
  "🈁",
  "🈂️",
  "🈂",
  "🈷️",
  "🈷",
  "🈶",
  "🈯",
  "🉐",
  "🈹",
  "🈚",
  "🈲",
  "🉑",
  "🈸",
  "🈴",
  "🈳",
  "㊗️",
  "㊗",
  "㊙️",
  "㊙",
  "🈺",
  "🈵",
  "🔴",
  "🟠",
  "🟡",
  "🟢",
  "🔵",
  "🟣",
  "🟤",
  "⚫",
  "⚪",
  "🟥",
  "🟧",
  "🟨",
  "🟩",
  "🟦",
  "🟪",
  "🟫",
  "⬛",
  "⬜",
  "◼️",
  "◼",
  "◻️",
  "◻",
  "◾",
  "◽",
  "▪️",
  "▪",
  "▫️",
  "▫",
  "🔶",
  "🔷",
  "🔸",
  "🔹",
  "🔺",
  "🔻",
  "💠",
  "🔘",
  "🔳",
  "🔲"
], Iue = [
  "👓",
  "🕶️",
  "🕶",
  "🥽",
  "🥼",
  "🦺",
  "👔",
  "👕",
  "👖",
  "🧣",
  "🧤",
  "🧥",
  "🧦",
  "👗",
  "👘",
  "🥻",
  "🩱",
  "🩲",
  "🩳",
  "👙",
  "👚",
  "👛",
  "👜",
  "👝",
  "🛍️",
  "🛍",
  "🎒",
  "🩴",
  "👞",
  "👟",
  "🥾",
  "🥿",
  "👠",
  "👡",
  "🩰",
  "👢",
  "👑",
  "👒",
  "🎩",
  "🎓",
  "🧢",
  "🪖",
  "⛑️",
  "⛑",
  "📿",
  "💄",
  "💍",
  "💎",
  "🔇",
  "🔈",
  "🔉",
  "🔊",
  "📢",
  "📣",
  "📯",
  "🔔",
  "🔕",
  "🎼",
  "🎵",
  "🎶",
  "🎙️",
  "🎙",
  "🎚️",
  "🎚",
  "🎛️",
  "🎛",
  "🎤",
  "🎧",
  "📻",
  "🎷",
  "🪗",
  "🎸",
  "🎹",
  "🎺",
  "🎻",
  "🪕",
  "🥁",
  "🪘",
  "📱",
  "📲",
  "☎️",
  "☎",
  "📞",
  "📟",
  "📠",
  "🔋",
  "🔌",
  "💻",
  "🖥️",
  "🖥",
  "🖨️",
  "🖨",
  "⌨️",
  "⌨",
  "🖱️",
  "🖱",
  "🖲️",
  "🖲",
  "💽",
  "💾",
  "💿",
  "📀",
  "🧮",
  "🎥",
  "🎞️",
  "🎞",
  "📽️",
  "📽",
  "🎬",
  "📺",
  "📷",
  "📸",
  "📹",
  "📼",
  "🔍",
  "🔎",
  "🕯️",
  "🕯",
  "💡",
  "🔦",
  "🏮",
  "🪔",
  "📔",
  "📕",
  "📖",
  "📗",
  "📘",
  "📙",
  "📚",
  "📓",
  "📒",
  "📃",
  "📜",
  "📄",
  "📰",
  "🗞️",
  "🗞",
  "📑",
  "🔖",
  "🏷️",
  "🏷",
  "💰",
  "🪙",
  "💴",
  "💵",
  "💶",
  "💷",
  "💸",
  "💳",
  "🧾",
  "💹",
  "✉️",
  "✉",
  "📧",
  "📨",
  "📩",
  "📤",
  "📥",
  "📦",
  "📫",
  "📪",
  "📬",
  "📭",
  "📮",
  "🗳️",
  "🗳",
  "✏️",
  "✏",
  "✒️",
  "✒",
  "🖋️",
  "🖋",
  "🖊️",
  "🖊",
  "🖌️",
  "🖌",
  "🖍️",
  "🖍",
  "📝",
  "💼",
  "📁",
  "📂",
  "🗂️",
  "🗂",
  "📅",
  "📆",
  "🗒️",
  "🗒",
  "🗓️",
  "🗓",
  "📇",
  "📈",
  "📉",
  "📊",
  "📋",
  "📌",
  "📍",
  "📎",
  "🖇️",
  "🖇",
  "📏",
  "📐",
  "✂️",
  "✂",
  "🗃️",
  "🗃",
  "🗄️",
  "🗄",
  "🗑️",
  "🗑",
  "🔒",
  "🔓",
  "🔏",
  "🔐",
  "🔑",
  "🗝️",
  "🗝",
  "🔨",
  "🪓",
  "⛏️",
  "⛏",
  "⚒️",
  "⚒",
  "🛠️",
  "🛠",
  "🗡️",
  "🗡",
  "⚔️",
  "⚔",
  "🔫",
  "🪃",
  "🏹",
  "🛡️",
  "🛡",
  "🪚",
  "🔧",
  "🪛",
  "🔩",
  "⚙️",
  "⚙",
  "🗜️",
  "🗜",
  "⚖️",
  "⚖",
  "🦯",
  "🔗",
  "⛓️",
  "⛓",
  "🪝",
  "🧰",
  "🧲",
  "🪜",
  "⚗️",
  "⚗",
  "🧪",
  "🧫",
  "🧬",
  "🔬",
  "🔭",
  "📡",
  "💉",
  "🩸",
  "💊",
  "🩹",
  "🩺",
  "🚪",
  "🛗",
  "🪞",
  "🪟",
  "🛏️",
  "🛏",
  "🛋️",
  "🛋",
  "🪑",
  "🚽",
  "🪠",
  "🚿",
  "🛁",
  "🪤",
  "🪒",
  "🧴",
  "🧷",
  "🧹",
  "🧺",
  "🧻",
  "🪣",
  "🧼",
  "🪥",
  "🧽",
  "🧯",
  "🛒",
  "🚬",
  "⚰️",
  "⚰",
  "🪦",
  "⚱️",
  "⚱",
  "🗿",
  "🪧"
], Oue = [
  "🎃",
  "🎄",
  "🎆",
  "🎇",
  "🧨",
  "✨",
  "🎈",
  "🎉",
  "🎊",
  "🎋",
  "🎍",
  "🎎",
  "🎏",
  "🎐",
  "🎑",
  "🧧",
  "🎀",
  "🎁",
  "🎗️",
  "🎗",
  "🎟️",
  "🎟",
  "🎫",
  "🎖️",
  "🎖",
  "🏆",
  "🏅",
  "🥇",
  "🥈",
  "🥉",
  "⚽",
  "⚾",
  "🥎",
  "🏀",
  "🏐",
  "🏈",
  "🏉",
  "🎾",
  "🥏",
  "🎳",
  "🏏",
  "🏑",
  "🏒",
  "🥍",
  "🏓",
  "🏸",
  "🥊",
  "🥋",
  "🥅",
  "⛳",
  "⛸️",
  "⛸",
  "🎣",
  "🤿",
  "🎽",
  "🎿",
  "🛷",
  "🥌",
  "🎯",
  "🪀",
  "🪁",
  "🎱",
  "🔮",
  "🪄",
  "🧿",
  "🎮",
  "🕹️",
  "🕹",
  "🎰",
  "🎲",
  "🧩",
  "🧸",
  "🪅",
  "🪆",
  "♠️",
  "♠",
  "♥️",
  "♥",
  "♦️",
  "♦",
  "♣️",
  "♣",
  "♟️",
  "♟",
  "🃏",
  "🀄",
  "🎴",
  "🎭",
  "🖼️",
  "🖼",
  "🎨",
  "🧵",
  "🪡",
  "🧶",
  "🪢"
], Fue = [
  "🌍",
  "🌎",
  "🌏",
  "🌐",
  "🗺️",
  "🗺",
  "🗾",
  "🧭",
  "🏔️",
  "🏔",
  "⛰️",
  "⛰",
  "🌋",
  "🗻",
  "🏕️",
  "🏕",
  "🏖️",
  "🏖",
  "🏜️",
  "🏜",
  "🏝️",
  "🏝",
  "🏞️",
  "🏞",
  "🏟️",
  "🏟",
  "🏛️",
  "🏛",
  "🏗️",
  "🏗",
  "🧱",
  "🪨",
  "🪵",
  "🛖",
  "🏘️",
  "🏘",
  "🏚️",
  "🏚",
  "🏠",
  "🏡",
  "🏢",
  "🏣",
  "🏤",
  "🏥",
  "🏦",
  "🏨",
  "🏩",
  "🏪",
  "🏫",
  "🏬",
  "🏭",
  "🏯",
  "🏰",
  "💒",
  "🗼",
  "🗽",
  "⛪",
  "🕌",
  "🛕",
  "🕍",
  "⛩️",
  "⛩",
  "🕋",
  "⛲",
  "⛺",
  "🌁",
  "🌃",
  "🏙️",
  "🏙",
  "🌄",
  "🌅",
  "🌆",
  "🌇",
  "🌉",
  "♨️",
  "♨",
  "🎠",
  "🎡",
  "🎢",
  "💈",
  "🎪",
  "🚂",
  "🚃",
  "🚄",
  "🚅",
  "🚆",
  "🚇",
  "🚈",
  "🚉",
  "🚊",
  "🚝",
  "🚞",
  "🚋",
  "🚌",
  "🚍",
  "🚎",
  "🚐",
  "🚑",
  "🚒",
  "🚓",
  "🚔",
  "🚕",
  "🚖",
  "🚗",
  "🚘",
  "🚙",
  "🛻",
  "🚚",
  "🚛",
  "🚜",
  "🏎️",
  "🏎",
  "🏍️",
  "🏍",
  "🛵",
  "🦽",
  "🦼",
  "🛺",
  "🚲",
  "🛴",
  "🛹",
  "🛼",
  "🚏",
  "🛣️",
  "🛣",
  "🛤️",
  "🛤",
  "🛢️",
  "🛢",
  "⛽",
  "🚨",
  "🚥",
  "🚦",
  "🛑",
  "🚧",
  "⚓",
  "⛵",
  "🛶",
  "🚤",
  "🛳️",
  "🛳",
  "⛴️",
  "⛴",
  "🛥️",
  "🛥",
  "🚢",
  "✈️",
  "✈",
  "🛩️",
  "🛩",
  "🛫",
  "🛬",
  "🪂",
  "💺",
  "🚁",
  "🚟",
  "🚠",
  "🚡",
  "🛰️",
  "🛰",
  "🚀",
  "🛸",
  "🛎️",
  "🛎",
  "🧳",
  "⌛",
  "⏳",
  "⌚",
  "⏰",
  "⏱️",
  "⏱",
  "⏲️",
  "⏲",
  "🕰️",
  "🕰",
  "🕛",
  "🕧",
  "🕐",
  "🕜",
  "🕑",
  "🕝",
  "🕒",
  "🕞",
  "🕓",
  "🕟",
  "🕔",
  "🕠",
  "🕕",
  "🕡",
  "🕖",
  "🕢",
  "🕗",
  "🕣",
  "🕘",
  "🕤",
  "🕙",
  "🕥",
  "🕚",
  "🕦",
  "🌑",
  "🌒",
  "🌓",
  "🌔",
  "🌕",
  "🌖",
  "🌗",
  "🌘",
  "🌙",
  "🌚",
  "🌛",
  "🌜",
  "🌡️",
  "🌡",
  "☀️",
  "☀",
  "🌝",
  "🌞",
  "🪐",
  "⭐",
  "🌟",
  "🌠",
  "🌌",
  "☁️",
  "☁",
  "⛅",
  "⛈️",
  "⛈",
  "🌤️",
  "🌤",
  "🌥️",
  "🌥",
  "🌦️",
  "🌦",
  "🌧️",
  "🌧",
  "🌨️",
  "🌨",
  "🌩️",
  "🌩",
  "🌪️",
  "🌪",
  "🌫️",
  "🌫",
  "🌬️",
  "🌬",
  "🌀",
  "🌈",
  "🌂",
  "☂️",
  "☂",
  "☔",
  "⛱️",
  "⛱",
  "⚡",
  "❄️",
  "❄",
  "☃️",
  "☃",
  "⛄",
  "☄️",
  "☄",
  "🔥",
  "💧",
  "🌊"
], Uue = [
  "🏁",
  "🚩",
  "🎌",
  "🏴",
  "🏳️",
  "🏳",
  "🏳️‍🌈",
  "🏳‍🌈",
  "🏳️‍⚧️",
  "🏳‍⚧️",
  "🏳️‍⚧",
  "🏳‍⚧",
  "🏴‍☠️",
  "🏴‍☠",
  "🇦🇨",
  "🇦🇩",
  "🇦🇪",
  "🇦🇫",
  "🇦🇬",
  "🇦🇮",
  "🇦🇱",
  "🇦🇲",
  "🇦🇴",
  "🇦🇶",
  "🇦🇷",
  "🇦🇸",
  "🇦🇹",
  "🇦🇺",
  "🇦🇼",
  "🇦🇽",
  "🇦🇿",
  "🇧🇦",
  "🇧🇧",
  "🇧🇩",
  "🇧🇪",
  "🇧🇫",
  "🇧🇬",
  "🇧🇭",
  "🇧🇮",
  "🇧🇯",
  "🇧🇱",
  "🇧🇲",
  "🇧🇳",
  "🇧🇴",
  "🇧🇶",
  "🇧🇷",
  "🇧🇸",
  "🇧🇹",
  "🇧🇻",
  "🇧🇼",
  "🇧🇾",
  "🇧🇿",
  "🇨🇦",
  "🇨🇨",
  "🇨🇩",
  "🇨🇫",
  "🇨🇬",
  "🇨🇭",
  "🇨🇮",
  "🇨🇰",
  "🇨🇱",
  "🇨🇲",
  "🇨🇳",
  "🇨🇴",
  "🇨🇵",
  "🇨🇷",
  "🇨🇺",
  "🇨🇻",
  "🇨🇼",
  "🇨🇽",
  "🇨🇾",
  "🇨🇿",
  "🇩🇪",
  "🇩🇬",
  "🇩🇯",
  "🇩🇰",
  "🇩🇲",
  "🇩🇴",
  "🇩🇿",
  "🇪🇦",
  "🇪🇨",
  "🇪🇪",
  "🇪🇬",
  "🇪🇭",
  "🇪🇷",
  "🇪🇸",
  "🇪🇹",
  "🇪🇺",
  "🇫🇮",
  "🇫🇯",
  "🇫🇰",
  "🇫🇲",
  "🇫🇴",
  "🇫🇷",
  "🇬🇦",
  "🇬🇧",
  "🇬🇩",
  "🇬🇪",
  "🇬🇫",
  "🇬🇬",
  "🇬🇭",
  "🇬🇮",
  "🇬🇱",
  "🇬🇲",
  "🇬🇳",
  "🇬🇵",
  "🇬🇶",
  "🇬🇷",
  "🇬🇸",
  "🇬🇹",
  "🇬🇺",
  "🇬🇼",
  "🇬🇾",
  "🇭🇰",
  "🇭🇲",
  "🇭🇳",
  "🇭🇷",
  "🇭🇹",
  "🇭🇺",
  "🇮🇨",
  "🇮🇩",
  "🇮🇪",
  "🇮🇱",
  "🇮🇲",
  "🇮🇳",
  "🇮🇴",
  "🇮🇶",
  "🇮🇷",
  "🇮🇸",
  "🇮🇹",
  "🇯🇪",
  "🇯🇲",
  "🇯🇴",
  "🇯🇵",
  "🇰🇪",
  "🇰🇬",
  "🇰🇭",
  "🇰🇮",
  "🇰🇲",
  "🇰🇳",
  "🇰🇵",
  "🇰🇷",
  "🇰🇼",
  "🇰🇾",
  "🇰🇿",
  "🇱🇦",
  "🇱🇧",
  "🇱🇨",
  "🇱🇮",
  "🇱🇰",
  "🇱🇷",
  "🇱🇸",
  "🇱🇹",
  "🇱🇺",
  "🇱🇻",
  "🇱🇾",
  "🇲🇦",
  "🇲🇨",
  "🇲🇩",
  "🇲🇪",
  "🇲🇫",
  "🇲🇬",
  "🇲🇭",
  "🇲🇰",
  "🇲🇱",
  "🇲🇲",
  "🇲🇳",
  "🇲🇴",
  "🇲🇵",
  "🇲🇶",
  "🇲🇷",
  "🇲🇸",
  "🇲🇹",
  "🇲🇺",
  "🇲🇻",
  "🇲🇼",
  "🇲🇽",
  "🇲🇾",
  "🇲🇿",
  "🇳🇦",
  "🇳🇨",
  "🇳🇪",
  "🇳🇫",
  "🇳🇬",
  "🇳🇮",
  "🇳🇱",
  "🇳🇴",
  "🇳🇵",
  "🇳🇷",
  "🇳🇺",
  "🇳🇿",
  "🇴🇲",
  "🇵🇦",
  "🇵🇪",
  "🇵🇫",
  "🇵🇬",
  "🇵🇭",
  "🇵🇰",
  "🇵🇱",
  "🇵🇲",
  "🇵🇳",
  "🇵🇷",
  "🇵🇸",
  "🇵🇹",
  "🇵🇼",
  "🇵🇾",
  "🇶🇦",
  "🇷🇪",
  "🇷🇴",
  "🇷🇸",
  "🇷🇺",
  "🇷🇼",
  "🇸🇦",
  "🇸🇧",
  "🇸🇨",
  "🇸🇩",
  "🇸🇪",
  "🇸🇬",
  "🇸🇭",
  "🇸🇮",
  "🇸🇯",
  "🇸🇰",
  "🇸🇱",
  "🇸🇲",
  "🇸🇳",
  "🇸🇴",
  "🇸🇷",
  "🇸🇸",
  "🇸🇹",
  "🇸🇻",
  "🇸🇽",
  "🇸🇾",
  "🇸🇿",
  "🇹🇦",
  "🇹🇨",
  "🇹🇩",
  "🇹🇫",
  "🇹🇬",
  "🇹🇭",
  "🇹🇯",
  "🇹🇰",
  "🇹🇱",
  "🇹🇲",
  "🇹🇳",
  "🇹🇴",
  "🇹🇷",
  "🇹🇹",
  "🇹🇻",
  "🇹🇼",
  "🇹🇿",
  "🇺🇦",
  "🇺🇬",
  "🇺🇲",
  "🇺🇳",
  "🇺🇸",
  "🇺🇾",
  "🇺🇿",
  "🇻🇦",
  "🇻🇨",
  "🇻🇪",
  "🇻🇬",
  "🇻🇮",
  "🇻🇳",
  "🇻🇺",
  "🇼🇫",
  "🇼🇸",
  "🇽🇰",
  "🇾🇪",
  "🇾🇹",
  "🇿🇦",
  "🇿🇲",
  "🇿🇼",
  "🏴󠁧󠁢󠁥󠁮󠁧󠁿",
  "🏴󠁧󠁢󠁳󠁣󠁴󠁿",
  "🏴󠁧󠁢󠁷󠁬󠁳󠁿"
], Nue = [
  "🐵",
  "🐒",
  "🦍",
  "🦧",
  "🐶",
  "🐕",
  "🦮",
  "🐕‍🦺",
  "🐩",
  "🐺",
  "🦊",
  "🦝",
  "🐱",
  "🐈",
  "🐈‍⬛",
  "🦁",
  "🐯",
  "🐅",
  "🐆",
  "🐴",
  "🐎",
  "🦄",
  "🦓",
  "🦌",
  "🦬",
  "🐮",
  "🐂",
  "🐃",
  "🐄",
  "🐷",
  "🐖",
  "🐗",
  "🐽",
  "🐏",
  "🐑",
  "🐐",
  "🐪",
  "🐫",
  "🦙",
  "🦒",
  "🐘",
  "🦣",
  "🦏",
  "🦛",
  "🐭",
  "🐁",
  "🐀",
  "🐹",
  "🐰",
  "🐇",
  "🐿️",
  "🐿",
  "🦫",
  "🦔",
  "🦇",
  "🐻",
  "🐻‍❄️",
  "🐻‍❄",
  "🐨",
  "🐼",
  "🦥",
  "🦦",
  "🦨",
  "🦘",
  "🦡",
  "🐾",
  "🦃",
  "🐔",
  "🐓",
  "🐣",
  "🐤",
  "🐥",
  "🐦",
  "🐧",
  "🕊️",
  "🕊",
  "🦅",
  "🦆",
  "🦢",
  "🦉",
  "🦤",
  "🪶",
  "🦩",
  "🦚",
  "🦜",
  "🐸",
  "🐊",
  "🐢",
  "🦎",
  "🐍",
  "🐲",
  "🐉",
  "🦕",
  "🦖",
  "🐳",
  "🐋",
  "🐬",
  "🦭",
  "🐟",
  "🐠",
  "🐡",
  "🦈",
  "🐙",
  "🐚",
  "🐌",
  "🦋",
  "🐛",
  "🐜",
  "🐝",
  "🪲",
  "🐞",
  "🦗",
  "🪳",
  "🕷️",
  "🕷",
  "🕸️",
  "🕸",
  "🦂",
  "🦟",
  "🪰",
  "🪱",
  "🦠",
  "💐",
  "🌸",
  "💮",
  "🏵️",
  "🏵",
  "🌹",
  "🥀",
  "🌺",
  "🌻",
  "🌼",
  "🌷",
  "🌱",
  "🪴",
  "🌲",
  "🌳",
  "🌴",
  "🌵",
  "🌾",
  "🌿",
  "☘️",
  "☘",
  "🍀",
  "🍁",
  "🍂",
  "🍃"
], Mue = [
  "🍇",
  "🍈",
  "🍉",
  "🍊",
  "🍋",
  "🍌",
  "🍍",
  "🥭",
  "🍎",
  "🍏",
  "🍐",
  "🍑",
  "🍒",
  "🍓",
  "🫐",
  "🥝",
  "🍅",
  "🫒",
  "🥥",
  "🥑",
  "🍆",
  "🥔",
  "🥕",
  "🌽",
  "🌶️",
  "🌶",
  "🫑",
  "🥒",
  "🥬",
  "🥦",
  "🧄",
  "🧅",
  "🍄",
  "🥜",
  "🌰",
  "🍞",
  "🥐",
  "🥖",
  "🫓",
  "🥨",
  "🥯",
  "🥞",
  "🧇",
  "🧀",
  "🍖",
  "🍗",
  "🥩",
  "🥓",
  "🍔",
  "🍟",
  "🍕",
  "🌭",
  "🥪",
  "🌮",
  "🌯",
  "🫔",
  "🥙",
  "🧆",
  "🥚",
  "🍳",
  "🥘",
  "🍲",
  "🫕",
  "🥣",
  "🥗",
  "🍿",
  "🧈",
  "🧂",
  "🥫",
  "🍱",
  "🍘",
  "🍙",
  "🍚",
  "🍛",
  "🍜",
  "🍝",
  "🍠",
  "🍢",
  "🍣",
  "🍤",
  "🍥",
  "🥮",
  "🍡",
  "🥟",
  "🥠",
  "🥡",
  "🦀",
  "🦞",
  "🦐",
  "🦑",
  "🦪",
  "🍦",
  "🍧",
  "🍨",
  "🍩",
  "🍪",
  "🎂",
  "🍰",
  "🧁",
  "🥧",
  "🍫",
  "🍬",
  "🍭",
  "🍮",
  "🍯",
  "🍼",
  "🥛",
  "☕",
  "🫖",
  "🍵",
  "🍶",
  "🍾",
  "🍷",
  "🍸",
  "🍹",
  "🍺",
  "🍻",
  "🥂",
  "🥃",
  "🥤",
  "🧋",
  "🧃",
  "🧉",
  "🧊",
  "🥢",
  "🍽️",
  "🍽",
  "🍴",
  "🥄",
  "🔪",
  "🏺"
];
function Bue() {
  return /* @__PURE__ */ z(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      width: "1em",
      height: "1em",
      children: /* @__PURE__ */ z(
        "path",
        {
          d: "M12 0C5.373 0 0 5.372 0 12c0 6.627 5.373 12 12 12 6.628 0 12-5.373 12-12 0-6.628-5.372-12-12-12m9.949 11H17.05c.224-2.527 1.232-4.773 1.968-6.113A9.966 9.966 0 0 1 21.949 11M13 11V2.051a9.945 9.945 0 0 1 4.432 1.564c-.858 1.491-2.156 4.22-2.392 7.385H13zm-2 0H8.961c-.238-3.165-1.536-5.894-2.393-7.385A9.95 9.95 0 0 1 11 2.051V11zm0 2v8.949a9.937 9.937 0 0 1-4.432-1.564c.857-1.492 2.155-4.221 2.393-7.385H11zm4.04 0c.236 3.164 1.534 5.893 2.392 7.385A9.92 9.92 0 0 1 13 21.949V13h2.04zM4.982 4.887C5.718 6.227 6.726 8.473 6.951 11h-4.9a9.977 9.977 0 0 1 2.931-6.113M2.051 13h4.9c-.226 2.527-1.233 4.771-1.969 6.113A9.972 9.972 0 0 1 2.051 13m16.967 6.113c-.735-1.342-1.744-3.586-1.968-6.113h4.899a9.961 9.961 0 0 1-2.931 6.113",
          fill: "currentColor"
        }
      )
    }
  );
}
function Lue() {
  return /* @__PURE__ */ Fe(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      width: "1em",
      height: "1em",
      children: [
        /* @__PURE__ */ z(
          "path",
          {
            d: "M15.5 8a1.5 1.5 0 1 0 .001 3.001A1.5 1.5 0 0 0 15.5 8M8.5 8a1.5 1.5 0 1 0 .001 3.001A1.5 1.5 0 0 0 8.5 8",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ z(
          "path",
          {
            d: "M18.933 0h-.027c-.97 0-2.138.787-3.018 1.497-1.274-.374-2.612-.51-3.887-.51-1.285 0-2.616.133-3.874.517C7.245.79 6.069 0 5.093 0h-.027C3.352 0 .07 2.67.002 7.026c-.039 2.479.276 4.238 1.04 5.013.254.258.882.677 1.295.882.191 3.177.922 5.238 2.536 6.38.897.637 2.187.949 3.2 1.102C8.04 20.6 8 20.795 8 21c0 1.773 2.35 3 4 3 1.648 0 4-1.227 4-3 0-.201-.038-.393-.072-.586 2.573-.385 5.435-1.877 5.925-7.587.396-.22.887-.568 1.104-.788.763-.774 1.079-2.534 1.04-5.013C23.929 2.67 20.646 0 18.933 0M3.223 9.135c-.237.281-.837 1.155-.884 1.238-.15-.41-.368-1.349-.337-3.291.051-3.281 2.478-4.972 3.091-5.031.256.015.731.27 1.265.646-1.11 1.171-2.275 2.915-2.352 5.125-.133.546-.398.858-.783 1.313M12 22c-.901 0-1.954-.693-2-1 0-.654.475-1.236 1-1.602V20a1 1 0 1 0 2 0v-.602c.524.365 1 .947 1 1.602-.046.307-1.099 1-2 1m3-3.48v.02a4.752 4.752 0 0 0-1.262-1.02c1.092-.516 2.239-1.334 2.239-2.217 0-1.842-1.781-2.195-3.977-2.195-2.196 0-3.978.354-3.978 2.195 0 .883 1.148 1.701 2.238 2.217A4.8 4.8 0 0 0 9 18.539v-.025c-1-.076-2.182-.281-2.973-.842-1.301-.92-1.838-3.045-1.853-6.478l.023-.041c.496-.826 1.49-1.45 1.804-3.102 0-2.047 1.357-3.631 2.362-4.522C9.37 3.178 10.555 3 11.948 3c1.447 0 2.685.192 3.733.57 1 .9 2.316 2.465 2.316 4.48.313 1.651 1.307 2.275 1.803 3.102.035.058.068.117.102.178-.059 5.967-1.949 7.01-4.902 7.19m6.628-8.202c-.037-.065-.074-.13-.113-.195a7.587 7.587 0 0 0-.739-.987c-.385-.455-.648-.768-.782-1.313-.076-2.209-1.241-3.954-2.353-5.124.531-.376 1.004-.63 1.261-.647.636.071 3.044 1.764 3.096 5.031.027 1.81-.347 3.218-.37 3.235",
            fill: "currentColor"
          }
        )
      ]
    }
  );
}
function Pue() {
  return /* @__PURE__ */ z(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      width: "1em",
      height: "1em",
      children: /* @__PURE__ */ z(
        "path",
        {
          d: "M0 0l6.084 24H8L1.916 0zM21 5h-4l-1-4H4l3 12h3l1 4h13L21 5zM6.563 3h7.875l2 8H8.563l-2-8zm8.832 10l-2.856 1.904L12.063 13h3.332zM19 13l-1.5-6h1.938l2 8H16l3-2z",
          fill: "currentColor"
        }
      )
    }
  );
}
function Wue() {
  return /* @__PURE__ */ z(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      width: "1em",
      height: "1em",
      children: /* @__PURE__ */ z(
        "path",
        {
          d: "M17 4.978c-1.838 0-2.876.396-3.68.934.513-1.172 1.768-2.934 4.68-2.934a1 1 0 0 0 0-2c-2.921 0-4.629 1.365-5.547 2.512-.064.078-.119.162-.18.244C11.73 1.838 10.798.023 9.207.023 8.579.022 7.85.306 7 .978 5.027 2.54 5.329 3.902 6.492 4.999 3.609 5.222 0 7.352 0 12.969c0 4.582 4.961 11.009 9 11.009 1.975 0 2.371-.486 3-1 .629.514 1.025 1 3 1 4.039 0 9-6.418 9-11 0-5.953-4.055-8-7-8M8.242 2.546c.641-.508.943-.523.965-.523.426.169.975 1.405 1.357 3.055-1.527-.629-2.741-1.352-2.98-1.846.059-.112.241-.356.658-.686M15 21.978c-1.08 0-1.21-.109-1.559-.402l-.176-.146c-.367-.302-.816-.452-1.266-.452s-.898.15-1.266.452l-.176.146c-.347.292-.477.402-1.557.402-2.813 0-7-5.389-7-9.009 0-5.823 4.488-5.991 5-5.991 1.939 0 2.484.471 3.387 1.251l.323.276a1.995 1.995 0 0 0 2.58 0l.323-.276c.902-.78 1.447-1.251 3.387-1.251.512 0 5 .168 5 6 0 3.617-4.187 9-7 9",
          fill: "currentColor"
        }
      )
    }
  );
}
function zue() {
  return /* @__PURE__ */ Fe(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      width: "1em",
      height: "1em",
      children: [
        /* @__PURE__ */ z(
          "path",
          {
            d: "M12 0a9 9 0 0 0-5 16.482V21s2.035 3 5 3 5-3 5-3v-4.518A9 9 0 0 0 12 0zm0 2c3.86 0 7 3.141 7 7s-3.14 7-7 7-7-3.141-7-7 3.14-7 7-7zM9 17.477c.94.332 1.946.523 3 .523s2.06-.19 3-.523v.834c-.91.436-1.925.689-3 .689a6.924 6.924 0 0 1-3-.69v-.833zm.236 3.07A8.854 8.854 0 0 0 12 21c.965 0 1.888-.167 2.758-.451C14.155 21.173 13.153 22 12 22c-1.102 0-2.117-.789-2.764-1.453z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ z(
          "path",
          {
            d: "M14.745 12.449h-.004c-.852-.024-1.188-.858-1.577-1.824-.421-1.061-.703-1.561-1.182-1.566h-.009c-.481 0-.783.497-1.235 1.537-.436.982-.801 1.811-1.636 1.791l-.276-.043c-.565-.171-.853-.691-1.284-1.794-.125-.313-.202-.632-.27-.913-.051-.213-.127-.53-.195-.634C7.067 9.004 7.039 9 6.99 9A1 1 0 0 1 7 7h.01c1.662.017 2.015 1.373 2.198 2.134.486-.981 1.304-2.058 2.797-2.075 1.531.018 2.28 1.153 2.731 2.141l.002-.008C14.944 8.424 15.327 7 16.979 7h.032A1 1 0 1 1 17 9h-.011c-.149.076-.256.474-.319.709a6.484 6.484 0 0 1-.311.951c-.429.973-.79 1.789-1.614 1.789",
            fill: "currentColor"
          }
        )
      ]
    }
  );
}
function $ue() {
  return /* @__PURE__ */ z(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      width: "1em",
      height: "1em",
      children: /* @__PURE__ */ z(
        "path",
        {
          d: "M0 0h11v2H0zM4 11h3V6h4V4H0v2h4zM15.5 17c1.381 0 2.5-1.116 2.5-2.493s-1.119-2.493-2.5-2.493S13 13.13 13 14.507 14.119 17 15.5 17m0-2.986c.276 0 .5.222.5.493 0 .272-.224.493-.5.493s-.5-.221-.5-.493.224-.493.5-.493M21.5 19.014c-1.381 0-2.5 1.116-2.5 2.493S20.119 24 21.5 24s2.5-1.116 2.5-2.493-1.119-2.493-2.5-2.493m0 2.986a.497.497 0 0 1-.5-.493c0-.271.224-.493.5-.493s.5.222.5.493a.497.497 0 0 1-.5.493M22 13l-9 9 1.513 1.5 8.99-9.009zM17 11c2.209 0 4-1.119 4-2.5V2s.985-.161 1.498.949C23.01 4.055 23 6 23 6s1-1.119 1-3.135C24-.02 21 0 21 0h-2v6.347A5.853 5.853 0 0 0 17 6c-2.209 0-4 1.119-4 2.5s1.791 2.5 4 2.5M10.297 20.482l-1.475-1.585a47.54 47.54 0 0 1-1.442 1.129c-.307-.288-.989-1.016-2.045-2.183.902-.836 1.479-1.466 1.729-1.892s.376-.871.376-1.336c0-.592-.273-1.178-.818-1.759-.546-.581-1.329-.871-2.349-.871-1.008 0-1.79.293-2.344.879-.556.587-.832 1.181-.832 1.784 0 .813.419 1.748 1.256 2.805-.847.614-1.444 1.208-1.794 1.784a3.465 3.465 0 0 0-.523 1.833c0 .857.308 1.56.924 2.107.616.549 1.423.823 2.42.823 1.173 0 2.444-.379 3.813-1.137L8.235 24h2.819l-2.09-2.383 1.333-1.135zm-6.736-6.389a1.02 1.02 0 0 1 .73-.286c.31 0 .559.085.747.254a.849.849 0 0 1 .283.659c0 .518-.419 1.112-1.257 1.784-.536-.651-.805-1.231-.805-1.742a.901.901 0 0 1 .302-.669M3.74 22c-.427 0-.778-.116-1.057-.349-.279-.232-.418-.487-.418-.766 0-.594.509-1.288 1.527-2.083.968 1.134 1.717 1.946 2.248 2.438-.921.507-1.686.76-2.3.76",
          fill: "currentColor"
        }
      )
    }
  );
}
function Hue() {
  return /* @__PURE__ */ Fe(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      width: "1em",
      height: "1em",
      children: [
        /* @__PURE__ */ z(
          "path",
          {
            d: "M6.5 12C5.122 12 4 13.121 4 14.5S5.122 17 6.5 17 9 15.879 9 14.5 7.878 12 6.5 12m0 3c-.275 0-.5-.225-.5-.5s.225-.5.5-.5.5.225.5.5-.225.5-.5.5M17.5 12c-1.378 0-2.5 1.121-2.5 2.5s1.122 2.5 2.5 2.5 2.5-1.121 2.5-2.5-1.122-2.5-2.5-2.5m0 3c-.275 0-.5-.225-.5-.5s.225-.5.5-.5.5.225.5.5-.225.5-.5.5",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ z(
          "path",
          {
            d: "M22.482 9.494l-1.039-.346L21.4 9h.6c.552 0 1-.439 1-.992 0-.006-.003-.008-.003-.008H23c0-1-.889-2-1.984-2h-.642l-.731-1.717C19.262 3.012 18.091 2 16.764 2H7.236C5.909 2 4.738 3.012 4.357 4.283L3.626 6h-.642C1.889 6 1 7 1 8h.003S1 8.002 1 8.008C1 8.561 1.448 9 2 9h.6l-.043.148-1.039.346a2.001 2.001 0 0 0-1.359 2.097l.751 7.508a1 1 0 0 0 .994.901H3v1c0 1.103.896 2 2 2h2c1.104 0 2-.897 2-2v-1h6v1c0 1.103.896 2 2 2h2c1.104 0 2-.897 2-2v-1h1.096a.999.999 0 0 0 .994-.901l.751-7.508a2.001 2.001 0 0 0-1.359-2.097M6.273 4.857C6.402 4.43 6.788 4 7.236 4h9.527c.448 0 .834.43.963.857L19.313 9H4.688l1.585-4.143zM7 21H5v-1h2v1zm12 0h-2v-1h2v1zm2.189-3H2.811l-.662-6.607L3 11h18l.852.393L21.189 18z",
            fill: "currentColor"
          }
        )
      ]
    }
  );
}
function jue(t, e = null) {
  if (typeof window > "u")
    throw new Error();
  const n = localStorage.getItem(t);
  if (!n)
    return e;
  try {
    return JSON.parse(n);
  } catch {
    return n;
  }
}
function Vue(t, e) {
  window.localStorage.setItem(t, `${e}`);
}
let Vx = class {
  constructor(e, n) {
    ti(this, "key");
    ti(this, "value");
    ti(this, "prev");
    ti(this, "next");
    this.key = e, this.value = n, this.prev = null, this.next = null;
  }
};
class que {
  constructor(e) {
    ti(this, "capacity");
    ti(this, "usedCapacity");
    ti(this, "head");
    ti(this, "tail");
    ti(this, "store");
    this.capacity = e || 20, this.usedCapacity = 0, this.store = {}, this.head = new Vx("fakeHeadNode", "fakeHeadNode"), this.tail = new Vx("fakeTailNode", "fakeTailNode"), this.head.next = this.tail, this.tail.prev = this.head;
  }
  removeNode(e) {
    e.prev.next = e.next, e.next.prev = e.prev;
  }
  addToHead(e) {
    e.prev = this.head, e.next = this.head.next, this.head.next.prev = e, this.head.next = e;
  }
  moveToHead(e) {
    this.removeNode(e), this.addToHead(e);
  }
  removeTail() {
    const e = this.tail.prev;
    return this.removeNode(e), e;
  }
  get(e) {
    if (e in this.store) {
      const n = this.store[e];
      return this.moveToHead(n), n.value;
    }
    return -1;
  }
  put(e, n) {
    if (e in this.store) {
      const r = this.store[e];
      r.value = n, this.moveToHead(r);
    } else {
      const r = new Vx(e, n);
      if (this.addToHead(r), this.store[e] = r, this.usedCapacity += 1, this.usedCapacity > this.capacity) {
        const i = this.removeTail();
        delete this.store[i.key], this.usedCapacity -= 1;
      }
    }
  }
  keys() {
    const e = [];
    let n = this.head;
    for (; n; )
      e.push(n.key), n = n.next;
    return e.slice(1, -1);
  }
  values() {
    const e = [];
    let n = this.head;
    for (; n; )
      e.push(n.value), n = n.next;
    return e.slice(1, -1);
  }
  toJSON() {
    return this.store;
  }
}
function Gue(t, e) {
  const n = new que(e);
  return {
    syncFromStorage() {
      (jue(t) || []).slice().reverse().forEach((o) => {
        n.put(o, o);
      });
    },
    syncToStorage() {
      Vue(t, UZ(n.keys()));
    },
    put(i) {
      n.put(i, i), this.syncToStorage();
    },
    get(i) {
      return i ? n.get(i) : n.keys();
    }
  };
}
const Rd = Gue("EMOJI_PICKER", 20), BR = [
  {
    title: "Smileys & People",
    data: Aue,
    icon: _W
  },
  {
    title: "Animals & Nature",
    data: Nue,
    icon: Lue
  },
  {
    title: "Food & Drink",
    data: Mue,
    icon: Wue
  },
  {
    title: "Activity",
    data: Oue,
    icon: Bue
  },
  {
    title: "Travel & Places",
    data: Fue,
    icon: Hue
  },
  {
    title: "Object",
    data: Iue,
    icon: zue
  },
  {
    title: "Symbol",
    data: Rue,
    icon: $ue
  },
  {
    title: "Flags",
    data: Uue,
    icon: Pue
  }
], Kue = ["😀", "😃", "😄", "😁", "😆", "😅", "😂", "🤣"];
function Xue({ onSelectEmoji: t, children: e }) {
  const [n, r] = nt([]), { t: i } = Wt(), o = Yt(
    () => n.length ? [{ title: "Frequently used", icon: xW, data: n }, ...BR] : BR,
    [n]
  ), a = Et(
    (s) => {
      Rd.put(s), r(Rd.get()), t && t(s);
    },
    [t]
  );
  return Tt(() => {
    Rd.syncFromStorage();
    const s = Rd.get();
    s != null && s.length || Kue.forEach((c) => {
      Rd.put(c);
    });
    const l = Rd.get();
    r(l);
  }, []), /* @__PURE__ */ Fe(Eo, { modal: !0, children: [
    /* @__PURE__ */ z(Co, { asChild: !0, children: e }),
    /* @__PURE__ */ z(oo, { hideWhenDetached: !0, className: "richtext-w-full richtext-h-full richtext-p-2", align: "start", side: "bottom", children: /* @__PURE__ */ Fe(LD, { defaultValue: "Frequently used", children: [
      /* @__PURE__ */ z(S1, { className: "richtext-flex richtext-items-center richtext-gap-[4px]", children: o.map((s) => /* @__PURE__ */ z(
        Tf,
        {
          value: s.title,
          className: "!richtext-p-[6px] richtext-bg-accent hover:richtext-text-accent-foreground",
          children: s.icon && /* @__PURE__ */ z(s.icon, { size: 16 })
        },
        `emoji-picker-title-${s.title}`
      )) }),
      o.map((s) => /* @__PURE__ */ Fe(
        Df,
        {
          value: s.title,
          children: [
            /* @__PURE__ */ z("p", { className: "richtext-mb-[6px] richtext-font-semibold", children: i(s.title) }),
            /* @__PURE__ */ z("div", { className: "richtext-max-h-[280px] richtext-overflow-y-auto", children: /* @__PURE__ */ z("div", { className: "richtext-grid richtext-grid-cols-8 richtext-gap-1 ", children: (s.data || []).map((l) => /* @__PURE__ */ z(
              "div",
              {
                onClick: () => a(l),
                className: "richtext-text-center richtext-cursor-pointer",
                children: l
              },
              `emoji-picker-${l}`
            )) }) })
          ]
        },
        `emoji-picker-content-${s.title}`
      ))
    ] }) })
  ] });
}
function Yue({ editor: t, icon: e, ...n }) {
  const r = Et(
    (i) => {
      const { selection: o } = t.state, { $anchor: a } = o;
      return t.chain().insertContentAt(a.pos, i).run();
    },
    [t]
  );
  return /* @__PURE__ */ z(Xue, { onSelectEmoji: r, children: /* @__PURE__ */ z(
    Je,
    {
      tooltip: n == null ? void 0 : n.tooltip,
      icon: e
    }
  ) });
}
const Jue = 200, Zue = new Nt("emoji"), Y2e = rn.create({
  name: "emoji",
  content: "text*",
  priority: Jue,
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      HTMLAttributes: {},
      suggestion: {
        char: ":",
        pluginKey: Zue,
        command: ({ editor: e, range: n, props: r }) => {
          e.chain().focus().insertContentAt(n, `${r.emoji} `).run();
        }
      },
      button: ({ editor: e, t: n }) => ({
        component: Yue,
        componentProps: {
          editor: e,
          action: () => {
          },
          isActive: () => !1,
          disabled: !1,
          icon: "EmojiIcon",
          tooltip: n("editor.emoji.tooltip")
        }
      })
    };
  },
  addCommands() {
    return {
      setEmoji: (t) => ({ commands: e }) => e.insertContent(`${t.emoji} `)
    };
  },
  addProseMirrorPlugins() {
    return [
      wE({
        editor: this.editor,
        ...this.options.suggestion
      })
    ];
  }
}).configure({
  suggestion: {
    items: ({ query: t }) => kue(t),
    render: () => {
      let t, e, n;
      return {
        onStart: (r) => {
          n = r.editor.isEditable, n && (t = new g1(EM, {
            props: r,
            editor: r.editor
          }), e = Fm("body", {
            getReferenceClientRect: r.clientRect,
            appendTo: () => document.body,
            content: t.element,
            showOnCreate: !0,
            interactive: !0,
            trigger: "manual",
            placement: "bottom-start"
          }));
        },
        onUpdate(r) {
          n && (t.updateProps(r), e[0].setProps({
            getReferenceClientRect: r.clientRect
          }));
        },
        onKeyDown(r) {
          var i;
          if (n)
            return r.event.key === "Escape" ? (e[0].hide(), !0) : (i = t.ref) == null ? void 0 : i.onKeyDown(r);
        },
        onExit() {
          n && (e[0].destroy(), t.destroy());
        }
      };
    }
  }
});
function Que(t) {
  const e = document.createElement("iframe");
  e.setAttribute("style", "position: absolute; width: 0; height: 0; top: 0; left: 0;"), document.body.appendChild(e), e.textContent = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <title>Echo Editor</title>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body class="is-print">
      <div class="tiptap ProseMirror" translate="no" aria-expanded="false">
          ${t}
      </div>
    </body>
    </html>
  `;
  const n = e.contentWindow, r = e.contentDocument || e.contentWindow && e.contentWindow.document, i = document.createElement("link");
  i.rel = "stylesheet", i.href = "https://cdn.jsdelivr.net/npm/reactjs-tiptap-editor@latest/lib/style.css", r.head.appendChild(i), r && (r.open(), r.write(t), r.close()), n && (e.onload = function() {
    try {
      setTimeout(() => {
        n.focus();
        try {
          n.document.execCommand("print", !1) || n.print();
        } catch {
          n.print();
        }
        n.close();
      }, 10);
    } catch (o) {
      console.error(o);
    }
    setTimeout(() => {
      document.body.removeChild(e);
    }, 100);
  });
}
function ede(t) {
  const e = t.getHTML();
  return e ? (Que(e), !0) : !1;
}
const J2e = St.create({
  name: "exportPdf",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: Je,
        componentProps: {
          action: () => {
            ede(e);
          },
          icon: "ExportPdf",
          tooltip: n("editor.exportPdf.tooltip"),
          isActive: () => !1,
          disabled: !1
        }
      })
    };
  }
});
var Ao = {}, _E = "1.13.7", LR = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {}, M1 = Array.prototype, SE = Object.prototype, PR = typeof Symbol < "u" ? Symbol.prototype : null, tde = M1.push, qm = M1.slice, wm = SE.toString, nde = SE.hasOwnProperty, CM = typeof ArrayBuffer < "u", rde = typeof DataView < "u", ide = Array.isArray, WR = Object.keys, zR = Object.create, $R = CM && ArrayBuffer.isView, ode = isNaN, ade = isFinite, kM = !{ toString: null }.propertyIsEnumerable("toString"), HR = [
  "valueOf",
  "isPrototypeOf",
  "toString",
  "propertyIsEnumerable",
  "hasOwnProperty",
  "toLocaleString"
], sde = Math.pow(2, 53) - 1;
function jr(t, e) {
  return e = e == null ? t.length - 1 : +e, function() {
    for (var n = Math.max(arguments.length - e, 0), r = Array(n), i = 0; i < n; i++)
      r[i] = arguments[i + e];
    switch (e) {
      case 0:
        return t.call(this, r);
      case 1:
        return t.call(this, arguments[0], r);
      case 2:
        return t.call(this, arguments[0], arguments[1], r);
    }
    var o = Array(e + 1);
    for (i = 0; i < e; i++)
      o[i] = arguments[i];
    return o[e] = r, t.apply(this, o);
  };
}
function Wl(t) {
  var e = typeof t;
  return e === "function" || e === "object" && !!t;
}
function AM(t) {
  return t === null;
}
function TE(t) {
  return t === void 0;
}
function DE(t) {
  return t === !0 || t === !1 || wm.call(t) === "[object Boolean]";
}
function RM(t) {
  return !!(t && t.nodeType === 1);
}
function Cr(t) {
  var e = "[object " + t + "]";
  return function(n) {
    return wm.call(n) === e;
  };
}
const B1 = Cr("String"), EE = Cr("Number"), IM = Cr("Date"), OM = Cr("RegExp"), FM = Cr("Error"), CE = Cr("Symbol"), kE = Cr("ArrayBuffer");
var UM = Cr("Function"), lde = LR.document && LR.document.childNodes;
typeof /./ != "function" && typeof Int8Array != "object" && typeof lde != "function" && (UM = function(t) {
  return typeof t == "function" || !1;
});
const Tr = UM, NM = Cr("Object");
var MM = rde && (!/\[native code\]/.test(String(DataView)) || NM(new DataView(new ArrayBuffer(8)))), AE = typeof Map < "u" && NM(/* @__PURE__ */ new Map()), cde = Cr("DataView");
function ude(t) {
  return t != null && Tr(t.getInt8) && kE(t.buffer);
}
const xm = MM ? ude : cde, zl = ide || Cr("Array");
function $l(t, e) {
  return t != null && nde.call(t, e);
}
var AT = Cr("Arguments");
(function() {
  AT(arguments) || (AT = function(t) {
    return $l(t, "callee");
  });
})();
const L1 = AT;
function BM(t) {
  return !CE(t) && ade(t) && !isNaN(parseFloat(t));
}
function RE(t) {
  return EE(t) && ode(t);
}
function IE(t) {
  return function() {
    return t;
  };
}
function LM(t) {
  return function(e) {
    var n = t(e);
    return typeof n == "number" && n >= 0 && n <= sde;
  };
}
function PM(t) {
  return function(e) {
    return e == null ? void 0 : e[t];
  };
}
const Iv = PM("byteLength"), dde = LM(Iv);
var fde = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function hde(t) {
  return $R ? $R(t) && !xm(t) : dde(t) && fde.test(wm.call(t));
}
const OE = CM ? hde : IE(!1), ci = PM("length");
function pde(t) {
  for (var e = {}, n = t.length, r = 0; r < n; ++r) e[t[r]] = !0;
  return {
    contains: function(i) {
      return e[i] === !0;
    },
    push: function(i) {
      return e[i] = !0, t.push(i);
    }
  };
}
function WM(t, e) {
  e = pde(e);
  var n = HR.length, r = t.constructor, i = Tr(r) && r.prototype || SE, o = "constructor";
  for ($l(t, o) && !e.contains(o) && e.push(o); n--; )
    o = HR[n], o in t && t[o] !== i[o] && !e.contains(o) && e.push(o);
}
function Mn(t) {
  if (!Wl(t)) return [];
  if (WR) return WR(t);
  var e = [];
  for (var n in t) $l(t, n) && e.push(n);
  return kM && WM(t, e), e;
}
function zM(t) {
  if (t == null) return !0;
  var e = ci(t);
  return typeof e == "number" && (zl(t) || B1(t) || L1(t)) ? e === 0 : ci(Mn(t)) === 0;
}
function FE(t, e) {
  var n = Mn(e), r = n.length;
  if (t == null) return !r;
  for (var i = Object(t), o = 0; o < r; o++) {
    var a = n[o];
    if (e[a] !== i[a] || !(a in i)) return !1;
  }
  return !0;
}
function Ht(t) {
  if (t instanceof Ht) return t;
  if (!(this instanceof Ht)) return new Ht(t);
  this._wrapped = t;
}
Ht.VERSION = _E;
Ht.prototype.value = function() {
  return this._wrapped;
};
Ht.prototype.valueOf = Ht.prototype.toJSON = Ht.prototype.value;
Ht.prototype.toString = function() {
  return String(this._wrapped);
};
function jR(t) {
  return new Uint8Array(
    t.buffer || t,
    t.byteOffset || 0,
    Iv(t)
  );
}
var VR = "[object DataView]";
function RT(t, e, n, r) {
  if (t === e) return t !== 0 || 1 / t === 1 / e;
  if (t == null || e == null) return !1;
  if (t !== t) return e !== e;
  var i = typeof t;
  return i !== "function" && i !== "object" && typeof e != "object" ? !1 : $M(t, e, n, r);
}
function $M(t, e, n, r) {
  t instanceof Ht && (t = t._wrapped), e instanceof Ht && (e = e._wrapped);
  var i = wm.call(t);
  if (i !== wm.call(e)) return !1;
  if (MM && i == "[object Object]" && xm(t)) {
    if (!xm(e)) return !1;
    i = VR;
  }
  switch (i) {
    case "[object RegExp]":
    case "[object String]":
      return "" + t == "" + e;
    case "[object Number]":
      return +t != +t ? +e != +e : +t == 0 ? 1 / +t === 1 / e : +t == +e;
    case "[object Date]":
    case "[object Boolean]":
      return +t == +e;
    case "[object Symbol]":
      return PR.valueOf.call(t) === PR.valueOf.call(e);
    case "[object ArrayBuffer]":
    case VR:
      return $M(jR(t), jR(e), n, r);
  }
  var o = i === "[object Array]";
  if (!o && OE(t)) {
    var a = Iv(t);
    if (a !== Iv(e)) return !1;
    if (t.buffer === e.buffer && t.byteOffset === e.byteOffset) return !0;
    o = !0;
  }
  if (!o) {
    if (typeof t != "object" || typeof e != "object") return !1;
    var s = t.constructor, l = e.constructor;
    if (s !== l && !(Tr(s) && s instanceof s && Tr(l) && l instanceof l) && "constructor" in t && "constructor" in e)
      return !1;
  }
  n = n || [], r = r || [];
  for (var c = n.length; c--; )
    if (n[c] === t) return r[c] === e;
  if (n.push(t), r.push(e), o) {
    if (c = t.length, c !== e.length) return !1;
    for (; c--; )
      if (!RT(t[c], e[c], n, r)) return !1;
  } else {
    var u = Mn(t), d;
    if (c = u.length, Mn(e).length !== c) return !1;
    for (; c--; )
      if (d = u[c], !($l(e, d) && RT(t[d], e[d], n, r))) return !1;
  }
  return n.pop(), r.pop(), !0;
}
function HM(t, e) {
  return RT(t, e);
}
function th(t) {
  if (!Wl(t)) return [];
  var e = [];
  for (var n in t) e.push(n);
  return kM && WM(t, e), e;
}
function UE(t) {
  var e = ci(t);
  return function(n) {
    if (n == null) return !1;
    var r = th(n);
    if (ci(r)) return !1;
    for (var i = 0; i < e; i++)
      if (!Tr(n[t[i]])) return !1;
    return t !== qM || !Tr(n[NE]);
  };
}
var NE = "forEach", jM = "has", ME = ["clear", "delete"], VM = ["get", jM, "set"], mde = ME.concat(NE, VM), qM = ME.concat(VM), gde = ["add"].concat(ME, NE, jM);
const GM = AE ? UE(mde) : Cr("Map"), KM = AE ? UE(qM) : Cr("WeakMap"), XM = AE ? UE(gde) : Cr("Set"), YM = Cr("WeakSet");
function vu(t) {
  for (var e = Mn(t), n = e.length, r = Array(n), i = 0; i < n; i++)
    r[i] = t[e[i]];
  return r;
}
function JM(t) {
  for (var e = Mn(t), n = e.length, r = Array(n), i = 0; i < n; i++)
    r[i] = [e[i], t[e[i]]];
  return r;
}
function BE(t) {
  for (var e = {}, n = Mn(t), r = 0, i = n.length; r < i; r++)
    e[t[n[r]]] = n[r];
  return e;
}
function _m(t) {
  var e = [];
  for (var n in t)
    Tr(t[n]) && e.push(n);
  return e.sort();
}
function LE(t, e) {
  return function(n) {
    var r = arguments.length;
    if (e && (n = Object(n)), r < 2 || n == null) return n;
    for (var i = 1; i < r; i++)
      for (var o = arguments[i], a = t(o), s = a.length, l = 0; l < s; l++) {
        var c = a[l];
        (!e || n[c] === void 0) && (n[c] = o[c]);
      }
    return n;
  };
}
const PE = LE(th), Ff = LE(Mn), WE = LE(th, !0);
function yde() {
  return function() {
  };
}
function ZM(t) {
  if (!Wl(t)) return {};
  if (zR) return zR(t);
  var e = yde();
  e.prototype = t;
  var n = new e();
  return e.prototype = null, n;
}
function QM(t, e) {
  var n = ZM(t);
  return e && Ff(n, e), n;
}
function eB(t) {
  return Wl(t) ? zl(t) ? t.slice() : PE({}, t) : t;
}
function tB(t, e) {
  return e(t), t;
}
function zE(t) {
  return zl(t) ? t : [t];
}
Ht.toPath = zE;
function Gm(t) {
  return Ht.toPath(t);
}
function $E(t, e) {
  for (var n = e.length, r = 0; r < n; r++) {
    if (t == null) return;
    t = t[e[r]];
  }
  return n ? t : void 0;
}
function HE(t, e, n) {
  var r = $E(t, Gm(e));
  return TE(r) ? n : r;
}
function nB(t, e) {
  e = Gm(e);
  for (var n = e.length, r = 0; r < n; r++) {
    var i = e[r];
    if (!$l(t, i)) return !1;
    t = t[i];
  }
  return !!n;
}
function P1(t) {
  return t;
}
function nu(t) {
  return t = Ff({}, t), function(e) {
    return FE(e, t);
  };
}
function W1(t) {
  return t = Gm(t), function(e) {
    return $E(e, t);
  };
}
function Km(t, e, n) {
  if (e === void 0) return t;
  switch (n ?? 3) {
    case 1:
      return function(r) {
        return t.call(e, r);
      };
    case 3:
      return function(r, i, o) {
        return t.call(e, r, i, o);
      };
    case 4:
      return function(r, i, o, a) {
        return t.call(e, r, i, o, a);
      };
  }
  return function() {
    return t.apply(e, arguments);
  };
}
function rB(t, e, n) {
  return t == null ? P1 : Tr(t) ? Km(t, e, n) : Wl(t) && !zl(t) ? nu(t) : W1(t);
}
function z1(t, e) {
  return rB(t, e, 1 / 0);
}
Ht.iteratee = z1;
function di(t, e, n) {
  return Ht.iteratee !== z1 ? Ht.iteratee(t, e) : rB(t, e, n);
}
function iB(t, e, n) {
  e = di(e, n);
  for (var r = Mn(t), i = r.length, o = {}, a = 0; a < i; a++) {
    var s = r[a];
    o[s] = e(t[s], s, t);
  }
  return o;
}
function jE() {
}
function oB(t) {
  return t == null ? jE : function(e) {
    return HE(t, e);
  };
}
function aB(t, e, n) {
  var r = Array(Math.max(0, t));
  e = Km(e, n, 1);
  for (var i = 0; i < t; i++) r[i] = e(i);
  return r;
}
function Ov(t, e) {
  return e == null && (e = t, t = 0), t + Math.floor(Math.random() * (e - t + 1));
}
const Uf = Date.now || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function sB(t) {
  var e = function(o) {
    return t[o];
  }, n = "(?:" + Mn(t).join("|") + ")", r = RegExp(n), i = RegExp(n, "g");
  return function(o) {
    return o = o == null ? "" : "" + o, r.test(o) ? o.replace(i, e) : o;
  };
}
const lB = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
}, cB = sB(lB), bde = BE(lB), uB = sB(bde), dB = Ht.templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
};
var qx = /(.)^/, vde = {
  "'": "'",
  "\\": "\\",
  "\r": "r",
  "\n": "n",
  "\u2028": "u2028",
  "\u2029": "u2029"
}, wde = /\\|'|\r|\n|\u2028|\u2029/g;
function xde(t) {
  return "\\" + vde[t];
}
var _de = /^\s*(\w|\$)+\s*$/;
function fB(t, e, n) {
  !e && n && (e = n), e = WE({}, e, Ht.templateSettings);
  var r = RegExp([
    (e.escape || qx).source,
    (e.interpolate || qx).source,
    (e.evaluate || qx).source
  ].join("|") + "|$", "g"), i = 0, o = "__p+='";
  t.replace(r, function(c, u, d, f, p) {
    return o += t.slice(i, p).replace(wde, xde), i = p + c.length, u ? o += `'+
((__t=(` + u + `))==null?'':_.escape(__t))+
'` : d ? o += `'+
((__t=(` + d + `))==null?'':__t)+
'` : f && (o += `';
` + f + `
__p+='`), c;
  }), o += `';
`;
  var a = e.variable;
  if (a) {
    if (!_de.test(a)) throw new Error(
      "variable is not a bare identifier: " + a
    );
  } else
    o = `with(obj||{}){
` + o + `}
`, a = "obj";
  o = `var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
` + o + `return __p;
`;
  var s;
  try {
    s = new Function(a, "_", o);
  } catch (c) {
    throw c.source = o, c;
  }
  var l = function(c) {
    return s.call(this, c, Ht);
  };
  return l.source = "function(" + a + `){
` + o + "}", l;
}
function hB(t, e, n) {
  e = Gm(e);
  var r = e.length;
  if (!r)
    return Tr(n) ? n.call(t) : n;
  for (var i = 0; i < r; i++) {
    var o = t == null ? void 0 : t[e[i]];
    o === void 0 && (o = n, i = r), t = Tr(o) ? o.call(t) : o;
  }
  return t;
}
var Sde = 0;
function pB(t) {
  var e = ++Sde + "";
  return t ? t + e : e;
}
function mB(t) {
  var e = Ht(t);
  return e._chain = !0, e;
}
function gB(t, e, n, r, i) {
  if (!(r instanceof e)) return t.apply(n, i);
  var o = ZM(t.prototype), a = t.apply(o, i);
  return Wl(a) ? a : o;
}
var wu = jr(function(t, e) {
  var n = wu.placeholder, r = function() {
    for (var i = 0, o = e.length, a = Array(o), s = 0; s < o; s++)
      a[s] = e[s] === n ? arguments[i++] : e[s];
    for (; i < arguments.length; ) a.push(arguments[i++]);
    return gB(t, r, this, this, a);
  };
  return r;
});
wu.placeholder = Ht;
const VE = jr(function(t, e, n) {
  if (!Tr(t)) throw new TypeError("Bind must be called on a function");
  var r = jr(function(i) {
    return gB(t, r, e, this, n.concat(i));
  });
  return r;
}), Ai = LM(ci);
function xu(t, e, n, r) {
  if (r = r || [], !e && e !== 0)
    e = 1 / 0;
  else if (e <= 0)
    return r.concat(t);
  for (var i = r.length, o = 0, a = ci(t); o < a; o++) {
    var s = t[o];
    if (Ai(s) && (zl(s) || L1(s)))
      if (e > 1)
        xu(s, e - 1, n, r), i = r.length;
      else
        for (var l = 0, c = s.length; l < c; ) r[i++] = s[l++];
    else n || (r[i++] = s);
  }
  return r;
}
const yB = jr(function(t, e) {
  e = xu(e, !1, !1);
  var n = e.length;
  if (n < 1) throw new Error("bindAll must be passed function names");
  for (; n--; ) {
    var r = e[n];
    t[r] = VE(t[r], t);
  }
  return t;
});
function bB(t, e) {
  var n = function(r) {
    var i = n.cache, o = "" + (e ? e.apply(this, arguments) : r);
    return $l(i, o) || (i[o] = t.apply(this, arguments)), i[o];
  };
  return n.cache = {}, n;
}
const qE = jr(function(t, e, n) {
  return setTimeout(function() {
    return t.apply(null, n);
  }, e);
}), vB = wu(qE, Ht, 1);
function wB(t, e, n) {
  var r, i, o, a, s = 0;
  n || (n = {});
  var l = function() {
    s = n.leading === !1 ? 0 : Uf(), r = null, a = t.apply(i, o), r || (i = o = null);
  }, c = function() {
    var u = Uf();
    !s && n.leading === !1 && (s = u);
    var d = e - (u - s);
    return i = this, o = arguments, d <= 0 || d > e ? (r && (clearTimeout(r), r = null), s = u, a = t.apply(i, o), r || (i = o = null)) : !r && n.trailing !== !1 && (r = setTimeout(l, d)), a;
  };
  return c.cancel = function() {
    clearTimeout(r), s = 0, r = i = o = null;
  }, c;
}
function xB(t, e, n) {
  var r, i, o, a, s, l = function() {
    var u = Uf() - i;
    e > u ? r = setTimeout(l, e - u) : (r = null, n || (a = t.apply(s, o)), r || (o = s = null));
  }, c = jr(function(u) {
    return s = this, o = u, i = Uf(), r || (r = setTimeout(l, e), n && (a = t.apply(s, o))), a;
  });
  return c.cancel = function() {
    clearTimeout(r), r = o = s = null;
  }, c;
}
function _B(t, e) {
  return wu(e, t);
}
function $1(t) {
  return function() {
    return !t.apply(this, arguments);
  };
}
function SB() {
  var t = arguments, e = t.length - 1;
  return function() {
    for (var n = e, r = t[e].apply(this, arguments); n--; ) r = t[n].call(this, r);
    return r;
  };
}
function TB(t, e) {
  return function() {
    if (--t < 1)
      return e.apply(this, arguments);
  };
}
function GE(t, e) {
  var n;
  return function() {
    return --t > 0 && (n = e.apply(this, arguments)), t <= 1 && (e = null), n;
  };
}
const DB = wu(GE, 2);
function KE(t, e, n) {
  e = di(e, n);
  for (var r = Mn(t), i, o = 0, a = r.length; o < a; o++)
    if (i = r[o], e(t[i], i, t)) return i;
}
function EB(t) {
  return function(e, n, r) {
    n = di(n, r);
    for (var i = ci(e), o = t > 0 ? 0 : i - 1; o >= 0 && o < i; o += t)
      if (n(e[o], o, e)) return o;
    return -1;
  };
}
const H1 = EB(1), XE = EB(-1);
function YE(t, e, n, r) {
  n = di(n, r, 1);
  for (var i = n(e), o = 0, a = ci(t); o < a; ) {
    var s = Math.floor((o + a) / 2);
    n(t[s]) < i ? o = s + 1 : a = s;
  }
  return o;
}
function CB(t, e, n) {
  return function(r, i, o) {
    var a = 0, s = ci(r);
    if (typeof o == "number")
      t > 0 ? a = o >= 0 ? o : Math.max(o + s, a) : s = o >= 0 ? Math.min(o + 1, s) : o + s + 1;
    else if (n && o && s)
      return o = n(r, i), r[o] === i ? o : -1;
    if (i !== i)
      return o = e(qm.call(r, a, s), RE), o >= 0 ? o + a : -1;
    for (o = t > 0 ? a : s - 1; o >= 0 && o < s; o += t)
      if (r[o] === i) return o;
    return -1;
  };
}
const JE = CB(1, H1, YE), kB = CB(-1, XE);
function Sm(t, e, n) {
  var r = Ai(t) ? H1 : KE, i = r(t, e, n);
  if (i !== void 0 && i !== -1) return t[i];
}
function AB(t, e) {
  return Sm(t, nu(e));
}
function Do(t, e, n) {
  e = Km(e, n);
  var r, i;
  if (Ai(t))
    for (r = 0, i = t.length; r < i; r++)
      e(t[r], r, t);
  else {
    var o = Mn(t);
    for (r = 0, i = o.length; r < i; r++)
      e(t[o[r]], o[r], t);
  }
  return t;
}
function us(t, e, n) {
  e = di(e, n);
  for (var r = !Ai(t) && Mn(t), i = (r || t).length, o = Array(i), a = 0; a < i; a++) {
    var s = r ? r[a] : a;
    o[a] = e(t[s], s, t);
  }
  return o;
}
function RB(t) {
  var e = function(n, r, i, o) {
    var a = !Ai(n) && Mn(n), s = (a || n).length, l = t > 0 ? 0 : s - 1;
    for (o || (i = n[a ? a[l] : l], l += t); l >= 0 && l < s; l += t) {
      var c = a ? a[l] : l;
      i = r(i, n[c], c, n);
    }
    return i;
  };
  return function(n, r, i, o) {
    var a = arguments.length >= 3;
    return e(n, Km(r, o, 4), i, a);
  };
}
const uf = RB(1), Fv = RB(-1);
function Al(t, e, n) {
  var r = [];
  return e = di(e, n), Do(t, function(i, o, a) {
    e(i, o, a) && r.push(i);
  }), r;
}
function IB(t, e, n) {
  return Al(t, $1(di(e)), n);
}
function Uv(t, e, n) {
  e = di(e, n);
  for (var r = !Ai(t) && Mn(t), i = (r || t).length, o = 0; o < i; o++) {
    var a = r ? r[o] : o;
    if (!e(t[a], a, t)) return !1;
  }
  return !0;
}
function Nv(t, e, n) {
  e = di(e, n);
  for (var r = !Ai(t) && Mn(t), i = (r || t).length, o = 0; o < i; o++) {
    var a = r ? r[o] : o;
    if (e(t[a], a, t)) return !0;
  }
  return !1;
}
function to(t, e, n, r) {
  return Ai(t) || (t = vu(t)), (typeof n != "number" || r) && (n = 0), JE(t, e, n) >= 0;
}
const OB = jr(function(t, e, n) {
  var r, i;
  return Tr(e) ? i = e : (e = Gm(e), r = e.slice(0, -1), e = e[e.length - 1]), us(t, function(o) {
    var a = i;
    if (!a) {
      if (r && r.length && (o = $E(o, r)), o == null) return;
      a = o[e];
    }
    return a == null ? a : a.apply(o, n);
  });
});
function j1(t, e) {
  return us(t, W1(e));
}
function FB(t, e) {
  return Al(t, nu(e));
}
function ZE(t, e, n) {
  var r = -1 / 0, i = -1 / 0, o, a;
  if (e == null || typeof e == "number" && typeof t[0] != "object" && t != null) {
    t = Ai(t) ? t : vu(t);
    for (var s = 0, l = t.length; s < l; s++)
      o = t[s], o != null && o > r && (r = o);
  } else
    e = di(e, n), Do(t, function(c, u, d) {
      a = e(c, u, d), (a > i || a === -1 / 0 && r === -1 / 0) && (r = c, i = a);
    });
  return r;
}
function UB(t, e, n) {
  var r = 1 / 0, i = 1 / 0, o, a;
  if (e == null || typeof e == "number" && typeof t[0] != "object" && t != null) {
    t = Ai(t) ? t : vu(t);
    for (var s = 0, l = t.length; s < l; s++)
      o = t[s], o != null && o < r && (r = o);
  } else
    e = di(e, n), Do(t, function(c, u, d) {
      a = e(c, u, d), (a < i || a === 1 / 0 && r === 1 / 0) && (r = c, i = a);
    });
  return r;
}
var Tde = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function QE(t) {
  return t ? zl(t) ? qm.call(t) : B1(t) ? t.match(Tde) : Ai(t) ? us(t, P1) : vu(t) : [];
}
function eC(t, e, n) {
  if (e == null || n)
    return Ai(t) || (t = vu(t)), t[Ov(t.length - 1)];
  var r = QE(t), i = ci(r);
  e = Math.max(Math.min(e, i), 0);
  for (var o = i - 1, a = 0; a < e; a++) {
    var s = Ov(a, o), l = r[a];
    r[a] = r[s], r[s] = l;
  }
  return r.slice(0, e);
}
function NB(t) {
  return eC(t, 1 / 0);
}
function MB(t, e, n) {
  var r = 0;
  return e = di(e, n), j1(us(t, function(i, o, a) {
    return {
      value: i,
      index: r++,
      criteria: e(i, o, a)
    };
  }).sort(function(i, o) {
    var a = i.criteria, s = o.criteria;
    if (a !== s) {
      if (a > s || a === void 0) return 1;
      if (a < s || s === void 0) return -1;
    }
    return i.index - o.index;
  }), "value");
}
function V1(t, e) {
  return function(n, r, i) {
    var o = e ? [[], []] : {};
    return r = di(r, i), Do(n, function(a, s) {
      var l = r(a, s, n);
      t(o, a, l);
    }), o;
  };
}
const BB = V1(function(t, e, n) {
  $l(t, n) ? t[n].push(e) : t[n] = [e];
}), LB = V1(function(t, e, n) {
  t[n] = e;
}), PB = V1(function(t, e, n) {
  $l(t, n) ? t[n]++ : t[n] = 1;
}), WB = V1(function(t, e, n) {
  t[n ? 0 : 1].push(e);
}, !0);
function zB(t) {
  return t == null ? 0 : Ai(t) ? t.length : Mn(t).length;
}
function Dde(t, e, n) {
  return e in n;
}
const tC = jr(function(t, e) {
  var n = {}, r = e[0];
  if (t == null) return n;
  Tr(r) ? (e.length > 1 && (r = Km(r, e[1])), e = th(t)) : (r = Dde, e = xu(e, !1, !1), t = Object(t));
  for (var i = 0, o = e.length; i < o; i++) {
    var a = e[i], s = t[a];
    r(s, a, t) && (n[a] = s);
  }
  return n;
}), $B = jr(function(t, e) {
  var n = e[0], r;
  return Tr(n) ? (n = $1(n), e.length > 1 && (r = e[1])) : (e = us(xu(e, !1, !1), String), n = function(i, o) {
    return !to(e, o);
  }), tC(t, n, r);
});
function nC(t, e, n) {
  return qm.call(t, 0, Math.max(0, t.length - (e == null || n ? 1 : e)));
}
function df(t, e, n) {
  return t == null || t.length < 1 ? e == null || n ? void 0 : [] : e == null || n ? t[0] : nC(t, t.length - e);
}
function qc(t, e, n) {
  return qm.call(t, e == null || n ? 1 : e);
}
function HB(t, e, n) {
  return t == null || t.length < 1 ? e == null || n ? void 0 : [] : e == null || n ? t[t.length - 1] : qc(t, Math.max(0, t.length - e));
}
function jB(t) {
  return Al(t, Boolean);
}
function VB(t, e) {
  return xu(t, e, !1);
}
const rC = jr(function(t, e) {
  return e = xu(e, !0, !0), Al(t, function(n) {
    return !to(e, n);
  });
}), qB = jr(function(t, e) {
  return rC(t, e);
});
function Tm(t, e, n, r) {
  DE(e) || (r = n, n = e, e = !1), n != null && (n = di(n, r));
  for (var i = [], o = [], a = 0, s = ci(t); a < s; a++) {
    var l = t[a], c = n ? n(l, a, t) : l;
    e && !n ? ((!a || o !== c) && i.push(l), o = c) : n ? to(o, c) || (o.push(c), i.push(l)) : to(i, l) || i.push(l);
  }
  return i;
}
const GB = jr(function(t) {
  return Tm(xu(t, !0, !0));
});
function KB(t) {
  for (var e = [], n = arguments.length, r = 0, i = ci(t); r < i; r++) {
    var o = t[r];
    if (!to(e, o)) {
      var a;
      for (a = 1; a < n && to(arguments[a], o); a++)
        ;
      a === n && e.push(o);
    }
  }
  return e;
}
function Dm(t) {
  for (var e = t && ZE(t, ci).length || 0, n = Array(e), r = 0; r < e; r++)
    n[r] = j1(t, r);
  return n;
}
const XB = jr(Dm);
function YB(t, e) {
  for (var n = {}, r = 0, i = ci(t); r < i; r++)
    e ? n[t[r]] = e[r] : n[t[r][0]] = t[r][1];
  return n;
}
function JB(t, e, n) {
  e == null && (e = t || 0, t = 0), n || (n = e < t ? -1 : 1);
  for (var r = Math.max(Math.ceil((e - t) / n), 0), i = Array(r), o = 0; o < r; o++, t += n)
    i[o] = t;
  return i;
}
function ZB(t, e) {
  if (e == null || e < 1) return [];
  for (var n = [], r = 0, i = t.length; r < i; )
    n.push(qm.call(t, r, r += e));
  return n;
}
function iC(t, e) {
  return t._chain ? Ht(e).chain() : e;
}
function oC(t) {
  return Do(_m(t), function(e) {
    var n = Ht[e] = t[e];
    Ht.prototype[e] = function() {
      var r = [this._wrapped];
      return tde.apply(r, arguments), iC(this, n.apply(Ht, r));
    };
  }), Ht;
}
Do(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(t) {
  var e = M1[t];
  Ht.prototype[t] = function() {
    var n = this._wrapped;
    return n != null && (e.apply(n, arguments), (t === "shift" || t === "splice") && n.length === 0 && delete n[0]), iC(this, n);
  };
});
Do(["concat", "join", "slice"], function(t) {
  var e = M1[t];
  Ht.prototype[t] = function() {
    var n = this._wrapped;
    return n != null && (n = e.apply(n, arguments)), iC(this, n);
  };
});
const Ede = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VERSION: _E,
  after: TB,
  all: Uv,
  allKeys: th,
  any: Nv,
  assign: Ff,
  before: GE,
  bind: VE,
  bindAll: yB,
  chain: mB,
  chunk: ZB,
  clone: eB,
  collect: us,
  compact: jB,
  compose: SB,
  constant: IE,
  contains: to,
  countBy: PB,
  create: QM,
  debounce: xB,
  default: Ht,
  defaults: WE,
  defer: vB,
  delay: qE,
  detect: Sm,
  difference: rC,
  drop: qc,
  each: Do,
  escape: cB,
  every: Uv,
  extend: PE,
  extendOwn: Ff,
  filter: Al,
  find: Sm,
  findIndex: H1,
  findKey: KE,
  findLastIndex: XE,
  findWhere: AB,
  first: df,
  flatten: VB,
  foldl: uf,
  foldr: Fv,
  forEach: Do,
  functions: _m,
  get: HE,
  groupBy: BB,
  has: nB,
  head: df,
  identity: P1,
  include: to,
  includes: to,
  indexBy: LB,
  indexOf: JE,
  initial: nC,
  inject: uf,
  intersection: KB,
  invert: BE,
  invoke: OB,
  isArguments: L1,
  isArray: zl,
  isArrayBuffer: kE,
  isBoolean: DE,
  isDataView: xm,
  isDate: IM,
  isElement: RM,
  isEmpty: zM,
  isEqual: HM,
  isError: FM,
  isFinite: BM,
  isFunction: Tr,
  isMap: GM,
  isMatch: FE,
  isNaN: RE,
  isNull: AM,
  isNumber: EE,
  isObject: Wl,
  isRegExp: OM,
  isSet: XM,
  isString: B1,
  isSymbol: CE,
  isTypedArray: OE,
  isUndefined: TE,
  isWeakMap: KM,
  isWeakSet: YM,
  iteratee: z1,
  keys: Mn,
  last: HB,
  lastIndexOf: kB,
  map: us,
  mapObject: iB,
  matcher: nu,
  matches: nu,
  max: ZE,
  memoize: bB,
  methods: _m,
  min: UB,
  mixin: oC,
  negate: $1,
  noop: jE,
  now: Uf,
  object: YB,
  omit: $B,
  once: DB,
  pairs: JM,
  partial: wu,
  partition: WB,
  pick: tC,
  pluck: j1,
  property: W1,
  propertyOf: oB,
  random: Ov,
  range: JB,
  reduce: uf,
  reduceRight: Fv,
  reject: IB,
  rest: qc,
  restArguments: jr,
  result: hB,
  sample: eC,
  select: Al,
  shuffle: NB,
  size: zB,
  some: Nv,
  sortBy: MB,
  sortedIndex: YE,
  tail: qc,
  take: df,
  tap: tB,
  template: fB,
  templateSettings: dB,
  throttle: wB,
  times: aB,
  toArray: QE,
  toPath: zE,
  transpose: Dm,
  unescape: uB,
  union: GB,
  uniq: Tm,
  unique: Tm,
  uniqueId: pB,
  unzip: Dm,
  values: vu,
  where: FB,
  without: qB,
  wrap: _B,
  zip: XB
}, Symbol.toStringTag, { value: "Module" }));
var IT = oC(Ede);
IT._ = IT;
const Cde = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VERSION: _E,
  after: TB,
  all: Uv,
  allKeys: th,
  any: Nv,
  assign: Ff,
  before: GE,
  bind: VE,
  bindAll: yB,
  chain: mB,
  chunk: ZB,
  clone: eB,
  collect: us,
  compact: jB,
  compose: SB,
  constant: IE,
  contains: to,
  countBy: PB,
  create: QM,
  debounce: xB,
  default: IT,
  defaults: WE,
  defer: vB,
  delay: qE,
  detect: Sm,
  difference: rC,
  drop: qc,
  each: Do,
  escape: cB,
  every: Uv,
  extend: PE,
  extendOwn: Ff,
  filter: Al,
  find: Sm,
  findIndex: H1,
  findKey: KE,
  findLastIndex: XE,
  findWhere: AB,
  first: df,
  flatten: VB,
  foldl: uf,
  foldr: Fv,
  forEach: Do,
  functions: _m,
  get: HE,
  groupBy: BB,
  has: nB,
  head: df,
  identity: P1,
  include: to,
  includes: to,
  indexBy: LB,
  indexOf: JE,
  initial: nC,
  inject: uf,
  intersection: KB,
  invert: BE,
  invoke: OB,
  isArguments: L1,
  isArray: zl,
  isArrayBuffer: kE,
  isBoolean: DE,
  isDataView: xm,
  isDate: IM,
  isElement: RM,
  isEmpty: zM,
  isEqual: HM,
  isError: FM,
  isFinite: BM,
  isFunction: Tr,
  isMap: GM,
  isMatch: FE,
  isNaN: RE,
  isNull: AM,
  isNumber: EE,
  isObject: Wl,
  isRegExp: OM,
  isSet: XM,
  isString: B1,
  isSymbol: CE,
  isTypedArray: OE,
  isUndefined: TE,
  isWeakMap: KM,
  isWeakSet: YM,
  iteratee: z1,
  keys: Mn,
  last: HB,
  lastIndexOf: kB,
  map: us,
  mapObject: iB,
  matcher: nu,
  matches: nu,
  max: ZE,
  memoize: bB,
  methods: _m,
  min: UB,
  mixin: oC,
  negate: $1,
  noop: jE,
  now: Uf,
  object: YB,
  omit: $B,
  once: DB,
  pairs: JM,
  partial: wu,
  partition: WB,
  pick: tC,
  pluck: j1,
  property: W1,
  propertyOf: oB,
  random: Ov,
  range: JB,
  reduce: uf,
  reduceRight: Fv,
  reject: IB,
  rest: qc,
  restArguments: jr,
  result: hB,
  sample: eC,
  select: Al,
  shuffle: NB,
  size: zB,
  some: Nv,
  sortBy: MB,
  sortedIndex: YE,
  tail: qc,
  take: df,
  tap: tB,
  template: fB,
  templateSettings: dB,
  throttle: wB,
  times: aB,
  toArray: QE,
  toPath: zE,
  transpose: Dm,
  unescape: uB,
  union: GB,
  uniq: Tm,
  unique: Tm,
  uniqueId: pB,
  unzip: Dm,
  values: vu,
  where: FB,
  without: qB,
  wrap: _B,
  zip: XB
}, Symbol.toStringTag, { value: "Module" })), Rn = /* @__PURE__ */ r6(Cde);
var aC = {}, Zn = {}, QB = { exports: {} }, gy = { exports: {} }, qR;
function nh() {
  if (qR) return gy.exports;
  qR = 1;
  var t = /* @__PURE__ */ function() {
    return this === void 0;
  }();
  if (t)
    gy.exports = {
      freeze: Object.freeze,
      defineProperty: Object.defineProperty,
      getDescriptor: Object.getOwnPropertyDescriptor,
      keys: Object.keys,
      names: Object.getOwnPropertyNames,
      getPrototypeOf: Object.getPrototypeOf,
      isArray: Array.isArray,
      isES5: t,
      propertyIsWritable: function(u, d) {
        var f = Object.getOwnPropertyDescriptor(u, d);
        return !!(!f || f.writable || f.set);
      }
    };
  else {
    var e = {}.hasOwnProperty, n = {}.toString, r = {}.constructor.prototype, i = function(u) {
      var d = [];
      for (var f in u)
        e.call(u, f) && d.push(f);
      return d;
    }, o = function(u, d) {
      return { value: u[d] };
    }, a = function(u, d, f) {
      return u[d] = f.value, u;
    }, s = function(u) {
      return u;
    }, l = function(u) {
      try {
        return Object(u).constructor.prototype;
      } catch {
        return r;
      }
    }, c = function(u) {
      try {
        return n.call(u) === "[object Array]";
      } catch {
        return !1;
      }
    };
    gy.exports = {
      isArray: c,
      keys: i,
      names: i,
      defineProperty: a,
      getDescriptor: o,
      freeze: s,
      getPrototypeOf: l,
      isES5: t,
      propertyIsWritable: function() {
        return !0;
      }
    };
  }
  return gy.exports;
}
var Gx, GR;
function ln() {
  if (GR) return Gx;
  GR = 1;
  var t = nh(), e = typeof navigator > "u", n = { e: {} }, r, i = typeof self < "u" ? self : typeof window < "u" ? window : typeof wt < "u" || wt !== void 0 ? wt : null;
  function o() {
    try {
      var N = r;
      return r = null, N.apply(this, arguments);
    } catch (ce) {
      return n.e = ce, n;
    }
  }
  function a(N) {
    return r = N, o;
  }
  var s = function(N, ce) {
    var me = {}.hasOwnProperty;
    function ve() {
      this.constructor = N, this.constructor$ = ce;
      for (var he in ce.prototype)
        me.call(ce.prototype, he) && he.charAt(he.length - 1) !== "$" && (this[he + "$"] = ce.prototype[he]);
    }
    return ve.prototype = ce.prototype, N.prototype = new ve(), N.prototype;
  };
  function l(N) {
    return N == null || N === !0 || N === !1 || typeof N == "string" || typeof N == "number";
  }
  function c(N) {
    return typeof N == "function" || typeof N == "object" && N !== null;
  }
  function u(N) {
    return l(N) ? new Error(U(N)) : N;
  }
  function d(N, ce) {
    var me = N.length, ve = new Array(me + 1), he;
    for (he = 0; he < me; ++he)
      ve[he] = N[he];
    return ve[he] = ce, ve;
  }
  function f(N, ce, me) {
    if (t.isES5) {
      var ve = Object.getOwnPropertyDescriptor(N, ce);
      if (ve != null)
        return ve.get == null && ve.set == null ? ve.value : me;
    } else
      return {}.hasOwnProperty.call(N, ce) ? N[ce] : void 0;
  }
  function p(N, ce, me) {
    if (l(N)) return N;
    var ve = {
      value: me,
      configurable: !0,
      enumerable: !1,
      writable: !0
    };
    return t.defineProperty(N, ce, ve), N;
  }
  function m(N) {
    throw N;
  }
  var g = function() {
    var N = [
      Array.prototype,
      Object.prototype,
      Function.prototype
    ], ce = function(he) {
      for (var H = 0; H < N.length; ++H)
        if (N[H] === he)
          return !0;
      return !1;
    };
    if (t.isES5) {
      var me = Object.getOwnPropertyNames;
      return function(he) {
        for (var H = [], W = /* @__PURE__ */ Object.create(null); he != null && !ce(he); ) {
          var we;
          try {
            we = me(he);
          } catch {
            return H;
          }
          for (var ye = 0; ye < we.length; ++ye) {
            var j = we[ye];
            if (!W[j]) {
              W[j] = !0;
              var Q = Object.getOwnPropertyDescriptor(he, j);
              Q != null && Q.get == null && Q.set == null && H.push(j);
            }
          }
          he = t.getPrototypeOf(he);
        }
        return H;
      };
    } else {
      var ve = {}.hasOwnProperty;
      return function(he) {
        if (ce(he)) return [];
        var H = [];
        e: for (var W in he)
          if (ve.call(he, W))
            H.push(W);
          else {
            for (var we = 0; we < N.length; ++we)
              if (ve.call(N[we], W))
                continue e;
            H.push(W);
          }
        return H;
      };
    }
  }(), b = /this\s*\.\s*\S+\s*=/;
  function y(N) {
    try {
      if (typeof N == "function") {
        var ce = t.names(N.prototype), me = t.isES5 && ce.length > 1, ve = ce.length > 0 && !(ce.length === 1 && ce[0] === "constructor"), he = b.test(N + "") && t.names(N).length > 0;
        if (me || ve || he)
          return !0;
      }
      return !1;
    } catch {
      return !1;
    }
  }
  function w(N) {
    return N;
  }
  var x = /^[a-z$_][a-z$_0-9]*$/i;
  function k(N) {
    return x.test(N);
  }
  function A(N, ce, me) {
    for (var ve = new Array(N), he = 0; he < N; ++he)
      ve[he] = ce + he + me;
    return ve;
  }
  function U(N) {
    try {
      return N + "";
    } catch {
      return "[no string representation]";
    }
  }
  function P(N) {
    return N !== null && typeof N == "object" && typeof N.message == "string" && typeof N.name == "string";
  }
  function V(N) {
    try {
      p(N, "isOperational", !0);
    } catch {
    }
  }
  function I(N) {
    return N == null ? !1 : N instanceof Error.__BluebirdErrorTypes__.OperationalError || N.isOperational === !0;
  }
  function le(N) {
    return P(N) && t.propertyIsWritable(N, "stack");
  }
  var be = function() {
    return "stack" in new Error() ? function(N) {
      return le(N) ? N : new Error(U(N));
    } : function(N) {
      if (le(N)) return N;
      try {
        throw new Error(U(N));
      } catch (ce) {
        return ce;
      }
    };
  }();
  function F(N) {
    return {}.toString.call(N);
  }
  function G(N, ce, me) {
    for (var ve = t.names(N), he = 0; he < ve.length; ++he) {
      var H = ve[he];
      if (me(H))
        try {
          t.defineProperty(ce, H, t.getDescriptor(N, H));
        } catch {
        }
    }
  }
  var C = function(N) {
    return t.isArray(N) ? N : null;
  };
  if (typeof Symbol < "u" && Symbol.iterator) {
    var ie = typeof Array.from == "function" ? function(N) {
      return Array.from(N);
    } : function(N) {
      for (var ce = [], me = N[Symbol.iterator](), ve; !(ve = me.next()).done; )
        ce.push(ve.value);
      return ce;
    };
    C = function(N) {
      return t.isArray(N) ? N : N != null && typeof N[Symbol.iterator] == "function" ? ie(N) : null;
    };
  }
  var ee = typeof process < "u" && F(process).toLowerCase() === "[object process]", Z = typeof process < "u" && typeof process.env < "u";
  function oe(N) {
    return Z ? process.env[N] : void 0;
  }
  function te() {
    if (typeof Promise == "function")
      try {
        var N = new Promise(function() {
        });
        if ({}.toString.call(N) === "[object Promise]")
          return Promise;
      } catch {
      }
  }
  function _e(N, ce) {
    return N.bind(ce);
  }
  var q = {
    isClass: y,
    isIdentifier: k,
    inheritedDataKeys: g,
    getDataPropertyOrDefault: f,
    thrower: m,
    isArray: t.isArray,
    asArray: C,
    notEnumerableProp: p,
    isPrimitive: l,
    isObject: c,
    isError: P,
    canEvaluate: e,
    errorObj: n,
    tryCatch: a,
    inherits: s,
    withAppended: d,
    maybeWrapAsError: u,
    toFastProperties: w,
    filledRange: A,
    toString: U,
    canAttachTrace: le,
    ensureErrorObject: be,
    originatesFromRejection: I,
    markAsOriginatingFromRejection: V,
    classString: F,
    copyDescriptors: G,
    hasDevTools: typeof chrome < "u" && chrome && typeof chrome.loadTimes == "function",
    isNode: ee,
    hasEnvVariables: Z,
    env: oe,
    global: i,
    getNativePromise: te,
    domainBind: _e
  };
  q.isRecentNode = q.isNode && function() {
    var N = process.versions.node.split(".").map(Number);
    return N[0] === 0 && N[1] > 10 || N[0] > 0;
  }(), q.isNode && q.toFastProperties(process);
  try {
    throw new Error();
  } catch (N) {
    q.lastLineError = N;
  }
  return Gx = q, Gx;
}
var yy = { exports: {} }, Kx, KR;
function kde() {
  if (KR) return Kx;
  KR = 1;
  var t = ln(), e, n = function() {
    throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
  }, r = t.getNativePromise();
  if (t.isNode && typeof MutationObserver > "u") {
    var i = wt.setImmediate, o = process.nextTick;
    e = t.isRecentNode ? function(s) {
      i.call(wt, s);
    } : function(s) {
      o.call(process, s);
    };
  } else if (typeof r == "function" && typeof r.resolve == "function") {
    var a = r.resolve();
    e = function(s) {
      a.then(s);
    };
  } else typeof MutationObserver < "u" && !(typeof window < "u" && window.navigator && (window.navigator.standalone || window.cordova)) ? e = function() {
    var s = document.createElement("div"), l = { attributes: !0 }, c = !1, u = document.createElement("div"), d = new MutationObserver(function() {
      s.classList.toggle("foo"), c = !1;
    });
    d.observe(u, l);
    var f = function() {
      c || (c = !0, u.classList.toggle("foo"));
    };
    return function(m) {
      var g = new MutationObserver(function() {
        g.disconnect(), m();
      });
      g.observe(s, l), f();
    };
  }() : typeof setImmediate < "u" ? e = function(s) {
    setImmediate(s);
  } : typeof setTimeout < "u" ? e = function(s) {
    setTimeout(s, 0);
  } : e = n;
  return Kx = e, Kx;
}
var Xx, XR;
function Ade() {
  if (XR) return Xx;
  XR = 1;
  function t(n, r, i, o, a) {
    for (var s = 0; s < a; ++s)
      i[s + o] = n[s + r], n[s + r] = void 0;
  }
  function e(n) {
    this._capacity = n, this._length = 0, this._front = 0;
  }
  return e.prototype._willBeOverCapacity = function(n) {
    return this._capacity < n;
  }, e.prototype._pushOne = function(n) {
    var r = this.length();
    this._checkCapacity(r + 1);
    var i = this._front + r & this._capacity - 1;
    this[i] = n, this._length = r + 1;
  }, e.prototype.push = function(n, r, i) {
    var o = this.length() + 3;
    if (this._willBeOverCapacity(o)) {
      this._pushOne(n), this._pushOne(r), this._pushOne(i);
      return;
    }
    var a = this._front + o - 3;
    this._checkCapacity(o);
    var s = this._capacity - 1;
    this[a + 0 & s] = n, this[a + 1 & s] = r, this[a + 2 & s] = i, this._length = o;
  }, e.prototype.shift = function() {
    var n = this._front, r = this[n];
    return this[n] = void 0, this._front = n + 1 & this._capacity - 1, this._length--, r;
  }, e.prototype.length = function() {
    return this._length;
  }, e.prototype._checkCapacity = function(n) {
    this._capacity < n && this._resizeTo(this._capacity << 1);
  }, e.prototype._resizeTo = function(n) {
    var r = this._capacity;
    this._capacity = n;
    var i = this._front, o = this._length, a = i + o & r - 1;
    t(this, 0, this, r, a);
  }, Xx = e, Xx;
}
var YR;
function Rde() {
  if (YR) return yy.exports;
  YR = 1;
  var t;
  try {
    throw new Error();
  } catch (l) {
    t = l;
  }
  var e = kde(), n = Ade(), r = ln();
  function i() {
    this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new n(16), this._normalQueue = new n(16), this._haveDrainedQueues = !1, this._trampolineEnabled = !0;
    var l = this;
    this.drainQueues = function() {
      l._drainQueues();
    }, this._schedule = e;
  }
  i.prototype.setScheduler = function(l) {
    var c = this._schedule;
    return this._schedule = l, this._customScheduler = !0, c;
  }, i.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
  }, i.prototype.enableTrampoline = function() {
    this._trampolineEnabled = !0;
  }, i.prototype.disableTrampolineIfNecessary = function() {
    r.hasDevTools && (this._trampolineEnabled = !1);
  }, i.prototype.haveItemsQueued = function() {
    return this._isTickUsed || this._haveDrainedQueues;
  }, i.prototype.fatalError = function(l, c) {
    c ? (process.stderr.write("Fatal " + (l instanceof Error ? l.stack : l) + `
`), process.exit(2)) : this.throwLater(l);
  }, i.prototype.throwLater = function(l, c) {
    if (arguments.length === 1 && (c = l, l = function() {
      throw c;
    }), typeof setTimeout < "u")
      setTimeout(function() {
        l(c);
      }, 0);
    else try {
      this._schedule(function() {
        l(c);
      });
    } catch {
      throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
    }
  };
  function o(l, c, u) {
    this._lateQueue.push(l, c, u), this._queueTick();
  }
  function a(l, c, u) {
    this._normalQueue.push(l, c, u), this._queueTick();
  }
  function s(l) {
    this._normalQueue._pushOne(l), this._queueTick();
  }
  return r.hasDevTools ? (i.prototype.invokeLater = function(l, c, u) {
    this._trampolineEnabled ? o.call(this, l, c, u) : this._schedule(function() {
      setTimeout(function() {
        l.call(c, u);
      }, 100);
    });
  }, i.prototype.invoke = function(l, c, u) {
    this._trampolineEnabled ? a.call(this, l, c, u) : this._schedule(function() {
      l.call(c, u);
    });
  }, i.prototype.settlePromises = function(l) {
    this._trampolineEnabled ? s.call(this, l) : this._schedule(function() {
      l._settlePromises();
    });
  }) : (i.prototype.invokeLater = o, i.prototype.invoke = a, i.prototype.settlePromises = s), i.prototype._drainQueue = function(l) {
    for (; l.length() > 0; ) {
      var c = l.shift();
      if (typeof c != "function") {
        c._settlePromises();
        continue;
      }
      var u = l.shift(), d = l.shift();
      c.call(u, d);
    }
  }, i.prototype._drainQueues = function() {
    this._drainQueue(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, this._drainQueue(this._lateQueue);
  }, i.prototype._queueTick = function() {
    this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues));
  }, i.prototype._reset = function() {
    this._isTickUsed = !1;
  }, yy.exports = i, yy.exports.firstLineError = t, yy.exports;
}
var Yx, JR;
function Rl() {
  if (JR) return Yx;
  JR = 1;
  var t = nh(), e = t.freeze, n = ln(), r = n.inherits, i = n.notEnumerableProp;
  function o(y, w) {
    function x(k) {
      if (!(this instanceof x)) return new x(k);
      i(
        this,
        "message",
        typeof k == "string" ? k : w
      ), i(this, "name", y), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this);
    }
    return r(x, Error), x;
  }
  var a, s, l = o("Warning", "warning"), c = o("CancellationError", "cancellation error"), u = o("TimeoutError", "timeout error"), d = o("AggregateError", "aggregate error");
  try {
    a = TypeError, s = RangeError;
  } catch {
    a = o("TypeError", "type error"), s = o("RangeError", "range error");
  }
  for (var f = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "), p = 0; p < f.length; ++p)
    typeof Array.prototype[f[p]] == "function" && (d.prototype[f[p]] = Array.prototype[f[p]]);
  t.defineProperty(d.prototype, "length", {
    value: 0,
    configurable: !1,
    writable: !0,
    enumerable: !0
  }), d.prototype.isOperational = !0;
  var m = 0;
  d.prototype.toString = function() {
    var y = Array(m * 4 + 1).join(" "), w = `
` + y + `AggregateError of:
`;
    m++, y = Array(m * 4 + 1).join(" ");
    for (var x = 0; x < this.length; ++x) {
      for (var k = this[x] === this ? "[Circular AggregateError]" : this[x] + "", A = k.split(`
`), U = 0; U < A.length; ++U)
        A[U] = y + A[U];
      k = A.join(`
`), w += k + `
`;
    }
    return m--, w;
  };
  function g(y) {
    if (!(this instanceof g))
      return new g(y);
    i(this, "name", "OperationalError"), i(this, "message", y), this.cause = y, this.isOperational = !0, y instanceof Error ? (i(this, "message", y.message), i(this, "stack", y.stack)) : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  }
  r(g, Error);
  var b = Error.__BluebirdErrorTypes__;
  return b || (b = e({
    CancellationError: c,
    TimeoutError: u,
    OperationalError: g,
    RejectionError: g,
    AggregateError: d
  }), t.defineProperty(Error, "__BluebirdErrorTypes__", {
    value: b,
    writable: !1,
    enumerable: !1,
    configurable: !1
  })), Yx = {
    Error,
    TypeError: a,
    RangeError: s,
    CancellationError: b.CancellationError,
    OperationalError: b.OperationalError,
    TimeoutError: b.TimeoutError,
    AggregateError: b.AggregateError,
    Warning: l
  }, Yx;
}
var Jx, ZR;
function Ide() {
  return ZR || (ZR = 1, Jx = function(t, e) {
    var n = ln(), r = n.errorObj, i = n.isObject;
    function o(d, f) {
      if (i(d)) {
        if (d instanceof t) return d;
        var p = s(d);
        if (p === r) {
          f && f._pushContext();
          var m = t.reject(p.e);
          return f && f._popContext(), m;
        } else if (typeof p == "function") {
          if (c(d)) {
            var m = new t(e);
            return d._then(
              m._fulfill,
              m._reject,
              void 0,
              m,
              null
            ), m;
          }
          return u(d, p, f);
        }
      }
      return d;
    }
    function a(d) {
      return d.then;
    }
    function s(d) {
      try {
        return a(d);
      } catch (f) {
        return r.e = f, r;
      }
    }
    var l = {}.hasOwnProperty;
    function c(d) {
      try {
        return l.call(d, "_promise0");
      } catch {
        return !1;
      }
    }
    function u(d, f, p) {
      var m = new t(e), g = m;
      p && p._pushContext(), m._captureStackTrace(), p && p._popContext();
      var b = !0, y = n.tryCatch(f).call(d, w, x);
      b = !1, m && y === r && (m._rejectCallback(y.e, !0, !0), m = null);
      function w(k) {
        m && (m._resolveCallback(k), m = null);
      }
      function x(k) {
        m && (m._rejectCallback(k, b, !0), m = null);
      }
      return g;
    }
    return o;
  }), Jx;
}
var Zx, QR;
function Ode() {
  return QR || (QR = 1, Zx = function(t, e, n, r, i) {
    var o = ln();
    o.isArray;
    function a(l) {
      switch (l) {
        case -2:
          return [];
        case -3:
          return {};
      }
    }
    function s(l) {
      var c = this._promise = new t(e);
      l instanceof t && c._propagateFrom(l, 3), c._setOnCancel(this), this._values = l, this._length = 0, this._totalResolved = 0, this._init(void 0, -2);
    }
    return o.inherits(s, i), s.prototype.length = function() {
      return this._length;
    }, s.prototype.promise = function() {
      return this._promise;
    }, s.prototype._init = function l(c, u) {
      var d = n(this._values, this._promise);
      if (d instanceof t) {
        d = d._target();
        var f = d._bitField;
        if (this._values = d, f & 50397184)
          if (f & 33554432)
            d = d._value();
          else return f & 16777216 ? this._reject(d._reason()) : this._cancel();
        else return this._promise._setAsyncGuaranteed(), d._then(
          l,
          this._reject,
          void 0,
          this,
          u
        );
      }
      if (d = o.asArray(d), d === null) {
        var p = r(
          "expecting an array or an iterable object but got " + o.classString(d)
        ).reason();
        this._promise._rejectCallback(p, !1);
        return;
      }
      if (d.length === 0) {
        u === -5 ? this._resolveEmptyArray() : this._resolve(a(u));
        return;
      }
      this._iterate(d);
    }, s.prototype._iterate = function(l) {
      var c = this.getActualLength(l.length);
      this._length = c, this._values = this.shouldCopyValues() ? new Array(c) : this._values;
      for (var u = this._promise, d = !1, f = null, p = 0; p < c; ++p) {
        var m = n(l[p], u);
        m instanceof t ? (m = m._target(), f = m._bitField) : f = null, d ? f !== null && m.suppressUnhandledRejections() : f !== null ? f & 50397184 ? f & 33554432 ? d = this._promiseFulfilled(m._value(), p) : f & 16777216 ? d = this._promiseRejected(m._reason(), p) : d = this._promiseCancelled(p) : (m._proxy(this, p), this._values[p] = m) : d = this._promiseFulfilled(m, p);
      }
      d || u._setAsyncGuaranteed();
    }, s.prototype._isResolved = function() {
      return this._values === null;
    }, s.prototype._resolve = function(l) {
      this._values = null, this._promise._fulfill(l);
    }, s.prototype._cancel = function() {
      this._isResolved() || !this._promise._isCancellable() || (this._values = null, this._promise._cancel());
    }, s.prototype._reject = function(l) {
      this._values = null, this._promise._rejectCallback(l, !1);
    }, s.prototype._promiseFulfilled = function(l, c) {
      this._values[c] = l;
      var u = ++this._totalResolved;
      return u >= this._length ? (this._resolve(this._values), !0) : !1;
    }, s.prototype._promiseCancelled = function() {
      return this._cancel(), !0;
    }, s.prototype._promiseRejected = function(l) {
      return this._totalResolved++, this._reject(l), !0;
    }, s.prototype._resultCancelled = function() {
      if (!this._isResolved()) {
        var l = this._values;
        if (this._cancel(), l instanceof t)
          l.cancel();
        else
          for (var c = 0; c < l.length; ++c)
            l[c] instanceof t && l[c].cancel();
      }
    }, s.prototype.shouldCopyValues = function() {
      return !0;
    }, s.prototype.getActualLength = function(l) {
      return l;
    }, s;
  }), Zx;
}
var Qx, e8;
function Fde() {
  return e8 || (e8 = 1, Qx = function(t) {
    var e = !1, n = [];
    t.prototype._promiseCreated = function() {
    }, t.prototype._pushContext = function() {
    }, t.prototype._popContext = function() {
      return null;
    }, t._peekContext = t.prototype._peekContext = function() {
    };
    function r() {
      this._trace = new r.CapturedTrace(o());
    }
    r.prototype._pushContext = function() {
      this._trace !== void 0 && (this._trace._promiseCreated = null, n.push(this._trace));
    }, r.prototype._popContext = function() {
      if (this._trace !== void 0) {
        var a = n.pop(), s = a._promiseCreated;
        return a._promiseCreated = null, s;
      }
      return null;
    };
    function i() {
      if (e) return new r();
    }
    function o() {
      var a = n.length - 1;
      if (a >= 0)
        return n[a];
    }
    return r.CapturedTrace = null, r.create = i, r.deactivateLongStackTraces = function() {
    }, r.activateLongStackTraces = function() {
      var a = t.prototype._pushContext, s = t.prototype._popContext, l = t._peekContext, c = t.prototype._peekContext, u = t.prototype._promiseCreated;
      r.deactivateLongStackTraces = function() {
        t.prototype._pushContext = a, t.prototype._popContext = s, t._peekContext = l, t.prototype._peekContext = c, t.prototype._promiseCreated = u, e = !1;
      }, e = !0, t.prototype._pushContext = r.prototype._pushContext, t.prototype._popContext = r.prototype._popContext, t._peekContext = t.prototype._peekContext = o, t.prototype._promiseCreated = function() {
        var d = this._peekContext();
        d && d._promiseCreated == null && (d._promiseCreated = this);
      };
    }, r;
  }), Qx;
}
var e2, t8;
function Ude() {
  return t8 || (t8 = 1, e2 = function(t, e) {
    var n = t._getDomain, r = t._async, i = Rl().Warning, o = ln(), a = o.canAttachTrace, s, l, c = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/, u = /\((?:timers\.js):\d+:\d+\)/, d = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/, f = null, p = null, m = !1, g, b = !!(o.env("BLUEBIRD_DEBUG") != 0 && (o.env("BLUEBIRD_DEBUG") || o.env("NODE_ENV") === "development")), y = !!(o.env("BLUEBIRD_WARNINGS") != 0 && (b || o.env("BLUEBIRD_WARNINGS"))), w = !!(o.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (b || o.env("BLUEBIRD_LONG_STACK_TRACES"))), x = o.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (y || !!o.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    t.prototype.suppressUnhandledRejections = function() {
      var re = this._target();
      re._bitField = re._bitField & -1048577 | 524288;
    }, t.prototype._ensurePossibleRejectionHandled = function() {
      this._bitField & 524288 || (this._setRejectionIsUnhandled(), r.invokeLater(this._notifyUnhandledRejection, this, void 0));
    }, t.prototype._notifyUnhandledRejectionIsHandled = function() {
      Q(
        "rejectionHandled",
        s,
        void 0,
        this
      );
    }, t.prototype._setReturnedNonUndefined = function() {
      this._bitField = this._bitField | 268435456;
    }, t.prototype._returnedNonUndefined = function() {
      return (this._bitField & 268435456) !== 0;
    }, t.prototype._notifyUnhandledRejection = function() {
      if (this._isRejectionUnhandled()) {
        var re = this._settledValue();
        this._setUnhandledRejectionIsNotified(), Q(
          "unhandledRejection",
          l,
          re,
          this
        );
      }
    }, t.prototype._setUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField | 262144;
    }, t.prototype._unsetUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField & -262145;
    }, t.prototype._isUnhandledRejectionNotified = function() {
      return (this._bitField & 262144) > 0;
    }, t.prototype._setRejectionIsUnhandled = function() {
      this._bitField = this._bitField | 1048576;
    }, t.prototype._unsetRejectionIsUnhandled = function() {
      this._bitField = this._bitField & -1048577, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), this._notifyUnhandledRejectionIsHandled());
    }, t.prototype._isRejectionUnhandled = function() {
      return (this._bitField & 1048576) > 0;
    }, t.prototype._warn = function(re, de, ge) {
      return me(re, de, ge || this);
    }, t.onPossiblyUnhandledRejection = function(re) {
      var de = n();
      l = typeof re == "function" ? de === null ? re : o.domainBind(de, re) : void 0;
    }, t.onUnhandledRejectionHandled = function(re) {
      var de = n();
      s = typeof re == "function" ? de === null ? re : o.domainBind(de, re) : void 0;
    };
    var k = function() {
    };
    t.longStackTraces = function() {
      if (r.haveItemsQueued() && !J.longStackTraces)
        throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
      if (!J.longStackTraces && pe()) {
        var re = t.prototype._captureStackTrace, de = t.prototype._attachExtraTrace;
        J.longStackTraces = !0, k = function() {
          if (r.haveItemsQueued() && !J.longStackTraces)
            throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
          t.prototype._captureStackTrace = re, t.prototype._attachExtraTrace = de, e.deactivateLongStackTraces(), r.enableTrampoline(), J.longStackTraces = !1;
        }, t.prototype._captureStackTrace = _e, t.prototype._attachExtraTrace = q, e.activateLongStackTraces(), r.disableTrampolineIfNecessary();
      }
    }, t.hasLongStackTraces = function() {
      return J.longStackTraces && pe();
    };
    var A = function() {
      try {
        if (typeof CustomEvent == "function") {
          var re = new CustomEvent("CustomEvent");
          return o.global.dispatchEvent(re), function(de, ge) {
            var Ee = new CustomEvent(de.toLowerCase(), {
              detail: ge,
              cancelable: !0
            });
            return !o.global.dispatchEvent(Ee);
          };
        } else if (typeof Event == "function") {
          var re = new Event("CustomEvent");
          return o.global.dispatchEvent(re), function(ge, Ee) {
            var Ne = new Event(ge.toLowerCase(), {
              cancelable: !0
            });
            return Ne.detail = Ee, !o.global.dispatchEvent(Ne);
          };
        } else {
          var re = document.createEvent("CustomEvent");
          return re.initCustomEvent("testingtheevent", !1, !0, {}), o.global.dispatchEvent(re), function(ge, Ee) {
            var Ne = document.createEvent("CustomEvent");
            return Ne.initCustomEvent(
              ge.toLowerCase(),
              !1,
              !0,
              Ee
            ), !o.global.dispatchEvent(Ne);
          };
        }
      } catch {
      }
      return function() {
        return !1;
      };
    }(), U = function() {
      return o.isNode ? function() {
        return process.emit.apply(process, arguments);
      } : o.global ? function(re) {
        var de = "on" + re.toLowerCase(), ge = o.global[de];
        return ge ? (ge.apply(o.global, [].slice.call(arguments, 1)), !0) : !1;
      } : function() {
        return !1;
      };
    }();
    function P(re, de) {
      return { promise: de };
    }
    var V = {
      promiseCreated: P,
      promiseFulfilled: P,
      promiseRejected: P,
      promiseResolved: P,
      promiseCancelled: P,
      promiseChained: function(re, de, ge) {
        return { promise: de, child: ge };
      },
      warning: function(re, de) {
        return { warning: de };
      },
      unhandledRejection: function(re, de, ge) {
        return { reason: de, promise: ge };
      },
      rejectionHandled: P
    }, I = function(re) {
      var de = !1;
      try {
        de = U.apply(null, arguments);
      } catch (Ee) {
        r.throwLater(Ee), de = !0;
      }
      var ge = !1;
      try {
        ge = A(
          re,
          V[re].apply(null, arguments)
        );
      } catch (Ee) {
        r.throwLater(Ee), ge = !0;
      }
      return ge || de;
    };
    t.config = function(re) {
      if (re = Object(re), "longStackTraces" in re && (re.longStackTraces ? t.longStackTraces() : !re.longStackTraces && t.hasLongStackTraces() && k()), "warnings" in re) {
        var de = re.warnings;
        J.warnings = !!de, x = J.warnings, o.isObject(de) && "wForgottenReturn" in de && (x = !!de.wForgottenReturn);
      }
      if ("cancellation" in re && re.cancellation && !J.cancellation) {
        if (r.haveItemsQueued())
          throw new Error(
            "cannot enable cancellation after promises are in use"
          );
        t.prototype._clearCancellationData = ie, t.prototype._propagateFrom = ee, t.prototype._onCancel = G, t.prototype._setOnCancel = C, t.prototype._attachCancellationCallback = F, t.prototype._execute = be, oe = ee, J.cancellation = !0;
      }
      return "monitoring" in re && (re.monitoring && !J.monitoring ? (J.monitoring = !0, t.prototype._fireEvent = I) : !re.monitoring && J.monitoring && (J.monitoring = !1, t.prototype._fireEvent = le)), t;
    };
    function le() {
      return !1;
    }
    t.prototype._fireEvent = le, t.prototype._execute = function(re, de, ge) {
      try {
        re(de, ge);
      } catch (Ee) {
        return Ee;
      }
    }, t.prototype._onCancel = function() {
    }, t.prototype._setOnCancel = function(re) {
    }, t.prototype._attachCancellationCallback = function(re) {
    }, t.prototype._captureStackTrace = function() {
    }, t.prototype._attachExtraTrace = function() {
    }, t.prototype._clearCancellationData = function() {
    }, t.prototype._propagateFrom = function(re, de) {
    };
    function be(re, de, ge) {
      var Ee = this;
      try {
        re(de, ge, function(Ne) {
          if (typeof Ne != "function")
            throw new TypeError("onCancel must be a function, got: " + o.toString(Ne));
          Ee._attachCancellationCallback(Ne);
        });
      } catch (Ne) {
        return Ne;
      }
    }
    function F(re) {
      if (!this._isCancellable()) return this;
      var de = this._onCancel();
      de !== void 0 ? o.isArray(de) ? de.push(re) : this._setOnCancel([de, re]) : this._setOnCancel(re);
    }
    function G() {
      return this._onCancelField;
    }
    function C(re) {
      this._onCancelField = re;
    }
    function ie() {
      this._cancellationParent = void 0, this._onCancelField = void 0;
    }
    function ee(re, de) {
      if (de & 1) {
        this._cancellationParent = re;
        var ge = re._branchesRemainingToCancel;
        ge === void 0 && (ge = 0), re._branchesRemainingToCancel = ge + 1;
      }
      de & 2 && re._isBound() && this._setBoundTo(re._boundTo);
    }
    function Z(re, de) {
      de & 2 && re._isBound() && this._setBoundTo(re._boundTo);
    }
    var oe = Z;
    function te() {
      var re = this._boundTo;
      return re !== void 0 && re instanceof t ? re.isFulfilled() ? re.value() : void 0 : re;
    }
    function _e() {
      this._trace = new ne(this._peekContext());
    }
    function q(re, de) {
      if (a(re)) {
        var ge = this._trace;
        if (ge !== void 0 && de && (ge = ge._parent), ge !== void 0)
          ge.attachExtraTrace(re);
        else if (!re.__stackCleaned__) {
          var Ee = ye(re);
          o.notEnumerableProp(
            re,
            "stack",
            Ee.message + `
` + Ee.stack.join(`
`)
          ), o.notEnumerableProp(re, "__stackCleaned__", !0);
        }
      }
    }
    function N(re, de, ge, Ee, Ne) {
      if (re === void 0 && de !== null && x) {
        if (Ne !== void 0 && Ne._returnedNonUndefined() || !(Ee._bitField & 65535)) return;
        ge && (ge = ge + " ");
        var Le = "", Qe = "";
        if (de._trace) {
          for (var Ze = de._trace.stack.split(`
`), at = W(Ze), gt = at.length - 1; gt >= 0; --gt) {
            var et = at[gt];
            if (!u.test(et)) {
              var Zt = et.match(d);
              Zt && (Le = "at " + Zt[1] + ":" + Zt[2] + ":" + Zt[3] + " ");
              break;
            }
          }
          if (at.length > 0) {
            for (var Un = at[0], gt = 0; gt < Ze.length; ++gt)
              if (Ze[gt] === Un) {
                gt > 0 && (Qe = `
` + Ze[gt - 1]);
                break;
              }
          }
        }
        var Ft = "a promise was created in a " + ge + "handler " + Le + "but was not returned from it, see http://goo.gl/rRqMUw" + Qe;
        Ee._warn(Ft, !0, de);
      }
    }
    function ce(re, de) {
      var ge = re + " is deprecated and will be removed in a future version.";
      return de && (ge += " Use " + de + " instead."), me(ge);
    }
    function me(re, de, ge) {
      if (J.warnings) {
        var Ee = new i(re), Ne;
        if (de)
          ge._attachExtraTrace(Ee);
        else if (J.longStackTraces && (Ne = t._peekContext()))
          Ne.attachExtraTrace(Ee);
        else {
          var Le = ye(Ee);
          Ee.stack = Le.message + `
` + Le.stack.join(`
`);
        }
        I("warning", Ee) || j(Ee, "", !0);
      }
    }
    function ve(re, de) {
      for (var ge = 0; ge < de.length - 1; ++ge)
        de[ge].push("From previous event:"), de[ge] = de[ge].join(`
`);
      return ge < de.length && (de[ge] = de[ge].join(`
`)), re + `
` + de.join(`
`);
    }
    function he(re) {
      for (var de = 0; de < re.length; ++de)
        (re[de].length === 0 || de + 1 < re.length && re[de][0] === re[de + 1][0]) && (re.splice(de, 1), de--);
    }
    function H(re) {
      for (var de = re[0], ge = 1; ge < re.length; ++ge) {
        for (var Ee = re[ge], Ne = de.length - 1, Le = de[Ne], Qe = -1, Ze = Ee.length - 1; Ze >= 0; --Ze)
          if (Ee[Ze] === Le) {
            Qe = Ze;
            break;
          }
        for (var Ze = Qe; Ze >= 0; --Ze) {
          var at = Ee[Ze];
          if (de[Ne] === at)
            de.pop(), Ne--;
          else
            break;
        }
        de = Ee;
      }
    }
    function W(re) {
      for (var de = [], ge = 0; ge < re.length; ++ge) {
        var Ee = re[ge], Ne = Ee === "    (No stack trace)" || f.test(Ee), Le = Ne && M(Ee);
        Ne && !Le && (m && Ee.charAt(0) !== " " && (Ee = "    " + Ee), de.push(Ee));
      }
      return de;
    }
    function we(re) {
      for (var de = re.stack.replace(/\s+$/g, "").split(`
`), ge = 0; ge < de.length; ++ge) {
        var Ee = de[ge];
        if (Ee === "    (No stack trace)" || f.test(Ee))
          break;
      }
      return ge > 0 && re.name != "SyntaxError" && (de = de.slice(ge)), de;
    }
    function ye(re) {
      var de = re.stack, ge = re.toString();
      return de = typeof de == "string" && de.length > 0 ? we(re) : ["    (No stack trace)"], {
        message: ge,
        stack: re.name == "SyntaxError" ? de : W(de)
      };
    }
    function j(re, de, ge) {
      if (typeof console < "u") {
        var Ee;
        if (o.isObject(re)) {
          var Ne = re.stack;
          Ee = de + p(Ne, re);
        } else
          Ee = de + String(re);
        typeof g == "function" ? g(Ee, ge) : (typeof console.log == "function" || typeof console.log == "object") && console.log(Ee);
      }
    }
    function Q(re, de, ge, Ee) {
      var Ne = !1;
      try {
        typeof de == "function" && (Ne = !0, re === "rejectionHandled" ? de(Ee) : de(ge, Ee));
      } catch (Le) {
        r.throwLater(Le);
      }
      re === "unhandledRejection" ? !I(re, ge, Ee) && !Ne && j(ge, "Unhandled rejection ") : I(re, Ee);
    }
    function De(re) {
      var de;
      if (typeof re == "function")
        de = "[function " + (re.name || "anonymous") + "]";
      else {
        de = re && typeof re.toString == "function" ? re.toString() : o.toString(re);
        var ge = /\[object [a-zA-Z0-9$_]+\]/;
        if (ge.test(de))
          try {
            var Ee = JSON.stringify(re);
            de = Ee;
          } catch {
          }
        de.length === 0 && (de = "(empty array)");
      }
      return "(<" + T(de) + ">, no stack trace)";
    }
    function T(re) {
      var de = 41;
      return re.length < de ? re : re.substr(0, de - 3) + "...";
    }
    function pe() {
      return typeof fe == "function";
    }
    var M = function() {
      return !1;
    }, _ = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function S(re) {
      var de = re.match(_);
      if (de)
        return {
          fileName: de[1],
          line: parseInt(de[2], 10)
        };
    }
    function O(re, de) {
      if (pe()) {
        for (var ge = re.stack.split(`
`), Ee = de.stack.split(`
`), Ne = -1, Le = -1, Qe, Ze, at = 0; at < ge.length; ++at) {
          var gt = S(ge[at]);
          if (gt) {
            Qe = gt.fileName, Ne = gt.line;
            break;
          }
        }
        for (var at = 0; at < Ee.length; ++at) {
          var gt = S(Ee[at]);
          if (gt) {
            Ze = gt.fileName, Le = gt.line;
            break;
          }
        }
        Ne < 0 || Le < 0 || !Qe || !Ze || Qe !== Ze || Ne >= Le || (M = function(et) {
          if (c.test(et)) return !0;
          var Zt = S(et);
          return !!(Zt && Zt.fileName === Qe && Ne <= Zt.line && Zt.line <= Le);
        });
      }
    }
    function ne(re) {
      this._parent = re, this._promisesCreated = 0;
      var de = this._length = 1 + (re === void 0 ? 0 : re._length);
      fe(this, ne), de > 32 && this.uncycle();
    }
    o.inherits(ne, Error), e.CapturedTrace = ne, ne.prototype.uncycle = function() {
      var re = this._length;
      if (!(re < 2)) {
        for (var de = [], ge = {}, Ee = 0, Ne = this; Ne !== void 0; ++Ee)
          de.push(Ne), Ne = Ne._parent;
        re = this._length = Ee;
        for (var Ee = re - 1; Ee >= 0; --Ee) {
          var Le = de[Ee].stack;
          ge[Le] === void 0 && (ge[Le] = Ee);
        }
        for (var Ee = 0; Ee < re; ++Ee) {
          var Qe = de[Ee].stack, Ze = ge[Qe];
          if (Ze !== void 0 && Ze !== Ee) {
            Ze > 0 && (de[Ze - 1]._parent = void 0, de[Ze - 1]._length = 1), de[Ee]._parent = void 0, de[Ee]._length = 1;
            var at = Ee > 0 ? de[Ee - 1] : this;
            Ze < re - 1 ? (at._parent = de[Ze + 1], at._parent.uncycle(), at._length = at._parent._length + 1) : (at._parent = void 0, at._length = 1);
            for (var gt = at._length + 1, et = Ee - 2; et >= 0; --et)
              de[et]._length = gt, gt++;
            return;
          }
        }
      }
    }, ne.prototype.attachExtraTrace = function(re) {
      if (!re.__stackCleaned__) {
        this.uncycle();
        for (var de = ye(re), ge = de.message, Ee = [de.stack], Ne = this; Ne !== void 0; )
          Ee.push(W(Ne.stack.split(`
`))), Ne = Ne._parent;
        H(Ee), he(Ee), o.notEnumerableProp(re, "stack", ve(ge, Ee)), o.notEnumerableProp(re, "__stackCleaned__", !0);
      }
    };
    var fe = function() {
      var de = /^\s*at\s*/, ge = function(Qe, Ze) {
        return typeof Qe == "string" ? Qe : Ze.name !== void 0 && Ze.message !== void 0 ? Ze.toString() : De(Ze);
      };
      if (typeof Error.stackTraceLimit == "number" && typeof Error.captureStackTrace == "function") {
        Error.stackTraceLimit += 6, f = de, p = ge;
        var Ee = Error.captureStackTrace;
        return M = function(Qe) {
          return c.test(Qe);
        }, function(Qe, Ze) {
          Error.stackTraceLimit += 6, Ee(Qe, Ze), Error.stackTraceLimit -= 6;
        };
      }
      var Ne = new Error();
      if (typeof Ne.stack == "string" && Ne.stack.split(`
`)[0].indexOf("stackDetection@") >= 0)
        return f = /@/, p = ge, m = !0, function(Ze) {
          Ze.stack = new Error().stack;
        };
      var Le;
      try {
        throw new Error();
      } catch (Qe) {
        Le = "stack" in Qe;
      }
      return !("stack" in Ne) && Le && typeof Error.stackTraceLimit == "number" ? (f = de, p = ge, function(Ze) {
        Error.stackTraceLimit += 6;
        try {
          throw new Error();
        } catch (at) {
          Ze.stack = at.stack;
        }
        Error.stackTraceLimit -= 6;
      }) : (p = function(Qe, Ze) {
        return typeof Qe == "string" ? Qe : (typeof Ze == "object" || typeof Ze == "function") && Ze.name !== void 0 && Ze.message !== void 0 ? Ze.toString() : De(Ze);
      }, null);
    }();
    typeof console < "u" && typeof console.warn < "u" && (g = function(re) {
      console.warn(re);
    }, o.isNode && process.stderr.isTTY ? g = function(re, de) {
      var ge = de ? "\x1B[33m" : "\x1B[31m";
      console.warn(ge + re + `\x1B[0m
`);
    } : !o.isNode && typeof new Error().stack == "string" && (g = function(re, de) {
      console.warn(
        "%c" + re,
        de ? "color: darkorange" : "color: red"
      );
    }));
    var J = {
      warnings: y,
      longStackTraces: !1,
      cancellation: !1,
      monitoring: !1
    };
    return w && t.longStackTraces(), {
      longStackTraces: function() {
        return J.longStackTraces;
      },
      warnings: function() {
        return J.warnings;
      },
      cancellation: function() {
        return J.cancellation;
      },
      monitoring: function() {
        return J.monitoring;
      },
      propagateFromFunction: function() {
        return oe;
      },
      boundValueFunction: function() {
        return te;
      },
      checkForgottenReturns: N,
      setBounds: O,
      warn: me,
      deprecated: ce,
      CapturedTrace: ne,
      fireDomEvent: A,
      fireGlobalEvent: U
    };
  }), e2;
}
var t2, n8;
function Nde() {
  return n8 || (n8 = 1, t2 = function(t, e) {
    var n = ln(), r = t.CancellationError, i = n.errorObj;
    function o(d, f, p) {
      this.promise = d, this.type = f, this.handler = p, this.called = !1, this.cancelPromise = null;
    }
    o.prototype.isFinallyHandler = function() {
      return this.type === 0;
    };
    function a(d) {
      this.finallyHandler = d;
    }
    a.prototype._resultCancelled = function() {
      s(this.finallyHandler);
    };
    function s(d, f) {
      return d.cancelPromise != null ? (arguments.length > 1 ? d.cancelPromise._reject(f) : d.cancelPromise._cancel(), d.cancelPromise = null, !0) : !1;
    }
    function l() {
      return u.call(this, this.promise._target()._settledValue());
    }
    function c(d) {
      if (!s(this, d))
        return i.e = d, i;
    }
    function u(d) {
      var f = this.promise, p = this.handler;
      if (!this.called) {
        this.called = !0;
        var m = this.isFinallyHandler() ? p.call(f._boundValue()) : p.call(f._boundValue(), d);
        if (m !== void 0) {
          f._setReturnedNonUndefined();
          var g = e(m, f);
          if (g instanceof t) {
            if (this.cancelPromise != null)
              if (g._isCancelled()) {
                var b = new r("late cancellation observer");
                return f._attachExtraTrace(b), i.e = b, i;
              } else g.isPending() && g._attachCancellationCallback(
                new a(this)
              );
            return g._then(
              l,
              c,
              void 0,
              this,
              void 0
            );
          }
        }
      }
      return f.isRejected() ? (s(this), i.e = d, i) : (s(this), d);
    }
    return t.prototype._passThrough = function(d, f, p, m) {
      return typeof d != "function" ? this.then() : this._then(
        p,
        m,
        void 0,
        new o(this, f, d),
        void 0
      );
    }, t.prototype.lastly = t.prototype.finally = function(d) {
      return this._passThrough(
        d,
        0,
        u,
        u
      );
    }, t.prototype.tap = function(d) {
      return this._passThrough(d, 1, u);
    }, o;
  }), t2;
}
var n2, r8;
function Mde() {
  return r8 || (r8 = 1, n2 = function(t) {
    var e = ln(), n = nh().keys, r = e.tryCatch, i = e.errorObj;
    function o(a, s, l) {
      return function(c) {
        var u = l._boundValue();
        e: for (var d = 0; d < a.length; ++d) {
          var f = a[d];
          if (f === Error || f != null && f.prototype instanceof Error) {
            if (c instanceof f)
              return r(s).call(u, c);
          } else if (typeof f == "function") {
            var p = r(f).call(u, c);
            if (p === i)
              return p;
            if (p)
              return r(s).call(u, c);
          } else if (e.isObject(c)) {
            for (var m = n(f), g = 0; g < m.length; ++g) {
              var b = m[g];
              if (f[b] != c[b])
                continue e;
            }
            return r(s).call(u, c);
          }
        }
        return t;
      };
    }
    return o;
  }), n2;
}
var r2, i8;
function eL() {
  if (i8) return r2;
  i8 = 1;
  var t = ln(), e = t.maybeWrapAsError, n = Rl(), r = n.OperationalError, i = nh();
  function o(c) {
    return c instanceof Error && i.getPrototypeOf(c) === Error.prototype;
  }
  var a = /^(?:name|message|stack|cause)$/;
  function s(c) {
    var u;
    if (o(c)) {
      u = new r(c), u.name = c.name, u.message = c.message, u.stack = c.stack;
      for (var d = i.keys(c), f = 0; f < d.length; ++f) {
        var p = d[f];
        a.test(p) || (u[p] = c[p]);
      }
      return u;
    }
    return t.markAsOriginatingFromRejection(c), c;
  }
  function l(c, u) {
    return function(d, f) {
      if (c !== null) {
        if (d) {
          var p = s(e(d));
          c._attachExtraTrace(p), c._reject(p);
        } else if (!u)
          c._fulfill(f);
        else {
          for (var m = arguments.length, g = new Array(Math.max(m - 1, 0)), b = 1; b < m; ++b)
            g[b - 1] = arguments[b];
          c._fulfill(g);
        }
        c = null;
      }
    };
  }
  return r2 = l, r2;
}
var i2, o8;
function Bde() {
  return o8 || (o8 = 1, i2 = function(t, e, n, r, i) {
    var o = ln(), a = o.tryCatch;
    t.method = function(s) {
      if (typeof s != "function")
        throw new t.TypeError("expecting a function but got " + o.classString(s));
      return function() {
        var l = new t(e);
        l._captureStackTrace(), l._pushContext();
        var c = a(s).apply(this, arguments), u = l._popContext();
        return i.checkForgottenReturns(
          c,
          u,
          "Promise.method",
          l
        ), l._resolveFromSyncValue(c), l;
      };
    }, t.attempt = t.try = function(s) {
      if (typeof s != "function")
        return r("expecting a function but got " + o.classString(s));
      var l = new t(e);
      l._captureStackTrace(), l._pushContext();
      var c;
      if (arguments.length > 1) {
        i.deprecated("calling Promise.try with more than 1 argument");
        var u = arguments[1], d = arguments[2];
        c = o.isArray(u) ? a(s).apply(d, u) : a(s).call(d, u);
      } else
        c = a(s)();
      var f = l._popContext();
      return i.checkForgottenReturns(
        c,
        f,
        "Promise.try",
        l
      ), l._resolveFromSyncValue(c), l;
    }, t.prototype._resolveFromSyncValue = function(s) {
      s === o.errorObj ? this._rejectCallback(s.e, !1) : this._resolveCallback(s, !0);
    };
  }), i2;
}
var o2, a8;
function Lde() {
  return a8 || (a8 = 1, o2 = function(t, e, n, r) {
    var i = !1, o = function(c, u) {
      this._reject(u);
    }, a = function(c, u) {
      u.promiseRejectionQueued = !0, u.bindingPromise._then(o, o, null, this, c);
    }, s = function(c, u) {
      this._bitField & 50397184 || this._resolveCallback(u.target);
    }, l = function(c, u) {
      u.promiseRejectionQueued || this._reject(c);
    };
    t.prototype.bind = function(c) {
      i || (i = !0, t.prototype._propagateFrom = r.propagateFromFunction(), t.prototype._boundValue = r.boundValueFunction());
      var u = n(c), d = new t(e);
      d._propagateFrom(this, 1);
      var f = this._target();
      if (d._setBoundTo(u), u instanceof t) {
        var p = {
          promiseRejectionQueued: !1,
          promise: d,
          target: f,
          bindingPromise: u
        };
        f._then(e, a, void 0, d, p), u._then(
          s,
          l,
          void 0,
          d,
          p
        ), d._setOnCancel(u);
      } else
        d._resolveCallback(f);
      return d;
    }, t.prototype._setBoundTo = function(c) {
      c !== void 0 ? (this._bitField = this._bitField | 2097152, this._boundTo = c) : this._bitField = this._bitField & -2097153;
    }, t.prototype._isBound = function() {
      return (this._bitField & 2097152) === 2097152;
    }, t.bind = function(c, u) {
      return t.resolve(u).bind(c);
    };
  }), o2;
}
var a2, s8;
function Pde() {
  return s8 || (s8 = 1, a2 = function(t, e, n, r) {
    var i = ln(), o = i.tryCatch, a = i.errorObj, s = t._async;
    t.prototype.break = t.prototype.cancel = function() {
      if (!r.cancellation()) return this._warn("cancellation is disabled");
      for (var l = this, c = l; l._isCancellable(); ) {
        if (!l._cancelBy(c)) {
          c._isFollowing() ? c._followee().cancel() : c._cancelBranched();
          break;
        }
        var u = l._cancellationParent;
        if (u == null || !u._isCancellable()) {
          l._isFollowing() ? l._followee().cancel() : l._cancelBranched();
          break;
        } else
          l._isFollowing() && l._followee().cancel(), l._setWillBeCancelled(), c = l, l = u;
      }
    }, t.prototype._branchHasCancelled = function() {
      this._branchesRemainingToCancel--;
    }, t.prototype._enoughBranchesHaveCancelled = function() {
      return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
    }, t.prototype._cancelBy = function(l) {
      return l === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), !0) : (this._branchHasCancelled(), this._enoughBranchesHaveCancelled() ? (this._invokeOnCancel(), !0) : !1);
    }, t.prototype._cancelBranched = function() {
      this._enoughBranchesHaveCancelled() && this._cancel();
    }, t.prototype._cancel = function() {
      this._isCancellable() && (this._setCancelled(), s.invoke(this._cancelPromises, this, void 0));
    }, t.prototype._cancelPromises = function() {
      this._length() > 0 && this._settlePromises();
    }, t.prototype._unsetOnCancel = function() {
      this._onCancelField = void 0;
    }, t.prototype._isCancellable = function() {
      return this.isPending() && !this._isCancelled();
    }, t.prototype.isCancellable = function() {
      return this.isPending() && !this.isCancelled();
    }, t.prototype._doInvokeOnCancel = function(l, c) {
      if (i.isArray(l))
        for (var u = 0; u < l.length; ++u)
          this._doInvokeOnCancel(l[u], c);
      else if (l !== void 0)
        if (typeof l == "function") {
          if (!c) {
            var d = o(l).call(this._boundValue());
            d === a && (this._attachExtraTrace(d.e), s.throwLater(d.e));
          }
        } else
          l._resultCancelled(this);
    }, t.prototype._invokeOnCancel = function() {
      var l = this._onCancel();
      this._unsetOnCancel(), s.invoke(this._doInvokeOnCancel, this, l);
    }, t.prototype._invokeInternalOnCancel = function() {
      this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel());
    }, t.prototype._resultCancelled = function() {
      this.cancel();
    };
  }), a2;
}
var s2, l8;
function Wde() {
  return l8 || (l8 = 1, s2 = function(t) {
    function e() {
      return this.value;
    }
    function n() {
      throw this.reason;
    }
    t.prototype.return = t.prototype.thenReturn = function(r) {
      return r instanceof t && r.suppressUnhandledRejections(), this._then(
        e,
        void 0,
        void 0,
        { value: r },
        void 0
      );
    }, t.prototype.throw = t.prototype.thenThrow = function(r) {
      return this._then(
        n,
        void 0,
        void 0,
        { reason: r },
        void 0
      );
    }, t.prototype.catchThrow = function(r) {
      if (arguments.length <= 1)
        return this._then(
          void 0,
          n,
          void 0,
          { reason: r },
          void 0
        );
      var i = arguments[1], o = function() {
        throw i;
      };
      return this.caught(r, o);
    }, t.prototype.catchReturn = function(r) {
      if (arguments.length <= 1)
        return r instanceof t && r.suppressUnhandledRejections(), this._then(
          void 0,
          e,
          void 0,
          { value: r },
          void 0
        );
      var i = arguments[1];
      i instanceof t && i.suppressUnhandledRejections();
      var o = function() {
        return i;
      };
      return this.caught(r, o);
    };
  }), s2;
}
var l2, c8;
function zde() {
  return c8 || (c8 = 1, l2 = function(t) {
    function e(l) {
      l !== void 0 ? (l = l._target(), this._bitField = l._bitField, this._settledValueField = l._isFateSealed() ? l._settledValue() : void 0) : (this._bitField = 0, this._settledValueField = void 0);
    }
    e.prototype._settledValue = function() {
      return this._settledValueField;
    };
    var n = e.prototype.value = function() {
      if (!this.isFulfilled())
        throw new TypeError(`cannot get fulfillment value of a non-fulfilled promise

    See http://goo.gl/MqrFmX
`);
      return this._settledValue();
    }, r = e.prototype.error = e.prototype.reason = function() {
      if (!this.isRejected())
        throw new TypeError(`cannot get rejection reason of a non-rejected promise

    See http://goo.gl/MqrFmX
`);
      return this._settledValue();
    }, i = e.prototype.isFulfilled = function() {
      return (this._bitField & 33554432) !== 0;
    }, o = e.prototype.isRejected = function() {
      return (this._bitField & 16777216) !== 0;
    }, a = e.prototype.isPending = function() {
      return (this._bitField & 50397184) === 0;
    }, s = e.prototype.isResolved = function() {
      return (this._bitField & 50331648) !== 0;
    };
    e.prototype.isCancelled = function() {
      return (this._bitField & 8454144) !== 0;
    }, t.prototype.__isCancelled = function() {
      return (this._bitField & 65536) === 65536;
    }, t.prototype._isCancelled = function() {
      return this._target().__isCancelled();
    }, t.prototype.isCancelled = function() {
      return (this._target()._bitField & 8454144) !== 0;
    }, t.prototype.isPending = function() {
      return a.call(this._target());
    }, t.prototype.isRejected = function() {
      return o.call(this._target());
    }, t.prototype.isFulfilled = function() {
      return i.call(this._target());
    }, t.prototype.isResolved = function() {
      return s.call(this._target());
    }, t.prototype.value = function() {
      return n.call(this._target());
    }, t.prototype.reason = function() {
      var l = this._target();
      return l._unsetRejectionIsUnhandled(), r.call(l);
    }, t.prototype._value = function() {
      return this._settledValue();
    }, t.prototype._reason = function() {
      return this._unsetRejectionIsUnhandled(), this._settledValue();
    }, t.PromiseInspection = e;
  }), l2;
}
var c2, u8;
function $de() {
  return u8 || (u8 = 1, c2 = function(t, e, n, r, i, o) {
    var a = ln(), s = a.canEvaluate, l = a.tryCatch, c = a.errorObj, u;
    if (s) {
      for (var d = function(w) {
        return new Function("value", "holder", `                             
	            'use strict';                                                    
	            holder.pIndex = value;                                           
	            holder.checkFulfillment(this);                                   
	            `.replace(/Index/g, w));
      }, f = function(w) {
        return new Function("promise", "holder", `                           
	            'use strict';                                                    
	            holder.pIndex = promise;                                         
	            `.replace(/Index/g, w));
      }, p = function(w) {
        for (var x = new Array(w), k = 0; k < x.length; ++k)
          x[k] = "this.p" + (k + 1);
        var A = x.join(" = ") + " = null;", U = `var promise;
` + x.map(function(le) {
          return `                                                         
	                promise = ` + le + `;                                      
	                if (promise instanceof Promise) {                            
	                    promise.cancel();                                        
	                }                                                            
	            `;
        }).join(`
`), P = x.join(", "), V = "Holder$" + w, I = `return function(tryCatch, errorObj, Promise, async) {    
	            'use strict';                                                    
	            function [TheName](fn) {                                         
	                [TheProperties]                                              
	                this.fn = fn;                                                
	                this.asyncNeeded = true;                                     
	                this.now = 0;                                                
	            }                                                                
	                                                                             
	            [TheName].prototype._callFunction = function(promise) {          
	                promise._pushContext();                                      
	                var ret = tryCatch(this.fn)([ThePassedArguments]);           
	                promise._popContext();                                       
	                if (ret === errorObj) {                                      
	                    promise._rejectCallback(ret.e, false);                   
	                } else {                                                     
	                    promise._resolveCallback(ret);                           
	                }                                                            
	            };                                                               
	                                                                             
	            [TheName].prototype.checkFulfillment = function(promise) {       
	                var now = ++this.now;                                        
	                if (now === [TheTotal]) {                                    
	                    if (this.asyncNeeded) {                                  
	                        async.invoke(this._callFunction, this, promise);     
	                    } else {                                                 
	                        this._callFunction(promise);                         
	                    }                                                        
	                                                                             
	                }                                                            
	            };                                                               
	                                                                             
	            [TheName].prototype._resultCancelled = function() {              
	                [CancellationCode]                                           
	            };                                                               
	                                                                             
	            return [TheName];                                                
	        }(tryCatch, errorObj, Promise, async);                               
	        `;
        return I = I.replace(/\[TheName\]/g, V).replace(/\[TheTotal\]/g, w).replace(/\[ThePassedArguments\]/g, P).replace(/\[TheProperties\]/g, A).replace(/\[CancellationCode\]/g, U), new Function("tryCatch", "errorObj", "Promise", "async", I)(l, c, t, i);
      }, m = [], g = [], b = [], y = 0; y < 8; ++y)
        m.push(p(y + 1)), g.push(d(y + 1)), b.push(f(y + 1));
      u = function(w) {
        this._reject(w);
      };
    }
    t.join = function() {
      var w = arguments.length - 1, x;
      if (w > 0 && typeof arguments[w] == "function" && (x = arguments[w], w <= 8 && s)) {
        var C = new t(r);
        C._captureStackTrace();
        for (var k = m[w - 1], A = new k(x), U = g, P = 0; P < w; ++P) {
          var V = n(arguments[P], C);
          if (V instanceof t) {
            V = V._target();
            var I = V._bitField;
            I & 50397184 ? I & 33554432 ? U[P].call(
              C,
              V._value(),
              A
            ) : I & 16777216 ? C._reject(V._reason()) : C._cancel() : (V._then(
              U[P],
              u,
              void 0,
              C,
              A
            ), b[P](V, A), A.asyncNeeded = !1);
          } else
            U[P].call(C, V, A);
        }
        if (!C._isFateSealed()) {
          if (A.asyncNeeded) {
            var le = o();
            le !== null && (A.fn = a.domainBind(le, A.fn));
          }
          C._setAsyncGuaranteed(), C._setOnCancel(A);
        }
        return C;
      }
      for (var be = arguments.length, F = new Array(be), G = 0; G < be; ++G)
        F[G] = arguments[G];
      x && F.pop();
      var C = new e(F).promise();
      return x !== void 0 ? C.spread(x) : C;
    };
  }), c2;
}
var u2, d8;
function Hde() {
  return d8 || (d8 = 1, u2 = function(t, e, n, r, i, o) {
    var a = t._getDomain, s = ln(), l = s.tryCatch, c = s.errorObj, u = t._async;
    function d(p, m, g, b) {
      this.constructor$(p), this._promise._captureStackTrace();
      var y = a();
      this._callback = y === null ? m : s.domainBind(y, m), this._preservedValues = b === i ? new Array(this.length()) : null, this._limit = g, this._inFlight = 0, this._queue = [], u.invoke(this._asyncInit, this, void 0);
    }
    s.inherits(d, e), d.prototype._asyncInit = function() {
      this._init$(void 0, -2);
    }, d.prototype._init = function() {
    }, d.prototype._promiseFulfilled = function(p, m) {
      var g = this._values, b = this.length(), y = this._preservedValues, w = this._limit;
      if (m < 0) {
        if (m = m * -1 - 1, g[m] = p, w >= 1 && (this._inFlight--, this._drainQueue(), this._isResolved()))
          return !0;
      } else {
        if (w >= 1 && this._inFlight >= w)
          return g[m] = p, this._queue.push(m), !1;
        y !== null && (y[m] = p);
        var x = this._promise, k = this._callback, A = x._boundValue();
        x._pushContext();
        var U = l(k).call(A, p, m, b), P = x._popContext();
        if (o.checkForgottenReturns(
          U,
          P,
          y !== null ? "Promise.filter" : "Promise.map",
          x
        ), U === c)
          return this._reject(U.e), !0;
        var V = r(U, this._promise);
        if (V instanceof t) {
          V = V._target();
          var I = V._bitField;
          if (I & 50397184)
            if (I & 33554432)
              U = V._value();
            else return I & 16777216 ? (this._reject(V._reason()), !0) : (this._cancel(), !0);
          else return w >= 1 && this._inFlight++, g[m] = V, V._proxy(this, (m + 1) * -1), !1;
        }
        g[m] = U;
      }
      var le = ++this._totalResolved;
      return le >= b ? (y !== null ? this._filter(g, y) : this._resolve(g), !0) : !1;
    }, d.prototype._drainQueue = function() {
      for (var p = this._queue, m = this._limit, g = this._values; p.length > 0 && this._inFlight < m; ) {
        if (this._isResolved()) return;
        var b = p.pop();
        this._promiseFulfilled(g[b], b);
      }
    }, d.prototype._filter = function(p, m) {
      for (var g = m.length, b = new Array(g), y = 0, w = 0; w < g; ++w)
        p[w] && (b[y++] = m[w]);
      b.length = y, this._resolve(b);
    }, d.prototype.preservedValues = function() {
      return this._preservedValues;
    };
    function f(p, m, g, b) {
      if (typeof m != "function")
        return n("expecting a function but got " + s.classString(m));
      var y = 0;
      if (g !== void 0)
        if (typeof g == "object" && g !== null) {
          if (typeof g.concurrency != "number")
            return t.reject(
              new TypeError("'concurrency' must be a number but it is " + s.classString(g.concurrency))
            );
          y = g.concurrency;
        } else
          return t.reject(new TypeError(
            "options argument must be an object but it is " + s.classString(g)
          ));
      return y = typeof y == "number" && isFinite(y) && y >= 1 ? y : 0, new d(p, m, y, b).promise();
    }
    t.prototype.map = function(p, m) {
      return f(this, p, m, null);
    }, t.map = function(p, m, g, b) {
      return f(p, m, g, b);
    };
  }), u2;
}
var d2, f8;
function jde() {
  if (f8) return d2;
  f8 = 1;
  var t = Object.create;
  if (t) {
    var e = t(null), n = t(null);
    e[" size"] = n[" size"] = 0;
  }
  return d2 = function(r) {
    var i = ln(), o = i.canEvaluate, a = i.isIdentifier, s, l;
    {
      var c = function(b) {
        return new Function("ensureMethod", `                                    
	        return function(obj) {                                               
	            'use strict'                                                     
	            var len = this.length;                                           
	            ensureMethod(obj, 'methodName');                                 
	            switch(len) {                                                    
	                case 1: return obj.methodName(this[0]);                      
	                case 2: return obj.methodName(this[0], this[1]);             
	                case 3: return obj.methodName(this[0], this[1], this[2]);    
	                case 0: return obj.methodName();                             
	                default:                                                     
	                    return obj.methodName.apply(obj, this);                  
	            }                                                                
	        };                                                                   
	        `.replace(/methodName/g, b))(f);
      }, u = function(b) {
        return new Function("obj", `                                             
	        'use strict';                                                        
	        return obj.propertyName;                                             
	        `.replace("propertyName", b));
      }, d = function(b, y, w) {
        var x = w[b];
        if (typeof x != "function") {
          if (!a(b))
            return null;
          if (x = y(b), w[b] = x, w[" size"]++, w[" size"] > 512) {
            for (var k = Object.keys(w), A = 0; A < 256; ++A) delete w[k[A]];
            w[" size"] = k.length - 256;
          }
        }
        return x;
      };
      s = function(b) {
        return d(b, c, e);
      }, l = function(b) {
        return d(b, u, n);
      };
    }
    function f(b, y) {
      var w;
      if (b != null && (w = b[y]), typeof w != "function") {
        var x = "Object " + i.classString(b) + " has no method '" + i.toString(y) + "'";
        throw new r.TypeError(x);
      }
      return w;
    }
    function p(b) {
      var y = this.pop(), w = f(b, y);
      return w.apply(b, this);
    }
    r.prototype.call = function(b) {
      for (var y = arguments.length, w = new Array(Math.max(y - 1, 0)), x = 1; x < y; ++x)
        w[x - 1] = arguments[x];
      if (o) {
        var k = s(b);
        if (k !== null)
          return this._then(
            k,
            void 0,
            void 0,
            w,
            void 0
          );
      }
      return w.push(b), this._then(p, void 0, void 0, w, void 0);
    };
    function m(b) {
      return b[this];
    }
    function g(b) {
      var y = +this;
      return y < 0 && (y = Math.max(0, y + b.length)), b[y];
    }
    r.prototype.get = function(b) {
      var y = typeof b == "number", w;
      if (y)
        w = g;
      else if (o) {
        var x = l(b);
        w = x !== null ? x : m;
      } else
        w = m;
      return this._then(w, void 0, void 0, b, void 0);
    };
  }, d2;
}
var f2, h8;
function Vde() {
  return h8 || (h8 = 1, f2 = function(t, e, n, r, i, o) {
    var a = ln(), s = Rl().TypeError, l = ln().inherits, c = a.errorObj, u = a.tryCatch, d = {};
    function f(x) {
      setTimeout(function() {
        throw x;
      }, 0);
    }
    function p(x) {
      var k = n(x);
      return k !== x && typeof x._isDisposable == "function" && typeof x._getDisposer == "function" && x._isDisposable() && k._setDisposable(x._getDisposer()), k;
    }
    function m(x, k) {
      var A = 0, U = x.length, P = new t(i);
      function V() {
        if (A >= U) return P._fulfill();
        var I = p(x[A++]);
        if (I instanceof t && I._isDisposable()) {
          try {
            I = n(
              I._getDisposer().tryDispose(k),
              x.promise
            );
          } catch (le) {
            return f(le);
          }
          if (I instanceof t)
            return I._then(
              V,
              f,
              null,
              null,
              null
            );
        }
        V();
      }
      return V(), P;
    }
    function g(x, k, A) {
      this._data = x, this._promise = k, this._context = A;
    }
    g.prototype.data = function() {
      return this._data;
    }, g.prototype.promise = function() {
      return this._promise;
    }, g.prototype.resource = function() {
      return this.promise().isFulfilled() ? this.promise().value() : d;
    }, g.prototype.tryDispose = function(x) {
      var k = this.resource(), A = this._context;
      A !== void 0 && A._pushContext();
      var U = k !== d ? this.doDispose(k, x) : null;
      return A !== void 0 && A._popContext(), this._promise._unsetDisposable(), this._data = null, U;
    }, g.isDisposer = function(x) {
      return x != null && typeof x.resource == "function" && typeof x.tryDispose == "function";
    };
    function b(x, k, A) {
      this.constructor$(x, k, A);
    }
    l(b, g), b.prototype.doDispose = function(x, k) {
      var A = this.data();
      return A.call(x, x, k);
    };
    function y(x) {
      return g.isDisposer(x) ? (this.resources[this.index]._setDisposable(x), x.promise()) : x;
    }
    function w(x) {
      this.length = x, this.promise = null, this[x - 1] = null;
    }
    w.prototype._resultCancelled = function() {
      for (var x = this.length, k = 0; k < x; ++k) {
        var A = this[k];
        A instanceof t && A.cancel();
      }
    }, t.using = function() {
      var x = arguments.length;
      if (x < 2) return e(
        "you must pass at least 2 arguments to Promise.using"
      );
      var k = arguments[x - 1];
      if (typeof k != "function")
        return e("expecting a function but got " + a.classString(k));
      var A, U = !0;
      x === 2 && Array.isArray(arguments[0]) ? (A = arguments[0], x = A.length, U = !1) : (A = arguments, x--);
      for (var P = new w(x), V = 0; V < x; ++V) {
        var I = A[V];
        if (g.isDisposer(I)) {
          var le = I;
          I = I.promise(), I._setDisposable(le);
        } else {
          var be = n(I);
          be instanceof t && (I = be._then(y, null, null, {
            resources: P,
            index: V
          }, void 0));
        }
        P[V] = I;
      }
      for (var F = new Array(P.length), V = 0; V < F.length; ++V)
        F[V] = t.resolve(P[V]).reflect();
      var G = t.all(F).then(function(ie) {
        for (var ee = 0; ee < ie.length; ++ee) {
          var Z = ie[ee];
          if (Z.isRejected())
            return c.e = Z.error(), c;
          if (!Z.isFulfilled()) {
            G.cancel();
            return;
          }
          ie[ee] = Z.value();
        }
        C._pushContext(), k = u(k);
        var oe = U ? k.apply(void 0, ie) : k(ie), te = C._popContext();
        return o.checkForgottenReturns(
          oe,
          te,
          "Promise.using",
          C
        ), oe;
      }), C = G.lastly(function() {
        var ie = new t.PromiseInspection(G);
        return m(P, ie);
      });
      return P.promise = C, C._setOnCancel(P), C;
    }, t.prototype._setDisposable = function(x) {
      this._bitField = this._bitField | 131072, this._disposer = x;
    }, t.prototype._isDisposable = function() {
      return (this._bitField & 131072) > 0;
    }, t.prototype._getDisposer = function() {
      return this._disposer;
    }, t.prototype._unsetDisposable = function() {
      this._bitField = this._bitField & -131073, this._disposer = void 0;
    }, t.prototype.disposer = function(x) {
      if (typeof x == "function")
        return new b(x, this, r());
      throw new s();
    };
  }), f2;
}
var h2, p8;
function qde() {
  return p8 || (p8 = 1, h2 = function(t, e, n) {
    var r = ln(), i = t.TimeoutError;
    function o(d) {
      this.handle = d;
    }
    o.prototype._resultCancelled = function() {
      clearTimeout(this.handle);
    };
    var a = function(d) {
      return s(+this).thenReturn(d);
    }, s = t.delay = function(d, f) {
      var p, m;
      return f !== void 0 ? (p = t.resolve(f)._then(a, null, null, d, void 0), n.cancellation() && f instanceof t && p._setOnCancel(f)) : (p = new t(e), m = setTimeout(function() {
        p._fulfill();
      }, +d), n.cancellation() && p._setOnCancel(new o(m)), p._captureStackTrace()), p._setAsyncGuaranteed(), p;
    };
    t.prototype.delay = function(d) {
      return s(d, this);
    };
    var l = function(d, f, p) {
      var m;
      typeof f != "string" ? f instanceof Error ? m = f : m = new i("operation timed out") : m = new i(f), r.markAsOriginatingFromRejection(m), d._attachExtraTrace(m), d._reject(m), p != null && p.cancel();
    };
    function c(d) {
      return clearTimeout(this.handle), d;
    }
    function u(d) {
      throw clearTimeout(this.handle), d;
    }
    t.prototype.timeout = function(d, f) {
      d = +d;
      var p, m, g = new o(setTimeout(function() {
        p.isPending() && l(p, f, m);
      }, d));
      return n.cancellation() ? (m = this.then(), p = m._then(
        c,
        u,
        void 0,
        g,
        void 0
      ), p._setOnCancel(g)) : p = this._then(
        c,
        u,
        void 0,
        g,
        void 0
      ), p;
    };
  }), h2;
}
var p2, m8;
function Gde() {
  return m8 || (m8 = 1, p2 = function(t, e, n, r, i, o) {
    var a = Rl(), s = a.TypeError, l = ln(), c = l.errorObj, u = l.tryCatch, d = [];
    function f(m, g, b) {
      for (var y = 0; y < g.length; ++y) {
        b._pushContext();
        var w = u(g[y])(m);
        if (b._popContext(), w === c) {
          b._pushContext();
          var x = t.reject(c.e);
          return b._popContext(), x;
        }
        var k = r(w, b);
        if (k instanceof t) return k;
      }
      return null;
    }
    function p(m, g, b, y) {
      if (o.cancellation()) {
        var w = new t(n), x = this._finallyPromise = new t(n);
        this._promise = w.lastly(function() {
          return x;
        }), w._captureStackTrace(), w._setOnCancel(this);
      } else {
        var k = this._promise = new t(n);
        k._captureStackTrace();
      }
      this._stack = y, this._generatorFunction = m, this._receiver = g, this._generator = void 0, this._yieldHandlers = typeof b == "function" ? [b].concat(d) : d, this._yieldedPromise = null, this._cancellationPhase = !1;
    }
    l.inherits(p, i), p.prototype._isResolved = function() {
      return this._promise === null;
    }, p.prototype._cleanup = function() {
      this._promise = this._generator = null, o.cancellation() && this._finallyPromise !== null && (this._finallyPromise._fulfill(), this._finallyPromise = null);
    }, p.prototype._promiseCancelled = function() {
      if (!this._isResolved()) {
        var m = typeof this._generator.return < "u", g;
        if (m)
          this._promise._pushContext(), g = u(this._generator.return).call(
            this._generator,
            void 0
          ), this._promise._popContext();
        else {
          var b = new t.CancellationError(
            "generator .return() sentinel"
          );
          t.coroutine.returnSentinel = b, this._promise._attachExtraTrace(b), this._promise._pushContext(), g = u(this._generator.throw).call(
            this._generator,
            b
          ), this._promise._popContext();
        }
        this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(g);
      }
    }, p.prototype._promiseFulfilled = function(m) {
      this._yieldedPromise = null, this._promise._pushContext();
      var g = u(this._generator.next).call(this._generator, m);
      this._promise._popContext(), this._continue(g);
    }, p.prototype._promiseRejected = function(m) {
      this._yieldedPromise = null, this._promise._attachExtraTrace(m), this._promise._pushContext();
      var g = u(this._generator.throw).call(this._generator, m);
      this._promise._popContext(), this._continue(g);
    }, p.prototype._resultCancelled = function() {
      if (this._yieldedPromise instanceof t) {
        var m = this._yieldedPromise;
        this._yieldedPromise = null, m.cancel();
      }
    }, p.prototype.promise = function() {
      return this._promise;
    }, p.prototype._run = function() {
      this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, this._promiseFulfilled(void 0);
    }, p.prototype._continue = function(m) {
      var g = this._promise;
      if (m === c)
        return this._cleanup(), this._cancellationPhase ? g.cancel() : g._rejectCallback(m.e, !1);
      var b = m.value;
      if (m.done === !0)
        return this._cleanup(), this._cancellationPhase ? g.cancel() : g._resolveCallback(b);
      var y = r(b, this._promise);
      if (!(y instanceof t) && (y = f(
        y,
        this._yieldHandlers,
        this._promise
      ), y === null)) {
        this._promiseRejected(
          new s(
            `A value %s was yielded that could not be treated as a promise

    See http://goo.gl/MqrFmX

`.replace("%s", b) + `From coroutine:
` + this._stack.split(`
`).slice(1, -7).join(`
`)
          )
        );
        return;
      }
      y = y._target();
      var w = y._bitField;
      w & 50397184 ? w & 33554432 ? t._async.invoke(
        this._promiseFulfilled,
        this,
        y._value()
      ) : w & 16777216 ? t._async.invoke(
        this._promiseRejected,
        this,
        y._reason()
      ) : this._promiseCancelled() : (this._yieldedPromise = y, y._proxy(this, null));
    }, t.coroutine = function(m, g) {
      if (typeof m != "function")
        throw new s(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
      var b = Object(g).yieldHandler, y = p, w = new Error().stack;
      return function() {
        var x = m.apply(this, arguments), k = new y(
          void 0,
          void 0,
          b,
          w
        ), A = k.promise();
        return k._generator = x, k._promiseFulfilled(void 0), A;
      };
    }, t.coroutine.addYieldHandler = function(m) {
      if (typeof m != "function")
        throw new s("expecting a function but got " + l.classString(m));
      d.push(m);
    }, t.spawn = function(m) {
      if (o.deprecated("Promise.spawn()", "Promise.coroutine()"), typeof m != "function")
        return e(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
      var g = new p(m, this), b = g.promise();
      return g._run(t.spawn), b;
    };
  }), p2;
}
var m2, g8;
function Kde() {
  return g8 || (g8 = 1, m2 = function(t) {
    var e = ln(), n = t._async, r = e.tryCatch, i = e.errorObj;
    function o(l, c) {
      var u = this;
      if (!e.isArray(l)) return a.call(u, l, c);
      var d = r(c).apply(u._boundValue(), [null].concat(l));
      d === i && n.throwLater(d.e);
    }
    function a(l, c) {
      var u = this, d = u._boundValue(), f = l === void 0 ? r(c).call(d, null) : r(c).call(d, null, l);
      f === i && n.throwLater(f.e);
    }
    function s(l, c) {
      var u = this;
      if (!l) {
        var d = new Error(l + "");
        d.cause = l, l = d;
      }
      var f = r(c).call(u._boundValue(), l);
      f === i && n.throwLater(f.e);
    }
    t.prototype.asCallback = t.prototype.nodeify = function(l, c) {
      if (typeof l == "function") {
        var u = a;
        c !== void 0 && Object(c).spread && (u = o), this._then(
          u,
          s,
          void 0,
          this,
          l
        );
      }
      return this;
    };
  }), m2;
}
var g2, y8;
function Xde() {
  return y8 || (y8 = 1, g2 = function(t, e) {
    var n = {}, r = ln(), i = eL(), o = r.withAppended, a = r.maybeWrapAsError, s = r.canEvaluate, l = Rl().TypeError, c = "Async", u = { __isPromisified__: !0 }, d = [
      "arity",
      "length",
      "name",
      "arguments",
      "caller",
      "callee",
      "prototype",
      "__isPromisified__"
    ], f = new RegExp("^(?:" + d.join("|") + ")$"), p = function(G) {
      return r.isIdentifier(G) && G.charAt(0) !== "_" && G !== "constructor";
    };
    function m(G) {
      return !f.test(G);
    }
    function g(G) {
      try {
        return G.__isPromisified__ === !0;
      } catch {
        return !1;
      }
    }
    function b(G, C, ie) {
      var ee = r.getDataPropertyOrDefault(
        G,
        C + ie,
        u
      );
      return ee ? g(ee) : !1;
    }
    function y(G, C, ie) {
      for (var ee = 0; ee < G.length; ee += 2) {
        var Z = G[ee];
        if (ie.test(Z)) {
          for (var oe = Z.replace(ie, ""), te = 0; te < G.length; te += 2)
            if (G[te] === oe)
              throw new l(`Cannot promisify an API that has normal methods with '%s'-suffix

    See http://goo.gl/MqrFmX
`.replace("%s", C));
        }
      }
    }
    function w(G, C, ie, ee) {
      for (var Z = r.inheritedDataKeys(G), oe = [], te = 0; te < Z.length; ++te) {
        var _e = Z[te], q = G[_e], N = ee === p ? !0 : p(_e);
        typeof q == "function" && !g(q) && !b(G, _e, C) && ee(_e, q, G, N) && oe.push(_e, q);
      }
      return y(oe, C, ie), oe;
    }
    var x = function(G) {
      return G.replace(/([$])/, "\\$");
    }, k;
    {
      var A = function(G) {
        for (var C = [G], ie = Math.max(0, G - 1 - 3), ee = G - 1; ee >= ie; --ee)
          C.push(ee);
        for (var ee = G + 1; ee <= 3; ++ee)
          C.push(ee);
        return C;
      }, U = function(G) {
        return r.filledRange(G, "_arg", "");
      }, P = function(G) {
        return r.filledRange(
          Math.max(G, 3),
          "_arg",
          ""
        );
      }, V = function(G) {
        return typeof G.length == "number" ? Math.max(Math.min(G.length, 1024), 0) : 0;
      };
      k = function(G, C, ie, ee, Z, oe) {
        var te = Math.max(0, V(ee) - 1), _e = A(te), q = typeof G == "string" || C === n;
        function N(he) {
          var H = U(he).join(", "), W = he > 0 ? ", " : "", we;
          return q ? we = `ret = callback.call(this, {{args}}, nodeback); break;
` : we = C === void 0 ? `ret = callback({{args}}, nodeback); break;
` : `ret = callback.call(receiver, {{args}}, nodeback); break;
`, we.replace("{{args}}", H).replace(", ", W);
        }
        function ce() {
          for (var he = "", H = 0; H < _e.length; ++H)
            he += "case " + _e[H] + ":" + N(_e[H]);
          return he += `                                                             
	        default:                                                             
	            var args = new Array(len + 1);                                   
	            var i = 0;                                                       
	            for (var i = 0; i < len; ++i) {                                  
	               args[i] = arguments[i];                                       
	            }                                                                
	            args[i] = nodeback;                                              
	            [CodeForCall]                                                    
	            break;                                                           
	        `.replace("[CodeForCall]", q ? `ret = callback.apply(this, args);
` : `ret = callback.apply(receiver, args);
`), he;
        }
        var me = typeof G == "string" ? "this != null ? this['" + G + "'] : fn" : "fn", ve = `'use strict';                                                
	        var ret = function (Parameters) {                                    
	            'use strict';                                                    
	            var len = arguments.length;                                      
	            var promise = new Promise(INTERNAL);                             
	            promise._captureStackTrace();                                    
	            var nodeback = nodebackForPromise(promise, ` + oe + `);   
	            var ret;                                                         
	            var callback = tryCatch([GetFunctionCode]);                      
	            switch(len) {                                                    
	                [CodeForSwitchCase]                                          
	            }                                                                
	            if (ret === errorObj) {                                          
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
	            }                                                                
	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     
	            return promise;                                                  
	        };                                                                   
	        notEnumerableProp(ret, '__isPromisified__', true);                   
	        return ret;                                                          
	    `.replace("[CodeForSwitchCase]", ce()).replace("[GetFunctionCode]", me);
        return ve = ve.replace("Parameters", P(te)), new Function(
          "Promise",
          "fn",
          "receiver",
          "withAppended",
          "maybeWrapAsError",
          "nodebackForPromise",
          "tryCatch",
          "errorObj",
          "notEnumerableProp",
          "INTERNAL",
          ve
        )(
          t,
          ee,
          C,
          o,
          a,
          i,
          r.tryCatch,
          r.errorObj,
          r.notEnumerableProp,
          e
        );
      };
    }
    function I(G, C, ie, ee, Z, oe) {
      var te = /* @__PURE__ */ function() {
        return this;
      }(), _e = G;
      typeof _e == "string" && (G = ee);
      function q() {
        var N = C;
        C === n && (N = this);
        var ce = new t(e);
        ce._captureStackTrace();
        var me = typeof _e == "string" && this !== te ? this[_e] : G, ve = i(ce, oe);
        try {
          me.apply(N, o(arguments, ve));
        } catch (he) {
          ce._rejectCallback(a(he), !0, !0);
        }
        return ce._isFateSealed() || ce._setAsyncGuaranteed(), ce;
      }
      return r.notEnumerableProp(q, "__isPromisified__", !0), q;
    }
    var le = s ? k : I;
    function be(G, C, ie, ee, Z) {
      for (var oe = new RegExp(x(C) + "$"), te = w(G, C, oe, ie), _e = 0, q = te.length; _e < q; _e += 2) {
        var N = te[_e], ce = te[_e + 1], me = N + C;
        if (ee === le)
          G[me] = le(N, n, N, ce, C, Z);
        else {
          var ve = ee(ce, function() {
            return le(
              N,
              n,
              N,
              ce,
              C,
              Z
            );
          });
          r.notEnumerableProp(ve, "__isPromisified__", !0), G[me] = ve;
        }
      }
      return r.toFastProperties(G), G;
    }
    function F(G, C, ie) {
      return le(
        G,
        C,
        void 0,
        G,
        null,
        ie
      );
    }
    t.promisify = function(G, C) {
      if (typeof G != "function")
        throw new l("expecting a function but got " + r.classString(G));
      if (g(G))
        return G;
      C = Object(C);
      var ie = C.context === void 0 ? n : C.context, ee = !!C.multiArgs, Z = F(G, ie, ee);
      return r.copyDescriptors(G, Z, m), Z;
    }, t.promisifyAll = function(G, C) {
      if (typeof G != "function" && typeof G != "object")
        throw new l(`the target of promisifyAll must be an object or a function

    See http://goo.gl/MqrFmX
`);
      C = Object(C);
      var ie = !!C.multiArgs, ee = C.suffix;
      typeof ee != "string" && (ee = c);
      var Z = C.filter;
      typeof Z != "function" && (Z = p);
      var oe = C.promisifier;
      if (typeof oe != "function" && (oe = le), !r.isIdentifier(ee))
        throw new RangeError(`suffix must be a valid identifier

    See http://goo.gl/MqrFmX
`);
      for (var te = r.inheritedDataKeys(G), _e = 0; _e < te.length; ++_e) {
        var q = G[te[_e]];
        te[_e] !== "constructor" && r.isClass(q) && (be(
          q.prototype,
          ee,
          Z,
          oe,
          ie
        ), be(q, ee, Z, oe, ie));
      }
      return be(G, ee, Z, oe, ie);
    };
  }), g2;
}
var y2, b8;
function Yde() {
  return b8 || (b8 = 1, y2 = function(t, e, n, r) {
    var i = ln(), o = i.isObject, a = nh(), s;
    typeof Map == "function" && (s = Map);
    var l = /* @__PURE__ */ function() {
      var f = 0, p = 0;
      function m(g, b) {
        this[f] = g, this[f + p] = b, f++;
      }
      return function(b) {
        p = b.size, f = 0;
        var y = new Array(b.size * 2);
        return b.forEach(m, y), y;
      };
    }(), c = function(f) {
      for (var p = new s(), m = f.length / 2 | 0, g = 0; g < m; ++g) {
        var b = f[m + g], y = f[g];
        p.set(b, y);
      }
      return p;
    };
    function u(f) {
      var p = !1, m;
      if (s !== void 0 && f instanceof s)
        m = l(f), p = !0;
      else {
        var g = a.keys(f), b = g.length;
        m = new Array(b * 2);
        for (var y = 0; y < b; ++y) {
          var w = g[y];
          m[y] = f[w], m[y + b] = w;
        }
      }
      this.constructor$(m), this._isMap = p, this._init$(void 0, -3);
    }
    i.inherits(u, e), u.prototype._init = function() {
    }, u.prototype._promiseFulfilled = function(f, p) {
      this._values[p] = f;
      var m = ++this._totalResolved;
      if (m >= this._length) {
        var g;
        if (this._isMap)
          g = c(this._values);
        else {
          g = {};
          for (var b = this.length(), y = 0, w = this.length(); y < w; ++y)
            g[this._values[y + b]] = this._values[y];
        }
        return this._resolve(g), !0;
      }
      return !1;
    }, u.prototype.shouldCopyValues = function() {
      return !1;
    }, u.prototype.getActualLength = function(f) {
      return f >> 1;
    };
    function d(f) {
      var p, m = n(f);
      if (o(m))
        m instanceof t ? p = m._then(
          t.props,
          void 0,
          void 0,
          void 0,
          void 0
        ) : p = new u(m).promise();
      else return r(`cannot await properties of a non-object

    See http://goo.gl/MqrFmX
`);
      return m instanceof t && p._propagateFrom(m, 2), p;
    }
    t.prototype.props = function() {
      return d(this);
    }, t.props = function(f) {
      return d(f);
    };
  }), y2;
}
var b2, v8;
function Jde() {
  return v8 || (v8 = 1, b2 = function(t, e, n, r) {
    var i = ln(), o = function(s) {
      return s.then(function(l) {
        return a(l, s);
      });
    };
    function a(s, l) {
      var c = n(s);
      if (c instanceof t)
        return o(c);
      if (s = i.asArray(s), s === null)
        return r("expecting an array or an iterable object but got " + i.classString(s));
      var u = new t(e);
      l !== void 0 && u._propagateFrom(l, 3);
      for (var d = u._fulfill, f = u._reject, p = 0, m = s.length; p < m; ++p) {
        var g = s[p];
        g === void 0 && !(p in s) || t.cast(g)._then(d, f, void 0, u, null);
      }
      return u;
    }
    t.race = function(s) {
      return a(s, void 0);
    }, t.prototype.race = function() {
      return a(this, void 0);
    };
  }), b2;
}
var v2, w8;
function Zde() {
  return w8 || (w8 = 1, v2 = function(t, e, n, r, i, o) {
    var a = t._getDomain, s = ln(), l = s.tryCatch;
    function c(m, g, b, y) {
      this.constructor$(m);
      var w = a();
      this._fn = w === null ? g : s.domainBind(w, g), b !== void 0 && (b = t.resolve(b), b._attachCancellationCallback(this)), this._initialValue = b, this._currentCancellable = null, y === i ? this._eachValues = Array(this._length) : y === 0 ? this._eachValues = null : this._eachValues = void 0, this._promise._captureStackTrace(), this._init$(void 0, -5);
    }
    s.inherits(c, e), c.prototype._gotAccum = function(m) {
      this._eachValues !== void 0 && this._eachValues !== null && m !== i && this._eachValues.push(m);
    }, c.prototype._eachComplete = function(m) {
      return this._eachValues !== null && this._eachValues.push(m), this._eachValues;
    }, c.prototype._init = function() {
    }, c.prototype._resolveEmptyArray = function() {
      this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
    }, c.prototype.shouldCopyValues = function() {
      return !1;
    }, c.prototype._resolve = function(m) {
      this._promise._resolveCallback(m), this._values = null;
    }, c.prototype._resultCancelled = function(m) {
      if (m === this._initialValue) return this._cancel();
      this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof t && this._currentCancellable.cancel(), this._initialValue instanceof t && this._initialValue.cancel());
    }, c.prototype._iterate = function(m) {
      this._values = m;
      var g, b, y = m.length;
      if (this._initialValue !== void 0 ? (g = this._initialValue, b = 0) : (g = t.resolve(m[0]), b = 1), this._currentCancellable = g, !g.isRejected())
        for (; b < y; ++b) {
          var w = {
            accum: null,
            value: m[b],
            index: b,
            length: y,
            array: this
          };
          g = g._then(f, void 0, void 0, w, void 0);
        }
      this._eachValues !== void 0 && (g = g._then(this._eachComplete, void 0, void 0, this, void 0)), g._then(u, u, void 0, g, this);
    }, t.prototype.reduce = function(m, g) {
      return d(this, m, g, null);
    }, t.reduce = function(m, g, b, y) {
      return d(m, g, b, y);
    };
    function u(m, g) {
      this.isFulfilled() ? g._resolve(m) : g._reject(m);
    }
    function d(m, g, b, y) {
      if (typeof g != "function")
        return n("expecting a function but got " + s.classString(g));
      var w = new c(m, g, b, y);
      return w.promise();
    }
    function f(m) {
      this.accum = m, this.array._gotAccum(m);
      var g = r(this.value, this.array._promise);
      return g instanceof t ? (this.array._currentCancellable = g, g._then(p, void 0, void 0, this, void 0)) : p.call(this, g);
    }
    function p(m) {
      var g = this.array, b = g._promise, y = l(g._fn);
      b._pushContext();
      var w;
      g._eachValues !== void 0 ? w = y.call(b._boundValue(), m, this.index, this.length) : w = y.call(
        b._boundValue(),
        this.accum,
        m,
        this.index,
        this.length
      ), w instanceof t && (g._currentCancellable = w);
      var x = b._popContext();
      return o.checkForgottenReturns(
        w,
        x,
        g._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
        b
      ), w;
    }
  }), v2;
}
var w2, x8;
function Qde() {
  return x8 || (x8 = 1, w2 = function(t, e, n) {
    var r = t.PromiseInspection, i = ln();
    function o(a) {
      this.constructor$(a);
    }
    i.inherits(o, e), o.prototype._promiseResolved = function(a, s) {
      this._values[a] = s;
      var l = ++this._totalResolved;
      return l >= this._length ? (this._resolve(this._values), !0) : !1;
    }, o.prototype._promiseFulfilled = function(a, s) {
      var l = new r();
      return l._bitField = 33554432, l._settledValueField = a, this._promiseResolved(s, l);
    }, o.prototype._promiseRejected = function(a, s) {
      var l = new r();
      return l._bitField = 16777216, l._settledValueField = a, this._promiseResolved(s, l);
    }, t.settle = function(a) {
      return n.deprecated(".settle()", ".reflect()"), new o(a).promise();
    }, t.prototype.settle = function() {
      return t.settle(this);
    };
  }), w2;
}
var x2, _8;
function efe() {
  return _8 || (_8 = 1, x2 = function(t, e, n) {
    var r = ln(), i = Rl().RangeError, o = Rl().AggregateError, a = r.isArray, s = {};
    function l(u) {
      this.constructor$(u), this._howMany = 0, this._unwrap = !1, this._initialized = !1;
    }
    r.inherits(l, e), l.prototype._init = function() {
      if (this._initialized) {
        if (this._howMany === 0) {
          this._resolve([]);
          return;
        }
        this._init$(void 0, -5);
        var u = a(this._values);
        !this._isResolved() && u && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()));
      }
    }, l.prototype.init = function() {
      this._initialized = !0, this._init();
    }, l.prototype.setUnwrap = function() {
      this._unwrap = !0;
    }, l.prototype.howMany = function() {
      return this._howMany;
    }, l.prototype.setHowMany = function(u) {
      this._howMany = u;
    }, l.prototype._promiseFulfilled = function(u) {
      return this._addFulfilled(u), this._fulfilled() === this.howMany() ? (this._values.length = this.howMany(), this.howMany() === 1 && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), !0) : !1;
    }, l.prototype._promiseRejected = function(u) {
      return this._addRejected(u), this._checkOutcome();
    }, l.prototype._promiseCancelled = function() {
      return this._values instanceof t || this._values == null ? this._cancel() : (this._addRejected(s), this._checkOutcome());
    }, l.prototype._checkOutcome = function() {
      if (this.howMany() > this._canPossiblyFulfill()) {
        for (var u = new o(), d = this.length(); d < this._values.length; ++d)
          this._values[d] !== s && u.push(this._values[d]);
        return u.length > 0 ? this._reject(u) : this._cancel(), !0;
      }
      return !1;
    }, l.prototype._fulfilled = function() {
      return this._totalResolved;
    }, l.prototype._rejected = function() {
      return this._values.length - this.length();
    }, l.prototype._addRejected = function(u) {
      this._values.push(u);
    }, l.prototype._addFulfilled = function(u) {
      this._values[this._totalResolved++] = u;
    }, l.prototype._canPossiblyFulfill = function() {
      return this.length() - this._rejected();
    }, l.prototype._getRangeError = function(u) {
      var d = "Input array must contain at least " + this._howMany + " items but contains only " + u + " items";
      return new i(d);
    }, l.prototype._resolveEmptyArray = function() {
      this._reject(this._getRangeError(0));
    };
    function c(u, d) {
      if ((d | 0) !== d || d < 0)
        return n(`expecting a positive integer

    See http://goo.gl/MqrFmX
`);
      var f = new l(u), p = f.promise();
      return f.setHowMany(d), f.init(), p;
    }
    t.some = function(u, d) {
      return c(u, d);
    }, t.prototype.some = function(u) {
      return c(this, u);
    }, t._SomePromiseArray = l;
  }), x2;
}
var _2, S8;
function tfe() {
  return S8 || (S8 = 1, _2 = function(t, e) {
    var n = t.map;
    t.prototype.filter = function(r, i) {
      return n(this, r, i, e);
    }, t.filter = function(r, i, o) {
      return n(r, i, o, e);
    };
  }), _2;
}
var S2, T8;
function nfe() {
  return T8 || (T8 = 1, S2 = function(t, e) {
    var n = t.reduce, r = t.all;
    function i() {
      return r(this);
    }
    function o(a, s) {
      return n(a, s, e, e);
    }
    t.prototype.each = function(a) {
      return n(this, a, e, 0)._then(i, void 0, void 0, this, void 0);
    }, t.prototype.mapSeries = function(a) {
      return n(this, a, e, e);
    }, t.each = function(a, s) {
      return n(a, s, e, 0)._then(i, void 0, void 0, a, void 0);
    }, t.mapSeries = o;
  }), S2;
}
var T2, D8;
function rfe() {
  return D8 || (D8 = 1, T2 = function(t) {
    var e = t._SomePromiseArray;
    function n(r) {
      var i = new e(r), o = i.promise();
      return i.setHowMany(1), i.setUnwrap(), i.init(), o;
    }
    t.any = function(r) {
      return n(r);
    }, t.prototype.any = function() {
      return n(this);
    };
  }), T2;
}
(function(t) {
  t.exports = function() {
    var e = function() {
      return new f(`circular promise resolution chain

    See http://goo.gl/MqrFmX
`);
    }, n = function() {
      return new F.PromiseInspection(this._target());
    }, r = function(ee) {
      return F.reject(new f(ee));
    };
    function i() {
    }
    var o = {}, a = ln(), s;
    a.isNode ? s = function() {
      var ee = process.domain;
      return ee === void 0 && (ee = null), ee;
    } : s = function() {
      return null;
    }, a.notEnumerableProp(F, "_getDomain", s);
    var l = nh(), c = Rde(), u = new c();
    l.defineProperty(F, "_async", { value: u });
    var d = Rl(), f = F.TypeError = d.TypeError;
    F.RangeError = d.RangeError;
    var p = F.CancellationError = d.CancellationError;
    F.TimeoutError = d.TimeoutError, F.OperationalError = d.OperationalError, F.RejectionError = d.OperationalError, F.AggregateError = d.AggregateError;
    var m = function() {
    }, g = {}, b = {}, y = Ide()(F, m), w = Ode()(
      F,
      m,
      y,
      r,
      i
    ), x = Fde()(F), k = x.create, A = Ude()(F, x);
    A.CapturedTrace;
    var U = Nde()(F, y), P = Mde()(b), V = eL(), I = a.errorObj, le = a.tryCatch;
    function be(ee, Z) {
      if (typeof Z != "function")
        throw new f("expecting a function but got " + a.classString(Z));
      if (ee.constructor !== F)
        throw new f(`the promise constructor cannot be invoked directly

    See http://goo.gl/MqrFmX
`);
    }
    function F(ee) {
      this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, this._promise0 = void 0, this._receiver0 = void 0, ee !== m && (be(this, ee), this._resolveFromExecutor(ee)), this._promiseCreated(), this._fireEvent("promiseCreated", this);
    }
    F.prototype.toString = function() {
      return "[object Promise]";
    }, F.prototype.caught = F.prototype.catch = function(ee) {
      var Z = arguments.length;
      if (Z > 1) {
        var oe = new Array(Z - 1), te = 0, _e;
        for (_e = 0; _e < Z - 1; ++_e) {
          var q = arguments[_e];
          if (a.isObject(q))
            oe[te++] = q;
          else
            return r("expecting an object but got A catch statement predicate " + a.classString(q));
        }
        return oe.length = te, ee = arguments[_e], this.then(void 0, P(oe, ee, this));
      }
      return this.then(void 0, ee);
    }, F.prototype.reflect = function() {
      return this._then(
        n,
        n,
        void 0,
        this,
        void 0
      );
    }, F.prototype.then = function(ee, Z) {
      if (A.warnings() && arguments.length > 0 && typeof ee != "function" && typeof Z != "function") {
        var oe = ".then() only accepts functions but was passed: " + a.classString(ee);
        arguments.length > 1 && (oe += ", " + a.classString(Z)), this._warn(oe);
      }
      return this._then(ee, Z, void 0, void 0, void 0);
    }, F.prototype.done = function(ee, Z) {
      var oe = this._then(ee, Z, void 0, void 0, void 0);
      oe._setIsFinal();
    }, F.prototype.spread = function(ee) {
      return typeof ee != "function" ? r("expecting a function but got " + a.classString(ee)) : this.all()._then(ee, void 0, void 0, g, void 0);
    }, F.prototype.toJSON = function() {
      var ee = {
        isFulfilled: !1,
        isRejected: !1,
        fulfillmentValue: void 0,
        rejectionReason: void 0
      };
      return this.isFulfilled() ? (ee.fulfillmentValue = this.value(), ee.isFulfilled = !0) : this.isRejected() && (ee.rejectionReason = this.reason(), ee.isRejected = !0), ee;
    }, F.prototype.all = function() {
      return arguments.length > 0 && this._warn(".all() was passed arguments but it does not take any"), new w(this).promise();
    }, F.prototype.error = function(ee) {
      return this.caught(a.originatesFromRejection, ee);
    }, F.getNewLibraryCopy = t.exports, F.is = function(ee) {
      return ee instanceof F;
    }, F.fromNode = F.fromCallback = function(ee) {
      var Z = new F(m);
      Z._captureStackTrace();
      var oe = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : !1, te = le(ee)(V(Z, oe));
      return te === I && Z._rejectCallback(te.e, !0), Z._isFateSealed() || Z._setAsyncGuaranteed(), Z;
    }, F.all = function(ee) {
      return new w(ee).promise();
    }, F.cast = function(ee) {
      var Z = y(ee);
      return Z instanceof F || (Z = new F(m), Z._captureStackTrace(), Z._setFulfilled(), Z._rejectionHandler0 = ee), Z;
    }, F.resolve = F.fulfilled = F.cast, F.reject = F.rejected = function(ee) {
      var Z = new F(m);
      return Z._captureStackTrace(), Z._rejectCallback(ee, !0), Z;
    }, F.setScheduler = function(ee) {
      if (typeof ee != "function")
        throw new f("expecting a function but got " + a.classString(ee));
      return u.setScheduler(ee);
    }, F.prototype._then = function(ee, Z, oe, te, _e) {
      var q = _e !== void 0, N = q ? _e : new F(m), ce = this._target(), me = ce._bitField;
      q || (N._propagateFrom(this, 3), N._captureStackTrace(), te === void 0 && this._bitField & 2097152 && (me & 50397184 ? te = this._boundValue() : te = ce === this ? void 0 : this._boundTo), this._fireEvent("promiseChained", this, N));
      var ve = s();
      if (me & 50397184) {
        var he, H, W = ce._settlePromiseCtx;
        me & 33554432 ? (H = ce._rejectionHandler0, he = ee) : me & 16777216 ? (H = ce._fulfillmentHandler0, he = Z, ce._unsetRejectionIsUnhandled()) : (W = ce._settlePromiseLateCancellationObserver, H = new p("late cancellation observer"), ce._attachExtraTrace(H), he = Z), u.invoke(W, ce, {
          handler: ve === null ? he : typeof he == "function" && a.domainBind(ve, he),
          promise: N,
          receiver: te,
          value: H
        });
      } else
        ce._addCallbacks(ee, Z, N, te, ve);
      return N;
    }, F.prototype._length = function() {
      return this._bitField & 65535;
    }, F.prototype._isFateSealed = function() {
      return (this._bitField & 117506048) !== 0;
    }, F.prototype._isFollowing = function() {
      return (this._bitField & 67108864) === 67108864;
    }, F.prototype._setLength = function(ee) {
      this._bitField = this._bitField & -65536 | ee & 65535;
    }, F.prototype._setFulfilled = function() {
      this._bitField = this._bitField | 33554432, this._fireEvent("promiseFulfilled", this);
    }, F.prototype._setRejected = function() {
      this._bitField = this._bitField | 16777216, this._fireEvent("promiseRejected", this);
    }, F.prototype._setFollowing = function() {
      this._bitField = this._bitField | 67108864, this._fireEvent("promiseResolved", this);
    }, F.prototype._setIsFinal = function() {
      this._bitField = this._bitField | 4194304;
    }, F.prototype._isFinal = function() {
      return (this._bitField & 4194304) > 0;
    }, F.prototype._unsetCancelled = function() {
      this._bitField = this._bitField & -65537;
    }, F.prototype._setCancelled = function() {
      this._bitField = this._bitField | 65536, this._fireEvent("promiseCancelled", this);
    }, F.prototype._setWillBeCancelled = function() {
      this._bitField = this._bitField | 8388608;
    }, F.prototype._setAsyncGuaranteed = function() {
      u.hasCustomScheduler() || (this._bitField = this._bitField | 134217728);
    }, F.prototype._receiverAt = function(ee) {
      var Z = ee === 0 ? this._receiver0 : this[ee * 4 - 4 + 3];
      if (Z !== o)
        return Z === void 0 && this._isBound() ? this._boundValue() : Z;
    }, F.prototype._promiseAt = function(ee) {
      return this[ee * 4 - 4 + 2];
    }, F.prototype._fulfillmentHandlerAt = function(ee) {
      return this[ee * 4 - 4 + 0];
    }, F.prototype._rejectionHandlerAt = function(ee) {
      return this[ee * 4 - 4 + 1];
    }, F.prototype._boundValue = function() {
    }, F.prototype._migrateCallback0 = function(ee) {
      ee._bitField;
      var Z = ee._fulfillmentHandler0, oe = ee._rejectionHandler0, te = ee._promise0, _e = ee._receiverAt(0);
      _e === void 0 && (_e = o), this._addCallbacks(Z, oe, te, _e, null);
    }, F.prototype._migrateCallbackAt = function(ee, Z) {
      var oe = ee._fulfillmentHandlerAt(Z), te = ee._rejectionHandlerAt(Z), _e = ee._promiseAt(Z), q = ee._receiverAt(Z);
      q === void 0 && (q = o), this._addCallbacks(oe, te, _e, q, null);
    }, F.prototype._addCallbacks = function(ee, Z, oe, te, _e) {
      var q = this._length();
      if (q >= 65531 && (q = 0, this._setLength(0)), q === 0)
        this._promise0 = oe, this._receiver0 = te, typeof ee == "function" && (this._fulfillmentHandler0 = _e === null ? ee : a.domainBind(_e, ee)), typeof Z == "function" && (this._rejectionHandler0 = _e === null ? Z : a.domainBind(_e, Z));
      else {
        var N = q * 4 - 4;
        this[N + 2] = oe, this[N + 3] = te, typeof ee == "function" && (this[N + 0] = _e === null ? ee : a.domainBind(_e, ee)), typeof Z == "function" && (this[N + 1] = _e === null ? Z : a.domainBind(_e, Z));
      }
      return this._setLength(q + 1), q;
    }, F.prototype._proxy = function(ee, Z) {
      this._addCallbacks(void 0, void 0, Z, ee, null);
    }, F.prototype._resolveCallback = function(ee, Z) {
      if (!(this._bitField & 117506048)) {
        if (ee === this)
          return this._rejectCallback(e(), !1);
        var oe = y(ee, this);
        if (!(oe instanceof F)) return this._fulfill(ee);
        Z && this._propagateFrom(oe, 2);
        var te = oe._target();
        if (te === this) {
          this._reject(e());
          return;
        }
        var _e = te._bitField;
        if (_e & 50397184)
          if (_e & 33554432)
            this._fulfill(te._value());
          else if (_e & 16777216)
            this._reject(te._reason());
          else {
            var ce = new p("late cancellation observer");
            te._attachExtraTrace(ce), this._reject(ce);
          }
        else {
          var q = this._length();
          q > 0 && te._migrateCallback0(this);
          for (var N = 1; N < q; ++N)
            te._migrateCallbackAt(this, N);
          this._setFollowing(), this._setLength(0), this._setFollowee(te);
        }
      }
    }, F.prototype._rejectCallback = function(ee, Z, oe) {
      var te = a.ensureErrorObject(ee), _e = te === ee;
      if (!_e && !oe && A.warnings()) {
        var q = "a promise was rejected with a non-error: " + a.classString(ee);
        this._warn(q, !0);
      }
      this._attachExtraTrace(te, Z ? _e : !1), this._reject(ee);
    }, F.prototype._resolveFromExecutor = function(ee) {
      var Z = this;
      this._captureStackTrace(), this._pushContext();
      var oe = !0, te = this._execute(ee, function(_e) {
        Z._resolveCallback(_e);
      }, function(_e) {
        Z._rejectCallback(_e, oe);
      });
      oe = !1, this._popContext(), te !== void 0 && Z._rejectCallback(te, !0);
    }, F.prototype._settlePromiseFromHandler = function(ee, Z, oe, te) {
      var _e = te._bitField;
      if (!(_e & 65536)) {
        te._pushContext();
        var q;
        Z === g ? !oe || typeof oe.length != "number" ? (q = I, q.e = new f("cannot .spread() a non-array: " + a.classString(oe))) : q = le(ee).apply(this._boundValue(), oe) : q = le(ee).call(Z, oe);
        var N = te._popContext();
        _e = te._bitField, !(_e & 65536) && (q === b ? te._reject(oe) : q === I ? te._rejectCallback(q.e, !1) : (A.checkForgottenReturns(q, N, "", te, this), te._resolveCallback(q)));
      }
    }, F.prototype._target = function() {
      for (var ee = this; ee._isFollowing(); ) ee = ee._followee();
      return ee;
    }, F.prototype._followee = function() {
      return this._rejectionHandler0;
    }, F.prototype._setFollowee = function(ee) {
      this._rejectionHandler0 = ee;
    }, F.prototype._settlePromise = function(ee, Z, oe, te) {
      var _e = ee instanceof F, q = this._bitField, N = (q & 134217728) !== 0;
      q & 65536 ? (_e && ee._invokeInternalOnCancel(), oe instanceof U && oe.isFinallyHandler() ? (oe.cancelPromise = ee, le(Z).call(oe, te) === I && ee._reject(I.e)) : Z === n ? ee._fulfill(n.call(oe)) : oe instanceof i ? oe._promiseCancelled(ee) : _e || ee instanceof w ? ee._cancel() : oe.cancel()) : typeof Z == "function" ? _e ? (N && ee._setAsyncGuaranteed(), this._settlePromiseFromHandler(Z, oe, te, ee)) : Z.call(oe, te, ee) : oe instanceof i ? oe._isResolved() || (q & 33554432 ? oe._promiseFulfilled(te, ee) : oe._promiseRejected(te, ee)) : _e && (N && ee._setAsyncGuaranteed(), q & 33554432 ? ee._fulfill(te) : ee._reject(te));
    }, F.prototype._settlePromiseLateCancellationObserver = function(ee) {
      var Z = ee.handler, oe = ee.promise, te = ee.receiver, _e = ee.value;
      typeof Z == "function" ? oe instanceof F ? this._settlePromiseFromHandler(Z, te, _e, oe) : Z.call(te, _e, oe) : oe instanceof F && oe._reject(_e);
    }, F.prototype._settlePromiseCtx = function(ee) {
      this._settlePromise(ee.promise, ee.handler, ee.receiver, ee.value);
    }, F.prototype._settlePromise0 = function(ee, Z, oe) {
      var te = this._promise0, _e = this._receiverAt(0);
      this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(te, ee, _e, Z);
    }, F.prototype._clearCallbackDataAtIndex = function(ee) {
      var Z = ee * 4 - 4;
      this[Z + 2] = this[Z + 3] = this[Z + 0] = this[Z + 1] = void 0;
    }, F.prototype._fulfill = function(ee) {
      var Z = this._bitField;
      if (!((Z & 117506048) >>> 16)) {
        if (ee === this) {
          var oe = e();
          return this._attachExtraTrace(oe), this._reject(oe);
        }
        this._setFulfilled(), this._rejectionHandler0 = ee, (Z & 65535) > 0 && (Z & 134217728 ? this._settlePromises() : u.settlePromises(this));
      }
    }, F.prototype._reject = function(ee) {
      var Z = this._bitField;
      if (!((Z & 117506048) >>> 16)) {
        if (this._setRejected(), this._fulfillmentHandler0 = ee, this._isFinal())
          return u.fatalError(ee, a.isNode);
        (Z & 65535) > 0 ? u.settlePromises(this) : this._ensurePossibleRejectionHandled();
      }
    }, F.prototype._fulfillPromises = function(ee, Z) {
      for (var oe = 1; oe < ee; oe++) {
        var te = this._fulfillmentHandlerAt(oe), _e = this._promiseAt(oe), q = this._receiverAt(oe);
        this._clearCallbackDataAtIndex(oe), this._settlePromise(_e, te, q, Z);
      }
    }, F.prototype._rejectPromises = function(ee, Z) {
      for (var oe = 1; oe < ee; oe++) {
        var te = this._rejectionHandlerAt(oe), _e = this._promiseAt(oe), q = this._receiverAt(oe);
        this._clearCallbackDataAtIndex(oe), this._settlePromise(_e, te, q, Z);
      }
    }, F.prototype._settlePromises = function() {
      var ee = this._bitField, Z = ee & 65535;
      if (Z > 0) {
        if (ee & 16842752) {
          var oe = this._fulfillmentHandler0;
          this._settlePromise0(this._rejectionHandler0, oe, ee), this._rejectPromises(Z, oe);
        } else {
          var te = this._rejectionHandler0;
          this._settlePromise0(this._fulfillmentHandler0, te, ee), this._fulfillPromises(Z, te);
        }
        this._setLength(0);
      }
      this._clearCancellationData();
    }, F.prototype._settledValue = function() {
      var ee = this._bitField;
      if (ee & 33554432)
        return this._rejectionHandler0;
      if (ee & 16777216)
        return this._fulfillmentHandler0;
    };
    function G(ee) {
      this.promise._resolveCallback(ee);
    }
    function C(ee) {
      this.promise._rejectCallback(ee, !1);
    }
    F.defer = F.pending = function() {
      A.deprecated("Promise.defer", "new Promise");
      var ee = new F(m);
      return {
        promise: ee,
        resolve: G,
        reject: C
      };
    }, a.notEnumerableProp(
      F,
      "_makeSelfResolutionError",
      e
    ), Bde()(
      F,
      m,
      y,
      r,
      A
    ), Lde()(F, m, y, A), Pde()(F, w, r, A), Wde()(F), zde()(F), $de()(
      F,
      w,
      y,
      m,
      u,
      s
    ), F.Promise = F, F.version = "3.4.7", Hde()(F, w, r, y, m, A), jde()(F), Vde()(F, r, y, k, m, A), qde()(F, m, A), Gde()(F, r, m, y, i, A), Kde()(F), Xde()(F, m), Yde()(F, w, y, r), Jde()(F, m, y, r), Zde()(F, w, r, y, m, A), Qde()(F, w, A), efe()(F, w, r), tfe()(F, m), nfe()(F, m), rfe()(F), a.toFastProperties(F), a.toFastProperties(F.prototype);
    function ie(ee) {
      var Z = new F(m);
      Z._fulfillmentHandler0 = ee, Z._rejectionHandler0 = ee, Z._promise0 = ee, Z._receiver0 = ee;
    }
    return ie({ a: 1 }), ie({ b: 2 }), ie({ c: 3 }), ie(1), ie(function() {
    }), ie(void 0), ie(!1), ie(new F(m)), A.setBounds(c.firstLineError, a.lastLineError), F;
  };
})(QB);
var ife = QB.exports, ofe = Rn, ui = ife();
Zn.defer = afe;
Zn.when = ui.resolve;
Zn.resolve = ui.resolve;
Zn.all = ui.all;
Zn.props = ui.props;
Zn.reject = ui.reject;
Zn.promisify = ui.promisify;
Zn.mapSeries = ui.mapSeries;
Zn.attempt = ui.attempt;
Zn.nfcall = function(t) {
  var e = Array.prototype.slice.call(arguments, 1), n = ui.promisify(t);
  return n.apply(null, e);
};
ui.prototype.fail = ui.prototype.caught;
ui.prototype.also = function(t) {
  return this.then(function(e) {
    var n = ofe.extend({}, e, t(e));
    return ui.props(n);
  });
};
function afe() {
  var t, e, n = new ui.Promise(function(r, i) {
    t = r, e = i;
  });
  return {
    resolve: t,
    reject: e,
    promise: n
  };
}
var At = {}, sfe = Rn, dr = At.types = {
  document: "document",
  paragraph: "paragraph",
  run: "run",
  text: "text",
  tab: "tab",
  checkbox: "checkbox",
  hyperlink: "hyperlink",
  noteReference: "noteReference",
  image: "image",
  note: "note",
  commentReference: "commentReference",
  comment: "comment",
  table: "table",
  tableRow: "tableRow",
  tableCell: "tableCell",
  break: "break",
  bookmarkStart: "bookmarkStart"
};
function lfe(t, e) {
  return e = e || {}, {
    type: dr.document,
    children: t,
    notes: e.notes || new q1({}),
    comments: e.comments || []
  };
}
function cfe(t, e) {
  e = e || {};
  var n = e.indent || {};
  return {
    type: dr.paragraph,
    children: t,
    styleId: e.styleId || null,
    styleName: e.styleName || null,
    numbering: e.numbering || null,
    alignment: e.alignment || null,
    indent: {
      start: n.start || null,
      end: n.end || null,
      firstLine: n.firstLine || null,
      hanging: n.hanging || null
    }
  };
}
function ufe(t, e) {
  return e = e || {}, {
    type: dr.run,
    children: t,
    styleId: e.styleId || null,
    styleName: e.styleName || null,
    isBold: !!e.isBold,
    isUnderline: !!e.isUnderline,
    isItalic: !!e.isItalic,
    isStrikethrough: !!e.isStrikethrough,
    isAllCaps: !!e.isAllCaps,
    isSmallCaps: !!e.isSmallCaps,
    verticalAlignment: e.verticalAlignment || tL.baseline,
    font: e.font || null,
    fontSize: e.fontSize || null,
    highlight: e.highlight || null
  };
}
var tL = {
  baseline: "baseline",
  superscript: "superscript",
  subscript: "subscript"
};
function dfe(t) {
  return {
    type: dr.text,
    value: t
  };
}
function ffe() {
  return {
    type: dr.tab
  };
}
function hfe(t) {
  return {
    type: dr.checkbox,
    checked: t.checked
  };
}
function pfe(t, e) {
  return {
    type: dr.hyperlink,
    children: t,
    href: e.href,
    anchor: e.anchor,
    targetFrame: e.targetFrame
  };
}
function mfe(t) {
  return {
    type: dr.noteReference,
    noteType: t.noteType,
    noteId: t.noteId
  };
}
function q1(t) {
  this._notes = sfe.indexBy(t, function(e) {
    return nL(e.noteType, e.noteId);
  });
}
q1.prototype.resolve = function(t) {
  return this.findNoteByKey(nL(t.noteType, t.noteId));
};
q1.prototype.findNoteByKey = function(t) {
  return this._notes[t] || null;
};
function gfe(t) {
  return {
    type: dr.note,
    noteType: t.noteType,
    noteId: t.noteId,
    body: t.body
  };
}
function yfe(t) {
  return {
    type: dr.commentReference,
    commentId: t.commentId
  };
}
function bfe(t) {
  return {
    type: dr.comment,
    commentId: t.commentId,
    body: t.body,
    authorName: t.authorName,
    authorInitials: t.authorInitials
  };
}
function nL(t, e) {
  return t + "-" + e;
}
function vfe(t) {
  return {
    type: dr.image,
    // `read` is retained for backwards compatibility, but other read
    // methods should be preferred.
    read: function(e) {
      return e ? t.readImage(e) : t.readImage().then(function(n) {
        return Buffer.from(n);
      });
    },
    readAsArrayBuffer: function() {
      return t.readImage();
    },
    readAsBase64String: function() {
      return t.readImage("base64");
    },
    readAsBuffer: function() {
      return t.readImage().then(function(e) {
        return Buffer.from(e);
      });
    },
    altText: t.altText,
    contentType: t.contentType
  };
}
function wfe(t, e) {
  return e = e || {}, {
    type: dr.table,
    children: t,
    styleId: e.styleId || null,
    styleName: e.styleName || null
  };
}
function xfe(t, e) {
  return e = e || {}, {
    type: dr.tableRow,
    children: t,
    isHeader: e.isHeader || !1
  };
}
function _fe(t, e) {
  return e = e || {}, {
    type: dr.tableCell,
    children: t,
    colSpan: e.colSpan == null ? 1 : e.colSpan,
    rowSpan: e.rowSpan == null ? 1 : e.rowSpan
  };
}
function sC(t) {
  return {
    type: dr.break,
    breakType: t
  };
}
function Sfe(t) {
  return {
    type: dr.bookmarkStart,
    name: t.name
  };
}
At.document = At.Document = lfe;
At.paragraph = At.Paragraph = cfe;
At.run = At.Run = ufe;
At.text = At.Text = dfe;
At.tab = At.Tab = ffe;
At.checkbox = At.Checkbox = hfe;
At.Hyperlink = pfe;
At.noteReference = At.NoteReference = mfe;
At.Notes = q1;
At.Note = gfe;
At.commentReference = yfe;
At.comment = bfe;
At.Image = vfe;
At.Table = wfe;
At.TableRow = xfe;
At.TableCell = _fe;
At.lineBreak = sC("line");
At.pageBreak = sC("page");
At.columnBreak = sC("column");
At.BookmarkStart = Sfe;
At.verticalAlignment = tL;
var Ri = {}, Em = Rn;
Ri.Result = ma;
Ri.success = Tfe;
Ri.warning = Dfe;
Ri.error = Efe;
function ma(t, e) {
  this.value = t, this.messages = e || [];
}
ma.prototype.map = function(t) {
  return new ma(t(this.value), this.messages);
};
ma.prototype.flatMap = function(t) {
  var e = t(this.value);
  return new ma(e.value, lC([this, e]));
};
ma.prototype.flatMapThen = function(t) {
  var e = this;
  return t(this.value).then(function(n) {
    return new ma(n.value, lC([e, n]));
  });
};
ma.combine = function(t) {
  var e = Em.flatten(Em.pluck(t, "value")), n = lC(t);
  return new ma(e, n);
};
function Tfe(t) {
  return new ma(t, []);
}
function Dfe(t) {
  return {
    type: "warning",
    message: t
  };
}
function Efe(t) {
  return {
    type: "error",
    message: t.message,
    error: t
  };
}
function lC(t) {
  var e = [];
  return Em.flatten(Em.pluck(t, "messages"), !0).forEach(function(n) {
    Cfe(e, n) || e.push(n);
  }), e;
}
function Cfe(t, e) {
  return Em.find(t, kfe.bind(null, e)) !== void 0;
}
function kfe(t, e) {
  return t.type === e.type && t.message === e.message;
}
var Xm = {}, G1 = {};
G1.byteLength = Ife;
G1.toByteArray = Ffe;
G1.fromByteArray = Mfe;
var ra = [], Ki = [], Afe = typeof Uint8Array < "u" ? Uint8Array : Array, D2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Id = 0, Rfe = D2.length; Id < Rfe; ++Id)
  ra[Id] = D2[Id], Ki[D2.charCodeAt(Id)] = Id;
Ki[45] = 62;
Ki[95] = 63;
function rL(t) {
  var e = t.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = t.indexOf("=");
  n === -1 && (n = e);
  var r = n === e ? 0 : 4 - n % 4;
  return [n, r];
}
function Ife(t) {
  var e = rL(t), n = e[0], r = e[1];
  return (n + r) * 3 / 4 - r;
}
function Ofe(t, e, n) {
  return (e + n) * 3 / 4 - n;
}
function Ffe(t) {
  var e, n = rL(t), r = n[0], i = n[1], o = new Afe(Ofe(t, r, i)), a = 0, s = i > 0 ? r - 4 : r, l;
  for (l = 0; l < s; l += 4)
    e = Ki[t.charCodeAt(l)] << 18 | Ki[t.charCodeAt(l + 1)] << 12 | Ki[t.charCodeAt(l + 2)] << 6 | Ki[t.charCodeAt(l + 3)], o[a++] = e >> 16 & 255, o[a++] = e >> 8 & 255, o[a++] = e & 255;
  return i === 2 && (e = Ki[t.charCodeAt(l)] << 2 | Ki[t.charCodeAt(l + 1)] >> 4, o[a++] = e & 255), i === 1 && (e = Ki[t.charCodeAt(l)] << 10 | Ki[t.charCodeAt(l + 1)] << 4 | Ki[t.charCodeAt(l + 2)] >> 2, o[a++] = e >> 8 & 255, o[a++] = e & 255), o;
}
function Ufe(t) {
  return ra[t >> 18 & 63] + ra[t >> 12 & 63] + ra[t >> 6 & 63] + ra[t & 63];
}
function Nfe(t, e, n) {
  for (var r, i = [], o = e; o < n; o += 3)
    r = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (t[o + 2] & 255), i.push(Ufe(r));
  return i.join("");
}
function Mfe(t) {
  for (var e, n = t.length, r = n % 3, i = [], o = 16383, a = 0, s = n - r; a < s; a += o)
    i.push(Nfe(t, a, a + o > s ? s : a + o));
  return r === 1 ? (e = t[n - 1], i.push(
    ra[e >> 2] + ra[e << 4 & 63] + "=="
  )) : r === 2 && (e = (t[n - 2] << 8) + t[n - 1], i.push(
    ra[e >> 10] + ra[e >> 4 & 63] + ra[e << 2 & 63] + "="
  )), i.join("");
}
function by(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var iL = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(t, e) {
  (function(n) {
    t.exports = n();
  })(function() {
    return function n(r, i, o) {
      function a(c, u) {
        if (!i[c]) {
          if (!r[c]) {
            var d = typeof by == "function" && by;
            if (!u && d) return d(c, !0);
            if (s) return s(c, !0);
            var f = new Error("Cannot find module '" + c + "'");
            throw f.code = "MODULE_NOT_FOUND", f;
          }
          var p = i[c] = { exports: {} };
          r[c][0].call(p.exports, function(m) {
            var g = r[c][1][m];
            return a(g || m);
          }, p, p.exports, n, r, i, o);
        }
        return i[c].exports;
      }
      for (var s = typeof by == "function" && by, l = 0; l < o.length; l++) a(o[l]);
      return a;
    }({ 1: [function(n, r, i) {
      var o = n("./utils"), a = n("./support"), s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      i.encode = function(l) {
        for (var c, u, d, f, p, m, g, b = [], y = 0, w = l.length, x = w, k = o.getTypeOf(l) !== "string"; y < l.length; ) x = w - y, d = k ? (c = l[y++], u = y < w ? l[y++] : 0, y < w ? l[y++] : 0) : (c = l.charCodeAt(y++), u = y < w ? l.charCodeAt(y++) : 0, y < w ? l.charCodeAt(y++) : 0), f = c >> 2, p = (3 & c) << 4 | u >> 4, m = 1 < x ? (15 & u) << 2 | d >> 6 : 64, g = 2 < x ? 63 & d : 64, b.push(s.charAt(f) + s.charAt(p) + s.charAt(m) + s.charAt(g));
        return b.join("");
      }, i.decode = function(l) {
        var c, u, d, f, p, m, g = 0, b = 0, y = "data:";
        if (l.substr(0, y.length) === y) throw new Error("Invalid base64 input, it looks like a data url.");
        var w, x = 3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (l.charAt(l.length - 1) === s.charAt(64) && x--, l.charAt(l.length - 2) === s.charAt(64) && x--, x % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (w = a.uint8array ? new Uint8Array(0 | x) : new Array(0 | x); g < l.length; ) c = s.indexOf(l.charAt(g++)) << 2 | (f = s.indexOf(l.charAt(g++))) >> 4, u = (15 & f) << 4 | (p = s.indexOf(l.charAt(g++))) >> 2, d = (3 & p) << 6 | (m = s.indexOf(l.charAt(g++))), w[b++] = c, p !== 64 && (w[b++] = u), m !== 64 && (w[b++] = d);
        return w;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(n, r, i) {
      var o = n("./external"), a = n("./stream/DataWorker"), s = n("./stream/Crc32Probe"), l = n("./stream/DataLengthProbe");
      function c(u, d, f, p, m) {
        this.compressedSize = u, this.uncompressedSize = d, this.crc32 = f, this.compression = p, this.compressedContent = m;
      }
      c.prototype = { getContentWorker: function() {
        var u = new a(o.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), d = this;
        return u.on("end", function() {
          if (this.streamInfo.data_length !== d.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), u;
      }, getCompressedWorker: function() {
        return new a(o.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, c.createWorkerFrom = function(u, d, f) {
        return u.pipe(new s()).pipe(new l("uncompressedSize")).pipe(d.compressWorker(f)).pipe(new l("compressedSize")).withStreamInfo("compression", d);
      }, r.exports = c;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(n, r, i) {
      var o = n("./stream/GenericWorker");
      i.STORE = { magic: "\0\0", compressWorker: function() {
        return new o("STORE compression");
      }, uncompressWorker: function() {
        return new o("STORE decompression");
      } }, i.DEFLATE = n("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(n, r, i) {
      var o = n("./utils"), a = function() {
        for (var s, l = [], c = 0; c < 256; c++) {
          s = c;
          for (var u = 0; u < 8; u++) s = 1 & s ? 3988292384 ^ s >>> 1 : s >>> 1;
          l[c] = s;
        }
        return l;
      }();
      r.exports = function(s, l) {
        return s !== void 0 && s.length ? o.getTypeOf(s) !== "string" ? function(c, u, d, f) {
          var p = a, m = f + d;
          c ^= -1;
          for (var g = f; g < m; g++) c = c >>> 8 ^ p[255 & (c ^ u[g])];
          return -1 ^ c;
        }(0 | l, s, s.length, 0) : function(c, u, d, f) {
          var p = a, m = f + d;
          c ^= -1;
          for (var g = f; g < m; g++) c = c >>> 8 ^ p[255 & (c ^ u.charCodeAt(g))];
          return -1 ^ c;
        }(0 | l, s, s.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(n, r, i) {
      i.base64 = !1, i.binary = !1, i.dir = !1, i.createFolders = !0, i.date = null, i.compression = null, i.compressionOptions = null, i.comment = null, i.unixPermissions = null, i.dosPermissions = null;
    }, {}], 6: [function(n, r, i) {
      var o = null;
      o = typeof Promise < "u" ? Promise : n("lie"), r.exports = { Promise: o };
    }, { lie: 37 }], 7: [function(n, r, i) {
      var o = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", a = n("pako"), s = n("./utils"), l = n("./stream/GenericWorker"), c = o ? "uint8array" : "array";
      function u(d, f) {
        l.call(this, "FlateWorker/" + d), this._pako = null, this._pakoAction = d, this._pakoOptions = f, this.meta = {};
      }
      i.magic = "\b\0", s.inherits(u, l), u.prototype.processChunk = function(d) {
        this.meta = d.meta, this._pako === null && this._createPako(), this._pako.push(s.transformTo(c, d.data), !1);
      }, u.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, u.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, u.prototype._createPako = function() {
        this._pako = new a[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var d = this;
        this._pako.onData = function(f) {
          d.push({ data: f, meta: d.meta });
        };
      }, i.compressWorker = function(d) {
        return new u("Deflate", d);
      }, i.uncompressWorker = function() {
        return new u("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(n, r, i) {
      function o(p, m) {
        var g, b = "";
        for (g = 0; g < m; g++) b += String.fromCharCode(255 & p), p >>>= 8;
        return b;
      }
      function a(p, m, g, b, y, w) {
        var x, k, A = p.file, U = p.compression, P = w !== c.utf8encode, V = s.transformTo("string", w(A.name)), I = s.transformTo("string", c.utf8encode(A.name)), le = A.comment, be = s.transformTo("string", w(le)), F = s.transformTo("string", c.utf8encode(le)), G = I.length !== A.name.length, C = F.length !== le.length, ie = "", ee = "", Z = "", oe = A.dir, te = A.date, _e = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        m && !g || (_e.crc32 = p.crc32, _e.compressedSize = p.compressedSize, _e.uncompressedSize = p.uncompressedSize);
        var q = 0;
        m && (q |= 8), P || !G && !C || (q |= 2048);
        var N = 0, ce = 0;
        oe && (N |= 16), y === "UNIX" ? (ce = 798, N |= function(ve, he) {
          var H = ve;
          return ve || (H = he ? 16893 : 33204), (65535 & H) << 16;
        }(A.unixPermissions, oe)) : (ce = 20, N |= function(ve) {
          return 63 & (ve || 0);
        }(A.dosPermissions)), x = te.getUTCHours(), x <<= 6, x |= te.getUTCMinutes(), x <<= 5, x |= te.getUTCSeconds() / 2, k = te.getUTCFullYear() - 1980, k <<= 4, k |= te.getUTCMonth() + 1, k <<= 5, k |= te.getUTCDate(), G && (ee = o(1, 1) + o(u(V), 4) + I, ie += "up" + o(ee.length, 2) + ee), C && (Z = o(1, 1) + o(u(be), 4) + F, ie += "uc" + o(Z.length, 2) + Z);
        var me = "";
        return me += `
\0`, me += o(q, 2), me += U.magic, me += o(x, 2), me += o(k, 2), me += o(_e.crc32, 4), me += o(_e.compressedSize, 4), me += o(_e.uncompressedSize, 4), me += o(V.length, 2), me += o(ie.length, 2), { fileRecord: d.LOCAL_FILE_HEADER + me + V + ie, dirRecord: d.CENTRAL_FILE_HEADER + o(ce, 2) + me + o(be.length, 2) + "\0\0\0\0" + o(N, 4) + o(b, 4) + V + ie + be };
      }
      var s = n("../utils"), l = n("../stream/GenericWorker"), c = n("../utf8"), u = n("../crc32"), d = n("../signature");
      function f(p, m, g, b) {
        l.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = m, this.zipPlatform = g, this.encodeFileName = b, this.streamFiles = p, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      s.inherits(f, l), f.prototype.push = function(p) {
        var m = p.meta.percent || 0, g = this.entriesCount, b = this._sources.length;
        this.accumulate ? this.contentBuffer.push(p) : (this.bytesWritten += p.data.length, l.prototype.push.call(this, { data: p.data, meta: { currentFile: this.currentFile, percent: g ? (m + 100 * (g - b - 1)) / g : 100 } }));
      }, f.prototype.openedSource = function(p) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = p.file.name;
        var m = this.streamFiles && !p.file.dir;
        if (m) {
          var g = a(p, m, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: g.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, f.prototype.closedSource = function(p) {
        this.accumulate = !1;
        var m = this.streamFiles && !p.file.dir, g = a(p, m, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(g.dirRecord), m) this.push({ data: function(b) {
          return d.DATA_DESCRIPTOR + o(b.crc32, 4) + o(b.compressedSize, 4) + o(b.uncompressedSize, 4);
        }(p), meta: { percent: 100 } });
        else for (this.push({ data: g.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, f.prototype.flush = function() {
        for (var p = this.bytesWritten, m = 0; m < this.dirRecords.length; m++) this.push({ data: this.dirRecords[m], meta: { percent: 100 } });
        var g = this.bytesWritten - p, b = function(y, w, x, k, A) {
          var U = s.transformTo("string", A(k));
          return d.CENTRAL_DIRECTORY_END + "\0\0\0\0" + o(y, 2) + o(y, 2) + o(w, 4) + o(x, 4) + o(U.length, 2) + U;
        }(this.dirRecords.length, g, p, this.zipComment, this.encodeFileName);
        this.push({ data: b, meta: { percent: 100 } });
      }, f.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, f.prototype.registerPrevious = function(p) {
        this._sources.push(p);
        var m = this;
        return p.on("data", function(g) {
          m.processChunk(g);
        }), p.on("end", function() {
          m.closedSource(m.previous.streamInfo), m._sources.length ? m.prepareNextSource() : m.end();
        }), p.on("error", function(g) {
          m.error(g);
        }), this;
      }, f.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, f.prototype.error = function(p) {
        var m = this._sources;
        if (!l.prototype.error.call(this, p)) return !1;
        for (var g = 0; g < m.length; g++) try {
          m[g].error(p);
        } catch {
        }
        return !0;
      }, f.prototype.lock = function() {
        l.prototype.lock.call(this);
        for (var p = this._sources, m = 0; m < p.length; m++) p[m].lock();
      }, r.exports = f;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(n, r, i) {
      var o = n("../compressions"), a = n("./ZipFileWorker");
      i.generateWorker = function(s, l, c) {
        var u = new a(l.streamFiles, c, l.platform, l.encodeFileName), d = 0;
        try {
          s.forEach(function(f, p) {
            d++;
            var m = function(w, x) {
              var k = w || x, A = o[k];
              if (!A) throw new Error(k + " is not a valid compression method !");
              return A;
            }(p.options.compression, l.compression), g = p.options.compressionOptions || l.compressionOptions || {}, b = p.dir, y = p.date;
            p._compressWorker(m, g).withStreamInfo("file", { name: f, dir: b, date: y, comment: p.comment || "", unixPermissions: p.unixPermissions, dosPermissions: p.dosPermissions }).pipe(u);
          }), u.entriesCount = d;
        } catch (f) {
          u.error(f);
        }
        return u;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(n, r, i) {
      function o() {
        if (!(this instanceof o)) return new o();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var a = new o();
          for (var s in this) typeof this[s] != "function" && (a[s] = this[s]);
          return a;
        };
      }
      (o.prototype = n("./object")).loadAsync = n("./load"), o.support = n("./support"), o.defaults = n("./defaults"), o.version = "3.10.1", o.loadAsync = function(a, s) {
        return new o().loadAsync(a, s);
      }, o.external = n("./external"), r.exports = o;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(n, r, i) {
      var o = n("./utils"), a = n("./external"), s = n("./utf8"), l = n("./zipEntries"), c = n("./stream/Crc32Probe"), u = n("./nodejsUtils");
      function d(f) {
        return new a.Promise(function(p, m) {
          var g = f.decompressed.getContentWorker().pipe(new c());
          g.on("error", function(b) {
            m(b);
          }).on("end", function() {
            g.streamInfo.crc32 !== f.decompressed.crc32 ? m(new Error("Corrupted zip : CRC32 mismatch")) : p();
          }).resume();
        });
      }
      r.exports = function(f, p) {
        var m = this;
        return p = o.extend(p || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: s.utf8decode }), u.isNode && u.isStream(f) ? a.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : o.prepareContent("the loaded zip file", f, !0, p.optimizedBinaryString, p.base64).then(function(g) {
          var b = new l(p);
          return b.load(g), b;
        }).then(function(g) {
          var b = [a.Promise.resolve(g)], y = g.files;
          if (p.checkCRC32) for (var w = 0; w < y.length; w++) b.push(d(y[w]));
          return a.Promise.all(b);
        }).then(function(g) {
          for (var b = g.shift(), y = b.files, w = 0; w < y.length; w++) {
            var x = y[w], k = x.fileNameStr, A = o.resolve(x.fileNameStr);
            m.file(A, x.decompressed, { binary: !0, optimizedBinaryString: !0, date: x.date, dir: x.dir, comment: x.fileCommentStr.length ? x.fileCommentStr : null, unixPermissions: x.unixPermissions, dosPermissions: x.dosPermissions, createFolders: p.createFolders }), x.dir || (m.file(A).unsafeOriginalName = k);
          }
          return b.zipComment.length && (m.comment = b.zipComment), m;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(n, r, i) {
      var o = n("../utils"), a = n("../stream/GenericWorker");
      function s(l, c) {
        a.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(c);
      }
      o.inherits(s, a), s.prototype._bindStream = function(l) {
        var c = this;
        (this._stream = l).pause(), l.on("data", function(u) {
          c.push({ data: u, meta: { percent: 0 } });
        }).on("error", function(u) {
          c.isPaused ? this.generatedError = u : c.error(u);
        }).on("end", function() {
          c.isPaused ? c._upstreamEnded = !0 : c.end();
        });
      }, s.prototype.pause = function() {
        return !!a.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, s.prototype.resume = function() {
        return !!a.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, r.exports = s;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(n, r, i) {
      var o = n("readable-stream").Readable;
      function a(s, l, c) {
        o.call(this, l), this._helper = s;
        var u = this;
        s.on("data", function(d, f) {
          u.push(d) || u._helper.pause(), c && c(f);
        }).on("error", function(d) {
          u.emit("error", d);
        }).on("end", function() {
          u.push(null);
        });
      }
      n("../utils").inherits(a, o), a.prototype._read = function() {
        this._helper.resume();
      }, r.exports = a;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(n, r, i) {
      r.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(o, a) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(o, a);
        if (typeof o == "number") throw new Error('The "data" argument must not be a number');
        return new Buffer(o, a);
      }, allocBuffer: function(o) {
        if (Buffer.alloc) return Buffer.alloc(o);
        var a = new Buffer(o);
        return a.fill(0), a;
      }, isBuffer: function(o) {
        return Buffer.isBuffer(o);
      }, isStream: function(o) {
        return o && typeof o.on == "function" && typeof o.pause == "function" && typeof o.resume == "function";
      } };
    }, {}], 15: [function(n, r, i) {
      function o(A, U, P) {
        var V, I = s.getTypeOf(U), le = s.extend(P || {}, u);
        le.date = le.date || /* @__PURE__ */ new Date(), le.compression !== null && (le.compression = le.compression.toUpperCase()), typeof le.unixPermissions == "string" && (le.unixPermissions = parseInt(le.unixPermissions, 8)), le.unixPermissions && 16384 & le.unixPermissions && (le.dir = !0), le.dosPermissions && 16 & le.dosPermissions && (le.dir = !0), le.dir && (A = y(A)), le.createFolders && (V = b(A)) && w.call(this, V, !0);
        var be = I === "string" && le.binary === !1 && le.base64 === !1;
        P && P.binary !== void 0 || (le.binary = !be), (U instanceof d && U.uncompressedSize === 0 || le.dir || !U || U.length === 0) && (le.base64 = !1, le.binary = !0, U = "", le.compression = "STORE", I = "string");
        var F = null;
        F = U instanceof d || U instanceof l ? U : m.isNode && m.isStream(U) ? new g(A, U) : s.prepareContent(A, U, le.binary, le.optimizedBinaryString, le.base64);
        var G = new f(A, F, le);
        this.files[A] = G;
      }
      var a = n("./utf8"), s = n("./utils"), l = n("./stream/GenericWorker"), c = n("./stream/StreamHelper"), u = n("./defaults"), d = n("./compressedObject"), f = n("./zipObject"), p = n("./generate"), m = n("./nodejsUtils"), g = n("./nodejs/NodejsStreamInputAdapter"), b = function(A) {
        A.slice(-1) === "/" && (A = A.substring(0, A.length - 1));
        var U = A.lastIndexOf("/");
        return 0 < U ? A.substring(0, U) : "";
      }, y = function(A) {
        return A.slice(-1) !== "/" && (A += "/"), A;
      }, w = function(A, U) {
        return U = U !== void 0 ? U : u.createFolders, A = y(A), this.files[A] || o.call(this, A, null, { dir: !0, createFolders: U }), this.files[A];
      };
      function x(A) {
        return Object.prototype.toString.call(A) === "[object RegExp]";
      }
      var k = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(A) {
        var U, P, V;
        for (U in this.files) V = this.files[U], (P = U.slice(this.root.length, U.length)) && U.slice(0, this.root.length) === this.root && A(P, V);
      }, filter: function(A) {
        var U = [];
        return this.forEach(function(P, V) {
          A(P, V) && U.push(V);
        }), U;
      }, file: function(A, U, P) {
        if (arguments.length !== 1) return A = this.root + A, o.call(this, A, U, P), this;
        if (x(A)) {
          var V = A;
          return this.filter(function(le, be) {
            return !be.dir && V.test(le);
          });
        }
        var I = this.files[this.root + A];
        return I && !I.dir ? I : null;
      }, folder: function(A) {
        if (!A) return this;
        if (x(A)) return this.filter(function(I, le) {
          return le.dir && A.test(I);
        });
        var U = this.root + A, P = w.call(this, U), V = this.clone();
        return V.root = P.name, V;
      }, remove: function(A) {
        A = this.root + A;
        var U = this.files[A];
        if (U || (A.slice(-1) !== "/" && (A += "/"), U = this.files[A]), U && !U.dir) delete this.files[A];
        else for (var P = this.filter(function(I, le) {
          return le.name.slice(0, A.length) === A;
        }), V = 0; V < P.length; V++) delete this.files[P[V].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(A) {
        var U, P = {};
        try {
          if ((P = s.extend(A || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: a.utf8encode })).type = P.type.toLowerCase(), P.compression = P.compression.toUpperCase(), P.type === "binarystring" && (P.type = "string"), !P.type) throw new Error("No output type specified.");
          s.checkSupport(P.type), P.platform !== "darwin" && P.platform !== "freebsd" && P.platform !== "linux" && P.platform !== "sunos" || (P.platform = "UNIX"), P.platform === "win32" && (P.platform = "DOS");
          var V = P.comment || this.comment || "";
          U = p.generateWorker(this, P, V);
        } catch (I) {
          (U = new l("error")).error(I);
        }
        return new c(U, P.type || "string", P.mimeType);
      }, generateAsync: function(A, U) {
        return this.generateInternalStream(A).accumulate(U);
      }, generateNodeStream: function(A, U) {
        return (A = A || {}).type || (A.type = "nodebuffer"), this.generateInternalStream(A).toNodejsStream(U);
      } };
      r.exports = k;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(n, r, i) {
      r.exports = n("stream");
    }, { stream: void 0 }], 17: [function(n, r, i) {
      var o = n("./DataReader");
      function a(s) {
        o.call(this, s);
        for (var l = 0; l < this.data.length; l++) s[l] = 255 & s[l];
      }
      n("../utils").inherits(a, o), a.prototype.byteAt = function(s) {
        return this.data[this.zero + s];
      }, a.prototype.lastIndexOfSignature = function(s) {
        for (var l = s.charCodeAt(0), c = s.charCodeAt(1), u = s.charCodeAt(2), d = s.charCodeAt(3), f = this.length - 4; 0 <= f; --f) if (this.data[f] === l && this.data[f + 1] === c && this.data[f + 2] === u && this.data[f + 3] === d) return f - this.zero;
        return -1;
      }, a.prototype.readAndCheckSignature = function(s) {
        var l = s.charCodeAt(0), c = s.charCodeAt(1), u = s.charCodeAt(2), d = s.charCodeAt(3), f = this.readData(4);
        return l === f[0] && c === f[1] && u === f[2] && d === f[3];
      }, a.prototype.readData = function(s) {
        if (this.checkOffset(s), s === 0) return [];
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + s);
        return this.index += s, l;
      }, r.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(n, r, i) {
      var o = n("../utils");
      function a(s) {
        this.data = s, this.length = s.length, this.index = 0, this.zero = 0;
      }
      a.prototype = { checkOffset: function(s) {
        this.checkIndex(this.index + s);
      }, checkIndex: function(s) {
        if (this.length < this.zero + s || s < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + s + "). Corrupted zip ?");
      }, setIndex: function(s) {
        this.checkIndex(s), this.index = s;
      }, skip: function(s) {
        this.setIndex(this.index + s);
      }, byteAt: function() {
      }, readInt: function(s) {
        var l, c = 0;
        for (this.checkOffset(s), l = this.index + s - 1; l >= this.index; l--) c = (c << 8) + this.byteAt(l);
        return this.index += s, c;
      }, readString: function(s) {
        return o.transformTo("string", this.readData(s));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var s = this.readInt(4);
        return new Date(Date.UTC(1980 + (s >> 25 & 127), (s >> 21 & 15) - 1, s >> 16 & 31, s >> 11 & 31, s >> 5 & 63, (31 & s) << 1));
      } }, r.exports = a;
    }, { "../utils": 32 }], 19: [function(n, r, i) {
      var o = n("./Uint8ArrayReader");
      function a(s) {
        o.call(this, s);
      }
      n("../utils").inherits(a, o), a.prototype.readData = function(s) {
        this.checkOffset(s);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + s);
        return this.index += s, l;
      }, r.exports = a;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(n, r, i) {
      var o = n("./DataReader");
      function a(s) {
        o.call(this, s);
      }
      n("../utils").inherits(a, o), a.prototype.byteAt = function(s) {
        return this.data.charCodeAt(this.zero + s);
      }, a.prototype.lastIndexOfSignature = function(s) {
        return this.data.lastIndexOf(s) - this.zero;
      }, a.prototype.readAndCheckSignature = function(s) {
        return s === this.readData(4);
      }, a.prototype.readData = function(s) {
        this.checkOffset(s);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + s);
        return this.index += s, l;
      }, r.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(n, r, i) {
      var o = n("./ArrayReader");
      function a(s) {
        o.call(this, s);
      }
      n("../utils").inherits(a, o), a.prototype.readData = function(s) {
        if (this.checkOffset(s), s === 0) return new Uint8Array(0);
        var l = this.data.subarray(this.zero + this.index, this.zero + this.index + s);
        return this.index += s, l;
      }, r.exports = a;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(n, r, i) {
      var o = n("../utils"), a = n("../support"), s = n("./ArrayReader"), l = n("./StringReader"), c = n("./NodeBufferReader"), u = n("./Uint8ArrayReader");
      r.exports = function(d) {
        var f = o.getTypeOf(d);
        return o.checkSupport(f), f !== "string" || a.uint8array ? f === "nodebuffer" ? new c(d) : a.uint8array ? new u(o.transformTo("uint8array", d)) : new s(o.transformTo("array", d)) : new l(d);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(n, r, i) {
      i.LOCAL_FILE_HEADER = "PK", i.CENTRAL_FILE_HEADER = "PK", i.CENTRAL_DIRECTORY_END = "PK", i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", i.ZIP64_CENTRAL_DIRECTORY_END = "PK", i.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(n, r, i) {
      var o = n("./GenericWorker"), a = n("../utils");
      function s(l) {
        o.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      a.inherits(s, o), s.prototype.processChunk = function(l) {
        this.push({ data: a.transformTo(this.destType, l.data), meta: l.meta });
      }, r.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(n, r, i) {
      var o = n("./GenericWorker"), a = n("../crc32");
      function s() {
        o.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      n("../utils").inherits(s, o), s.prototype.processChunk = function(l) {
        this.streamInfo.crc32 = a(l.data, this.streamInfo.crc32 || 0), this.push(l);
      }, r.exports = s;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(n, r, i) {
      var o = n("../utils"), a = n("./GenericWorker");
      function s(l) {
        a.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      o.inherits(s, a), s.prototype.processChunk = function(l) {
        if (l) {
          var c = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = c + l.data.length;
        }
        a.prototype.processChunk.call(this, l);
      }, r.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(n, r, i) {
      var o = n("../utils"), a = n("./GenericWorker");
      function s(l) {
        a.call(this, "DataWorker");
        var c = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, l.then(function(u) {
          c.dataIsReady = !0, c.data = u, c.max = u && u.length || 0, c.type = o.getTypeOf(u), c.isPaused || c._tickAndRepeat();
        }, function(u) {
          c.error(u);
        });
      }
      o.inherits(s, a), s.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this.data = null;
      }, s.prototype.resume = function() {
        return !!a.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, o.delay(this._tickAndRepeat, [], this)), !0);
      }, s.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (o.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, s.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var l = null, c = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            l = this.data.substring(this.index, c);
            break;
          case "uint8array":
            l = this.data.subarray(this.index, c);
            break;
          case "array":
          case "nodebuffer":
            l = this.data.slice(this.index, c);
        }
        return this.index = c, this.push({ data: l, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, r.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(n, r, i) {
      function o(a) {
        this.name = a || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      o.prototype = { push: function(a) {
        this.emit("data", a);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (a) {
          this.emit("error", a);
        }
        return !0;
      }, error: function(a) {
        return !this.isFinished && (this.isPaused ? this.generatedError = a : (this.isFinished = !0, this.emit("error", a), this.previous && this.previous.error(a), this.cleanUp()), !0);
      }, on: function(a, s) {
        return this._listeners[a].push(s), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(a, s) {
        if (this._listeners[a]) for (var l = 0; l < this._listeners[a].length; l++) this._listeners[a][l].call(this, s);
      }, pipe: function(a) {
        return a.registerPrevious(this);
      }, registerPrevious: function(a) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = a.streamInfo, this.mergeStreamInfo(), this.previous = a;
        var s = this;
        return a.on("data", function(l) {
          s.processChunk(l);
        }), a.on("end", function() {
          s.end();
        }), a.on("error", function(l) {
          s.error(l);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var a = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), a = !0), this.previous && this.previous.resume(), !a;
      }, flush: function() {
      }, processChunk: function(a) {
        this.push(a);
      }, withStreamInfo: function(a, s) {
        return this.extraStreamInfo[a] = s, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var a in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, a) && (this.streamInfo[a] = this.extraStreamInfo[a]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var a = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + a : a;
      } }, r.exports = o;
    }, {}], 29: [function(n, r, i) {
      var o = n("../utils"), a = n("./ConvertWorker"), s = n("./GenericWorker"), l = n("../base64"), c = n("../support"), u = n("../external"), d = null;
      if (c.nodestream) try {
        d = n("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function f(m, g) {
        return new u.Promise(function(b, y) {
          var w = [], x = m._internalType, k = m._outputType, A = m._mimeType;
          m.on("data", function(U, P) {
            w.push(U), g && g(P);
          }).on("error", function(U) {
            w = [], y(U);
          }).on("end", function() {
            try {
              var U = function(P, V, I) {
                switch (P) {
                  case "blob":
                    return o.newBlob(o.transformTo("arraybuffer", V), I);
                  case "base64":
                    return l.encode(V);
                  default:
                    return o.transformTo(P, V);
                }
              }(k, function(P, V) {
                var I, le = 0, be = null, F = 0;
                for (I = 0; I < V.length; I++) F += V[I].length;
                switch (P) {
                  case "string":
                    return V.join("");
                  case "array":
                    return Array.prototype.concat.apply([], V);
                  case "uint8array":
                    for (be = new Uint8Array(F), I = 0; I < V.length; I++) be.set(V[I], le), le += V[I].length;
                    return be;
                  case "nodebuffer":
                    return Buffer.concat(V);
                  default:
                    throw new Error("concat : unsupported type '" + P + "'");
                }
              }(x, w), A);
              b(U);
            } catch (P) {
              y(P);
            }
            w = [];
          }).resume();
        });
      }
      function p(m, g, b) {
        var y = g;
        switch (g) {
          case "blob":
          case "arraybuffer":
            y = "uint8array";
            break;
          case "base64":
            y = "string";
        }
        try {
          this._internalType = y, this._outputType = g, this._mimeType = b, o.checkSupport(y), this._worker = m.pipe(new a(y)), m.lock();
        } catch (w) {
          this._worker = new s("error"), this._worker.error(w);
        }
      }
      p.prototype = { accumulate: function(m) {
        return f(this, m);
      }, on: function(m, g) {
        var b = this;
        return m === "data" ? this._worker.on(m, function(y) {
          g.call(b, y.data, y.meta);
        }) : this._worker.on(m, function() {
          o.delay(g, arguments, b);
        }), this;
      }, resume: function() {
        return o.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(m) {
        if (o.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new d(this, { objectMode: this._outputType !== "nodebuffer" }, m);
      } }, r.exports = p;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(n, r, i) {
      if (i.base64 = !0, i.array = !0, i.string = !0, i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", i.nodebuffer = typeof Buffer < "u", i.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") i.blob = !1;
      else {
        var o = new ArrayBuffer(0);
        try {
          i.blob = new Blob([o], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var a = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            a.append(o), i.blob = a.getBlob("application/zip").size === 0;
          } catch {
            i.blob = !1;
          }
        }
      }
      try {
        i.nodestream = !!n("readable-stream").Readable;
      } catch {
        i.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(n, r, i) {
      for (var o = n("./utils"), a = n("./support"), s = n("./nodejsUtils"), l = n("./stream/GenericWorker"), c = new Array(256), u = 0; u < 256; u++) c[u] = 252 <= u ? 6 : 248 <= u ? 5 : 240 <= u ? 4 : 224 <= u ? 3 : 192 <= u ? 2 : 1;
      c[254] = c[254] = 1;
      function d() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function f() {
        l.call(this, "utf-8 encode");
      }
      i.utf8encode = function(p) {
        return a.nodebuffer ? s.newBufferFrom(p, "utf-8") : function(m) {
          var g, b, y, w, x, k = m.length, A = 0;
          for (w = 0; w < k; w++) (64512 & (b = m.charCodeAt(w))) == 55296 && w + 1 < k && (64512 & (y = m.charCodeAt(w + 1))) == 56320 && (b = 65536 + (b - 55296 << 10) + (y - 56320), w++), A += b < 128 ? 1 : b < 2048 ? 2 : b < 65536 ? 3 : 4;
          for (g = a.uint8array ? new Uint8Array(A) : new Array(A), w = x = 0; x < A; w++) (64512 & (b = m.charCodeAt(w))) == 55296 && w + 1 < k && (64512 & (y = m.charCodeAt(w + 1))) == 56320 && (b = 65536 + (b - 55296 << 10) + (y - 56320), w++), b < 128 ? g[x++] = b : (b < 2048 ? g[x++] = 192 | b >>> 6 : (b < 65536 ? g[x++] = 224 | b >>> 12 : (g[x++] = 240 | b >>> 18, g[x++] = 128 | b >>> 12 & 63), g[x++] = 128 | b >>> 6 & 63), g[x++] = 128 | 63 & b);
          return g;
        }(p);
      }, i.utf8decode = function(p) {
        return a.nodebuffer ? o.transformTo("nodebuffer", p).toString("utf-8") : function(m) {
          var g, b, y, w, x = m.length, k = new Array(2 * x);
          for (g = b = 0; g < x; ) if ((y = m[g++]) < 128) k[b++] = y;
          else if (4 < (w = c[y])) k[b++] = 65533, g += w - 1;
          else {
            for (y &= w === 2 ? 31 : w === 3 ? 15 : 7; 1 < w && g < x; ) y = y << 6 | 63 & m[g++], w--;
            1 < w ? k[b++] = 65533 : y < 65536 ? k[b++] = y : (y -= 65536, k[b++] = 55296 | y >> 10 & 1023, k[b++] = 56320 | 1023 & y);
          }
          return k.length !== b && (k.subarray ? k = k.subarray(0, b) : k.length = b), o.applyFromCharCode(k);
        }(p = o.transformTo(a.uint8array ? "uint8array" : "array", p));
      }, o.inherits(d, l), d.prototype.processChunk = function(p) {
        var m = o.transformTo(a.uint8array ? "uint8array" : "array", p.data);
        if (this.leftOver && this.leftOver.length) {
          if (a.uint8array) {
            var g = m;
            (m = new Uint8Array(g.length + this.leftOver.length)).set(this.leftOver, 0), m.set(g, this.leftOver.length);
          } else m = this.leftOver.concat(m);
          this.leftOver = null;
        }
        var b = function(w, x) {
          var k;
          for ((x = x || w.length) > w.length && (x = w.length), k = x - 1; 0 <= k && (192 & w[k]) == 128; ) k--;
          return k < 0 || k === 0 ? x : k + c[w[k]] > x ? k : x;
        }(m), y = m;
        b !== m.length && (a.uint8array ? (y = m.subarray(0, b), this.leftOver = m.subarray(b, m.length)) : (y = m.slice(0, b), this.leftOver = m.slice(b, m.length))), this.push({ data: i.utf8decode(y), meta: p.meta });
      }, d.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: i.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, i.Utf8DecodeWorker = d, o.inherits(f, l), f.prototype.processChunk = function(p) {
        this.push({ data: i.utf8encode(p.data), meta: p.meta });
      }, i.Utf8EncodeWorker = f;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(n, r, i) {
      var o = n("./support"), a = n("./base64"), s = n("./nodejsUtils"), l = n("./external");
      function c(g) {
        return g;
      }
      function u(g, b) {
        for (var y = 0; y < g.length; ++y) b[y] = 255 & g.charCodeAt(y);
        return b;
      }
      n("setimmediate"), i.newBlob = function(g, b) {
        i.checkSupport("blob");
        try {
          return new Blob([g], { type: b });
        } catch {
          try {
            var y = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return y.append(g), y.getBlob(b);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var d = { stringifyByChunk: function(g, b, y) {
        var w = [], x = 0, k = g.length;
        if (k <= y) return String.fromCharCode.apply(null, g);
        for (; x < k; ) b === "array" || b === "nodebuffer" ? w.push(String.fromCharCode.apply(null, g.slice(x, Math.min(x + y, k)))) : w.push(String.fromCharCode.apply(null, g.subarray(x, Math.min(x + y, k)))), x += y;
        return w.join("");
      }, stringifyByChar: function(g) {
        for (var b = "", y = 0; y < g.length; y++) b += String.fromCharCode(g[y]);
        return b;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return o.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return o.nodebuffer && String.fromCharCode.apply(null, s.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function f(g) {
        var b = 65536, y = i.getTypeOf(g), w = !0;
        if (y === "uint8array" ? w = d.applyCanBeUsed.uint8array : y === "nodebuffer" && (w = d.applyCanBeUsed.nodebuffer), w) for (; 1 < b; ) try {
          return d.stringifyByChunk(g, y, b);
        } catch {
          b = Math.floor(b / 2);
        }
        return d.stringifyByChar(g);
      }
      function p(g, b) {
        for (var y = 0; y < g.length; y++) b[y] = g[y];
        return b;
      }
      i.applyFromCharCode = f;
      var m = {};
      m.string = { string: c, array: function(g) {
        return u(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return m.string.uint8array(g).buffer;
      }, uint8array: function(g) {
        return u(g, new Uint8Array(g.length));
      }, nodebuffer: function(g) {
        return u(g, s.allocBuffer(g.length));
      } }, m.array = { string: f, array: c, arraybuffer: function(g) {
        return new Uint8Array(g).buffer;
      }, uint8array: function(g) {
        return new Uint8Array(g);
      }, nodebuffer: function(g) {
        return s.newBufferFrom(g);
      } }, m.arraybuffer = { string: function(g) {
        return f(new Uint8Array(g));
      }, array: function(g) {
        return p(new Uint8Array(g), new Array(g.byteLength));
      }, arraybuffer: c, uint8array: function(g) {
        return new Uint8Array(g);
      }, nodebuffer: function(g) {
        return s.newBufferFrom(new Uint8Array(g));
      } }, m.uint8array = { string: f, array: function(g) {
        return p(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return g.buffer;
      }, uint8array: c, nodebuffer: function(g) {
        return s.newBufferFrom(g);
      } }, m.nodebuffer = { string: f, array: function(g) {
        return p(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return m.nodebuffer.uint8array(g).buffer;
      }, uint8array: function(g) {
        return p(g, new Uint8Array(g.length));
      }, nodebuffer: c }, i.transformTo = function(g, b) {
        if (b = b || "", !g) return b;
        i.checkSupport(g);
        var y = i.getTypeOf(b);
        return m[y][g](b);
      }, i.resolve = function(g) {
        for (var b = g.split("/"), y = [], w = 0; w < b.length; w++) {
          var x = b[w];
          x === "." || x === "" && w !== 0 && w !== b.length - 1 || (x === ".." ? y.pop() : y.push(x));
        }
        return y.join("/");
      }, i.getTypeOf = function(g) {
        return typeof g == "string" ? "string" : Object.prototype.toString.call(g) === "[object Array]" ? "array" : o.nodebuffer && s.isBuffer(g) ? "nodebuffer" : o.uint8array && g instanceof Uint8Array ? "uint8array" : o.arraybuffer && g instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, i.checkSupport = function(g) {
        if (!o[g.toLowerCase()]) throw new Error(g + " is not supported by this platform");
      }, i.MAX_VALUE_16BITS = 65535, i.MAX_VALUE_32BITS = -1, i.pretty = function(g) {
        var b, y, w = "";
        for (y = 0; y < (g || "").length; y++) w += "\\x" + ((b = g.charCodeAt(y)) < 16 ? "0" : "") + b.toString(16).toUpperCase();
        return w;
      }, i.delay = function(g, b, y) {
        setImmediate(function() {
          g.apply(y || null, b || []);
        });
      }, i.inherits = function(g, b) {
        function y() {
        }
        y.prototype = b.prototype, g.prototype = new y();
      }, i.extend = function() {
        var g, b, y = {};
        for (g = 0; g < arguments.length; g++) for (b in arguments[g]) Object.prototype.hasOwnProperty.call(arguments[g], b) && y[b] === void 0 && (y[b] = arguments[g][b]);
        return y;
      }, i.prepareContent = function(g, b, y, w, x) {
        return l.Promise.resolve(b).then(function(k) {
          return o.blob && (k instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(k)) !== -1) && typeof FileReader < "u" ? new l.Promise(function(A, U) {
            var P = new FileReader();
            P.onload = function(V) {
              A(V.target.result);
            }, P.onerror = function(V) {
              U(V.target.error);
            }, P.readAsArrayBuffer(k);
          }) : k;
        }).then(function(k) {
          var A = i.getTypeOf(k);
          return A ? (A === "arraybuffer" ? k = i.transformTo("uint8array", k) : A === "string" && (x ? k = a.decode(k) : y && w !== !0 && (k = function(U) {
            return u(U, o.uint8array ? new Uint8Array(U.length) : new Array(U.length));
          }(k))), k) : l.Promise.reject(new Error("Can't read the data of '" + g + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(n, r, i) {
      var o = n("./reader/readerFor"), a = n("./utils"), s = n("./signature"), l = n("./zipEntry"), c = n("./support");
      function u(d) {
        this.files = [], this.loadOptions = d;
      }
      u.prototype = { checkSignature: function(d) {
        if (!this.reader.readAndCheckSignature(d)) {
          this.reader.index -= 4;
          var f = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + a.pretty(f) + ", expected " + a.pretty(d) + ")");
        }
      }, isSignature: function(d, f) {
        var p = this.reader.index;
        this.reader.setIndex(d);
        var m = this.reader.readString(4) === f;
        return this.reader.setIndex(p), m;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var d = this.reader.readData(this.zipCommentLength), f = c.uint8array ? "uint8array" : "array", p = a.transformTo(f, d);
        this.zipComment = this.loadOptions.decodeFileName(p);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var d, f, p, m = this.zip64EndOfCentralSize - 44; 0 < m; ) d = this.reader.readInt(2), f = this.reader.readInt(4), p = this.reader.readData(f), this.zip64ExtensibleData[d] = { id: d, length: f, value: p };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var d, f;
        for (d = 0; d < this.files.length; d++) f = this.files[d], this.reader.setIndex(f.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), f.readLocalPart(this.reader), f.handleUTF8(), f.processAttributes();
      }, readCentralDir: function() {
        var d;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); ) (d = new l({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(d);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var d = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
        if (d < 0) throw this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(d);
        var f = d;
        if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === a.MAX_VALUE_16BITS || this.diskWithCentralDirStart === a.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === a.MAX_VALUE_16BITS || this.centralDirRecords === a.MAX_VALUE_16BITS || this.centralDirSize === a.MAX_VALUE_32BITS || this.centralDirOffset === a.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (d = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(d), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var p = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (p += 20, p += 12 + this.zip64EndOfCentralSize);
        var m = f - p;
        if (0 < m) this.isSignature(f, s.CENTRAL_FILE_HEADER) || (this.reader.zero = m);
        else if (m < 0) throw new Error("Corrupted zip: missing " + Math.abs(m) + " bytes.");
      }, prepareReader: function(d) {
        this.reader = o(d);
      }, load: function(d) {
        this.prepareReader(d), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, r.exports = u;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(n, r, i) {
      var o = n("./reader/readerFor"), a = n("./utils"), s = n("./compressedObject"), l = n("./crc32"), c = n("./utf8"), u = n("./compressions"), d = n("./support");
      function f(p, m) {
        this.options = p, this.loadOptions = m;
      }
      f.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(p) {
        var m, g;
        if (p.skip(22), this.fileNameLength = p.readInt(2), g = p.readInt(2), this.fileName = p.readData(this.fileNameLength), p.skip(g), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((m = function(b) {
          for (var y in u) if (Object.prototype.hasOwnProperty.call(u, y) && u[y].magic === b) return u[y];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + a.pretty(this.compressionMethod) + " unknown (inner file : " + a.transformTo("string", this.fileName) + ")");
        this.decompressed = new s(this.compressedSize, this.uncompressedSize, this.crc32, m, p.readData(this.compressedSize));
      }, readCentralPart: function(p) {
        this.versionMadeBy = p.readInt(2), p.skip(2), this.bitFlag = p.readInt(2), this.compressionMethod = p.readString(2), this.date = p.readDate(), this.crc32 = p.readInt(4), this.compressedSize = p.readInt(4), this.uncompressedSize = p.readInt(4);
        var m = p.readInt(2);
        if (this.extraFieldsLength = p.readInt(2), this.fileCommentLength = p.readInt(2), this.diskNumberStart = p.readInt(2), this.internalFileAttributes = p.readInt(2), this.externalFileAttributes = p.readInt(4), this.localHeaderOffset = p.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        p.skip(m), this.readExtraFields(p), this.parseZIP64ExtraField(p), this.fileComment = p.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var p = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), p == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), p == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var p = o(this.extraFields[1].value);
          this.uncompressedSize === a.MAX_VALUE_32BITS && (this.uncompressedSize = p.readInt(8)), this.compressedSize === a.MAX_VALUE_32BITS && (this.compressedSize = p.readInt(8)), this.localHeaderOffset === a.MAX_VALUE_32BITS && (this.localHeaderOffset = p.readInt(8)), this.diskNumberStart === a.MAX_VALUE_32BITS && (this.diskNumberStart = p.readInt(4));
        }
      }, readExtraFields: function(p) {
        var m, g, b, y = p.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); p.index + 4 < y; ) m = p.readInt(2), g = p.readInt(2), b = p.readData(g), this.extraFields[m] = { id: m, length: g, value: b };
        p.setIndex(y);
      }, handleUTF8: function() {
        var p = d.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
        else {
          var m = this.findExtraFieldUnicodePath();
          if (m !== null) this.fileNameStr = m;
          else {
            var g = a.transformTo(p, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(g);
          }
          var b = this.findExtraFieldUnicodeComment();
          if (b !== null) this.fileCommentStr = b;
          else {
            var y = a.transformTo(p, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(y);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var p = this.extraFields[28789];
        if (p) {
          var m = o(p.value);
          return m.readInt(1) !== 1 || l(this.fileName) !== m.readInt(4) ? null : c.utf8decode(m.readData(p.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var p = this.extraFields[25461];
        if (p) {
          var m = o(p.value);
          return m.readInt(1) !== 1 || l(this.fileComment) !== m.readInt(4) ? null : c.utf8decode(m.readData(p.length - 5));
        }
        return null;
      } }, r.exports = f;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(n, r, i) {
      function o(m, g, b) {
        this.name = m, this.dir = b.dir, this.date = b.date, this.comment = b.comment, this.unixPermissions = b.unixPermissions, this.dosPermissions = b.dosPermissions, this._data = g, this._dataBinary = b.binary, this.options = { compression: b.compression, compressionOptions: b.compressionOptions };
      }
      var a = n("./stream/StreamHelper"), s = n("./stream/DataWorker"), l = n("./utf8"), c = n("./compressedObject"), u = n("./stream/GenericWorker");
      o.prototype = { internalStream: function(m) {
        var g = null, b = "string";
        try {
          if (!m) throw new Error("No output type specified.");
          var y = (b = m.toLowerCase()) === "string" || b === "text";
          b !== "binarystring" && b !== "text" || (b = "string"), g = this._decompressWorker();
          var w = !this._dataBinary;
          w && !y && (g = g.pipe(new l.Utf8EncodeWorker())), !w && y && (g = g.pipe(new l.Utf8DecodeWorker()));
        } catch (x) {
          (g = new u("error")).error(x);
        }
        return new a(g, b, "");
      }, async: function(m, g) {
        return this.internalStream(m).accumulate(g);
      }, nodeStream: function(m, g) {
        return this.internalStream(m || "nodebuffer").toNodejsStream(g);
      }, _compressWorker: function(m, g) {
        if (this._data instanceof c && this._data.compression.magic === m.magic) return this._data.getCompressedWorker();
        var b = this._decompressWorker();
        return this._dataBinary || (b = b.pipe(new l.Utf8EncodeWorker())), c.createWorkerFrom(b, m, g);
      }, _decompressWorker: function() {
        return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof u ? this._data : new s(this._data);
      } };
      for (var d = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], f = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, p = 0; p < d.length; p++) o.prototype[d[p]] = f;
      r.exports = o;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(n, r, i) {
      (function(o) {
        var a, s, l = o.MutationObserver || o.WebKitMutationObserver;
        if (l) {
          var c = 0, u = new l(m), d = o.document.createTextNode("");
          u.observe(d, { characterData: !0 }), a = function() {
            d.data = c = ++c % 2;
          };
        } else if (o.setImmediate || o.MessageChannel === void 0) a = "document" in o && "onreadystatechange" in o.document.createElement("script") ? function() {
          var g = o.document.createElement("script");
          g.onreadystatechange = function() {
            m(), g.onreadystatechange = null, g.parentNode.removeChild(g), g = null;
          }, o.document.documentElement.appendChild(g);
        } : function() {
          setTimeout(m, 0);
        };
        else {
          var f = new o.MessageChannel();
          f.port1.onmessage = m, a = function() {
            f.port2.postMessage(0);
          };
        }
        var p = [];
        function m() {
          var g, b;
          s = !0;
          for (var y = p.length; y; ) {
            for (b = p, p = [], g = -1; ++g < y; ) b[g]();
            y = p.length;
          }
          s = !1;
        }
        r.exports = function(g) {
          p.push(g) !== 1 || s || a();
        };
      }).call(this, typeof wt < "u" ? wt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(n, r, i) {
      var o = n("immediate");
      function a() {
      }
      var s = {}, l = ["REJECTED"], c = ["FULFILLED"], u = ["PENDING"];
      function d(y) {
        if (typeof y != "function") throw new TypeError("resolver must be a function");
        this.state = u, this.queue = [], this.outcome = void 0, y !== a && g(this, y);
      }
      function f(y, w, x) {
        this.promise = y, typeof w == "function" && (this.onFulfilled = w, this.callFulfilled = this.otherCallFulfilled), typeof x == "function" && (this.onRejected = x, this.callRejected = this.otherCallRejected);
      }
      function p(y, w, x) {
        o(function() {
          var k;
          try {
            k = w(x);
          } catch (A) {
            return s.reject(y, A);
          }
          k === y ? s.reject(y, new TypeError("Cannot resolve promise with itself")) : s.resolve(y, k);
        });
      }
      function m(y) {
        var w = y && y.then;
        if (y && (typeof y == "object" || typeof y == "function") && typeof w == "function") return function() {
          w.apply(y, arguments);
        };
      }
      function g(y, w) {
        var x = !1;
        function k(P) {
          x || (x = !0, s.reject(y, P));
        }
        function A(P) {
          x || (x = !0, s.resolve(y, P));
        }
        var U = b(function() {
          w(A, k);
        });
        U.status === "error" && k(U.value);
      }
      function b(y, w) {
        var x = {};
        try {
          x.value = y(w), x.status = "success";
        } catch (k) {
          x.status = "error", x.value = k;
        }
        return x;
      }
      (r.exports = d).prototype.finally = function(y) {
        if (typeof y != "function") return this;
        var w = this.constructor;
        return this.then(function(x) {
          return w.resolve(y()).then(function() {
            return x;
          });
        }, function(x) {
          return w.resolve(y()).then(function() {
            throw x;
          });
        });
      }, d.prototype.catch = function(y) {
        return this.then(null, y);
      }, d.prototype.then = function(y, w) {
        if (typeof y != "function" && this.state === c || typeof w != "function" && this.state === l) return this;
        var x = new this.constructor(a);
        return this.state !== u ? p(x, this.state === c ? y : w, this.outcome) : this.queue.push(new f(x, y, w)), x;
      }, f.prototype.callFulfilled = function(y) {
        s.resolve(this.promise, y);
      }, f.prototype.otherCallFulfilled = function(y) {
        p(this.promise, this.onFulfilled, y);
      }, f.prototype.callRejected = function(y) {
        s.reject(this.promise, y);
      }, f.prototype.otherCallRejected = function(y) {
        p(this.promise, this.onRejected, y);
      }, s.resolve = function(y, w) {
        var x = b(m, w);
        if (x.status === "error") return s.reject(y, x.value);
        var k = x.value;
        if (k) g(y, k);
        else {
          y.state = c, y.outcome = w;
          for (var A = -1, U = y.queue.length; ++A < U; ) y.queue[A].callFulfilled(w);
        }
        return y;
      }, s.reject = function(y, w) {
        y.state = l, y.outcome = w;
        for (var x = -1, k = y.queue.length; ++x < k; ) y.queue[x].callRejected(w);
        return y;
      }, d.resolve = function(y) {
        return y instanceof this ? y : s.resolve(new this(a), y);
      }, d.reject = function(y) {
        var w = new this(a);
        return s.reject(w, y);
      }, d.all = function(y) {
        var w = this;
        if (Object.prototype.toString.call(y) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var x = y.length, k = !1;
        if (!x) return this.resolve([]);
        for (var A = new Array(x), U = 0, P = -1, V = new this(a); ++P < x; ) I(y[P], P);
        return V;
        function I(le, be) {
          w.resolve(le).then(function(F) {
            A[be] = F, ++U !== x || k || (k = !0, s.resolve(V, A));
          }, function(F) {
            k || (k = !0, s.reject(V, F));
          });
        }
      }, d.race = function(y) {
        var w = this;
        if (Object.prototype.toString.call(y) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var x = y.length, k = !1;
        if (!x) return this.resolve([]);
        for (var A = -1, U = new this(a); ++A < x; ) P = y[A], w.resolve(P).then(function(V) {
          k || (k = !0, s.resolve(U, V));
        }, function(V) {
          k || (k = !0, s.reject(U, V));
        });
        var P;
        return U;
      };
    }, { immediate: 36 }], 38: [function(n, r, i) {
      var o = {};
      (0, n("./lib/utils/common").assign)(o, n("./lib/deflate"), n("./lib/inflate"), n("./lib/zlib/constants")), r.exports = o;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(n, r, i) {
      var o = n("./zlib/deflate"), a = n("./utils/common"), s = n("./utils/strings"), l = n("./zlib/messages"), c = n("./zlib/zstream"), u = Object.prototype.toString, d = 0, f = -1, p = 0, m = 8;
      function g(y) {
        if (!(this instanceof g)) return new g(y);
        this.options = a.assign({ level: f, method: m, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: p, to: "" }, y || {});
        var w = this.options;
        w.raw && 0 < w.windowBits ? w.windowBits = -w.windowBits : w.gzip && 0 < w.windowBits && w.windowBits < 16 && (w.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var x = o.deflateInit2(this.strm, w.level, w.method, w.windowBits, w.memLevel, w.strategy);
        if (x !== d) throw new Error(l[x]);
        if (w.header && o.deflateSetHeader(this.strm, w.header), w.dictionary) {
          var k;
          if (k = typeof w.dictionary == "string" ? s.string2buf(w.dictionary) : u.call(w.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(w.dictionary) : w.dictionary, (x = o.deflateSetDictionary(this.strm, k)) !== d) throw new Error(l[x]);
          this._dict_set = !0;
        }
      }
      function b(y, w) {
        var x = new g(w);
        if (x.push(y, !0), x.err) throw x.msg || l[x.err];
        return x.result;
      }
      g.prototype.push = function(y, w) {
        var x, k, A = this.strm, U = this.options.chunkSize;
        if (this.ended) return !1;
        k = w === ~~w ? w : w === !0 ? 4 : 0, typeof y == "string" ? A.input = s.string2buf(y) : u.call(y) === "[object ArrayBuffer]" ? A.input = new Uint8Array(y) : A.input = y, A.next_in = 0, A.avail_in = A.input.length;
        do {
          if (A.avail_out === 0 && (A.output = new a.Buf8(U), A.next_out = 0, A.avail_out = U), (x = o.deflate(A, k)) !== 1 && x !== d) return this.onEnd(x), !(this.ended = !0);
          A.avail_out !== 0 && (A.avail_in !== 0 || k !== 4 && k !== 2) || (this.options.to === "string" ? this.onData(s.buf2binstring(a.shrinkBuf(A.output, A.next_out))) : this.onData(a.shrinkBuf(A.output, A.next_out)));
        } while ((0 < A.avail_in || A.avail_out === 0) && x !== 1);
        return k === 4 ? (x = o.deflateEnd(this.strm), this.onEnd(x), this.ended = !0, x === d) : k !== 2 || (this.onEnd(d), !(A.avail_out = 0));
      }, g.prototype.onData = function(y) {
        this.chunks.push(y);
      }, g.prototype.onEnd = function(y) {
        y === d && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = a.flattenChunks(this.chunks)), this.chunks = [], this.err = y, this.msg = this.strm.msg;
      }, i.Deflate = g, i.deflate = b, i.deflateRaw = function(y, w) {
        return (w = w || {}).raw = !0, b(y, w);
      }, i.gzip = function(y, w) {
        return (w = w || {}).gzip = !0, b(y, w);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(n, r, i) {
      var o = n("./zlib/inflate"), a = n("./utils/common"), s = n("./utils/strings"), l = n("./zlib/constants"), c = n("./zlib/messages"), u = n("./zlib/zstream"), d = n("./zlib/gzheader"), f = Object.prototype.toString;
      function p(g) {
        if (!(this instanceof p)) return new p(g);
        this.options = a.assign({ chunkSize: 16384, windowBits: 0, to: "" }, g || {});
        var b = this.options;
        b.raw && 0 <= b.windowBits && b.windowBits < 16 && (b.windowBits = -b.windowBits, b.windowBits === 0 && (b.windowBits = -15)), !(0 <= b.windowBits && b.windowBits < 16) || g && g.windowBits || (b.windowBits += 32), 15 < b.windowBits && b.windowBits < 48 && !(15 & b.windowBits) && (b.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var y = o.inflateInit2(this.strm, b.windowBits);
        if (y !== l.Z_OK) throw new Error(c[y]);
        this.header = new d(), o.inflateGetHeader(this.strm, this.header);
      }
      function m(g, b) {
        var y = new p(b);
        if (y.push(g, !0), y.err) throw y.msg || c[y.err];
        return y.result;
      }
      p.prototype.push = function(g, b) {
        var y, w, x, k, A, U, P = this.strm, V = this.options.chunkSize, I = this.options.dictionary, le = !1;
        if (this.ended) return !1;
        w = b === ~~b ? b : b === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof g == "string" ? P.input = s.binstring2buf(g) : f.call(g) === "[object ArrayBuffer]" ? P.input = new Uint8Array(g) : P.input = g, P.next_in = 0, P.avail_in = P.input.length;
        do {
          if (P.avail_out === 0 && (P.output = new a.Buf8(V), P.next_out = 0, P.avail_out = V), (y = o.inflate(P, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && I && (U = typeof I == "string" ? s.string2buf(I) : f.call(I) === "[object ArrayBuffer]" ? new Uint8Array(I) : I, y = o.inflateSetDictionary(this.strm, U)), y === l.Z_BUF_ERROR && le === !0 && (y = l.Z_OK, le = !1), y !== l.Z_STREAM_END && y !== l.Z_OK) return this.onEnd(y), !(this.ended = !0);
          P.next_out && (P.avail_out !== 0 && y !== l.Z_STREAM_END && (P.avail_in !== 0 || w !== l.Z_FINISH && w !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (x = s.utf8border(P.output, P.next_out), k = P.next_out - x, A = s.buf2string(P.output, x), P.next_out = k, P.avail_out = V - k, k && a.arraySet(P.output, P.output, x, k, 0), this.onData(A)) : this.onData(a.shrinkBuf(P.output, P.next_out)))), P.avail_in === 0 && P.avail_out === 0 && (le = !0);
        } while ((0 < P.avail_in || P.avail_out === 0) && y !== l.Z_STREAM_END);
        return y === l.Z_STREAM_END && (w = l.Z_FINISH), w === l.Z_FINISH ? (y = o.inflateEnd(this.strm), this.onEnd(y), this.ended = !0, y === l.Z_OK) : w !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(P.avail_out = 0));
      }, p.prototype.onData = function(g) {
        this.chunks.push(g);
      }, p.prototype.onEnd = function(g) {
        g === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = a.flattenChunks(this.chunks)), this.chunks = [], this.err = g, this.msg = this.strm.msg;
      }, i.Inflate = p, i.inflate = m, i.inflateRaw = function(g, b) {
        return (b = b || {}).raw = !0, m(g, b);
      }, i.ungzip = m;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(n, r, i) {
      var o = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      i.assign = function(l) {
        for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
          var u = c.shift();
          if (u) {
            if (typeof u != "object") throw new TypeError(u + "must be non-object");
            for (var d in u) u.hasOwnProperty(d) && (l[d] = u[d]);
          }
        }
        return l;
      }, i.shrinkBuf = function(l, c) {
        return l.length === c ? l : l.subarray ? l.subarray(0, c) : (l.length = c, l);
      };
      var a = { arraySet: function(l, c, u, d, f) {
        if (c.subarray && l.subarray) l.set(c.subarray(u, u + d), f);
        else for (var p = 0; p < d; p++) l[f + p] = c[u + p];
      }, flattenChunks: function(l) {
        var c, u, d, f, p, m;
        for (c = d = 0, u = l.length; c < u; c++) d += l[c].length;
        for (m = new Uint8Array(d), c = f = 0, u = l.length; c < u; c++) p = l[c], m.set(p, f), f += p.length;
        return m;
      } }, s = { arraySet: function(l, c, u, d, f) {
        for (var p = 0; p < d; p++) l[f + p] = c[u + p];
      }, flattenChunks: function(l) {
        return [].concat.apply([], l);
      } };
      i.setTyped = function(l) {
        l ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, a)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, s));
      }, i.setTyped(o);
    }, {}], 42: [function(n, r, i) {
      var o = n("./common"), a = !0, s = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        a = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        s = !1;
      }
      for (var l = new o.Buf8(256), c = 0; c < 256; c++) l[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
      function u(d, f) {
        if (f < 65537 && (d.subarray && s || !d.subarray && a)) return String.fromCharCode.apply(null, o.shrinkBuf(d, f));
        for (var p = "", m = 0; m < f; m++) p += String.fromCharCode(d[m]);
        return p;
      }
      l[254] = l[254] = 1, i.string2buf = function(d) {
        var f, p, m, g, b, y = d.length, w = 0;
        for (g = 0; g < y; g++) (64512 & (p = d.charCodeAt(g))) == 55296 && g + 1 < y && (64512 & (m = d.charCodeAt(g + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (m - 56320), g++), w += p < 128 ? 1 : p < 2048 ? 2 : p < 65536 ? 3 : 4;
        for (f = new o.Buf8(w), g = b = 0; b < w; g++) (64512 & (p = d.charCodeAt(g))) == 55296 && g + 1 < y && (64512 & (m = d.charCodeAt(g + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (m - 56320), g++), p < 128 ? f[b++] = p : (p < 2048 ? f[b++] = 192 | p >>> 6 : (p < 65536 ? f[b++] = 224 | p >>> 12 : (f[b++] = 240 | p >>> 18, f[b++] = 128 | p >>> 12 & 63), f[b++] = 128 | p >>> 6 & 63), f[b++] = 128 | 63 & p);
        return f;
      }, i.buf2binstring = function(d) {
        return u(d, d.length);
      }, i.binstring2buf = function(d) {
        for (var f = new o.Buf8(d.length), p = 0, m = f.length; p < m; p++) f[p] = d.charCodeAt(p);
        return f;
      }, i.buf2string = function(d, f) {
        var p, m, g, b, y = f || d.length, w = new Array(2 * y);
        for (p = m = 0; p < y; ) if ((g = d[p++]) < 128) w[m++] = g;
        else if (4 < (b = l[g])) w[m++] = 65533, p += b - 1;
        else {
          for (g &= b === 2 ? 31 : b === 3 ? 15 : 7; 1 < b && p < y; ) g = g << 6 | 63 & d[p++], b--;
          1 < b ? w[m++] = 65533 : g < 65536 ? w[m++] = g : (g -= 65536, w[m++] = 55296 | g >> 10 & 1023, w[m++] = 56320 | 1023 & g);
        }
        return u(w, m);
      }, i.utf8border = function(d, f) {
        var p;
        for ((f = f || d.length) > d.length && (f = d.length), p = f - 1; 0 <= p && (192 & d[p]) == 128; ) p--;
        return p < 0 || p === 0 ? f : p + l[d[p]] > f ? p : f;
      };
    }, { "./common": 41 }], 43: [function(n, r, i) {
      r.exports = function(o, a, s, l) {
        for (var c = 65535 & o | 0, u = o >>> 16 & 65535 | 0, d = 0; s !== 0; ) {
          for (s -= d = 2e3 < s ? 2e3 : s; u = u + (c = c + a[l++] | 0) | 0, --d; ) ;
          c %= 65521, u %= 65521;
        }
        return c | u << 16 | 0;
      };
    }, {}], 44: [function(n, r, i) {
      r.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(n, r, i) {
      var o = function() {
        for (var a, s = [], l = 0; l < 256; l++) {
          a = l;
          for (var c = 0; c < 8; c++) a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
          s[l] = a;
        }
        return s;
      }();
      r.exports = function(a, s, l, c) {
        var u = o, d = c + l;
        a ^= -1;
        for (var f = c; f < d; f++) a = a >>> 8 ^ u[255 & (a ^ s[f])];
        return -1 ^ a;
      };
    }, {}], 46: [function(n, r, i) {
      var o, a = n("../utils/common"), s = n("./trees"), l = n("./adler32"), c = n("./crc32"), u = n("./messages"), d = 0, f = 4, p = 0, m = -2, g = -1, b = 4, y = 2, w = 8, x = 9, k = 286, A = 30, U = 19, P = 2 * k + 1, V = 15, I = 3, le = 258, be = le + I + 1, F = 42, G = 113, C = 1, ie = 2, ee = 3, Z = 4;
      function oe(T, pe) {
        return T.msg = u[pe], pe;
      }
      function te(T) {
        return (T << 1) - (4 < T ? 9 : 0);
      }
      function _e(T) {
        for (var pe = T.length; 0 <= --pe; ) T[pe] = 0;
      }
      function q(T) {
        var pe = T.state, M = pe.pending;
        M > T.avail_out && (M = T.avail_out), M !== 0 && (a.arraySet(T.output, pe.pending_buf, pe.pending_out, M, T.next_out), T.next_out += M, pe.pending_out += M, T.total_out += M, T.avail_out -= M, pe.pending -= M, pe.pending === 0 && (pe.pending_out = 0));
      }
      function N(T, pe) {
        s._tr_flush_block(T, 0 <= T.block_start ? T.block_start : -1, T.strstart - T.block_start, pe), T.block_start = T.strstart, q(T.strm);
      }
      function ce(T, pe) {
        T.pending_buf[T.pending++] = pe;
      }
      function me(T, pe) {
        T.pending_buf[T.pending++] = pe >>> 8 & 255, T.pending_buf[T.pending++] = 255 & pe;
      }
      function ve(T, pe) {
        var M, _, S = T.max_chain_length, O = T.strstart, ne = T.prev_length, fe = T.nice_match, J = T.strstart > T.w_size - be ? T.strstart - (T.w_size - be) : 0, re = T.window, de = T.w_mask, ge = T.prev, Ee = T.strstart + le, Ne = re[O + ne - 1], Le = re[O + ne];
        T.prev_length >= T.good_match && (S >>= 2), fe > T.lookahead && (fe = T.lookahead);
        do
          if (re[(M = pe) + ne] === Le && re[M + ne - 1] === Ne && re[M] === re[O] && re[++M] === re[O + 1]) {
            O += 2, M++;
            do
              ;
            while (re[++O] === re[++M] && re[++O] === re[++M] && re[++O] === re[++M] && re[++O] === re[++M] && re[++O] === re[++M] && re[++O] === re[++M] && re[++O] === re[++M] && re[++O] === re[++M] && O < Ee);
            if (_ = le - (Ee - O), O = Ee - le, ne < _) {
              if (T.match_start = pe, fe <= (ne = _)) break;
              Ne = re[O + ne - 1], Le = re[O + ne];
            }
          }
        while ((pe = ge[pe & de]) > J && --S != 0);
        return ne <= T.lookahead ? ne : T.lookahead;
      }
      function he(T) {
        var pe, M, _, S, O, ne, fe, J, re, de, ge = T.w_size;
        do {
          if (S = T.window_size - T.lookahead - T.strstart, T.strstart >= ge + (ge - be)) {
            for (a.arraySet(T.window, T.window, ge, ge, 0), T.match_start -= ge, T.strstart -= ge, T.block_start -= ge, pe = M = T.hash_size; _ = T.head[--pe], T.head[pe] = ge <= _ ? _ - ge : 0, --M; ) ;
            for (pe = M = ge; _ = T.prev[--pe], T.prev[pe] = ge <= _ ? _ - ge : 0, --M; ) ;
            S += ge;
          }
          if (T.strm.avail_in === 0) break;
          if (ne = T.strm, fe = T.window, J = T.strstart + T.lookahead, re = S, de = void 0, de = ne.avail_in, re < de && (de = re), M = de === 0 ? 0 : (ne.avail_in -= de, a.arraySet(fe, ne.input, ne.next_in, de, J), ne.state.wrap === 1 ? ne.adler = l(ne.adler, fe, de, J) : ne.state.wrap === 2 && (ne.adler = c(ne.adler, fe, de, J)), ne.next_in += de, ne.total_in += de, de), T.lookahead += M, T.lookahead + T.insert >= I) for (O = T.strstart - T.insert, T.ins_h = T.window[O], T.ins_h = (T.ins_h << T.hash_shift ^ T.window[O + 1]) & T.hash_mask; T.insert && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[O + I - 1]) & T.hash_mask, T.prev[O & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = O, O++, T.insert--, !(T.lookahead + T.insert < I)); ) ;
        } while (T.lookahead < be && T.strm.avail_in !== 0);
      }
      function H(T, pe) {
        for (var M, _; ; ) {
          if (T.lookahead < be) {
            if (he(T), T.lookahead < be && pe === d) return C;
            if (T.lookahead === 0) break;
          }
          if (M = 0, T.lookahead >= I && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + I - 1]) & T.hash_mask, M = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart), M !== 0 && T.strstart - M <= T.w_size - be && (T.match_length = ve(T, M)), T.match_length >= I) if (_ = s._tr_tally(T, T.strstart - T.match_start, T.match_length - I), T.lookahead -= T.match_length, T.match_length <= T.max_lazy_match && T.lookahead >= I) {
            for (T.match_length--; T.strstart++, T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + I - 1]) & T.hash_mask, M = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart, --T.match_length != 0; ) ;
            T.strstart++;
          } else T.strstart += T.match_length, T.match_length = 0, T.ins_h = T.window[T.strstart], T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + 1]) & T.hash_mask;
          else _ = s._tr_tally(T, 0, T.window[T.strstart]), T.lookahead--, T.strstart++;
          if (_ && (N(T, !1), T.strm.avail_out === 0)) return C;
        }
        return T.insert = T.strstart < I - 1 ? T.strstart : I - 1, pe === f ? (N(T, !0), T.strm.avail_out === 0 ? ee : Z) : T.last_lit && (N(T, !1), T.strm.avail_out === 0) ? C : ie;
      }
      function W(T, pe) {
        for (var M, _, S; ; ) {
          if (T.lookahead < be) {
            if (he(T), T.lookahead < be && pe === d) return C;
            if (T.lookahead === 0) break;
          }
          if (M = 0, T.lookahead >= I && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + I - 1]) & T.hash_mask, M = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart), T.prev_length = T.match_length, T.prev_match = T.match_start, T.match_length = I - 1, M !== 0 && T.prev_length < T.max_lazy_match && T.strstart - M <= T.w_size - be && (T.match_length = ve(T, M), T.match_length <= 5 && (T.strategy === 1 || T.match_length === I && 4096 < T.strstart - T.match_start) && (T.match_length = I - 1)), T.prev_length >= I && T.match_length <= T.prev_length) {
            for (S = T.strstart + T.lookahead - I, _ = s._tr_tally(T, T.strstart - 1 - T.prev_match, T.prev_length - I), T.lookahead -= T.prev_length - 1, T.prev_length -= 2; ++T.strstart <= S && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + I - 1]) & T.hash_mask, M = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart), --T.prev_length != 0; ) ;
            if (T.match_available = 0, T.match_length = I - 1, T.strstart++, _ && (N(T, !1), T.strm.avail_out === 0)) return C;
          } else if (T.match_available) {
            if ((_ = s._tr_tally(T, 0, T.window[T.strstart - 1])) && N(T, !1), T.strstart++, T.lookahead--, T.strm.avail_out === 0) return C;
          } else T.match_available = 1, T.strstart++, T.lookahead--;
        }
        return T.match_available && (_ = s._tr_tally(T, 0, T.window[T.strstart - 1]), T.match_available = 0), T.insert = T.strstart < I - 1 ? T.strstart : I - 1, pe === f ? (N(T, !0), T.strm.avail_out === 0 ? ee : Z) : T.last_lit && (N(T, !1), T.strm.avail_out === 0) ? C : ie;
      }
      function we(T, pe, M, _, S) {
        this.good_length = T, this.max_lazy = pe, this.nice_length = M, this.max_chain = _, this.func = S;
      }
      function ye() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = w, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new a.Buf16(2 * P), this.dyn_dtree = new a.Buf16(2 * (2 * A + 1)), this.bl_tree = new a.Buf16(2 * (2 * U + 1)), _e(this.dyn_ltree), _e(this.dyn_dtree), _e(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new a.Buf16(V + 1), this.heap = new a.Buf16(2 * k + 1), _e(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new a.Buf16(2 * k + 1), _e(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function j(T) {
        var pe;
        return T && T.state ? (T.total_in = T.total_out = 0, T.data_type = y, (pe = T.state).pending = 0, pe.pending_out = 0, pe.wrap < 0 && (pe.wrap = -pe.wrap), pe.status = pe.wrap ? F : G, T.adler = pe.wrap === 2 ? 0 : 1, pe.last_flush = d, s._tr_init(pe), p) : oe(T, m);
      }
      function Q(T) {
        var pe = j(T);
        return pe === p && function(M) {
          M.window_size = 2 * M.w_size, _e(M.head), M.max_lazy_match = o[M.level].max_lazy, M.good_match = o[M.level].good_length, M.nice_match = o[M.level].nice_length, M.max_chain_length = o[M.level].max_chain, M.strstart = 0, M.block_start = 0, M.lookahead = 0, M.insert = 0, M.match_length = M.prev_length = I - 1, M.match_available = 0, M.ins_h = 0;
        }(T.state), pe;
      }
      function De(T, pe, M, _, S, O) {
        if (!T) return m;
        var ne = 1;
        if (pe === g && (pe = 6), _ < 0 ? (ne = 0, _ = -_) : 15 < _ && (ne = 2, _ -= 16), S < 1 || x < S || M !== w || _ < 8 || 15 < _ || pe < 0 || 9 < pe || O < 0 || b < O) return oe(T, m);
        _ === 8 && (_ = 9);
        var fe = new ye();
        return (T.state = fe).strm = T, fe.wrap = ne, fe.gzhead = null, fe.w_bits = _, fe.w_size = 1 << fe.w_bits, fe.w_mask = fe.w_size - 1, fe.hash_bits = S + 7, fe.hash_size = 1 << fe.hash_bits, fe.hash_mask = fe.hash_size - 1, fe.hash_shift = ~~((fe.hash_bits + I - 1) / I), fe.window = new a.Buf8(2 * fe.w_size), fe.head = new a.Buf16(fe.hash_size), fe.prev = new a.Buf16(fe.w_size), fe.lit_bufsize = 1 << S + 6, fe.pending_buf_size = 4 * fe.lit_bufsize, fe.pending_buf = new a.Buf8(fe.pending_buf_size), fe.d_buf = 1 * fe.lit_bufsize, fe.l_buf = 3 * fe.lit_bufsize, fe.level = pe, fe.strategy = O, fe.method = M, Q(T);
      }
      o = [new we(0, 0, 0, 0, function(T, pe) {
        var M = 65535;
        for (M > T.pending_buf_size - 5 && (M = T.pending_buf_size - 5); ; ) {
          if (T.lookahead <= 1) {
            if (he(T), T.lookahead === 0 && pe === d) return C;
            if (T.lookahead === 0) break;
          }
          T.strstart += T.lookahead, T.lookahead = 0;
          var _ = T.block_start + M;
          if ((T.strstart === 0 || T.strstart >= _) && (T.lookahead = T.strstart - _, T.strstart = _, N(T, !1), T.strm.avail_out === 0) || T.strstart - T.block_start >= T.w_size - be && (N(T, !1), T.strm.avail_out === 0)) return C;
        }
        return T.insert = 0, pe === f ? (N(T, !0), T.strm.avail_out === 0 ? ee : Z) : (T.strstart > T.block_start && (N(T, !1), T.strm.avail_out), C);
      }), new we(4, 4, 8, 4, H), new we(4, 5, 16, 8, H), new we(4, 6, 32, 32, H), new we(4, 4, 16, 16, W), new we(8, 16, 32, 32, W), new we(8, 16, 128, 128, W), new we(8, 32, 128, 256, W), new we(32, 128, 258, 1024, W), new we(32, 258, 258, 4096, W)], i.deflateInit = function(T, pe) {
        return De(T, pe, w, 15, 8, 0);
      }, i.deflateInit2 = De, i.deflateReset = Q, i.deflateResetKeep = j, i.deflateSetHeader = function(T, pe) {
        return T && T.state ? T.state.wrap !== 2 ? m : (T.state.gzhead = pe, p) : m;
      }, i.deflate = function(T, pe) {
        var M, _, S, O;
        if (!T || !T.state || 5 < pe || pe < 0) return T ? oe(T, m) : m;
        if (_ = T.state, !T.output || !T.input && T.avail_in !== 0 || _.status === 666 && pe !== f) return oe(T, T.avail_out === 0 ? -5 : m);
        if (_.strm = T, M = _.last_flush, _.last_flush = pe, _.status === F) if (_.wrap === 2) T.adler = 0, ce(_, 31), ce(_, 139), ce(_, 8), _.gzhead ? (ce(_, (_.gzhead.text ? 1 : 0) + (_.gzhead.hcrc ? 2 : 0) + (_.gzhead.extra ? 4 : 0) + (_.gzhead.name ? 8 : 0) + (_.gzhead.comment ? 16 : 0)), ce(_, 255 & _.gzhead.time), ce(_, _.gzhead.time >> 8 & 255), ce(_, _.gzhead.time >> 16 & 255), ce(_, _.gzhead.time >> 24 & 255), ce(_, _.level === 9 ? 2 : 2 <= _.strategy || _.level < 2 ? 4 : 0), ce(_, 255 & _.gzhead.os), _.gzhead.extra && _.gzhead.extra.length && (ce(_, 255 & _.gzhead.extra.length), ce(_, _.gzhead.extra.length >> 8 & 255)), _.gzhead.hcrc && (T.adler = c(T.adler, _.pending_buf, _.pending, 0)), _.gzindex = 0, _.status = 69) : (ce(_, 0), ce(_, 0), ce(_, 0), ce(_, 0), ce(_, 0), ce(_, _.level === 9 ? 2 : 2 <= _.strategy || _.level < 2 ? 4 : 0), ce(_, 3), _.status = G);
        else {
          var ne = w + (_.w_bits - 8 << 4) << 8;
          ne |= (2 <= _.strategy || _.level < 2 ? 0 : _.level < 6 ? 1 : _.level === 6 ? 2 : 3) << 6, _.strstart !== 0 && (ne |= 32), ne += 31 - ne % 31, _.status = G, me(_, ne), _.strstart !== 0 && (me(_, T.adler >>> 16), me(_, 65535 & T.adler)), T.adler = 1;
        }
        if (_.status === 69) if (_.gzhead.extra) {
          for (S = _.pending; _.gzindex < (65535 & _.gzhead.extra.length) && (_.pending !== _.pending_buf_size || (_.gzhead.hcrc && _.pending > S && (T.adler = c(T.adler, _.pending_buf, _.pending - S, S)), q(T), S = _.pending, _.pending !== _.pending_buf_size)); ) ce(_, 255 & _.gzhead.extra[_.gzindex]), _.gzindex++;
          _.gzhead.hcrc && _.pending > S && (T.adler = c(T.adler, _.pending_buf, _.pending - S, S)), _.gzindex === _.gzhead.extra.length && (_.gzindex = 0, _.status = 73);
        } else _.status = 73;
        if (_.status === 73) if (_.gzhead.name) {
          S = _.pending;
          do {
            if (_.pending === _.pending_buf_size && (_.gzhead.hcrc && _.pending > S && (T.adler = c(T.adler, _.pending_buf, _.pending - S, S)), q(T), S = _.pending, _.pending === _.pending_buf_size)) {
              O = 1;
              break;
            }
            O = _.gzindex < _.gzhead.name.length ? 255 & _.gzhead.name.charCodeAt(_.gzindex++) : 0, ce(_, O);
          } while (O !== 0);
          _.gzhead.hcrc && _.pending > S && (T.adler = c(T.adler, _.pending_buf, _.pending - S, S)), O === 0 && (_.gzindex = 0, _.status = 91);
        } else _.status = 91;
        if (_.status === 91) if (_.gzhead.comment) {
          S = _.pending;
          do {
            if (_.pending === _.pending_buf_size && (_.gzhead.hcrc && _.pending > S && (T.adler = c(T.adler, _.pending_buf, _.pending - S, S)), q(T), S = _.pending, _.pending === _.pending_buf_size)) {
              O = 1;
              break;
            }
            O = _.gzindex < _.gzhead.comment.length ? 255 & _.gzhead.comment.charCodeAt(_.gzindex++) : 0, ce(_, O);
          } while (O !== 0);
          _.gzhead.hcrc && _.pending > S && (T.adler = c(T.adler, _.pending_buf, _.pending - S, S)), O === 0 && (_.status = 103);
        } else _.status = 103;
        if (_.status === 103 && (_.gzhead.hcrc ? (_.pending + 2 > _.pending_buf_size && q(T), _.pending + 2 <= _.pending_buf_size && (ce(_, 255 & T.adler), ce(_, T.adler >> 8 & 255), T.adler = 0, _.status = G)) : _.status = G), _.pending !== 0) {
          if (q(T), T.avail_out === 0) return _.last_flush = -1, p;
        } else if (T.avail_in === 0 && te(pe) <= te(M) && pe !== f) return oe(T, -5);
        if (_.status === 666 && T.avail_in !== 0) return oe(T, -5);
        if (T.avail_in !== 0 || _.lookahead !== 0 || pe !== d && _.status !== 666) {
          var fe = _.strategy === 2 ? function(J, re) {
            for (var de; ; ) {
              if (J.lookahead === 0 && (he(J), J.lookahead === 0)) {
                if (re === d) return C;
                break;
              }
              if (J.match_length = 0, de = s._tr_tally(J, 0, J.window[J.strstart]), J.lookahead--, J.strstart++, de && (N(J, !1), J.strm.avail_out === 0)) return C;
            }
            return J.insert = 0, re === f ? (N(J, !0), J.strm.avail_out === 0 ? ee : Z) : J.last_lit && (N(J, !1), J.strm.avail_out === 0) ? C : ie;
          }(_, pe) : _.strategy === 3 ? function(J, re) {
            for (var de, ge, Ee, Ne, Le = J.window; ; ) {
              if (J.lookahead <= le) {
                if (he(J), J.lookahead <= le && re === d) return C;
                if (J.lookahead === 0) break;
              }
              if (J.match_length = 0, J.lookahead >= I && 0 < J.strstart && (ge = Le[Ee = J.strstart - 1]) === Le[++Ee] && ge === Le[++Ee] && ge === Le[++Ee]) {
                Ne = J.strstart + le;
                do
                  ;
                while (ge === Le[++Ee] && ge === Le[++Ee] && ge === Le[++Ee] && ge === Le[++Ee] && ge === Le[++Ee] && ge === Le[++Ee] && ge === Le[++Ee] && ge === Le[++Ee] && Ee < Ne);
                J.match_length = le - (Ne - Ee), J.match_length > J.lookahead && (J.match_length = J.lookahead);
              }
              if (J.match_length >= I ? (de = s._tr_tally(J, 1, J.match_length - I), J.lookahead -= J.match_length, J.strstart += J.match_length, J.match_length = 0) : (de = s._tr_tally(J, 0, J.window[J.strstart]), J.lookahead--, J.strstart++), de && (N(J, !1), J.strm.avail_out === 0)) return C;
            }
            return J.insert = 0, re === f ? (N(J, !0), J.strm.avail_out === 0 ? ee : Z) : J.last_lit && (N(J, !1), J.strm.avail_out === 0) ? C : ie;
          }(_, pe) : o[_.level].func(_, pe);
          if (fe !== ee && fe !== Z || (_.status = 666), fe === C || fe === ee) return T.avail_out === 0 && (_.last_flush = -1), p;
          if (fe === ie && (pe === 1 ? s._tr_align(_) : pe !== 5 && (s._tr_stored_block(_, 0, 0, !1), pe === 3 && (_e(_.head), _.lookahead === 0 && (_.strstart = 0, _.block_start = 0, _.insert = 0))), q(T), T.avail_out === 0)) return _.last_flush = -1, p;
        }
        return pe !== f ? p : _.wrap <= 0 ? 1 : (_.wrap === 2 ? (ce(_, 255 & T.adler), ce(_, T.adler >> 8 & 255), ce(_, T.adler >> 16 & 255), ce(_, T.adler >> 24 & 255), ce(_, 255 & T.total_in), ce(_, T.total_in >> 8 & 255), ce(_, T.total_in >> 16 & 255), ce(_, T.total_in >> 24 & 255)) : (me(_, T.adler >>> 16), me(_, 65535 & T.adler)), q(T), 0 < _.wrap && (_.wrap = -_.wrap), _.pending !== 0 ? p : 1);
      }, i.deflateEnd = function(T) {
        var pe;
        return T && T.state ? (pe = T.state.status) !== F && pe !== 69 && pe !== 73 && pe !== 91 && pe !== 103 && pe !== G && pe !== 666 ? oe(T, m) : (T.state = null, pe === G ? oe(T, -3) : p) : m;
      }, i.deflateSetDictionary = function(T, pe) {
        var M, _, S, O, ne, fe, J, re, de = pe.length;
        if (!T || !T.state || (O = (M = T.state).wrap) === 2 || O === 1 && M.status !== F || M.lookahead) return m;
        for (O === 1 && (T.adler = l(T.adler, pe, de, 0)), M.wrap = 0, de >= M.w_size && (O === 0 && (_e(M.head), M.strstart = 0, M.block_start = 0, M.insert = 0), re = new a.Buf8(M.w_size), a.arraySet(re, pe, de - M.w_size, M.w_size, 0), pe = re, de = M.w_size), ne = T.avail_in, fe = T.next_in, J = T.input, T.avail_in = de, T.next_in = 0, T.input = pe, he(M); M.lookahead >= I; ) {
          for (_ = M.strstart, S = M.lookahead - (I - 1); M.ins_h = (M.ins_h << M.hash_shift ^ M.window[_ + I - 1]) & M.hash_mask, M.prev[_ & M.w_mask] = M.head[M.ins_h], M.head[M.ins_h] = _, _++, --S; ) ;
          M.strstart = _, M.lookahead = I - 1, he(M);
        }
        return M.strstart += M.lookahead, M.block_start = M.strstart, M.insert = M.lookahead, M.lookahead = 0, M.match_length = M.prev_length = I - 1, M.match_available = 0, T.next_in = fe, T.input = J, T.avail_in = ne, M.wrap = O, p;
      }, i.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(n, r, i) {
      r.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(n, r, i) {
      r.exports = function(o, a) {
        var s, l, c, u, d, f, p, m, g, b, y, w, x, k, A, U, P, V, I, le, be, F, G, C, ie;
        s = o.state, l = o.next_in, C = o.input, c = l + (o.avail_in - 5), u = o.next_out, ie = o.output, d = u - (a - o.avail_out), f = u + (o.avail_out - 257), p = s.dmax, m = s.wsize, g = s.whave, b = s.wnext, y = s.window, w = s.hold, x = s.bits, k = s.lencode, A = s.distcode, U = (1 << s.lenbits) - 1, P = (1 << s.distbits) - 1;
        e: do {
          x < 15 && (w += C[l++] << x, x += 8, w += C[l++] << x, x += 8), V = k[w & U];
          t: for (; ; ) {
            if (w >>>= I = V >>> 24, x -= I, (I = V >>> 16 & 255) === 0) ie[u++] = 65535 & V;
            else {
              if (!(16 & I)) {
                if (!(64 & I)) {
                  V = k[(65535 & V) + (w & (1 << I) - 1)];
                  continue t;
                }
                if (32 & I) {
                  s.mode = 12;
                  break e;
                }
                o.msg = "invalid literal/length code", s.mode = 30;
                break e;
              }
              le = 65535 & V, (I &= 15) && (x < I && (w += C[l++] << x, x += 8), le += w & (1 << I) - 1, w >>>= I, x -= I), x < 15 && (w += C[l++] << x, x += 8, w += C[l++] << x, x += 8), V = A[w & P];
              n: for (; ; ) {
                if (w >>>= I = V >>> 24, x -= I, !(16 & (I = V >>> 16 & 255))) {
                  if (!(64 & I)) {
                    V = A[(65535 & V) + (w & (1 << I) - 1)];
                    continue n;
                  }
                  o.msg = "invalid distance code", s.mode = 30;
                  break e;
                }
                if (be = 65535 & V, x < (I &= 15) && (w += C[l++] << x, (x += 8) < I && (w += C[l++] << x, x += 8)), p < (be += w & (1 << I) - 1)) {
                  o.msg = "invalid distance too far back", s.mode = 30;
                  break e;
                }
                if (w >>>= I, x -= I, (I = u - d) < be) {
                  if (g < (I = be - I) && s.sane) {
                    o.msg = "invalid distance too far back", s.mode = 30;
                    break e;
                  }
                  if (G = y, (F = 0) === b) {
                    if (F += m - I, I < le) {
                      for (le -= I; ie[u++] = y[F++], --I; ) ;
                      F = u - be, G = ie;
                    }
                  } else if (b < I) {
                    if (F += m + b - I, (I -= b) < le) {
                      for (le -= I; ie[u++] = y[F++], --I; ) ;
                      if (F = 0, b < le) {
                        for (le -= I = b; ie[u++] = y[F++], --I; ) ;
                        F = u - be, G = ie;
                      }
                    }
                  } else if (F += b - I, I < le) {
                    for (le -= I; ie[u++] = y[F++], --I; ) ;
                    F = u - be, G = ie;
                  }
                  for (; 2 < le; ) ie[u++] = G[F++], ie[u++] = G[F++], ie[u++] = G[F++], le -= 3;
                  le && (ie[u++] = G[F++], 1 < le && (ie[u++] = G[F++]));
                } else {
                  for (F = u - be; ie[u++] = ie[F++], ie[u++] = ie[F++], ie[u++] = ie[F++], 2 < (le -= 3); ) ;
                  le && (ie[u++] = ie[F++], 1 < le && (ie[u++] = ie[F++]));
                }
                break;
              }
            }
            break;
          }
        } while (l < c && u < f);
        l -= le = x >> 3, w &= (1 << (x -= le << 3)) - 1, o.next_in = l, o.next_out = u, o.avail_in = l < c ? c - l + 5 : 5 - (l - c), o.avail_out = u < f ? f - u + 257 : 257 - (u - f), s.hold = w, s.bits = x;
      };
    }, {}], 49: [function(n, r, i) {
      var o = n("../utils/common"), a = n("./adler32"), s = n("./crc32"), l = n("./inffast"), c = n("./inftrees"), u = 1, d = 2, f = 0, p = -2, m = 1, g = 852, b = 592;
      function y(F) {
        return (F >>> 24 & 255) + (F >>> 8 & 65280) + ((65280 & F) << 8) + ((255 & F) << 24);
      }
      function w() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new o.Buf16(320), this.work = new o.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function x(F) {
        var G;
        return F && F.state ? (G = F.state, F.total_in = F.total_out = G.total = 0, F.msg = "", G.wrap && (F.adler = 1 & G.wrap), G.mode = m, G.last = 0, G.havedict = 0, G.dmax = 32768, G.head = null, G.hold = 0, G.bits = 0, G.lencode = G.lendyn = new o.Buf32(g), G.distcode = G.distdyn = new o.Buf32(b), G.sane = 1, G.back = -1, f) : p;
      }
      function k(F) {
        var G;
        return F && F.state ? ((G = F.state).wsize = 0, G.whave = 0, G.wnext = 0, x(F)) : p;
      }
      function A(F, G) {
        var C, ie;
        return F && F.state ? (ie = F.state, G < 0 ? (C = 0, G = -G) : (C = 1 + (G >> 4), G < 48 && (G &= 15)), G && (G < 8 || 15 < G) ? p : (ie.window !== null && ie.wbits !== G && (ie.window = null), ie.wrap = C, ie.wbits = G, k(F))) : p;
      }
      function U(F, G) {
        var C, ie;
        return F ? (ie = new w(), (F.state = ie).window = null, (C = A(F, G)) !== f && (F.state = null), C) : p;
      }
      var P, V, I = !0;
      function le(F) {
        if (I) {
          var G;
          for (P = new o.Buf32(512), V = new o.Buf32(32), G = 0; G < 144; ) F.lens[G++] = 8;
          for (; G < 256; ) F.lens[G++] = 9;
          for (; G < 280; ) F.lens[G++] = 7;
          for (; G < 288; ) F.lens[G++] = 8;
          for (c(u, F.lens, 0, 288, P, 0, F.work, { bits: 9 }), G = 0; G < 32; ) F.lens[G++] = 5;
          c(d, F.lens, 0, 32, V, 0, F.work, { bits: 5 }), I = !1;
        }
        F.lencode = P, F.lenbits = 9, F.distcode = V, F.distbits = 5;
      }
      function be(F, G, C, ie) {
        var ee, Z = F.state;
        return Z.window === null && (Z.wsize = 1 << Z.wbits, Z.wnext = 0, Z.whave = 0, Z.window = new o.Buf8(Z.wsize)), ie >= Z.wsize ? (o.arraySet(Z.window, G, C - Z.wsize, Z.wsize, 0), Z.wnext = 0, Z.whave = Z.wsize) : (ie < (ee = Z.wsize - Z.wnext) && (ee = ie), o.arraySet(Z.window, G, C - ie, ee, Z.wnext), (ie -= ee) ? (o.arraySet(Z.window, G, C - ie, ie, 0), Z.wnext = ie, Z.whave = Z.wsize) : (Z.wnext += ee, Z.wnext === Z.wsize && (Z.wnext = 0), Z.whave < Z.wsize && (Z.whave += ee))), 0;
      }
      i.inflateReset = k, i.inflateReset2 = A, i.inflateResetKeep = x, i.inflateInit = function(F) {
        return U(F, 15);
      }, i.inflateInit2 = U, i.inflate = function(F, G) {
        var C, ie, ee, Z, oe, te, _e, q, N, ce, me, ve, he, H, W, we, ye, j, Q, De, T, pe, M, _, S = 0, O = new o.Buf8(4), ne = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!F || !F.state || !F.output || !F.input && F.avail_in !== 0) return p;
        (C = F.state).mode === 12 && (C.mode = 13), oe = F.next_out, ee = F.output, _e = F.avail_out, Z = F.next_in, ie = F.input, te = F.avail_in, q = C.hold, N = C.bits, ce = te, me = _e, pe = f;
        e: for (; ; ) switch (C.mode) {
          case m:
            if (C.wrap === 0) {
              C.mode = 13;
              break;
            }
            for (; N < 16; ) {
              if (te === 0) break e;
              te--, q += ie[Z++] << N, N += 8;
            }
            if (2 & C.wrap && q === 35615) {
              O[C.check = 0] = 255 & q, O[1] = q >>> 8 & 255, C.check = s(C.check, O, 2, 0), N = q = 0, C.mode = 2;
              break;
            }
            if (C.flags = 0, C.head && (C.head.done = !1), !(1 & C.wrap) || (((255 & q) << 8) + (q >> 8)) % 31) {
              F.msg = "incorrect header check", C.mode = 30;
              break;
            }
            if ((15 & q) != 8) {
              F.msg = "unknown compression method", C.mode = 30;
              break;
            }
            if (N -= 4, T = 8 + (15 & (q >>>= 4)), C.wbits === 0) C.wbits = T;
            else if (T > C.wbits) {
              F.msg = "invalid window size", C.mode = 30;
              break;
            }
            C.dmax = 1 << T, F.adler = C.check = 1, C.mode = 512 & q ? 10 : 12, N = q = 0;
            break;
          case 2:
            for (; N < 16; ) {
              if (te === 0) break e;
              te--, q += ie[Z++] << N, N += 8;
            }
            if (C.flags = q, (255 & C.flags) != 8) {
              F.msg = "unknown compression method", C.mode = 30;
              break;
            }
            if (57344 & C.flags) {
              F.msg = "unknown header flags set", C.mode = 30;
              break;
            }
            C.head && (C.head.text = q >> 8 & 1), 512 & C.flags && (O[0] = 255 & q, O[1] = q >>> 8 & 255, C.check = s(C.check, O, 2, 0)), N = q = 0, C.mode = 3;
          case 3:
            for (; N < 32; ) {
              if (te === 0) break e;
              te--, q += ie[Z++] << N, N += 8;
            }
            C.head && (C.head.time = q), 512 & C.flags && (O[0] = 255 & q, O[1] = q >>> 8 & 255, O[2] = q >>> 16 & 255, O[3] = q >>> 24 & 255, C.check = s(C.check, O, 4, 0)), N = q = 0, C.mode = 4;
          case 4:
            for (; N < 16; ) {
              if (te === 0) break e;
              te--, q += ie[Z++] << N, N += 8;
            }
            C.head && (C.head.xflags = 255 & q, C.head.os = q >> 8), 512 & C.flags && (O[0] = 255 & q, O[1] = q >>> 8 & 255, C.check = s(C.check, O, 2, 0)), N = q = 0, C.mode = 5;
          case 5:
            if (1024 & C.flags) {
              for (; N < 16; ) {
                if (te === 0) break e;
                te--, q += ie[Z++] << N, N += 8;
              }
              C.length = q, C.head && (C.head.extra_len = q), 512 & C.flags && (O[0] = 255 & q, O[1] = q >>> 8 & 255, C.check = s(C.check, O, 2, 0)), N = q = 0;
            } else C.head && (C.head.extra = null);
            C.mode = 6;
          case 6:
            if (1024 & C.flags && (te < (ve = C.length) && (ve = te), ve && (C.head && (T = C.head.extra_len - C.length, C.head.extra || (C.head.extra = new Array(C.head.extra_len)), o.arraySet(C.head.extra, ie, Z, ve, T)), 512 & C.flags && (C.check = s(C.check, ie, ve, Z)), te -= ve, Z += ve, C.length -= ve), C.length)) break e;
            C.length = 0, C.mode = 7;
          case 7:
            if (2048 & C.flags) {
              if (te === 0) break e;
              for (ve = 0; T = ie[Z + ve++], C.head && T && C.length < 65536 && (C.head.name += String.fromCharCode(T)), T && ve < te; ) ;
              if (512 & C.flags && (C.check = s(C.check, ie, ve, Z)), te -= ve, Z += ve, T) break e;
            } else C.head && (C.head.name = null);
            C.length = 0, C.mode = 8;
          case 8:
            if (4096 & C.flags) {
              if (te === 0) break e;
              for (ve = 0; T = ie[Z + ve++], C.head && T && C.length < 65536 && (C.head.comment += String.fromCharCode(T)), T && ve < te; ) ;
              if (512 & C.flags && (C.check = s(C.check, ie, ve, Z)), te -= ve, Z += ve, T) break e;
            } else C.head && (C.head.comment = null);
            C.mode = 9;
          case 9:
            if (512 & C.flags) {
              for (; N < 16; ) {
                if (te === 0) break e;
                te--, q += ie[Z++] << N, N += 8;
              }
              if (q !== (65535 & C.check)) {
                F.msg = "header crc mismatch", C.mode = 30;
                break;
              }
              N = q = 0;
            }
            C.head && (C.head.hcrc = C.flags >> 9 & 1, C.head.done = !0), F.adler = C.check = 0, C.mode = 12;
            break;
          case 10:
            for (; N < 32; ) {
              if (te === 0) break e;
              te--, q += ie[Z++] << N, N += 8;
            }
            F.adler = C.check = y(q), N = q = 0, C.mode = 11;
          case 11:
            if (C.havedict === 0) return F.next_out = oe, F.avail_out = _e, F.next_in = Z, F.avail_in = te, C.hold = q, C.bits = N, 2;
            F.adler = C.check = 1, C.mode = 12;
          case 12:
            if (G === 5 || G === 6) break e;
          case 13:
            if (C.last) {
              q >>>= 7 & N, N -= 7 & N, C.mode = 27;
              break;
            }
            for (; N < 3; ) {
              if (te === 0) break e;
              te--, q += ie[Z++] << N, N += 8;
            }
            switch (C.last = 1 & q, N -= 1, 3 & (q >>>= 1)) {
              case 0:
                C.mode = 14;
                break;
              case 1:
                if (le(C), C.mode = 20, G !== 6) break;
                q >>>= 2, N -= 2;
                break e;
              case 2:
                C.mode = 17;
                break;
              case 3:
                F.msg = "invalid block type", C.mode = 30;
            }
            q >>>= 2, N -= 2;
            break;
          case 14:
            for (q >>>= 7 & N, N -= 7 & N; N < 32; ) {
              if (te === 0) break e;
              te--, q += ie[Z++] << N, N += 8;
            }
            if ((65535 & q) != (q >>> 16 ^ 65535)) {
              F.msg = "invalid stored block lengths", C.mode = 30;
              break;
            }
            if (C.length = 65535 & q, N = q = 0, C.mode = 15, G === 6) break e;
          case 15:
            C.mode = 16;
          case 16:
            if (ve = C.length) {
              if (te < ve && (ve = te), _e < ve && (ve = _e), ve === 0) break e;
              o.arraySet(ee, ie, Z, ve, oe), te -= ve, Z += ve, _e -= ve, oe += ve, C.length -= ve;
              break;
            }
            C.mode = 12;
            break;
          case 17:
            for (; N < 14; ) {
              if (te === 0) break e;
              te--, q += ie[Z++] << N, N += 8;
            }
            if (C.nlen = 257 + (31 & q), q >>>= 5, N -= 5, C.ndist = 1 + (31 & q), q >>>= 5, N -= 5, C.ncode = 4 + (15 & q), q >>>= 4, N -= 4, 286 < C.nlen || 30 < C.ndist) {
              F.msg = "too many length or distance symbols", C.mode = 30;
              break;
            }
            C.have = 0, C.mode = 18;
          case 18:
            for (; C.have < C.ncode; ) {
              for (; N < 3; ) {
                if (te === 0) break e;
                te--, q += ie[Z++] << N, N += 8;
              }
              C.lens[ne[C.have++]] = 7 & q, q >>>= 3, N -= 3;
            }
            for (; C.have < 19; ) C.lens[ne[C.have++]] = 0;
            if (C.lencode = C.lendyn, C.lenbits = 7, M = { bits: C.lenbits }, pe = c(0, C.lens, 0, 19, C.lencode, 0, C.work, M), C.lenbits = M.bits, pe) {
              F.msg = "invalid code lengths set", C.mode = 30;
              break;
            }
            C.have = 0, C.mode = 19;
          case 19:
            for (; C.have < C.nlen + C.ndist; ) {
              for (; we = (S = C.lencode[q & (1 << C.lenbits) - 1]) >>> 16 & 255, ye = 65535 & S, !((W = S >>> 24) <= N); ) {
                if (te === 0) break e;
                te--, q += ie[Z++] << N, N += 8;
              }
              if (ye < 16) q >>>= W, N -= W, C.lens[C.have++] = ye;
              else {
                if (ye === 16) {
                  for (_ = W + 2; N < _; ) {
                    if (te === 0) break e;
                    te--, q += ie[Z++] << N, N += 8;
                  }
                  if (q >>>= W, N -= W, C.have === 0) {
                    F.msg = "invalid bit length repeat", C.mode = 30;
                    break;
                  }
                  T = C.lens[C.have - 1], ve = 3 + (3 & q), q >>>= 2, N -= 2;
                } else if (ye === 17) {
                  for (_ = W + 3; N < _; ) {
                    if (te === 0) break e;
                    te--, q += ie[Z++] << N, N += 8;
                  }
                  N -= W, T = 0, ve = 3 + (7 & (q >>>= W)), q >>>= 3, N -= 3;
                } else {
                  for (_ = W + 7; N < _; ) {
                    if (te === 0) break e;
                    te--, q += ie[Z++] << N, N += 8;
                  }
                  N -= W, T = 0, ve = 11 + (127 & (q >>>= W)), q >>>= 7, N -= 7;
                }
                if (C.have + ve > C.nlen + C.ndist) {
                  F.msg = "invalid bit length repeat", C.mode = 30;
                  break;
                }
                for (; ve--; ) C.lens[C.have++] = T;
              }
            }
            if (C.mode === 30) break;
            if (C.lens[256] === 0) {
              F.msg = "invalid code -- missing end-of-block", C.mode = 30;
              break;
            }
            if (C.lenbits = 9, M = { bits: C.lenbits }, pe = c(u, C.lens, 0, C.nlen, C.lencode, 0, C.work, M), C.lenbits = M.bits, pe) {
              F.msg = "invalid literal/lengths set", C.mode = 30;
              break;
            }
            if (C.distbits = 6, C.distcode = C.distdyn, M = { bits: C.distbits }, pe = c(d, C.lens, C.nlen, C.ndist, C.distcode, 0, C.work, M), C.distbits = M.bits, pe) {
              F.msg = "invalid distances set", C.mode = 30;
              break;
            }
            if (C.mode = 20, G === 6) break e;
          case 20:
            C.mode = 21;
          case 21:
            if (6 <= te && 258 <= _e) {
              F.next_out = oe, F.avail_out = _e, F.next_in = Z, F.avail_in = te, C.hold = q, C.bits = N, l(F, me), oe = F.next_out, ee = F.output, _e = F.avail_out, Z = F.next_in, ie = F.input, te = F.avail_in, q = C.hold, N = C.bits, C.mode === 12 && (C.back = -1);
              break;
            }
            for (C.back = 0; we = (S = C.lencode[q & (1 << C.lenbits) - 1]) >>> 16 & 255, ye = 65535 & S, !((W = S >>> 24) <= N); ) {
              if (te === 0) break e;
              te--, q += ie[Z++] << N, N += 8;
            }
            if (we && !(240 & we)) {
              for (j = W, Q = we, De = ye; we = (S = C.lencode[De + ((q & (1 << j + Q) - 1) >> j)]) >>> 16 & 255, ye = 65535 & S, !(j + (W = S >>> 24) <= N); ) {
                if (te === 0) break e;
                te--, q += ie[Z++] << N, N += 8;
              }
              q >>>= j, N -= j, C.back += j;
            }
            if (q >>>= W, N -= W, C.back += W, C.length = ye, we === 0) {
              C.mode = 26;
              break;
            }
            if (32 & we) {
              C.back = -1, C.mode = 12;
              break;
            }
            if (64 & we) {
              F.msg = "invalid literal/length code", C.mode = 30;
              break;
            }
            C.extra = 15 & we, C.mode = 22;
          case 22:
            if (C.extra) {
              for (_ = C.extra; N < _; ) {
                if (te === 0) break e;
                te--, q += ie[Z++] << N, N += 8;
              }
              C.length += q & (1 << C.extra) - 1, q >>>= C.extra, N -= C.extra, C.back += C.extra;
            }
            C.was = C.length, C.mode = 23;
          case 23:
            for (; we = (S = C.distcode[q & (1 << C.distbits) - 1]) >>> 16 & 255, ye = 65535 & S, !((W = S >>> 24) <= N); ) {
              if (te === 0) break e;
              te--, q += ie[Z++] << N, N += 8;
            }
            if (!(240 & we)) {
              for (j = W, Q = we, De = ye; we = (S = C.distcode[De + ((q & (1 << j + Q) - 1) >> j)]) >>> 16 & 255, ye = 65535 & S, !(j + (W = S >>> 24) <= N); ) {
                if (te === 0) break e;
                te--, q += ie[Z++] << N, N += 8;
              }
              q >>>= j, N -= j, C.back += j;
            }
            if (q >>>= W, N -= W, C.back += W, 64 & we) {
              F.msg = "invalid distance code", C.mode = 30;
              break;
            }
            C.offset = ye, C.extra = 15 & we, C.mode = 24;
          case 24:
            if (C.extra) {
              for (_ = C.extra; N < _; ) {
                if (te === 0) break e;
                te--, q += ie[Z++] << N, N += 8;
              }
              C.offset += q & (1 << C.extra) - 1, q >>>= C.extra, N -= C.extra, C.back += C.extra;
            }
            if (C.offset > C.dmax) {
              F.msg = "invalid distance too far back", C.mode = 30;
              break;
            }
            C.mode = 25;
          case 25:
            if (_e === 0) break e;
            if (ve = me - _e, C.offset > ve) {
              if ((ve = C.offset - ve) > C.whave && C.sane) {
                F.msg = "invalid distance too far back", C.mode = 30;
                break;
              }
              he = ve > C.wnext ? (ve -= C.wnext, C.wsize - ve) : C.wnext - ve, ve > C.length && (ve = C.length), H = C.window;
            } else H = ee, he = oe - C.offset, ve = C.length;
            for (_e < ve && (ve = _e), _e -= ve, C.length -= ve; ee[oe++] = H[he++], --ve; ) ;
            C.length === 0 && (C.mode = 21);
            break;
          case 26:
            if (_e === 0) break e;
            ee[oe++] = C.length, _e--, C.mode = 21;
            break;
          case 27:
            if (C.wrap) {
              for (; N < 32; ) {
                if (te === 0) break e;
                te--, q |= ie[Z++] << N, N += 8;
              }
              if (me -= _e, F.total_out += me, C.total += me, me && (F.adler = C.check = C.flags ? s(C.check, ee, me, oe - me) : a(C.check, ee, me, oe - me)), me = _e, (C.flags ? q : y(q)) !== C.check) {
                F.msg = "incorrect data check", C.mode = 30;
                break;
              }
              N = q = 0;
            }
            C.mode = 28;
          case 28:
            if (C.wrap && C.flags) {
              for (; N < 32; ) {
                if (te === 0) break e;
                te--, q += ie[Z++] << N, N += 8;
              }
              if (q !== (4294967295 & C.total)) {
                F.msg = "incorrect length check", C.mode = 30;
                break;
              }
              N = q = 0;
            }
            C.mode = 29;
          case 29:
            pe = 1;
            break e;
          case 30:
            pe = -3;
            break e;
          case 31:
            return -4;
          case 32:
          default:
            return p;
        }
        return F.next_out = oe, F.avail_out = _e, F.next_in = Z, F.avail_in = te, C.hold = q, C.bits = N, (C.wsize || me !== F.avail_out && C.mode < 30 && (C.mode < 27 || G !== 4)) && be(F, F.output, F.next_out, me - F.avail_out) ? (C.mode = 31, -4) : (ce -= F.avail_in, me -= F.avail_out, F.total_in += ce, F.total_out += me, C.total += me, C.wrap && me && (F.adler = C.check = C.flags ? s(C.check, ee, me, F.next_out - me) : a(C.check, ee, me, F.next_out - me)), F.data_type = C.bits + (C.last ? 64 : 0) + (C.mode === 12 ? 128 : 0) + (C.mode === 20 || C.mode === 15 ? 256 : 0), (ce == 0 && me === 0 || G === 4) && pe === f && (pe = -5), pe);
      }, i.inflateEnd = function(F) {
        if (!F || !F.state) return p;
        var G = F.state;
        return G.window && (G.window = null), F.state = null, f;
      }, i.inflateGetHeader = function(F, G) {
        var C;
        return F && F.state && 2 & (C = F.state).wrap ? ((C.head = G).done = !1, f) : p;
      }, i.inflateSetDictionary = function(F, G) {
        var C, ie = G.length;
        return F && F.state ? (C = F.state).wrap !== 0 && C.mode !== 11 ? p : C.mode === 11 && a(1, G, ie, 0) !== C.check ? -3 : be(F, G, ie, ie) ? (C.mode = 31, -4) : (C.havedict = 1, f) : p;
      }, i.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(n, r, i) {
      var o = n("../utils/common"), a = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], s = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      r.exports = function(u, d, f, p, m, g, b, y) {
        var w, x, k, A, U, P, V, I, le, be = y.bits, F = 0, G = 0, C = 0, ie = 0, ee = 0, Z = 0, oe = 0, te = 0, _e = 0, q = 0, N = null, ce = 0, me = new o.Buf16(16), ve = new o.Buf16(16), he = null, H = 0;
        for (F = 0; F <= 15; F++) me[F] = 0;
        for (G = 0; G < p; G++) me[d[f + G]]++;
        for (ee = be, ie = 15; 1 <= ie && me[ie] === 0; ie--) ;
        if (ie < ee && (ee = ie), ie === 0) return m[g++] = 20971520, m[g++] = 20971520, y.bits = 1, 0;
        for (C = 1; C < ie && me[C] === 0; C++) ;
        for (ee < C && (ee = C), F = te = 1; F <= 15; F++) if (te <<= 1, (te -= me[F]) < 0) return -1;
        if (0 < te && (u === 0 || ie !== 1)) return -1;
        for (ve[1] = 0, F = 1; F < 15; F++) ve[F + 1] = ve[F] + me[F];
        for (G = 0; G < p; G++) d[f + G] !== 0 && (b[ve[d[f + G]]++] = G);
        if (P = u === 0 ? (N = he = b, 19) : u === 1 ? (N = a, ce -= 257, he = s, H -= 257, 256) : (N = l, he = c, -1), F = C, U = g, oe = G = q = 0, k = -1, A = (_e = 1 << (Z = ee)) - 1, u === 1 && 852 < _e || u === 2 && 592 < _e) return 1;
        for (; ; ) {
          for (V = F - oe, le = b[G] < P ? (I = 0, b[G]) : b[G] > P ? (I = he[H + b[G]], N[ce + b[G]]) : (I = 96, 0), w = 1 << F - oe, C = x = 1 << Z; m[U + (q >> oe) + (x -= w)] = V << 24 | I << 16 | le | 0, x !== 0; ) ;
          for (w = 1 << F - 1; q & w; ) w >>= 1;
          if (w !== 0 ? (q &= w - 1, q += w) : q = 0, G++, --me[F] == 0) {
            if (F === ie) break;
            F = d[f + b[G]];
          }
          if (ee < F && (q & A) !== k) {
            for (oe === 0 && (oe = ee), U += C, te = 1 << (Z = F - oe); Z + oe < ie && !((te -= me[Z + oe]) <= 0); ) Z++, te <<= 1;
            if (_e += 1 << Z, u === 1 && 852 < _e || u === 2 && 592 < _e) return 1;
            m[k = q & A] = ee << 24 | Z << 16 | U - g | 0;
          }
        }
        return q !== 0 && (m[U + q] = F - oe << 24 | 64 << 16 | 0), y.bits = ee, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(n, r, i) {
      r.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(n, r, i) {
      var o = n("../utils/common"), a = 0, s = 1;
      function l(S) {
        for (var O = S.length; 0 <= --O; ) S[O] = 0;
      }
      var c = 0, u = 29, d = 256, f = d + 1 + u, p = 30, m = 19, g = 2 * f + 1, b = 15, y = 16, w = 7, x = 256, k = 16, A = 17, U = 18, P = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], V = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], I = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], le = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], be = new Array(2 * (f + 2));
      l(be);
      var F = new Array(2 * p);
      l(F);
      var G = new Array(512);
      l(G);
      var C = new Array(256);
      l(C);
      var ie = new Array(u);
      l(ie);
      var ee, Z, oe, te = new Array(p);
      function _e(S, O, ne, fe, J) {
        this.static_tree = S, this.extra_bits = O, this.extra_base = ne, this.elems = fe, this.max_length = J, this.has_stree = S && S.length;
      }
      function q(S, O) {
        this.dyn_tree = S, this.max_code = 0, this.stat_desc = O;
      }
      function N(S) {
        return S < 256 ? G[S] : G[256 + (S >>> 7)];
      }
      function ce(S, O) {
        S.pending_buf[S.pending++] = 255 & O, S.pending_buf[S.pending++] = O >>> 8 & 255;
      }
      function me(S, O, ne) {
        S.bi_valid > y - ne ? (S.bi_buf |= O << S.bi_valid & 65535, ce(S, S.bi_buf), S.bi_buf = O >> y - S.bi_valid, S.bi_valid += ne - y) : (S.bi_buf |= O << S.bi_valid & 65535, S.bi_valid += ne);
      }
      function ve(S, O, ne) {
        me(S, ne[2 * O], ne[2 * O + 1]);
      }
      function he(S, O) {
        for (var ne = 0; ne |= 1 & S, S >>>= 1, ne <<= 1, 0 < --O; ) ;
        return ne >>> 1;
      }
      function H(S, O, ne) {
        var fe, J, re = new Array(b + 1), de = 0;
        for (fe = 1; fe <= b; fe++) re[fe] = de = de + ne[fe - 1] << 1;
        for (J = 0; J <= O; J++) {
          var ge = S[2 * J + 1];
          ge !== 0 && (S[2 * J] = he(re[ge]++, ge));
        }
      }
      function W(S) {
        var O;
        for (O = 0; O < f; O++) S.dyn_ltree[2 * O] = 0;
        for (O = 0; O < p; O++) S.dyn_dtree[2 * O] = 0;
        for (O = 0; O < m; O++) S.bl_tree[2 * O] = 0;
        S.dyn_ltree[2 * x] = 1, S.opt_len = S.static_len = 0, S.last_lit = S.matches = 0;
      }
      function we(S) {
        8 < S.bi_valid ? ce(S, S.bi_buf) : 0 < S.bi_valid && (S.pending_buf[S.pending++] = S.bi_buf), S.bi_buf = 0, S.bi_valid = 0;
      }
      function ye(S, O, ne, fe) {
        var J = 2 * O, re = 2 * ne;
        return S[J] < S[re] || S[J] === S[re] && fe[O] <= fe[ne];
      }
      function j(S, O, ne) {
        for (var fe = S.heap[ne], J = ne << 1; J <= S.heap_len && (J < S.heap_len && ye(O, S.heap[J + 1], S.heap[J], S.depth) && J++, !ye(O, fe, S.heap[J], S.depth)); ) S.heap[ne] = S.heap[J], ne = J, J <<= 1;
        S.heap[ne] = fe;
      }
      function Q(S, O, ne) {
        var fe, J, re, de, ge = 0;
        if (S.last_lit !== 0) for (; fe = S.pending_buf[S.d_buf + 2 * ge] << 8 | S.pending_buf[S.d_buf + 2 * ge + 1], J = S.pending_buf[S.l_buf + ge], ge++, fe === 0 ? ve(S, J, O) : (ve(S, (re = C[J]) + d + 1, O), (de = P[re]) !== 0 && me(S, J -= ie[re], de), ve(S, re = N(--fe), ne), (de = V[re]) !== 0 && me(S, fe -= te[re], de)), ge < S.last_lit; ) ;
        ve(S, x, O);
      }
      function De(S, O) {
        var ne, fe, J, re = O.dyn_tree, de = O.stat_desc.static_tree, ge = O.stat_desc.has_stree, Ee = O.stat_desc.elems, Ne = -1;
        for (S.heap_len = 0, S.heap_max = g, ne = 0; ne < Ee; ne++) re[2 * ne] !== 0 ? (S.heap[++S.heap_len] = Ne = ne, S.depth[ne] = 0) : re[2 * ne + 1] = 0;
        for (; S.heap_len < 2; ) re[2 * (J = S.heap[++S.heap_len] = Ne < 2 ? ++Ne : 0)] = 1, S.depth[J] = 0, S.opt_len--, ge && (S.static_len -= de[2 * J + 1]);
        for (O.max_code = Ne, ne = S.heap_len >> 1; 1 <= ne; ne--) j(S, re, ne);
        for (J = Ee; ne = S.heap[1], S.heap[1] = S.heap[S.heap_len--], j(S, re, 1), fe = S.heap[1], S.heap[--S.heap_max] = ne, S.heap[--S.heap_max] = fe, re[2 * J] = re[2 * ne] + re[2 * fe], S.depth[J] = (S.depth[ne] >= S.depth[fe] ? S.depth[ne] : S.depth[fe]) + 1, re[2 * ne + 1] = re[2 * fe + 1] = J, S.heap[1] = J++, j(S, re, 1), 2 <= S.heap_len; ) ;
        S.heap[--S.heap_max] = S.heap[1], function(Le, Qe) {
          var Ze, at, gt, et, Zt, Un, Ft = Qe.dyn_tree, Ar = Qe.max_code, Ii = Qe.stat_desc.static_tree, xn = Qe.stat_desc.has_stree, Bn = Qe.stat_desc.extra_bits, Ln = Qe.stat_desc.extra_base, ht = Qe.stat_desc.max_length, _n = 0;
          for (et = 0; et <= b; et++) Le.bl_count[et] = 0;
          for (Ft[2 * Le.heap[Le.heap_max] + 1] = 0, Ze = Le.heap_max + 1; Ze < g; Ze++) ht < (et = Ft[2 * Ft[2 * (at = Le.heap[Ze]) + 1] + 1] + 1) && (et = ht, _n++), Ft[2 * at + 1] = et, Ar < at || (Le.bl_count[et]++, Zt = 0, Ln <= at && (Zt = Bn[at - Ln]), Un = Ft[2 * at], Le.opt_len += Un * (et + Zt), xn && (Le.static_len += Un * (Ii[2 * at + 1] + Zt)));
          if (_n !== 0) {
            do {
              for (et = ht - 1; Le.bl_count[et] === 0; ) et--;
              Le.bl_count[et]--, Le.bl_count[et + 1] += 2, Le.bl_count[ht]--, _n -= 2;
            } while (0 < _n);
            for (et = ht; et !== 0; et--) for (at = Le.bl_count[et]; at !== 0; ) Ar < (gt = Le.heap[--Ze]) || (Ft[2 * gt + 1] !== et && (Le.opt_len += (et - Ft[2 * gt + 1]) * Ft[2 * gt], Ft[2 * gt + 1] = et), at--);
          }
        }(S, O), H(re, Ne, S.bl_count);
      }
      function T(S, O, ne) {
        var fe, J, re = -1, de = O[1], ge = 0, Ee = 7, Ne = 4;
        for (de === 0 && (Ee = 138, Ne = 3), O[2 * (ne + 1) + 1] = 65535, fe = 0; fe <= ne; fe++) J = de, de = O[2 * (fe + 1) + 1], ++ge < Ee && J === de || (ge < Ne ? S.bl_tree[2 * J] += ge : J !== 0 ? (J !== re && S.bl_tree[2 * J]++, S.bl_tree[2 * k]++) : ge <= 10 ? S.bl_tree[2 * A]++ : S.bl_tree[2 * U]++, re = J, Ne = (ge = 0) === de ? (Ee = 138, 3) : J === de ? (Ee = 6, 3) : (Ee = 7, 4));
      }
      function pe(S, O, ne) {
        var fe, J, re = -1, de = O[1], ge = 0, Ee = 7, Ne = 4;
        for (de === 0 && (Ee = 138, Ne = 3), fe = 0; fe <= ne; fe++) if (J = de, de = O[2 * (fe + 1) + 1], !(++ge < Ee && J === de)) {
          if (ge < Ne) for (; ve(S, J, S.bl_tree), --ge != 0; ) ;
          else J !== 0 ? (J !== re && (ve(S, J, S.bl_tree), ge--), ve(S, k, S.bl_tree), me(S, ge - 3, 2)) : ge <= 10 ? (ve(S, A, S.bl_tree), me(S, ge - 3, 3)) : (ve(S, U, S.bl_tree), me(S, ge - 11, 7));
          re = J, Ne = (ge = 0) === de ? (Ee = 138, 3) : J === de ? (Ee = 6, 3) : (Ee = 7, 4);
        }
      }
      l(te);
      var M = !1;
      function _(S, O, ne, fe) {
        me(S, (c << 1) + (fe ? 1 : 0), 3), function(J, re, de, ge) {
          we(J), ce(J, de), ce(J, ~de), o.arraySet(J.pending_buf, J.window, re, de, J.pending), J.pending += de;
        }(S, O, ne);
      }
      i._tr_init = function(S) {
        M || (function() {
          var O, ne, fe, J, re, de = new Array(b + 1);
          for (J = fe = 0; J < u - 1; J++) for (ie[J] = fe, O = 0; O < 1 << P[J]; O++) C[fe++] = J;
          for (C[fe - 1] = J, J = re = 0; J < 16; J++) for (te[J] = re, O = 0; O < 1 << V[J]; O++) G[re++] = J;
          for (re >>= 7; J < p; J++) for (te[J] = re << 7, O = 0; O < 1 << V[J] - 7; O++) G[256 + re++] = J;
          for (ne = 0; ne <= b; ne++) de[ne] = 0;
          for (O = 0; O <= 143; ) be[2 * O + 1] = 8, O++, de[8]++;
          for (; O <= 255; ) be[2 * O + 1] = 9, O++, de[9]++;
          for (; O <= 279; ) be[2 * O + 1] = 7, O++, de[7]++;
          for (; O <= 287; ) be[2 * O + 1] = 8, O++, de[8]++;
          for (H(be, f + 1, de), O = 0; O < p; O++) F[2 * O + 1] = 5, F[2 * O] = he(O, 5);
          ee = new _e(be, P, d + 1, f, b), Z = new _e(F, V, 0, p, b), oe = new _e(new Array(0), I, 0, m, w);
        }(), M = !0), S.l_desc = new q(S.dyn_ltree, ee), S.d_desc = new q(S.dyn_dtree, Z), S.bl_desc = new q(S.bl_tree, oe), S.bi_buf = 0, S.bi_valid = 0, W(S);
      }, i._tr_stored_block = _, i._tr_flush_block = function(S, O, ne, fe) {
        var J, re, de = 0;
        0 < S.level ? (S.strm.data_type === 2 && (S.strm.data_type = function(ge) {
          var Ee, Ne = 4093624447;
          for (Ee = 0; Ee <= 31; Ee++, Ne >>>= 1) if (1 & Ne && ge.dyn_ltree[2 * Ee] !== 0) return a;
          if (ge.dyn_ltree[18] !== 0 || ge.dyn_ltree[20] !== 0 || ge.dyn_ltree[26] !== 0) return s;
          for (Ee = 32; Ee < d; Ee++) if (ge.dyn_ltree[2 * Ee] !== 0) return s;
          return a;
        }(S)), De(S, S.l_desc), De(S, S.d_desc), de = function(ge) {
          var Ee;
          for (T(ge, ge.dyn_ltree, ge.l_desc.max_code), T(ge, ge.dyn_dtree, ge.d_desc.max_code), De(ge, ge.bl_desc), Ee = m - 1; 3 <= Ee && ge.bl_tree[2 * le[Ee] + 1] === 0; Ee--) ;
          return ge.opt_len += 3 * (Ee + 1) + 5 + 5 + 4, Ee;
        }(S), J = S.opt_len + 3 + 7 >>> 3, (re = S.static_len + 3 + 7 >>> 3) <= J && (J = re)) : J = re = ne + 5, ne + 4 <= J && O !== -1 ? _(S, O, ne, fe) : S.strategy === 4 || re === J ? (me(S, 2 + (fe ? 1 : 0), 3), Q(S, be, F)) : (me(S, 4 + (fe ? 1 : 0), 3), function(ge, Ee, Ne, Le) {
          var Qe;
          for (me(ge, Ee - 257, 5), me(ge, Ne - 1, 5), me(ge, Le - 4, 4), Qe = 0; Qe < Le; Qe++) me(ge, ge.bl_tree[2 * le[Qe] + 1], 3);
          pe(ge, ge.dyn_ltree, Ee - 1), pe(ge, ge.dyn_dtree, Ne - 1);
        }(S, S.l_desc.max_code + 1, S.d_desc.max_code + 1, de + 1), Q(S, S.dyn_ltree, S.dyn_dtree)), W(S), fe && we(S);
      }, i._tr_tally = function(S, O, ne) {
        return S.pending_buf[S.d_buf + 2 * S.last_lit] = O >>> 8 & 255, S.pending_buf[S.d_buf + 2 * S.last_lit + 1] = 255 & O, S.pending_buf[S.l_buf + S.last_lit] = 255 & ne, S.last_lit++, O === 0 ? S.dyn_ltree[2 * ne]++ : (S.matches++, O--, S.dyn_ltree[2 * (C[ne] + d + 1)]++, S.dyn_dtree[2 * N(O)]++), S.last_lit === S.lit_bufsize - 1;
      }, i._tr_align = function(S) {
        me(S, 2, 3), ve(S, x, be), function(O) {
          O.bi_valid === 16 ? (ce(O, O.bi_buf), O.bi_buf = 0, O.bi_valid = 0) : 8 <= O.bi_valid && (O.pending_buf[O.pending++] = 255 & O.bi_buf, O.bi_buf >>= 8, O.bi_valid -= 8);
        }(S);
      };
    }, { "../utils/common": 41 }], 53: [function(n, r, i) {
      r.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(n, r, i) {
      (function(o) {
        (function(a, s) {
          if (!a.setImmediate) {
            var l, c, u, d, f = 1, p = {}, m = !1, g = a.document, b = Object.getPrototypeOf && Object.getPrototypeOf(a);
            b = b && b.setTimeout ? b : a, l = {}.toString.call(a.process) === "[object process]" ? function(k) {
              process.nextTick(function() {
                w(k);
              });
            } : function() {
              if (a.postMessage && !a.importScripts) {
                var k = !0, A = a.onmessage;
                return a.onmessage = function() {
                  k = !1;
                }, a.postMessage("", "*"), a.onmessage = A, k;
              }
            }() ? (d = "setImmediate$" + Math.random() + "$", a.addEventListener ? a.addEventListener("message", x, !1) : a.attachEvent("onmessage", x), function(k) {
              a.postMessage(d + k, "*");
            }) : a.MessageChannel ? ((u = new MessageChannel()).port1.onmessage = function(k) {
              w(k.data);
            }, function(k) {
              u.port2.postMessage(k);
            }) : g && "onreadystatechange" in g.createElement("script") ? (c = g.documentElement, function(k) {
              var A = g.createElement("script");
              A.onreadystatechange = function() {
                w(k), A.onreadystatechange = null, c.removeChild(A), A = null;
              }, c.appendChild(A);
            }) : function(k) {
              setTimeout(w, 0, k);
            }, b.setImmediate = function(k) {
              typeof k != "function" && (k = new Function("" + k));
              for (var A = new Array(arguments.length - 1), U = 0; U < A.length; U++) A[U] = arguments[U + 1];
              var P = { callback: k, args: A };
              return p[f] = P, l(f), f++;
            }, b.clearImmediate = y;
          }
          function y(k) {
            delete p[k];
          }
          function w(k) {
            if (m) setTimeout(w, 0, k);
            else {
              var A = p[k];
              if (A) {
                m = !0;
                try {
                  (function(U) {
                    var P = U.callback, V = U.args;
                    switch (V.length) {
                      case 0:
                        P();
                        break;
                      case 1:
                        P(V[0]);
                        break;
                      case 2:
                        P(V[0], V[1]);
                        break;
                      case 3:
                        P(V[0], V[1], V[2]);
                        break;
                      default:
                        P.apply(s, V);
                    }
                  })(A);
                } finally {
                  y(k), m = !1;
                }
              }
            }
          }
          function x(k) {
            k.source === a && typeof k.data == "string" && k.data.indexOf(d) === 0 && w(+k.data.slice(d.length));
          }
        })(typeof self > "u" ? o === void 0 ? this : o : self);
      }).call(this, typeof wt < "u" ? wt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(iL);
var Bfe = iL.exports, Lfe = G1, Pfe = Bfe;
Xm.openArrayBuffer = Wfe;
Xm.splitPath = zfe;
Xm.joinPath = $fe;
function Wfe(t) {
  return Pfe.loadAsync(t).then(function(e) {
    function n(a) {
      return e.file(a) !== null;
    }
    function r(a, s) {
      return e.file(a).async("uint8array").then(function(l) {
        if (s === "base64")
          return Lfe.fromByteArray(l);
        if (s) {
          var c = new TextDecoder(s);
          return c.decode(l);
        } else
          return l;
      });
    }
    function i(a, s) {
      e.file(a, s);
    }
    function o() {
      return e.generateAsync({ type: "arraybuffer" });
    }
    return {
      exists: n,
      read: r,
      write: i,
      toArrayBuffer: o
    };
  });
}
function zfe(t) {
  var e = t.lastIndexOf("/");
  return e === -1 ? { dirname: "", basename: t } : {
    dirname: t.substring(0, e),
    basename: t.substring(e + 1)
  };
}
function $fe() {
  var t = Array.prototype.filter.call(arguments, function(n) {
    return n;
  }), e = [];
  return t.forEach(function(n) {
    /^\//.test(n) ? e = [n] : e.push(n);
  }), e.join("/");
}
var cC = {}, ys = {}, rh = {}, K1 = Rn;
rh.Element = ih;
rh.element = function(t, e, n) {
  return new ih(t, e, n);
};
rh.text = function(t) {
  return {
    type: "text",
    value: t
  };
};
var oL = rh.emptyElement = {
  first: function() {
    return null;
  },
  firstOrEmpty: function() {
    return oL;
  },
  attributes: {},
  children: []
};
function ih(t, e, n) {
  this.type = "element", this.name = t, this.attributes = e || {}, this.children = n || [];
}
ih.prototype.first = function(t) {
  return K1.find(this.children, function(e) {
    return e.name === t;
  });
};
ih.prototype.firstOrEmpty = function(t) {
  return this.first(t) || oL;
};
ih.prototype.getElementsByTagName = function(t) {
  var e = K1.filter(this.children, function(n) {
    return n.name === t;
  });
  return aL(e);
};
ih.prototype.text = function() {
  if (this.children.length === 0)
    return "";
  if (this.children.length !== 1 || this.children[0].type !== "text")
    throw new Error("Not implemented");
  return this.children[0].value;
};
var Hfe = {
  getElementsByTagName: function(t) {
    return aL(K1.flatten(this.map(function(e) {
      return e.getElementsByTagName(t);
    }, !0)));
  }
};
function aL(t) {
  return K1.extend(t, Hfe);
}
var sL = {}, uC = {}, X1 = {}, wa = {}, bs = {};
function jfe(t, e, n) {
  if (n === void 0 && (n = Array.prototype), t && typeof n.find == "function")
    return n.find.call(t, e);
  for (var r = 0; r < t.length; r++)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      var i = t[r];
      if (e.call(void 0, i, r, t))
        return i;
    }
}
function dC(t, e) {
  return e === void 0 && (e = Object), e && typeof e.freeze == "function" ? e.freeze(t) : t;
}
function Vfe(t, e) {
  if (t === null || typeof t != "object")
    throw new TypeError("target is not an object");
  for (var n in e)
    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
  return t;
}
var lL = dC({
  /**
   * `text/html`, the only mime type that triggers treating an XML document as HTML.
   *
   * @see DOMParser.SupportedType.isHTML
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
   */
  HTML: "text/html",
  /**
   * Helper method to check a mime type if it indicates an HTML document
   *
   * @param {string} [value]
   * @returns {boolean}
   *
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
  isHTML: function(t) {
    return t === lL.HTML;
  },
  /**
   * `application/xml`, the standard mime type for XML documents.
   *
   * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
   * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_APPLICATION: "application/xml",
  /**
   * `text/html`, an alias for `application/xml`.
   *
   * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
   * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_TEXT: "text/xml",
  /**
   * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
   * but is parsed as an XML document.
   *
   * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
   * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
   */
  XML_XHTML_APPLICATION: "application/xhtml+xml",
  /**
   * `image/svg+xml`,
   *
   * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
   * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
   * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
   */
  XML_SVG_IMAGE: "image/svg+xml"
}), cL = dC({
  /**
   * The XHTML namespace.
   *
   * @see http://www.w3.org/1999/xhtml
   */
  HTML: "http://www.w3.org/1999/xhtml",
  /**
   * Checks if `uri` equals `NAMESPACE.HTML`.
   *
   * @param {string} [uri]
   *
   * @see NAMESPACE.HTML
   */
  isHTML: function(t) {
    return t === cL.HTML;
  },
  /**
   * The SVG namespace.
   *
   * @see http://www.w3.org/2000/svg
   */
  SVG: "http://www.w3.org/2000/svg",
  /**
   * The `xml:` namespace.
   *
   * @see http://www.w3.org/XML/1998/namespace
   */
  XML: "http://www.w3.org/XML/1998/namespace",
  /**
   * The `xmlns:` namespace
   *
   * @see https://www.w3.org/2000/xmlns/
   */
  XMLNS: "http://www.w3.org/2000/xmlns/"
});
bs.assign = Vfe;
bs.find = jfe;
bs.freeze = dC;
bs.MIME_TYPE = lL;
bs.NAMESPACE = cL;
var uL = bs, ca = uL.find, Cm = uL.NAMESPACE;
function qfe(t) {
  return t !== "";
}
function Gfe(t) {
  return t ? t.split(/[\t\n\f\r ]+/).filter(qfe) : [];
}
function Kfe(t, e) {
  return t.hasOwnProperty(e) || (t[e] = !0), t;
}
function E8(t) {
  if (!t) return [];
  var e = Gfe(t);
  return Object.keys(e.reduce(Kfe, {}));
}
function Xfe(t) {
  return function(e) {
    return t && t.indexOf(e) !== -1;
  };
}
function Ym(t, e) {
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
}
function fi(t, e) {
  var n = t.prototype;
  if (!(n instanceof e)) {
    let r = function() {
    };
    r.prototype = e.prototype, r = new r(), Ym(n, r), t.prototype = n = r;
  }
  n.constructor != t && (typeof t != "function" && console.error("unknown Class:" + t), n.constructor = t);
}
var hi = {}, So = hi.ELEMENT_NODE = 1, Nf = hi.ATTRIBUTE_NODE = 2, Mv = hi.TEXT_NODE = 3, dL = hi.CDATA_SECTION_NODE = 4, fL = hi.ENTITY_REFERENCE_NODE = 5, Yfe = hi.ENTITY_NODE = 6, hL = hi.PROCESSING_INSTRUCTION_NODE = 7, pL = hi.COMMENT_NODE = 8, mL = hi.DOCUMENT_NODE = 9, gL = hi.DOCUMENT_TYPE_NODE = 10, ds = hi.DOCUMENT_FRAGMENT_NODE = 11, Jfe = hi.NOTATION_NODE = 12, kr = {}, Jn = {};
kr.INDEX_SIZE_ERR = (Jn[1] = "Index size error", 1);
kr.DOMSTRING_SIZE_ERR = (Jn[2] = "DOMString size error", 2);
var oi = kr.HIERARCHY_REQUEST_ERR = (Jn[3] = "Hierarchy request error", 3);
kr.WRONG_DOCUMENT_ERR = (Jn[4] = "Wrong document", 4);
kr.INVALID_CHARACTER_ERR = (Jn[5] = "Invalid character", 5);
kr.NO_DATA_ALLOWED_ERR = (Jn[6] = "No data allowed", 6);
kr.NO_MODIFICATION_ALLOWED_ERR = (Jn[7] = "No modification allowed", 7);
var yL = kr.NOT_FOUND_ERR = (Jn[8] = "Not found", 8);
kr.NOT_SUPPORTED_ERR = (Jn[9] = "Not supported", 9);
var C8 = kr.INUSE_ATTRIBUTE_ERR = (Jn[10] = "Attribute in use", 10);
kr.INVALID_STATE_ERR = (Jn[11] = "Invalid state", 11);
kr.SYNTAX_ERR = (Jn[12] = "Syntax error", 12);
kr.INVALID_MODIFICATION_ERR = (Jn[13] = "Invalid modification", 13);
kr.NAMESPACE_ERR = (Jn[14] = "Invalid namespace", 14);
kr.INVALID_ACCESS_ERR = (Jn[15] = "Invalid access", 15);
function An(t, e) {
  if (e instanceof Error)
    var n = e;
  else
    n = this, Error.call(this, Jn[t]), this.message = Jn[t], Error.captureStackTrace && Error.captureStackTrace(this, An);
  return n.code = t, e && (this.message = this.message + ": " + e), n;
}
An.prototype = Error.prototype;
Ym(kr, An);
function as() {
}
as.prototype = {
  /**
   * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
   * @standard level1
   */
  length: 0,
  /**
   * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
   * @standard level1
   * @param index  unsigned long
   *   Index into the collection.
   * @return Node
   * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
   */
  item: function(t) {
    return t >= 0 && t < this.length ? this[t] : null;
  },
  toString: function(t, e) {
    for (var n = [], r = 0; r < this.length; r++)
      Jd(this[r], n, t, e);
    return n.join("");
  },
  /**
   * @private
   * @param {function (Node):boolean} predicate
   * @returns {Node[]}
   */
  filter: function(t) {
    return Array.prototype.filter.call(this, t);
  },
  /**
   * @private
   * @param {Node} item
   * @returns {number}
   */
  indexOf: function(t) {
    return Array.prototype.indexOf.call(this, t);
  }
};
function Mf(t, e) {
  this._node = t, this._refresh = e, fC(this);
}
function fC(t) {
  var e = t._node._inc || t._node.ownerDocument._inc;
  if (t._inc !== e) {
    var n = t._refresh(t._node);
    if (AL(t, "length", n.length), !t.$$length || n.length < t.$$length)
      for (var r = n.length; r in t; r++)
        Object.prototype.hasOwnProperty.call(t, r) && delete t[r];
    Ym(n, t), t._inc = e;
  }
}
Mf.prototype.item = function(t) {
  return fC(this), this[t] || null;
};
fi(Mf, as);
function Bv() {
}
function bL(t, e) {
  for (var n = t.length; n--; )
    if (t[n] === e)
      return n;
}
function k8(t, e, n, r) {
  if (r ? e[bL(e, r)] = n : e[e.length++] = n, t) {
    n.ownerElement = t;
    var i = t.ownerDocument;
    i && (r && xL(i, t, r), Zfe(i, t, n));
  }
}
function A8(t, e, n) {
  var r = bL(e, n);
  if (r >= 0) {
    for (var i = e.length - 1; r < i; )
      e[r] = e[++r];
    if (e.length = i, t) {
      var o = t.ownerDocument;
      o && (xL(o, t, n), n.ownerElement = null);
    }
  } else
    throw new An(yL, new Error(t.tagName + "@" + n));
}
Bv.prototype = {
  length: 0,
  item: as.prototype.item,
  getNamedItem: function(t) {
    for (var e = this.length; e--; ) {
      var n = this[e];
      if (n.nodeName == t)
        return n;
    }
  },
  setNamedItem: function(t) {
    var e = t.ownerElement;
    if (e && e != this._ownerElement)
      throw new An(C8);
    var n = this.getNamedItem(t.nodeName);
    return k8(this._ownerElement, this, t, n), n;
  },
  /* returns Node */
  setNamedItemNS: function(t) {
    var e = t.ownerElement, n;
    if (e && e != this._ownerElement)
      throw new An(C8);
    return n = this.getNamedItemNS(t.namespaceURI, t.localName), k8(this._ownerElement, this, t, n), n;
  },
  /* returns Node */
  removeNamedItem: function(t) {
    var e = this.getNamedItem(t);
    return A8(this._ownerElement, this, e), e;
  },
  // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
  //for level2
  removeNamedItemNS: function(t, e) {
    var n = this.getNamedItemNS(t, e);
    return A8(this._ownerElement, this, n), n;
  },
  getNamedItemNS: function(t, e) {
    for (var n = this.length; n--; ) {
      var r = this[n];
      if (r.localName == e && r.namespaceURI == t)
        return r;
    }
    return null;
  }
};
function vL() {
}
vL.prototype = {
  /**
   * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
   * The different implementations fairly diverged in what kind of features were reported.
   * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
   *
   * @deprecated It is deprecated and modern browsers return true in all cases.
   *
   * @param {string} feature
   * @param {string} [version]
   * @returns {boolean} always true
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
   * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
   */
  hasFeature: function(t, e) {
    return !0;
  },
  /**
   * Creates an XML Document object of the specified type with its document element.
   *
   * __It behaves slightly different from the description in the living standard__:
   * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
   * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string|null} namespaceURI
   * @param {string} qualifiedName
   * @param {DocumentType=null} doctype
   * @returns {Document}
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocument: function(t, e, n) {
    var r = new Jm();
    if (r.implementation = this, r.childNodes = new as(), r.doctype = n || null, n && r.appendChild(n), e) {
      var i = r.createElementNS(t, e);
      r.appendChild(i);
    }
    return r;
  },
  /**
   * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
   *
   * __This behavior is slightly different from the in the specs__:
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string} qualifiedName
   * @param {string} [publicId]
   * @param {string} [systemId]
   * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
   * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocumentType: function(t, e, n) {
    var r = new Y1();
    return r.name = t, r.nodeName = t, r.publicId = e || "", r.systemId = n || "", r;
  }
};
function qt() {
}
qt.prototype = {
  firstChild: null,
  lastChild: null,
  previousSibling: null,
  nextSibling: null,
  attributes: null,
  parentNode: null,
  childNodes: null,
  ownerDocument: null,
  nodeValue: null,
  namespaceURI: null,
  prefix: null,
  localName: null,
  // Modified in DOM Level 2:
  insertBefore: function(t, e) {
    return Lv(this, t, e);
  },
  replaceChild: function(t, e) {
    Lv(this, t, e, SL), e && this.removeChild(e);
  },
  removeChild: function(t) {
    return _L(this, t);
  },
  appendChild: function(t) {
    return this.insertBefore(t, null);
  },
  hasChildNodes: function() {
    return this.firstChild != null;
  },
  cloneNode: function(t) {
    return OT(this.ownerDocument || this, this, t);
  },
  // Modified in DOM Level 2:
  normalize: function() {
    for (var t = this.firstChild; t; ) {
      var e = t.nextSibling;
      e && e.nodeType == Mv && t.nodeType == Mv ? (this.removeChild(e), t.appendData(e.data)) : (t.normalize(), t = e);
    }
  },
  // Introduced in DOM Level 2:
  isSupported: function(t, e) {
    return this.ownerDocument.implementation.hasFeature(t, e);
  },
  // Introduced in DOM Level 2:
  hasAttributes: function() {
    return this.attributes.length > 0;
  },
  /**
   * Look up the prefix associated to the given namespace URI, starting from this node.
   * **The default namespace declarations are ignored by this method.**
   * See Namespace Prefix Lookup for details on the algorithm used by this method.
   *
   * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
   *
   * @param {string | null} namespaceURI
   * @returns {string | null}
   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
   * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
   * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
   * @see https://github.com/xmldom/xmldom/issues/322
   */
  lookupPrefix: function(t) {
    for (var e = this; e; ) {
      var n = e._nsMap;
      if (n) {
        for (var r in n)
          if (Object.prototype.hasOwnProperty.call(n, r) && n[r] === t)
            return r;
      }
      e = e.nodeType == Nf ? e.ownerDocument : e.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  lookupNamespaceURI: function(t) {
    for (var e = this; e; ) {
      var n = e._nsMap;
      if (n && Object.prototype.hasOwnProperty.call(n, t))
        return n[t];
      e = e.nodeType == Nf ? e.ownerDocument : e.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  isDefaultNamespace: function(t) {
    var e = this.lookupPrefix(t);
    return e == null;
  }
};
function wL(t) {
  return t == "<" && "&lt;" || t == ">" && "&gt;" || t == "&" && "&amp;" || t == '"' && "&quot;" || "&#" + t.charCodeAt() + ";";
}
Ym(hi, qt);
Ym(hi, qt.prototype);
function km(t, e) {
  if (e(t))
    return !0;
  if (t = t.firstChild)
    do
      if (km(t, e))
        return !0;
    while (t = t.nextSibling);
}
function Jm() {
  this.ownerDocument = this;
}
function Zfe(t, e, n) {
  t && t._inc++;
  var r = n.namespaceURI;
  r === Cm.XMLNS && (e._nsMap[n.prefix ? n.localName : ""] = n.value);
}
function xL(t, e, n, r) {
  t && t._inc++;
  var i = n.namespaceURI;
  i === Cm.XMLNS && delete e._nsMap[n.prefix ? n.localName : ""];
}
function hC(t, e, n) {
  if (t && t._inc) {
    t._inc++;
    var r = e.childNodes;
    if (n)
      r[r.length++] = n;
    else {
      for (var i = e.firstChild, o = 0; i; )
        r[o++] = i, i = i.nextSibling;
      r.length = o, delete r[r.length];
    }
  }
}
function _L(t, e) {
  var n = e.previousSibling, r = e.nextSibling;
  return n ? n.nextSibling = r : t.firstChild = r, r ? r.previousSibling = n : t.lastChild = n, e.parentNode = null, e.previousSibling = null, e.nextSibling = null, hC(t.ownerDocument, t), e;
}
function Qfe(t) {
  return t && (t.nodeType === qt.DOCUMENT_NODE || t.nodeType === qt.DOCUMENT_FRAGMENT_NODE || t.nodeType === qt.ELEMENT_NODE);
}
function ehe(t) {
  return t && (ua(t) || pC(t) || fs(t) || t.nodeType === qt.DOCUMENT_FRAGMENT_NODE || t.nodeType === qt.COMMENT_NODE || t.nodeType === qt.PROCESSING_INSTRUCTION_NODE);
}
function fs(t) {
  return t && t.nodeType === qt.DOCUMENT_TYPE_NODE;
}
function ua(t) {
  return t && t.nodeType === qt.ELEMENT_NODE;
}
function pC(t) {
  return t && t.nodeType === qt.TEXT_NODE;
}
function R8(t, e) {
  var n = t.childNodes || [];
  if (ca(n, ua) || fs(e))
    return !1;
  var r = ca(n, fs);
  return !(e && r && n.indexOf(r) > n.indexOf(e));
}
function I8(t, e) {
  var n = t.childNodes || [];
  function r(o) {
    return ua(o) && o !== e;
  }
  if (ca(n, r))
    return !1;
  var i = ca(n, fs);
  return !(e && i && n.indexOf(i) > n.indexOf(e));
}
function the(t, e, n) {
  if (!Qfe(t))
    throw new An(oi, "Unexpected parent node type " + t.nodeType);
  if (n && n.parentNode !== t)
    throw new An(yL, "child not in parent");
  if (
    // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
    !ehe(e) || // 5. If either `node` is a Text node and `parent` is a document,
    // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
    // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
    // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
    fs(e) && t.nodeType !== qt.DOCUMENT_NODE
  )
    throw new An(
      oi,
      "Unexpected node type " + e.nodeType + " for parent node type " + t.nodeType
    );
}
function nhe(t, e, n) {
  var r = t.childNodes || [], i = e.childNodes || [];
  if (e.nodeType === qt.DOCUMENT_FRAGMENT_NODE) {
    var o = i.filter(ua);
    if (o.length > 1 || ca(i, pC))
      throw new An(oi, "More than one element or text in fragment");
    if (o.length === 1 && !R8(t, n))
      throw new An(oi, "Element in fragment can not be inserted before doctype");
  }
  if (ua(e) && !R8(t, n))
    throw new An(oi, "Only one element can be added and only after doctype");
  if (fs(e)) {
    if (ca(r, fs))
      throw new An(oi, "Only one doctype is allowed");
    var a = ca(r, ua);
    if (n && r.indexOf(a) < r.indexOf(n))
      throw new An(oi, "Doctype can only be inserted before an element");
    if (!n && a)
      throw new An(oi, "Doctype can not be appended since element is present");
  }
}
function SL(t, e, n) {
  var r = t.childNodes || [], i = e.childNodes || [];
  if (e.nodeType === qt.DOCUMENT_FRAGMENT_NODE) {
    var o = i.filter(ua);
    if (o.length > 1 || ca(i, pC))
      throw new An(oi, "More than one element or text in fragment");
    if (o.length === 1 && !I8(t, n))
      throw new An(oi, "Element in fragment can not be inserted before doctype");
  }
  if (ua(e) && !I8(t, n))
    throw new An(oi, "Only one element can be added and only after doctype");
  if (fs(e)) {
    if (ca(r, function(l) {
      return fs(l) && l !== n;
    }))
      throw new An(oi, "Only one doctype is allowed");
    var a = ca(r, ua);
    if (n && r.indexOf(a) < r.indexOf(n))
      throw new An(oi, "Doctype can only be inserted before an element");
  }
}
function Lv(t, e, n, r) {
  the(t, e, n), t.nodeType === qt.DOCUMENT_NODE && (r || nhe)(t, e, n);
  var i = e.parentNode;
  if (i && i.removeChild(e), e.nodeType === ds) {
    var o = e.firstChild;
    if (o == null)
      return e;
    var a = e.lastChild;
  } else
    o = a = e;
  var s = n ? n.previousSibling : t.lastChild;
  o.previousSibling = s, a.nextSibling = n, s ? s.nextSibling = o : t.firstChild = o, n == null ? t.lastChild = a : n.previousSibling = a;
  do
    o.parentNode = t;
  while (o !== a && (o = o.nextSibling));
  return hC(t.ownerDocument || t, t), e.nodeType == ds && (e.firstChild = e.lastChild = null), e;
}
function rhe(t, e) {
  return e.parentNode && e.parentNode.removeChild(e), e.parentNode = t, e.previousSibling = t.lastChild, e.nextSibling = null, e.previousSibling ? e.previousSibling.nextSibling = e : t.firstChild = e, t.lastChild = e, hC(t.ownerDocument, t, e), e;
}
Jm.prototype = {
  //implementation : null,
  nodeName: "#document",
  nodeType: mL,
  /**
   * The DocumentType node of the document.
   *
   * @readonly
   * @type DocumentType
   */
  doctype: null,
  documentElement: null,
  _inc: 1,
  insertBefore: function(t, e) {
    if (t.nodeType == ds) {
      for (var n = t.firstChild; n; ) {
        var r = n.nextSibling;
        this.insertBefore(n, e), n = r;
      }
      return t;
    }
    return Lv(this, t, e), t.ownerDocument = this, this.documentElement === null && t.nodeType === So && (this.documentElement = t), t;
  },
  removeChild: function(t) {
    return this.documentElement == t && (this.documentElement = null), _L(this, t);
  },
  replaceChild: function(t, e) {
    Lv(this, t, e, SL), t.ownerDocument = this, e && this.removeChild(e), ua(t) && (this.documentElement = t);
  },
  // Introduced in DOM Level 2:
  importNode: function(t, e) {
    return kL(this, t, e);
  },
  // Introduced in DOM Level 2:
  getElementById: function(t) {
    var e = null;
    return km(this.documentElement, function(n) {
      if (n.nodeType == So && n.getAttribute("id") == t)
        return e = n, !0;
    }), e;
  },
  /**
   * The `getElementsByClassName` method of `Document` interface returns an array-like object
   * of all child elements which have **all** of the given class name(s).
   *
   * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
   *
   *
   * Warning: This is a live LiveNodeList.
   * Changes in the DOM will reflect in the array as the changes occur.
   * If an element selected by this array no longer qualifies for the selector,
   * it will automatically be removed. Be aware of this for iteration purposes.
   *
   * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
   * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
   */
  getElementsByClassName: function(t) {
    var e = E8(t);
    return new Mf(this, function(n) {
      var r = [];
      return e.length > 0 && km(n.documentElement, function(i) {
        if (i !== n && i.nodeType === So) {
          var o = i.getAttribute("class");
          if (o) {
            var a = t === o;
            if (!a) {
              var s = E8(o);
              a = e.every(Xfe(s));
            }
            a && r.push(i);
          }
        }
      }), r;
    });
  },
  //document factory method:
  createElement: function(t) {
    var e = new ru();
    e.ownerDocument = this, e.nodeName = t, e.tagName = t, e.localName = t, e.childNodes = new as();
    var n = e.attributes = new Bv();
    return n._ownerElement = e, e;
  },
  createDocumentFragment: function() {
    var t = new J1();
    return t.ownerDocument = this, t.childNodes = new as(), t;
  },
  createTextNode: function(t) {
    var e = new mC();
    return e.ownerDocument = this, e.appendData(t), e;
  },
  createComment: function(t) {
    var e = new gC();
    return e.ownerDocument = this, e.appendData(t), e;
  },
  createCDATASection: function(t) {
    var e = new yC();
    return e.ownerDocument = this, e.appendData(t), e;
  },
  createProcessingInstruction: function(t, e) {
    var n = new vC();
    return n.ownerDocument = this, n.tagName = n.nodeName = n.target = t, n.nodeValue = n.data = e, n;
  },
  createAttribute: function(t) {
    var e = new Pv();
    return e.ownerDocument = this, e.name = t, e.nodeName = t, e.localName = t, e.specified = !0, e;
  },
  createEntityReference: function(t) {
    var e = new bC();
    return e.ownerDocument = this, e.nodeName = t, e;
  },
  // Introduced in DOM Level 2:
  createElementNS: function(t, e) {
    var n = new ru(), r = e.split(":"), i = n.attributes = new Bv();
    return n.childNodes = new as(), n.ownerDocument = this, n.nodeName = e, n.tagName = e, n.namespaceURI = t, r.length == 2 ? (n.prefix = r[0], n.localName = r[1]) : n.localName = e, i._ownerElement = n, n;
  },
  // Introduced in DOM Level 2:
  createAttributeNS: function(t, e) {
    var n = new Pv(), r = e.split(":");
    return n.ownerDocument = this, n.nodeName = e, n.name = e, n.namespaceURI = t, n.specified = !0, r.length == 2 ? (n.prefix = r[0], n.localName = r[1]) : n.localName = e, n;
  }
};
fi(Jm, qt);
function ru() {
  this._nsMap = {};
}
ru.prototype = {
  nodeType: So,
  hasAttribute: function(t) {
    return this.getAttributeNode(t) != null;
  },
  getAttribute: function(t) {
    var e = this.getAttributeNode(t);
    return e && e.value || "";
  },
  getAttributeNode: function(t) {
    return this.attributes.getNamedItem(t);
  },
  setAttribute: function(t, e) {
    var n = this.ownerDocument.createAttribute(t);
    n.value = n.nodeValue = "" + e, this.setAttributeNode(n);
  },
  removeAttribute: function(t) {
    var e = this.getAttributeNode(t);
    e && this.removeAttributeNode(e);
  },
  //four real opeartion method
  appendChild: function(t) {
    return t.nodeType === ds ? this.insertBefore(t, null) : rhe(this, t);
  },
  setAttributeNode: function(t) {
    return this.attributes.setNamedItem(t);
  },
  setAttributeNodeNS: function(t) {
    return this.attributes.setNamedItemNS(t);
  },
  removeAttributeNode: function(t) {
    return this.attributes.removeNamedItem(t.nodeName);
  },
  //get real attribute name,and remove it by removeAttributeNode
  removeAttributeNS: function(t, e) {
    var n = this.getAttributeNodeNS(t, e);
    n && this.removeAttributeNode(n);
  },
  hasAttributeNS: function(t, e) {
    return this.getAttributeNodeNS(t, e) != null;
  },
  getAttributeNS: function(t, e) {
    var n = this.getAttributeNodeNS(t, e);
    return n && n.value || "";
  },
  setAttributeNS: function(t, e, n) {
    var r = this.ownerDocument.createAttributeNS(t, e);
    r.value = r.nodeValue = "" + n, this.setAttributeNode(r);
  },
  getAttributeNodeNS: function(t, e) {
    return this.attributes.getNamedItemNS(t, e);
  },
  getElementsByTagName: function(t) {
    return new Mf(this, function(e) {
      var n = [];
      return km(e, function(r) {
        r !== e && r.nodeType == So && (t === "*" || r.tagName == t) && n.push(r);
      }), n;
    });
  },
  getElementsByTagNameNS: function(t, e) {
    return new Mf(this, function(n) {
      var r = [];
      return km(n, function(i) {
        i !== n && i.nodeType === So && (t === "*" || i.namespaceURI === t) && (e === "*" || i.localName == e) && r.push(i);
      }), r;
    });
  }
};
Jm.prototype.getElementsByTagName = ru.prototype.getElementsByTagName;
Jm.prototype.getElementsByTagNameNS = ru.prototype.getElementsByTagNameNS;
fi(ru, qt);
function Pv() {
}
Pv.prototype.nodeType = Nf;
fi(Pv, qt);
function Zm() {
}
Zm.prototype = {
  data: "",
  substringData: function(t, e) {
    return this.data.substring(t, t + e);
  },
  appendData: function(t) {
    t = this.data + t, this.nodeValue = this.data = t, this.length = t.length;
  },
  insertData: function(t, e) {
    this.replaceData(t, 0, e);
  },
  appendChild: function(t) {
    throw new Error(Jn[oi]);
  },
  deleteData: function(t, e) {
    this.replaceData(t, e, "");
  },
  replaceData: function(t, e, n) {
    var r = this.data.substring(0, t), i = this.data.substring(t + e);
    n = r + n + i, this.nodeValue = this.data = n, this.length = n.length;
  }
};
fi(Zm, qt);
function mC() {
}
mC.prototype = {
  nodeName: "#text",
  nodeType: Mv,
  splitText: function(t) {
    var e = this.data, n = e.substring(t);
    e = e.substring(0, t), this.data = this.nodeValue = e, this.length = e.length;
    var r = this.ownerDocument.createTextNode(n);
    return this.parentNode && this.parentNode.insertBefore(r, this.nextSibling), r;
  }
};
fi(mC, Zm);
function gC() {
}
gC.prototype = {
  nodeName: "#comment",
  nodeType: pL
};
fi(gC, Zm);
function yC() {
}
yC.prototype = {
  nodeName: "#cdata-section",
  nodeType: dL
};
fi(yC, Zm);
function Y1() {
}
Y1.prototype.nodeType = gL;
fi(Y1, qt);
function TL() {
}
TL.prototype.nodeType = Jfe;
fi(TL, qt);
function DL() {
}
DL.prototype.nodeType = Yfe;
fi(DL, qt);
function bC() {
}
bC.prototype.nodeType = fL;
fi(bC, qt);
function J1() {
}
J1.prototype.nodeName = "#document-fragment";
J1.prototype.nodeType = ds;
fi(J1, qt);
function vC() {
}
vC.prototype.nodeType = hL;
fi(vC, qt);
function EL() {
}
EL.prototype.serializeToString = function(t, e, n) {
  return CL.call(t, e, n);
};
qt.prototype.toString = CL;
function CL(t, e) {
  var n = [], r = this.nodeType == 9 && this.documentElement || this, i = r.prefix, o = r.namespaceURI;
  if (o && i == null) {
    var i = r.lookupPrefix(o);
    if (i == null)
      var a = [
        { namespace: o, prefix: null }
        //{namespace:uri,prefix:''}
      ];
  }
  return Jd(this, n, t, e, a), n.join("");
}
function O8(t, e, n) {
  var r = t.prefix || "", i = t.namespaceURI;
  if (!i || r === "xml" && i === Cm.XML || i === Cm.XMLNS)
    return !1;
  for (var o = n.length; o--; ) {
    var a = n[o];
    if (a.prefix === r)
      return a.namespace !== i;
  }
  return !0;
}
function E2(t, e, n) {
  t.push(" ", e, '="', n.replace(/[<>&"\t\n\r]/g, wL), '"');
}
function Jd(t, e, n, r, i) {
  if (i || (i = []), r)
    if (t = r(t), t) {
      if (typeof t == "string") {
        e.push(t);
        return;
      }
    } else
      return;
  switch (t.nodeType) {
    case So:
      var o = t.attributes, a = o.length, y = t.firstChild, s = t.tagName;
      n = Cm.isHTML(t.namespaceURI) || n;
      var l = s;
      if (!n && !t.prefix && t.namespaceURI) {
        for (var c, u = 0; u < o.length; u++)
          if (o.item(u).name === "xmlns") {
            c = o.item(u).value;
            break;
          }
        if (!c)
          for (var d = i.length - 1; d >= 0; d--) {
            var f = i[d];
            if (f.prefix === "" && f.namespace === t.namespaceURI) {
              c = f.namespace;
              break;
            }
          }
        if (c !== t.namespaceURI)
          for (var d = i.length - 1; d >= 0; d--) {
            var f = i[d];
            if (f.namespace === t.namespaceURI) {
              f.prefix && (l = f.prefix + ":" + s);
              break;
            }
          }
      }
      e.push("<", l);
      for (var p = 0; p < a; p++) {
        var m = o.item(p);
        m.prefix == "xmlns" ? i.push({ prefix: m.localName, namespace: m.value }) : m.nodeName == "xmlns" && i.push({ prefix: "", namespace: m.value });
      }
      for (var p = 0; p < a; p++) {
        var m = o.item(p);
        if (O8(m, n, i)) {
          var g = m.prefix || "", b = m.namespaceURI;
          E2(e, g ? "xmlns:" + g : "xmlns", b), i.push({ prefix: g, namespace: b });
        }
        Jd(m, e, n, r, i);
      }
      if (s === l && O8(t, n, i)) {
        var g = t.prefix || "", b = t.namespaceURI;
        E2(e, g ? "xmlns:" + g : "xmlns", b), i.push({ prefix: g, namespace: b });
      }
      if (y || n && !/^(?:meta|link|img|br|hr|input)$/i.test(s)) {
        if (e.push(">"), n && /^script$/i.test(s))
          for (; y; )
            y.data ? e.push(y.data) : Jd(y, e, n, r, i.slice()), y = y.nextSibling;
        else
          for (; y; )
            Jd(y, e, n, r, i.slice()), y = y.nextSibling;
        e.push("</", l, ">");
      } else
        e.push("/>");
      return;
    case mL:
    case ds:
      for (var y = t.firstChild; y; )
        Jd(y, e, n, r, i.slice()), y = y.nextSibling;
      return;
    case Nf:
      return E2(e, t.name, t.value);
    case Mv:
      return e.push(
        t.data.replace(/[<&>]/g, wL)
      );
    case dL:
      return e.push("<![CDATA[", t.data, "]]>");
    case pL:
      return e.push("<!--", t.data, "-->");
    case gL:
      var w = t.publicId, x = t.systemId;
      if (e.push("<!DOCTYPE ", t.name), w)
        e.push(" PUBLIC ", w), x && x != "." && e.push(" ", x), e.push(">");
      else if (x && x != ".")
        e.push(" SYSTEM ", x, ">");
      else {
        var k = t.internalSubset;
        k && e.push(" [", k, "]"), e.push(">");
      }
      return;
    case hL:
      return e.push("<?", t.target, " ", t.data, "?>");
    case fL:
      return e.push("&", t.nodeName, ";");
    default:
      e.push("??", t.nodeName);
  }
}
function kL(t, e, n) {
  var r;
  switch (e.nodeType) {
    case So:
      r = e.cloneNode(!1), r.ownerDocument = t;
    case ds:
      break;
    case Nf:
      n = !0;
      break;
  }
  if (r || (r = e.cloneNode(!1)), r.ownerDocument = t, r.parentNode = null, n)
    for (var i = e.firstChild; i; )
      r.appendChild(kL(t, i, n)), i = i.nextSibling;
  return r;
}
function OT(t, e, n) {
  var r = new e.constructor();
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      var o = e[i];
      typeof o != "object" && o != r[i] && (r[i] = o);
    }
  switch (e.childNodes && (r.childNodes = new as()), r.ownerDocument = t, r.nodeType) {
    case So:
      var a = e.attributes, s = r.attributes = new Bv(), l = a.length;
      s._ownerElement = r;
      for (var c = 0; c < l; c++)
        r.setAttributeNode(OT(t, a.item(c), !0));
      break;
    case Nf:
      n = !0;
  }
  if (n)
    for (var u = e.firstChild; u; )
      r.appendChild(OT(t, u, n)), u = u.nextSibling;
  return r;
}
function AL(t, e, n) {
  t[e] = n;
}
try {
  if (Object.defineProperty) {
    let t = function(e) {
      switch (e.nodeType) {
        case So:
        case ds:
          var n = [];
          for (e = e.firstChild; e; )
            e.nodeType !== 7 && e.nodeType !== 8 && n.push(t(e)), e = e.nextSibling;
          return n.join("");
        default:
          return e.nodeValue;
      }
    };
    Object.defineProperty(Mf.prototype, "length", {
      get: function() {
        return fC(this), this.$$length;
      }
    }), Object.defineProperty(qt.prototype, "textContent", {
      get: function() {
        return t(this);
      },
      set: function(e) {
        switch (this.nodeType) {
          case So:
          case ds:
            for (; this.firstChild; )
              this.removeChild(this.firstChild);
            (e || String(e)) && this.appendChild(this.ownerDocument.createTextNode(e));
            break;
          default:
            this.data = e, this.value = e, this.nodeValue = e;
        }
      }
    }), AL = function(e, n, r) {
      e["$$" + n] = r;
    };
  }
} catch {
}
wa.DocumentType = Y1;
wa.DOMException = An;
wa.DOMImplementation = vL;
wa.Element = ru;
wa.Node = qt;
wa.NodeList = as;
wa.XMLSerializer = EL;
var Z1 = {}, RL = {};
(function(t) {
  var e = bs.freeze;
  t.XML_ENTITIES = e({
    amp: "&",
    apos: "'",
    gt: ">",
    lt: "<",
    quot: '"'
  }), t.HTML_ENTITIES = e({
    Aacute: "Á",
    aacute: "á",
    Abreve: "Ă",
    abreve: "ă",
    ac: "∾",
    acd: "∿",
    acE: "∾̳",
    Acirc: "Â",
    acirc: "â",
    acute: "´",
    Acy: "А",
    acy: "а",
    AElig: "Æ",
    aelig: "æ",
    af: "⁡",
    Afr: "𝔄",
    afr: "𝔞",
    Agrave: "À",
    agrave: "à",
    alefsym: "ℵ",
    aleph: "ℵ",
    Alpha: "Α",
    alpha: "α",
    Amacr: "Ā",
    amacr: "ā",
    amalg: "⨿",
    AMP: "&",
    amp: "&",
    And: "⩓",
    and: "∧",
    andand: "⩕",
    andd: "⩜",
    andslope: "⩘",
    andv: "⩚",
    ang: "∠",
    ange: "⦤",
    angle: "∠",
    angmsd: "∡",
    angmsdaa: "⦨",
    angmsdab: "⦩",
    angmsdac: "⦪",
    angmsdad: "⦫",
    angmsdae: "⦬",
    angmsdaf: "⦭",
    angmsdag: "⦮",
    angmsdah: "⦯",
    angrt: "∟",
    angrtvb: "⊾",
    angrtvbd: "⦝",
    angsph: "∢",
    angst: "Å",
    angzarr: "⍼",
    Aogon: "Ą",
    aogon: "ą",
    Aopf: "𝔸",
    aopf: "𝕒",
    ap: "≈",
    apacir: "⩯",
    apE: "⩰",
    ape: "≊",
    apid: "≋",
    apos: "'",
    ApplyFunction: "⁡",
    approx: "≈",
    approxeq: "≊",
    Aring: "Å",
    aring: "å",
    Ascr: "𝒜",
    ascr: "𝒶",
    Assign: "≔",
    ast: "*",
    asymp: "≈",
    asympeq: "≍",
    Atilde: "Ã",
    atilde: "ã",
    Auml: "Ä",
    auml: "ä",
    awconint: "∳",
    awint: "⨑",
    backcong: "≌",
    backepsilon: "϶",
    backprime: "‵",
    backsim: "∽",
    backsimeq: "⋍",
    Backslash: "∖",
    Barv: "⫧",
    barvee: "⊽",
    Barwed: "⌆",
    barwed: "⌅",
    barwedge: "⌅",
    bbrk: "⎵",
    bbrktbrk: "⎶",
    bcong: "≌",
    Bcy: "Б",
    bcy: "б",
    bdquo: "„",
    becaus: "∵",
    Because: "∵",
    because: "∵",
    bemptyv: "⦰",
    bepsi: "϶",
    bernou: "ℬ",
    Bernoullis: "ℬ",
    Beta: "Β",
    beta: "β",
    beth: "ℶ",
    between: "≬",
    Bfr: "𝔅",
    bfr: "𝔟",
    bigcap: "⋂",
    bigcirc: "◯",
    bigcup: "⋃",
    bigodot: "⨀",
    bigoplus: "⨁",
    bigotimes: "⨂",
    bigsqcup: "⨆",
    bigstar: "★",
    bigtriangledown: "▽",
    bigtriangleup: "△",
    biguplus: "⨄",
    bigvee: "⋁",
    bigwedge: "⋀",
    bkarow: "⤍",
    blacklozenge: "⧫",
    blacksquare: "▪",
    blacktriangle: "▴",
    blacktriangledown: "▾",
    blacktriangleleft: "◂",
    blacktriangleright: "▸",
    blank: "␣",
    blk12: "▒",
    blk14: "░",
    blk34: "▓",
    block: "█",
    bne: "=⃥",
    bnequiv: "≡⃥",
    bNot: "⫭",
    bnot: "⌐",
    Bopf: "𝔹",
    bopf: "𝕓",
    bot: "⊥",
    bottom: "⊥",
    bowtie: "⋈",
    boxbox: "⧉",
    boxDL: "╗",
    boxDl: "╖",
    boxdL: "╕",
    boxdl: "┐",
    boxDR: "╔",
    boxDr: "╓",
    boxdR: "╒",
    boxdr: "┌",
    boxH: "═",
    boxh: "─",
    boxHD: "╦",
    boxHd: "╤",
    boxhD: "╥",
    boxhd: "┬",
    boxHU: "╩",
    boxHu: "╧",
    boxhU: "╨",
    boxhu: "┴",
    boxminus: "⊟",
    boxplus: "⊞",
    boxtimes: "⊠",
    boxUL: "╝",
    boxUl: "╜",
    boxuL: "╛",
    boxul: "┘",
    boxUR: "╚",
    boxUr: "╙",
    boxuR: "╘",
    boxur: "└",
    boxV: "║",
    boxv: "│",
    boxVH: "╬",
    boxVh: "╫",
    boxvH: "╪",
    boxvh: "┼",
    boxVL: "╣",
    boxVl: "╢",
    boxvL: "╡",
    boxvl: "┤",
    boxVR: "╠",
    boxVr: "╟",
    boxvR: "╞",
    boxvr: "├",
    bprime: "‵",
    Breve: "˘",
    breve: "˘",
    brvbar: "¦",
    Bscr: "ℬ",
    bscr: "𝒷",
    bsemi: "⁏",
    bsim: "∽",
    bsime: "⋍",
    bsol: "\\",
    bsolb: "⧅",
    bsolhsub: "⟈",
    bull: "•",
    bullet: "•",
    bump: "≎",
    bumpE: "⪮",
    bumpe: "≏",
    Bumpeq: "≎",
    bumpeq: "≏",
    Cacute: "Ć",
    cacute: "ć",
    Cap: "⋒",
    cap: "∩",
    capand: "⩄",
    capbrcup: "⩉",
    capcap: "⩋",
    capcup: "⩇",
    capdot: "⩀",
    CapitalDifferentialD: "ⅅ",
    caps: "∩︀",
    caret: "⁁",
    caron: "ˇ",
    Cayleys: "ℭ",
    ccaps: "⩍",
    Ccaron: "Č",
    ccaron: "č",
    Ccedil: "Ç",
    ccedil: "ç",
    Ccirc: "Ĉ",
    ccirc: "ĉ",
    Cconint: "∰",
    ccups: "⩌",
    ccupssm: "⩐",
    Cdot: "Ċ",
    cdot: "ċ",
    cedil: "¸",
    Cedilla: "¸",
    cemptyv: "⦲",
    cent: "¢",
    CenterDot: "·",
    centerdot: "·",
    Cfr: "ℭ",
    cfr: "𝔠",
    CHcy: "Ч",
    chcy: "ч",
    check: "✓",
    checkmark: "✓",
    Chi: "Χ",
    chi: "χ",
    cir: "○",
    circ: "ˆ",
    circeq: "≗",
    circlearrowleft: "↺",
    circlearrowright: "↻",
    circledast: "⊛",
    circledcirc: "⊚",
    circleddash: "⊝",
    CircleDot: "⊙",
    circledR: "®",
    circledS: "Ⓢ",
    CircleMinus: "⊖",
    CirclePlus: "⊕",
    CircleTimes: "⊗",
    cirE: "⧃",
    cire: "≗",
    cirfnint: "⨐",
    cirmid: "⫯",
    cirscir: "⧂",
    ClockwiseContourIntegral: "∲",
    CloseCurlyDoubleQuote: "”",
    CloseCurlyQuote: "’",
    clubs: "♣",
    clubsuit: "♣",
    Colon: "∷",
    colon: ":",
    Colone: "⩴",
    colone: "≔",
    coloneq: "≔",
    comma: ",",
    commat: "@",
    comp: "∁",
    compfn: "∘",
    complement: "∁",
    complexes: "ℂ",
    cong: "≅",
    congdot: "⩭",
    Congruent: "≡",
    Conint: "∯",
    conint: "∮",
    ContourIntegral: "∮",
    Copf: "ℂ",
    copf: "𝕔",
    coprod: "∐",
    Coproduct: "∐",
    COPY: "©",
    copy: "©",
    copysr: "℗",
    CounterClockwiseContourIntegral: "∳",
    crarr: "↵",
    Cross: "⨯",
    cross: "✗",
    Cscr: "𝒞",
    cscr: "𝒸",
    csub: "⫏",
    csube: "⫑",
    csup: "⫐",
    csupe: "⫒",
    ctdot: "⋯",
    cudarrl: "⤸",
    cudarrr: "⤵",
    cuepr: "⋞",
    cuesc: "⋟",
    cularr: "↶",
    cularrp: "⤽",
    Cup: "⋓",
    cup: "∪",
    cupbrcap: "⩈",
    CupCap: "≍",
    cupcap: "⩆",
    cupcup: "⩊",
    cupdot: "⊍",
    cupor: "⩅",
    cups: "∪︀",
    curarr: "↷",
    curarrm: "⤼",
    curlyeqprec: "⋞",
    curlyeqsucc: "⋟",
    curlyvee: "⋎",
    curlywedge: "⋏",
    curren: "¤",
    curvearrowleft: "↶",
    curvearrowright: "↷",
    cuvee: "⋎",
    cuwed: "⋏",
    cwconint: "∲",
    cwint: "∱",
    cylcty: "⌭",
    Dagger: "‡",
    dagger: "†",
    daleth: "ℸ",
    Darr: "↡",
    dArr: "⇓",
    darr: "↓",
    dash: "‐",
    Dashv: "⫤",
    dashv: "⊣",
    dbkarow: "⤏",
    dblac: "˝",
    Dcaron: "Ď",
    dcaron: "ď",
    Dcy: "Д",
    dcy: "д",
    DD: "ⅅ",
    dd: "ⅆ",
    ddagger: "‡",
    ddarr: "⇊",
    DDotrahd: "⤑",
    ddotseq: "⩷",
    deg: "°",
    Del: "∇",
    Delta: "Δ",
    delta: "δ",
    demptyv: "⦱",
    dfisht: "⥿",
    Dfr: "𝔇",
    dfr: "𝔡",
    dHar: "⥥",
    dharl: "⇃",
    dharr: "⇂",
    DiacriticalAcute: "´",
    DiacriticalDot: "˙",
    DiacriticalDoubleAcute: "˝",
    DiacriticalGrave: "`",
    DiacriticalTilde: "˜",
    diam: "⋄",
    Diamond: "⋄",
    diamond: "⋄",
    diamondsuit: "♦",
    diams: "♦",
    die: "¨",
    DifferentialD: "ⅆ",
    digamma: "ϝ",
    disin: "⋲",
    div: "÷",
    divide: "÷",
    divideontimes: "⋇",
    divonx: "⋇",
    DJcy: "Ђ",
    djcy: "ђ",
    dlcorn: "⌞",
    dlcrop: "⌍",
    dollar: "$",
    Dopf: "𝔻",
    dopf: "𝕕",
    Dot: "¨",
    dot: "˙",
    DotDot: "⃜",
    doteq: "≐",
    doteqdot: "≑",
    DotEqual: "≐",
    dotminus: "∸",
    dotplus: "∔",
    dotsquare: "⊡",
    doublebarwedge: "⌆",
    DoubleContourIntegral: "∯",
    DoubleDot: "¨",
    DoubleDownArrow: "⇓",
    DoubleLeftArrow: "⇐",
    DoubleLeftRightArrow: "⇔",
    DoubleLeftTee: "⫤",
    DoubleLongLeftArrow: "⟸",
    DoubleLongLeftRightArrow: "⟺",
    DoubleLongRightArrow: "⟹",
    DoubleRightArrow: "⇒",
    DoubleRightTee: "⊨",
    DoubleUpArrow: "⇑",
    DoubleUpDownArrow: "⇕",
    DoubleVerticalBar: "∥",
    DownArrow: "↓",
    Downarrow: "⇓",
    downarrow: "↓",
    DownArrowBar: "⤓",
    DownArrowUpArrow: "⇵",
    DownBreve: "̑",
    downdownarrows: "⇊",
    downharpoonleft: "⇃",
    downharpoonright: "⇂",
    DownLeftRightVector: "⥐",
    DownLeftTeeVector: "⥞",
    DownLeftVector: "↽",
    DownLeftVectorBar: "⥖",
    DownRightTeeVector: "⥟",
    DownRightVector: "⇁",
    DownRightVectorBar: "⥗",
    DownTee: "⊤",
    DownTeeArrow: "↧",
    drbkarow: "⤐",
    drcorn: "⌟",
    drcrop: "⌌",
    Dscr: "𝒟",
    dscr: "𝒹",
    DScy: "Ѕ",
    dscy: "ѕ",
    dsol: "⧶",
    Dstrok: "Đ",
    dstrok: "đ",
    dtdot: "⋱",
    dtri: "▿",
    dtrif: "▾",
    duarr: "⇵",
    duhar: "⥯",
    dwangle: "⦦",
    DZcy: "Џ",
    dzcy: "џ",
    dzigrarr: "⟿",
    Eacute: "É",
    eacute: "é",
    easter: "⩮",
    Ecaron: "Ě",
    ecaron: "ě",
    ecir: "≖",
    Ecirc: "Ê",
    ecirc: "ê",
    ecolon: "≕",
    Ecy: "Э",
    ecy: "э",
    eDDot: "⩷",
    Edot: "Ė",
    eDot: "≑",
    edot: "ė",
    ee: "ⅇ",
    efDot: "≒",
    Efr: "𝔈",
    efr: "𝔢",
    eg: "⪚",
    Egrave: "È",
    egrave: "è",
    egs: "⪖",
    egsdot: "⪘",
    el: "⪙",
    Element: "∈",
    elinters: "⏧",
    ell: "ℓ",
    els: "⪕",
    elsdot: "⪗",
    Emacr: "Ē",
    emacr: "ē",
    empty: "∅",
    emptyset: "∅",
    EmptySmallSquare: "◻",
    emptyv: "∅",
    EmptyVerySmallSquare: "▫",
    emsp: " ",
    emsp13: " ",
    emsp14: " ",
    ENG: "Ŋ",
    eng: "ŋ",
    ensp: " ",
    Eogon: "Ę",
    eogon: "ę",
    Eopf: "𝔼",
    eopf: "𝕖",
    epar: "⋕",
    eparsl: "⧣",
    eplus: "⩱",
    epsi: "ε",
    Epsilon: "Ε",
    epsilon: "ε",
    epsiv: "ϵ",
    eqcirc: "≖",
    eqcolon: "≕",
    eqsim: "≂",
    eqslantgtr: "⪖",
    eqslantless: "⪕",
    Equal: "⩵",
    equals: "=",
    EqualTilde: "≂",
    equest: "≟",
    Equilibrium: "⇌",
    equiv: "≡",
    equivDD: "⩸",
    eqvparsl: "⧥",
    erarr: "⥱",
    erDot: "≓",
    Escr: "ℰ",
    escr: "ℯ",
    esdot: "≐",
    Esim: "⩳",
    esim: "≂",
    Eta: "Η",
    eta: "η",
    ETH: "Ð",
    eth: "ð",
    Euml: "Ë",
    euml: "ë",
    euro: "€",
    excl: "!",
    exist: "∃",
    Exists: "∃",
    expectation: "ℰ",
    ExponentialE: "ⅇ",
    exponentiale: "ⅇ",
    fallingdotseq: "≒",
    Fcy: "Ф",
    fcy: "ф",
    female: "♀",
    ffilig: "ﬃ",
    fflig: "ﬀ",
    ffllig: "ﬄ",
    Ffr: "𝔉",
    ffr: "𝔣",
    filig: "ﬁ",
    FilledSmallSquare: "◼",
    FilledVerySmallSquare: "▪",
    fjlig: "fj",
    flat: "♭",
    fllig: "ﬂ",
    fltns: "▱",
    fnof: "ƒ",
    Fopf: "𝔽",
    fopf: "𝕗",
    ForAll: "∀",
    forall: "∀",
    fork: "⋔",
    forkv: "⫙",
    Fouriertrf: "ℱ",
    fpartint: "⨍",
    frac12: "½",
    frac13: "⅓",
    frac14: "¼",
    frac15: "⅕",
    frac16: "⅙",
    frac18: "⅛",
    frac23: "⅔",
    frac25: "⅖",
    frac34: "¾",
    frac35: "⅗",
    frac38: "⅜",
    frac45: "⅘",
    frac56: "⅚",
    frac58: "⅝",
    frac78: "⅞",
    frasl: "⁄",
    frown: "⌢",
    Fscr: "ℱ",
    fscr: "𝒻",
    gacute: "ǵ",
    Gamma: "Γ",
    gamma: "γ",
    Gammad: "Ϝ",
    gammad: "ϝ",
    gap: "⪆",
    Gbreve: "Ğ",
    gbreve: "ğ",
    Gcedil: "Ģ",
    Gcirc: "Ĝ",
    gcirc: "ĝ",
    Gcy: "Г",
    gcy: "г",
    Gdot: "Ġ",
    gdot: "ġ",
    gE: "≧",
    ge: "≥",
    gEl: "⪌",
    gel: "⋛",
    geq: "≥",
    geqq: "≧",
    geqslant: "⩾",
    ges: "⩾",
    gescc: "⪩",
    gesdot: "⪀",
    gesdoto: "⪂",
    gesdotol: "⪄",
    gesl: "⋛︀",
    gesles: "⪔",
    Gfr: "𝔊",
    gfr: "𝔤",
    Gg: "⋙",
    gg: "≫",
    ggg: "⋙",
    gimel: "ℷ",
    GJcy: "Ѓ",
    gjcy: "ѓ",
    gl: "≷",
    gla: "⪥",
    glE: "⪒",
    glj: "⪤",
    gnap: "⪊",
    gnapprox: "⪊",
    gnE: "≩",
    gne: "⪈",
    gneq: "⪈",
    gneqq: "≩",
    gnsim: "⋧",
    Gopf: "𝔾",
    gopf: "𝕘",
    grave: "`",
    GreaterEqual: "≥",
    GreaterEqualLess: "⋛",
    GreaterFullEqual: "≧",
    GreaterGreater: "⪢",
    GreaterLess: "≷",
    GreaterSlantEqual: "⩾",
    GreaterTilde: "≳",
    Gscr: "𝒢",
    gscr: "ℊ",
    gsim: "≳",
    gsime: "⪎",
    gsiml: "⪐",
    Gt: "≫",
    GT: ">",
    gt: ">",
    gtcc: "⪧",
    gtcir: "⩺",
    gtdot: "⋗",
    gtlPar: "⦕",
    gtquest: "⩼",
    gtrapprox: "⪆",
    gtrarr: "⥸",
    gtrdot: "⋗",
    gtreqless: "⋛",
    gtreqqless: "⪌",
    gtrless: "≷",
    gtrsim: "≳",
    gvertneqq: "≩︀",
    gvnE: "≩︀",
    Hacek: "ˇ",
    hairsp: " ",
    half: "½",
    hamilt: "ℋ",
    HARDcy: "Ъ",
    hardcy: "ъ",
    hArr: "⇔",
    harr: "↔",
    harrcir: "⥈",
    harrw: "↭",
    Hat: "^",
    hbar: "ℏ",
    Hcirc: "Ĥ",
    hcirc: "ĥ",
    hearts: "♥",
    heartsuit: "♥",
    hellip: "…",
    hercon: "⊹",
    Hfr: "ℌ",
    hfr: "𝔥",
    HilbertSpace: "ℋ",
    hksearow: "⤥",
    hkswarow: "⤦",
    hoarr: "⇿",
    homtht: "∻",
    hookleftarrow: "↩",
    hookrightarrow: "↪",
    Hopf: "ℍ",
    hopf: "𝕙",
    horbar: "―",
    HorizontalLine: "─",
    Hscr: "ℋ",
    hscr: "𝒽",
    hslash: "ℏ",
    Hstrok: "Ħ",
    hstrok: "ħ",
    HumpDownHump: "≎",
    HumpEqual: "≏",
    hybull: "⁃",
    hyphen: "‐",
    Iacute: "Í",
    iacute: "í",
    ic: "⁣",
    Icirc: "Î",
    icirc: "î",
    Icy: "И",
    icy: "и",
    Idot: "İ",
    IEcy: "Е",
    iecy: "е",
    iexcl: "¡",
    iff: "⇔",
    Ifr: "ℑ",
    ifr: "𝔦",
    Igrave: "Ì",
    igrave: "ì",
    ii: "ⅈ",
    iiiint: "⨌",
    iiint: "∭",
    iinfin: "⧜",
    iiota: "℩",
    IJlig: "Ĳ",
    ijlig: "ĳ",
    Im: "ℑ",
    Imacr: "Ī",
    imacr: "ī",
    image: "ℑ",
    ImaginaryI: "ⅈ",
    imagline: "ℐ",
    imagpart: "ℑ",
    imath: "ı",
    imof: "⊷",
    imped: "Ƶ",
    Implies: "⇒",
    in: "∈",
    incare: "℅",
    infin: "∞",
    infintie: "⧝",
    inodot: "ı",
    Int: "∬",
    int: "∫",
    intcal: "⊺",
    integers: "ℤ",
    Integral: "∫",
    intercal: "⊺",
    Intersection: "⋂",
    intlarhk: "⨗",
    intprod: "⨼",
    InvisibleComma: "⁣",
    InvisibleTimes: "⁢",
    IOcy: "Ё",
    iocy: "ё",
    Iogon: "Į",
    iogon: "į",
    Iopf: "𝕀",
    iopf: "𝕚",
    Iota: "Ι",
    iota: "ι",
    iprod: "⨼",
    iquest: "¿",
    Iscr: "ℐ",
    iscr: "𝒾",
    isin: "∈",
    isindot: "⋵",
    isinE: "⋹",
    isins: "⋴",
    isinsv: "⋳",
    isinv: "∈",
    it: "⁢",
    Itilde: "Ĩ",
    itilde: "ĩ",
    Iukcy: "І",
    iukcy: "і",
    Iuml: "Ï",
    iuml: "ï",
    Jcirc: "Ĵ",
    jcirc: "ĵ",
    Jcy: "Й",
    jcy: "й",
    Jfr: "𝔍",
    jfr: "𝔧",
    jmath: "ȷ",
    Jopf: "𝕁",
    jopf: "𝕛",
    Jscr: "𝒥",
    jscr: "𝒿",
    Jsercy: "Ј",
    jsercy: "ј",
    Jukcy: "Є",
    jukcy: "є",
    Kappa: "Κ",
    kappa: "κ",
    kappav: "ϰ",
    Kcedil: "Ķ",
    kcedil: "ķ",
    Kcy: "К",
    kcy: "к",
    Kfr: "𝔎",
    kfr: "𝔨",
    kgreen: "ĸ",
    KHcy: "Х",
    khcy: "х",
    KJcy: "Ќ",
    kjcy: "ќ",
    Kopf: "𝕂",
    kopf: "𝕜",
    Kscr: "𝒦",
    kscr: "𝓀",
    lAarr: "⇚",
    Lacute: "Ĺ",
    lacute: "ĺ",
    laemptyv: "⦴",
    lagran: "ℒ",
    Lambda: "Λ",
    lambda: "λ",
    Lang: "⟪",
    lang: "⟨",
    langd: "⦑",
    langle: "⟨",
    lap: "⪅",
    Laplacetrf: "ℒ",
    laquo: "«",
    Larr: "↞",
    lArr: "⇐",
    larr: "←",
    larrb: "⇤",
    larrbfs: "⤟",
    larrfs: "⤝",
    larrhk: "↩",
    larrlp: "↫",
    larrpl: "⤹",
    larrsim: "⥳",
    larrtl: "↢",
    lat: "⪫",
    lAtail: "⤛",
    latail: "⤙",
    late: "⪭",
    lates: "⪭︀",
    lBarr: "⤎",
    lbarr: "⤌",
    lbbrk: "❲",
    lbrace: "{",
    lbrack: "[",
    lbrke: "⦋",
    lbrksld: "⦏",
    lbrkslu: "⦍",
    Lcaron: "Ľ",
    lcaron: "ľ",
    Lcedil: "Ļ",
    lcedil: "ļ",
    lceil: "⌈",
    lcub: "{",
    Lcy: "Л",
    lcy: "л",
    ldca: "⤶",
    ldquo: "“",
    ldquor: "„",
    ldrdhar: "⥧",
    ldrushar: "⥋",
    ldsh: "↲",
    lE: "≦",
    le: "≤",
    LeftAngleBracket: "⟨",
    LeftArrow: "←",
    Leftarrow: "⇐",
    leftarrow: "←",
    LeftArrowBar: "⇤",
    LeftArrowRightArrow: "⇆",
    leftarrowtail: "↢",
    LeftCeiling: "⌈",
    LeftDoubleBracket: "⟦",
    LeftDownTeeVector: "⥡",
    LeftDownVector: "⇃",
    LeftDownVectorBar: "⥙",
    LeftFloor: "⌊",
    leftharpoondown: "↽",
    leftharpoonup: "↼",
    leftleftarrows: "⇇",
    LeftRightArrow: "↔",
    Leftrightarrow: "⇔",
    leftrightarrow: "↔",
    leftrightarrows: "⇆",
    leftrightharpoons: "⇋",
    leftrightsquigarrow: "↭",
    LeftRightVector: "⥎",
    LeftTee: "⊣",
    LeftTeeArrow: "↤",
    LeftTeeVector: "⥚",
    leftthreetimes: "⋋",
    LeftTriangle: "⊲",
    LeftTriangleBar: "⧏",
    LeftTriangleEqual: "⊴",
    LeftUpDownVector: "⥑",
    LeftUpTeeVector: "⥠",
    LeftUpVector: "↿",
    LeftUpVectorBar: "⥘",
    LeftVector: "↼",
    LeftVectorBar: "⥒",
    lEg: "⪋",
    leg: "⋚",
    leq: "≤",
    leqq: "≦",
    leqslant: "⩽",
    les: "⩽",
    lescc: "⪨",
    lesdot: "⩿",
    lesdoto: "⪁",
    lesdotor: "⪃",
    lesg: "⋚︀",
    lesges: "⪓",
    lessapprox: "⪅",
    lessdot: "⋖",
    lesseqgtr: "⋚",
    lesseqqgtr: "⪋",
    LessEqualGreater: "⋚",
    LessFullEqual: "≦",
    LessGreater: "≶",
    lessgtr: "≶",
    LessLess: "⪡",
    lesssim: "≲",
    LessSlantEqual: "⩽",
    LessTilde: "≲",
    lfisht: "⥼",
    lfloor: "⌊",
    Lfr: "𝔏",
    lfr: "𝔩",
    lg: "≶",
    lgE: "⪑",
    lHar: "⥢",
    lhard: "↽",
    lharu: "↼",
    lharul: "⥪",
    lhblk: "▄",
    LJcy: "Љ",
    ljcy: "љ",
    Ll: "⋘",
    ll: "≪",
    llarr: "⇇",
    llcorner: "⌞",
    Lleftarrow: "⇚",
    llhard: "⥫",
    lltri: "◺",
    Lmidot: "Ŀ",
    lmidot: "ŀ",
    lmoust: "⎰",
    lmoustache: "⎰",
    lnap: "⪉",
    lnapprox: "⪉",
    lnE: "≨",
    lne: "⪇",
    lneq: "⪇",
    lneqq: "≨",
    lnsim: "⋦",
    loang: "⟬",
    loarr: "⇽",
    lobrk: "⟦",
    LongLeftArrow: "⟵",
    Longleftarrow: "⟸",
    longleftarrow: "⟵",
    LongLeftRightArrow: "⟷",
    Longleftrightarrow: "⟺",
    longleftrightarrow: "⟷",
    longmapsto: "⟼",
    LongRightArrow: "⟶",
    Longrightarrow: "⟹",
    longrightarrow: "⟶",
    looparrowleft: "↫",
    looparrowright: "↬",
    lopar: "⦅",
    Lopf: "𝕃",
    lopf: "𝕝",
    loplus: "⨭",
    lotimes: "⨴",
    lowast: "∗",
    lowbar: "_",
    LowerLeftArrow: "↙",
    LowerRightArrow: "↘",
    loz: "◊",
    lozenge: "◊",
    lozf: "⧫",
    lpar: "(",
    lparlt: "⦓",
    lrarr: "⇆",
    lrcorner: "⌟",
    lrhar: "⇋",
    lrhard: "⥭",
    lrm: "‎",
    lrtri: "⊿",
    lsaquo: "‹",
    Lscr: "ℒ",
    lscr: "𝓁",
    Lsh: "↰",
    lsh: "↰",
    lsim: "≲",
    lsime: "⪍",
    lsimg: "⪏",
    lsqb: "[",
    lsquo: "‘",
    lsquor: "‚",
    Lstrok: "Ł",
    lstrok: "ł",
    Lt: "≪",
    LT: "<",
    lt: "<",
    ltcc: "⪦",
    ltcir: "⩹",
    ltdot: "⋖",
    lthree: "⋋",
    ltimes: "⋉",
    ltlarr: "⥶",
    ltquest: "⩻",
    ltri: "◃",
    ltrie: "⊴",
    ltrif: "◂",
    ltrPar: "⦖",
    lurdshar: "⥊",
    luruhar: "⥦",
    lvertneqq: "≨︀",
    lvnE: "≨︀",
    macr: "¯",
    male: "♂",
    malt: "✠",
    maltese: "✠",
    Map: "⤅",
    map: "↦",
    mapsto: "↦",
    mapstodown: "↧",
    mapstoleft: "↤",
    mapstoup: "↥",
    marker: "▮",
    mcomma: "⨩",
    Mcy: "М",
    mcy: "м",
    mdash: "—",
    mDDot: "∺",
    measuredangle: "∡",
    MediumSpace: " ",
    Mellintrf: "ℳ",
    Mfr: "𝔐",
    mfr: "𝔪",
    mho: "℧",
    micro: "µ",
    mid: "∣",
    midast: "*",
    midcir: "⫰",
    middot: "·",
    minus: "−",
    minusb: "⊟",
    minusd: "∸",
    minusdu: "⨪",
    MinusPlus: "∓",
    mlcp: "⫛",
    mldr: "…",
    mnplus: "∓",
    models: "⊧",
    Mopf: "𝕄",
    mopf: "𝕞",
    mp: "∓",
    Mscr: "ℳ",
    mscr: "𝓂",
    mstpos: "∾",
    Mu: "Μ",
    mu: "μ",
    multimap: "⊸",
    mumap: "⊸",
    nabla: "∇",
    Nacute: "Ń",
    nacute: "ń",
    nang: "∠⃒",
    nap: "≉",
    napE: "⩰̸",
    napid: "≋̸",
    napos: "ŉ",
    napprox: "≉",
    natur: "♮",
    natural: "♮",
    naturals: "ℕ",
    nbsp: " ",
    nbump: "≎̸",
    nbumpe: "≏̸",
    ncap: "⩃",
    Ncaron: "Ň",
    ncaron: "ň",
    Ncedil: "Ņ",
    ncedil: "ņ",
    ncong: "≇",
    ncongdot: "⩭̸",
    ncup: "⩂",
    Ncy: "Н",
    ncy: "н",
    ndash: "–",
    ne: "≠",
    nearhk: "⤤",
    neArr: "⇗",
    nearr: "↗",
    nearrow: "↗",
    nedot: "≐̸",
    NegativeMediumSpace: "​",
    NegativeThickSpace: "​",
    NegativeThinSpace: "​",
    NegativeVeryThinSpace: "​",
    nequiv: "≢",
    nesear: "⤨",
    nesim: "≂̸",
    NestedGreaterGreater: "≫",
    NestedLessLess: "≪",
    NewLine: `
`,
    nexist: "∄",
    nexists: "∄",
    Nfr: "𝔑",
    nfr: "𝔫",
    ngE: "≧̸",
    nge: "≱",
    ngeq: "≱",
    ngeqq: "≧̸",
    ngeqslant: "⩾̸",
    nges: "⩾̸",
    nGg: "⋙̸",
    ngsim: "≵",
    nGt: "≫⃒",
    ngt: "≯",
    ngtr: "≯",
    nGtv: "≫̸",
    nhArr: "⇎",
    nharr: "↮",
    nhpar: "⫲",
    ni: "∋",
    nis: "⋼",
    nisd: "⋺",
    niv: "∋",
    NJcy: "Њ",
    njcy: "њ",
    nlArr: "⇍",
    nlarr: "↚",
    nldr: "‥",
    nlE: "≦̸",
    nle: "≰",
    nLeftarrow: "⇍",
    nleftarrow: "↚",
    nLeftrightarrow: "⇎",
    nleftrightarrow: "↮",
    nleq: "≰",
    nleqq: "≦̸",
    nleqslant: "⩽̸",
    nles: "⩽̸",
    nless: "≮",
    nLl: "⋘̸",
    nlsim: "≴",
    nLt: "≪⃒",
    nlt: "≮",
    nltri: "⋪",
    nltrie: "⋬",
    nLtv: "≪̸",
    nmid: "∤",
    NoBreak: "⁠",
    NonBreakingSpace: " ",
    Nopf: "ℕ",
    nopf: "𝕟",
    Not: "⫬",
    not: "¬",
    NotCongruent: "≢",
    NotCupCap: "≭",
    NotDoubleVerticalBar: "∦",
    NotElement: "∉",
    NotEqual: "≠",
    NotEqualTilde: "≂̸",
    NotExists: "∄",
    NotGreater: "≯",
    NotGreaterEqual: "≱",
    NotGreaterFullEqual: "≧̸",
    NotGreaterGreater: "≫̸",
    NotGreaterLess: "≹",
    NotGreaterSlantEqual: "⩾̸",
    NotGreaterTilde: "≵",
    NotHumpDownHump: "≎̸",
    NotHumpEqual: "≏̸",
    notin: "∉",
    notindot: "⋵̸",
    notinE: "⋹̸",
    notinva: "∉",
    notinvb: "⋷",
    notinvc: "⋶",
    NotLeftTriangle: "⋪",
    NotLeftTriangleBar: "⧏̸",
    NotLeftTriangleEqual: "⋬",
    NotLess: "≮",
    NotLessEqual: "≰",
    NotLessGreater: "≸",
    NotLessLess: "≪̸",
    NotLessSlantEqual: "⩽̸",
    NotLessTilde: "≴",
    NotNestedGreaterGreater: "⪢̸",
    NotNestedLessLess: "⪡̸",
    notni: "∌",
    notniva: "∌",
    notnivb: "⋾",
    notnivc: "⋽",
    NotPrecedes: "⊀",
    NotPrecedesEqual: "⪯̸",
    NotPrecedesSlantEqual: "⋠",
    NotReverseElement: "∌",
    NotRightTriangle: "⋫",
    NotRightTriangleBar: "⧐̸",
    NotRightTriangleEqual: "⋭",
    NotSquareSubset: "⊏̸",
    NotSquareSubsetEqual: "⋢",
    NotSquareSuperset: "⊐̸",
    NotSquareSupersetEqual: "⋣",
    NotSubset: "⊂⃒",
    NotSubsetEqual: "⊈",
    NotSucceeds: "⊁",
    NotSucceedsEqual: "⪰̸",
    NotSucceedsSlantEqual: "⋡",
    NotSucceedsTilde: "≿̸",
    NotSuperset: "⊃⃒",
    NotSupersetEqual: "⊉",
    NotTilde: "≁",
    NotTildeEqual: "≄",
    NotTildeFullEqual: "≇",
    NotTildeTilde: "≉",
    NotVerticalBar: "∤",
    npar: "∦",
    nparallel: "∦",
    nparsl: "⫽⃥",
    npart: "∂̸",
    npolint: "⨔",
    npr: "⊀",
    nprcue: "⋠",
    npre: "⪯̸",
    nprec: "⊀",
    npreceq: "⪯̸",
    nrArr: "⇏",
    nrarr: "↛",
    nrarrc: "⤳̸",
    nrarrw: "↝̸",
    nRightarrow: "⇏",
    nrightarrow: "↛",
    nrtri: "⋫",
    nrtrie: "⋭",
    nsc: "⊁",
    nsccue: "⋡",
    nsce: "⪰̸",
    Nscr: "𝒩",
    nscr: "𝓃",
    nshortmid: "∤",
    nshortparallel: "∦",
    nsim: "≁",
    nsime: "≄",
    nsimeq: "≄",
    nsmid: "∤",
    nspar: "∦",
    nsqsube: "⋢",
    nsqsupe: "⋣",
    nsub: "⊄",
    nsubE: "⫅̸",
    nsube: "⊈",
    nsubset: "⊂⃒",
    nsubseteq: "⊈",
    nsubseteqq: "⫅̸",
    nsucc: "⊁",
    nsucceq: "⪰̸",
    nsup: "⊅",
    nsupE: "⫆̸",
    nsupe: "⊉",
    nsupset: "⊃⃒",
    nsupseteq: "⊉",
    nsupseteqq: "⫆̸",
    ntgl: "≹",
    Ntilde: "Ñ",
    ntilde: "ñ",
    ntlg: "≸",
    ntriangleleft: "⋪",
    ntrianglelefteq: "⋬",
    ntriangleright: "⋫",
    ntrianglerighteq: "⋭",
    Nu: "Ν",
    nu: "ν",
    num: "#",
    numero: "№",
    numsp: " ",
    nvap: "≍⃒",
    nVDash: "⊯",
    nVdash: "⊮",
    nvDash: "⊭",
    nvdash: "⊬",
    nvge: "≥⃒",
    nvgt: ">⃒",
    nvHarr: "⤄",
    nvinfin: "⧞",
    nvlArr: "⤂",
    nvle: "≤⃒",
    nvlt: "<⃒",
    nvltrie: "⊴⃒",
    nvrArr: "⤃",
    nvrtrie: "⊵⃒",
    nvsim: "∼⃒",
    nwarhk: "⤣",
    nwArr: "⇖",
    nwarr: "↖",
    nwarrow: "↖",
    nwnear: "⤧",
    Oacute: "Ó",
    oacute: "ó",
    oast: "⊛",
    ocir: "⊚",
    Ocirc: "Ô",
    ocirc: "ô",
    Ocy: "О",
    ocy: "о",
    odash: "⊝",
    Odblac: "Ő",
    odblac: "ő",
    odiv: "⨸",
    odot: "⊙",
    odsold: "⦼",
    OElig: "Œ",
    oelig: "œ",
    ofcir: "⦿",
    Ofr: "𝔒",
    ofr: "𝔬",
    ogon: "˛",
    Ograve: "Ò",
    ograve: "ò",
    ogt: "⧁",
    ohbar: "⦵",
    ohm: "Ω",
    oint: "∮",
    olarr: "↺",
    olcir: "⦾",
    olcross: "⦻",
    oline: "‾",
    olt: "⧀",
    Omacr: "Ō",
    omacr: "ō",
    Omega: "Ω",
    omega: "ω",
    Omicron: "Ο",
    omicron: "ο",
    omid: "⦶",
    ominus: "⊖",
    Oopf: "𝕆",
    oopf: "𝕠",
    opar: "⦷",
    OpenCurlyDoubleQuote: "“",
    OpenCurlyQuote: "‘",
    operp: "⦹",
    oplus: "⊕",
    Or: "⩔",
    or: "∨",
    orarr: "↻",
    ord: "⩝",
    order: "ℴ",
    orderof: "ℴ",
    ordf: "ª",
    ordm: "º",
    origof: "⊶",
    oror: "⩖",
    orslope: "⩗",
    orv: "⩛",
    oS: "Ⓢ",
    Oscr: "𝒪",
    oscr: "ℴ",
    Oslash: "Ø",
    oslash: "ø",
    osol: "⊘",
    Otilde: "Õ",
    otilde: "õ",
    Otimes: "⨷",
    otimes: "⊗",
    otimesas: "⨶",
    Ouml: "Ö",
    ouml: "ö",
    ovbar: "⌽",
    OverBar: "‾",
    OverBrace: "⏞",
    OverBracket: "⎴",
    OverParenthesis: "⏜",
    par: "∥",
    para: "¶",
    parallel: "∥",
    parsim: "⫳",
    parsl: "⫽",
    part: "∂",
    PartialD: "∂",
    Pcy: "П",
    pcy: "п",
    percnt: "%",
    period: ".",
    permil: "‰",
    perp: "⊥",
    pertenk: "‱",
    Pfr: "𝔓",
    pfr: "𝔭",
    Phi: "Φ",
    phi: "φ",
    phiv: "ϕ",
    phmmat: "ℳ",
    phone: "☎",
    Pi: "Π",
    pi: "π",
    pitchfork: "⋔",
    piv: "ϖ",
    planck: "ℏ",
    planckh: "ℎ",
    plankv: "ℏ",
    plus: "+",
    plusacir: "⨣",
    plusb: "⊞",
    pluscir: "⨢",
    plusdo: "∔",
    plusdu: "⨥",
    pluse: "⩲",
    PlusMinus: "±",
    plusmn: "±",
    plussim: "⨦",
    plustwo: "⨧",
    pm: "±",
    Poincareplane: "ℌ",
    pointint: "⨕",
    Popf: "ℙ",
    popf: "𝕡",
    pound: "£",
    Pr: "⪻",
    pr: "≺",
    prap: "⪷",
    prcue: "≼",
    prE: "⪳",
    pre: "⪯",
    prec: "≺",
    precapprox: "⪷",
    preccurlyeq: "≼",
    Precedes: "≺",
    PrecedesEqual: "⪯",
    PrecedesSlantEqual: "≼",
    PrecedesTilde: "≾",
    preceq: "⪯",
    precnapprox: "⪹",
    precneqq: "⪵",
    precnsim: "⋨",
    precsim: "≾",
    Prime: "″",
    prime: "′",
    primes: "ℙ",
    prnap: "⪹",
    prnE: "⪵",
    prnsim: "⋨",
    prod: "∏",
    Product: "∏",
    profalar: "⌮",
    profline: "⌒",
    profsurf: "⌓",
    prop: "∝",
    Proportion: "∷",
    Proportional: "∝",
    propto: "∝",
    prsim: "≾",
    prurel: "⊰",
    Pscr: "𝒫",
    pscr: "𝓅",
    Psi: "Ψ",
    psi: "ψ",
    puncsp: " ",
    Qfr: "𝔔",
    qfr: "𝔮",
    qint: "⨌",
    Qopf: "ℚ",
    qopf: "𝕢",
    qprime: "⁗",
    Qscr: "𝒬",
    qscr: "𝓆",
    quaternions: "ℍ",
    quatint: "⨖",
    quest: "?",
    questeq: "≟",
    QUOT: '"',
    quot: '"',
    rAarr: "⇛",
    race: "∽̱",
    Racute: "Ŕ",
    racute: "ŕ",
    radic: "√",
    raemptyv: "⦳",
    Rang: "⟫",
    rang: "⟩",
    rangd: "⦒",
    range: "⦥",
    rangle: "⟩",
    raquo: "»",
    Rarr: "↠",
    rArr: "⇒",
    rarr: "→",
    rarrap: "⥵",
    rarrb: "⇥",
    rarrbfs: "⤠",
    rarrc: "⤳",
    rarrfs: "⤞",
    rarrhk: "↪",
    rarrlp: "↬",
    rarrpl: "⥅",
    rarrsim: "⥴",
    Rarrtl: "⤖",
    rarrtl: "↣",
    rarrw: "↝",
    rAtail: "⤜",
    ratail: "⤚",
    ratio: "∶",
    rationals: "ℚ",
    RBarr: "⤐",
    rBarr: "⤏",
    rbarr: "⤍",
    rbbrk: "❳",
    rbrace: "}",
    rbrack: "]",
    rbrke: "⦌",
    rbrksld: "⦎",
    rbrkslu: "⦐",
    Rcaron: "Ř",
    rcaron: "ř",
    Rcedil: "Ŗ",
    rcedil: "ŗ",
    rceil: "⌉",
    rcub: "}",
    Rcy: "Р",
    rcy: "р",
    rdca: "⤷",
    rdldhar: "⥩",
    rdquo: "”",
    rdquor: "”",
    rdsh: "↳",
    Re: "ℜ",
    real: "ℜ",
    realine: "ℛ",
    realpart: "ℜ",
    reals: "ℝ",
    rect: "▭",
    REG: "®",
    reg: "®",
    ReverseElement: "∋",
    ReverseEquilibrium: "⇋",
    ReverseUpEquilibrium: "⥯",
    rfisht: "⥽",
    rfloor: "⌋",
    Rfr: "ℜ",
    rfr: "𝔯",
    rHar: "⥤",
    rhard: "⇁",
    rharu: "⇀",
    rharul: "⥬",
    Rho: "Ρ",
    rho: "ρ",
    rhov: "ϱ",
    RightAngleBracket: "⟩",
    RightArrow: "→",
    Rightarrow: "⇒",
    rightarrow: "→",
    RightArrowBar: "⇥",
    RightArrowLeftArrow: "⇄",
    rightarrowtail: "↣",
    RightCeiling: "⌉",
    RightDoubleBracket: "⟧",
    RightDownTeeVector: "⥝",
    RightDownVector: "⇂",
    RightDownVectorBar: "⥕",
    RightFloor: "⌋",
    rightharpoondown: "⇁",
    rightharpoonup: "⇀",
    rightleftarrows: "⇄",
    rightleftharpoons: "⇌",
    rightrightarrows: "⇉",
    rightsquigarrow: "↝",
    RightTee: "⊢",
    RightTeeArrow: "↦",
    RightTeeVector: "⥛",
    rightthreetimes: "⋌",
    RightTriangle: "⊳",
    RightTriangleBar: "⧐",
    RightTriangleEqual: "⊵",
    RightUpDownVector: "⥏",
    RightUpTeeVector: "⥜",
    RightUpVector: "↾",
    RightUpVectorBar: "⥔",
    RightVector: "⇀",
    RightVectorBar: "⥓",
    ring: "˚",
    risingdotseq: "≓",
    rlarr: "⇄",
    rlhar: "⇌",
    rlm: "‏",
    rmoust: "⎱",
    rmoustache: "⎱",
    rnmid: "⫮",
    roang: "⟭",
    roarr: "⇾",
    robrk: "⟧",
    ropar: "⦆",
    Ropf: "ℝ",
    ropf: "𝕣",
    roplus: "⨮",
    rotimes: "⨵",
    RoundImplies: "⥰",
    rpar: ")",
    rpargt: "⦔",
    rppolint: "⨒",
    rrarr: "⇉",
    Rrightarrow: "⇛",
    rsaquo: "›",
    Rscr: "ℛ",
    rscr: "𝓇",
    Rsh: "↱",
    rsh: "↱",
    rsqb: "]",
    rsquo: "’",
    rsquor: "’",
    rthree: "⋌",
    rtimes: "⋊",
    rtri: "▹",
    rtrie: "⊵",
    rtrif: "▸",
    rtriltri: "⧎",
    RuleDelayed: "⧴",
    ruluhar: "⥨",
    rx: "℞",
    Sacute: "Ś",
    sacute: "ś",
    sbquo: "‚",
    Sc: "⪼",
    sc: "≻",
    scap: "⪸",
    Scaron: "Š",
    scaron: "š",
    sccue: "≽",
    scE: "⪴",
    sce: "⪰",
    Scedil: "Ş",
    scedil: "ş",
    Scirc: "Ŝ",
    scirc: "ŝ",
    scnap: "⪺",
    scnE: "⪶",
    scnsim: "⋩",
    scpolint: "⨓",
    scsim: "≿",
    Scy: "С",
    scy: "с",
    sdot: "⋅",
    sdotb: "⊡",
    sdote: "⩦",
    searhk: "⤥",
    seArr: "⇘",
    searr: "↘",
    searrow: "↘",
    sect: "§",
    semi: ";",
    seswar: "⤩",
    setminus: "∖",
    setmn: "∖",
    sext: "✶",
    Sfr: "𝔖",
    sfr: "𝔰",
    sfrown: "⌢",
    sharp: "♯",
    SHCHcy: "Щ",
    shchcy: "щ",
    SHcy: "Ш",
    shcy: "ш",
    ShortDownArrow: "↓",
    ShortLeftArrow: "←",
    shortmid: "∣",
    shortparallel: "∥",
    ShortRightArrow: "→",
    ShortUpArrow: "↑",
    shy: "­",
    Sigma: "Σ",
    sigma: "σ",
    sigmaf: "ς",
    sigmav: "ς",
    sim: "∼",
    simdot: "⩪",
    sime: "≃",
    simeq: "≃",
    simg: "⪞",
    simgE: "⪠",
    siml: "⪝",
    simlE: "⪟",
    simne: "≆",
    simplus: "⨤",
    simrarr: "⥲",
    slarr: "←",
    SmallCircle: "∘",
    smallsetminus: "∖",
    smashp: "⨳",
    smeparsl: "⧤",
    smid: "∣",
    smile: "⌣",
    smt: "⪪",
    smte: "⪬",
    smtes: "⪬︀",
    SOFTcy: "Ь",
    softcy: "ь",
    sol: "/",
    solb: "⧄",
    solbar: "⌿",
    Sopf: "𝕊",
    sopf: "𝕤",
    spades: "♠",
    spadesuit: "♠",
    spar: "∥",
    sqcap: "⊓",
    sqcaps: "⊓︀",
    sqcup: "⊔",
    sqcups: "⊔︀",
    Sqrt: "√",
    sqsub: "⊏",
    sqsube: "⊑",
    sqsubset: "⊏",
    sqsubseteq: "⊑",
    sqsup: "⊐",
    sqsupe: "⊒",
    sqsupset: "⊐",
    sqsupseteq: "⊒",
    squ: "□",
    Square: "□",
    square: "□",
    SquareIntersection: "⊓",
    SquareSubset: "⊏",
    SquareSubsetEqual: "⊑",
    SquareSuperset: "⊐",
    SquareSupersetEqual: "⊒",
    SquareUnion: "⊔",
    squarf: "▪",
    squf: "▪",
    srarr: "→",
    Sscr: "𝒮",
    sscr: "𝓈",
    ssetmn: "∖",
    ssmile: "⌣",
    sstarf: "⋆",
    Star: "⋆",
    star: "☆",
    starf: "★",
    straightepsilon: "ϵ",
    straightphi: "ϕ",
    strns: "¯",
    Sub: "⋐",
    sub: "⊂",
    subdot: "⪽",
    subE: "⫅",
    sube: "⊆",
    subedot: "⫃",
    submult: "⫁",
    subnE: "⫋",
    subne: "⊊",
    subplus: "⪿",
    subrarr: "⥹",
    Subset: "⋐",
    subset: "⊂",
    subseteq: "⊆",
    subseteqq: "⫅",
    SubsetEqual: "⊆",
    subsetneq: "⊊",
    subsetneqq: "⫋",
    subsim: "⫇",
    subsub: "⫕",
    subsup: "⫓",
    succ: "≻",
    succapprox: "⪸",
    succcurlyeq: "≽",
    Succeeds: "≻",
    SucceedsEqual: "⪰",
    SucceedsSlantEqual: "≽",
    SucceedsTilde: "≿",
    succeq: "⪰",
    succnapprox: "⪺",
    succneqq: "⪶",
    succnsim: "⋩",
    succsim: "≿",
    SuchThat: "∋",
    Sum: "∑",
    sum: "∑",
    sung: "♪",
    Sup: "⋑",
    sup: "⊃",
    sup1: "¹",
    sup2: "²",
    sup3: "³",
    supdot: "⪾",
    supdsub: "⫘",
    supE: "⫆",
    supe: "⊇",
    supedot: "⫄",
    Superset: "⊃",
    SupersetEqual: "⊇",
    suphsol: "⟉",
    suphsub: "⫗",
    suplarr: "⥻",
    supmult: "⫂",
    supnE: "⫌",
    supne: "⊋",
    supplus: "⫀",
    Supset: "⋑",
    supset: "⊃",
    supseteq: "⊇",
    supseteqq: "⫆",
    supsetneq: "⊋",
    supsetneqq: "⫌",
    supsim: "⫈",
    supsub: "⫔",
    supsup: "⫖",
    swarhk: "⤦",
    swArr: "⇙",
    swarr: "↙",
    swarrow: "↙",
    swnwar: "⤪",
    szlig: "ß",
    Tab: "	",
    target: "⌖",
    Tau: "Τ",
    tau: "τ",
    tbrk: "⎴",
    Tcaron: "Ť",
    tcaron: "ť",
    Tcedil: "Ţ",
    tcedil: "ţ",
    Tcy: "Т",
    tcy: "т",
    tdot: "⃛",
    telrec: "⌕",
    Tfr: "𝔗",
    tfr: "𝔱",
    there4: "∴",
    Therefore: "∴",
    therefore: "∴",
    Theta: "Θ",
    theta: "θ",
    thetasym: "ϑ",
    thetav: "ϑ",
    thickapprox: "≈",
    thicksim: "∼",
    ThickSpace: "  ",
    thinsp: " ",
    ThinSpace: " ",
    thkap: "≈",
    thksim: "∼",
    THORN: "Þ",
    thorn: "þ",
    Tilde: "∼",
    tilde: "˜",
    TildeEqual: "≃",
    TildeFullEqual: "≅",
    TildeTilde: "≈",
    times: "×",
    timesb: "⊠",
    timesbar: "⨱",
    timesd: "⨰",
    tint: "∭",
    toea: "⤨",
    top: "⊤",
    topbot: "⌶",
    topcir: "⫱",
    Topf: "𝕋",
    topf: "𝕥",
    topfork: "⫚",
    tosa: "⤩",
    tprime: "‴",
    TRADE: "™",
    trade: "™",
    triangle: "▵",
    triangledown: "▿",
    triangleleft: "◃",
    trianglelefteq: "⊴",
    triangleq: "≜",
    triangleright: "▹",
    trianglerighteq: "⊵",
    tridot: "◬",
    trie: "≜",
    triminus: "⨺",
    TripleDot: "⃛",
    triplus: "⨹",
    trisb: "⧍",
    tritime: "⨻",
    trpezium: "⏢",
    Tscr: "𝒯",
    tscr: "𝓉",
    TScy: "Ц",
    tscy: "ц",
    TSHcy: "Ћ",
    tshcy: "ћ",
    Tstrok: "Ŧ",
    tstrok: "ŧ",
    twixt: "≬",
    twoheadleftarrow: "↞",
    twoheadrightarrow: "↠",
    Uacute: "Ú",
    uacute: "ú",
    Uarr: "↟",
    uArr: "⇑",
    uarr: "↑",
    Uarrocir: "⥉",
    Ubrcy: "Ў",
    ubrcy: "ў",
    Ubreve: "Ŭ",
    ubreve: "ŭ",
    Ucirc: "Û",
    ucirc: "û",
    Ucy: "У",
    ucy: "у",
    udarr: "⇅",
    Udblac: "Ű",
    udblac: "ű",
    udhar: "⥮",
    ufisht: "⥾",
    Ufr: "𝔘",
    ufr: "𝔲",
    Ugrave: "Ù",
    ugrave: "ù",
    uHar: "⥣",
    uharl: "↿",
    uharr: "↾",
    uhblk: "▀",
    ulcorn: "⌜",
    ulcorner: "⌜",
    ulcrop: "⌏",
    ultri: "◸",
    Umacr: "Ū",
    umacr: "ū",
    uml: "¨",
    UnderBar: "_",
    UnderBrace: "⏟",
    UnderBracket: "⎵",
    UnderParenthesis: "⏝",
    Union: "⋃",
    UnionPlus: "⊎",
    Uogon: "Ų",
    uogon: "ų",
    Uopf: "𝕌",
    uopf: "𝕦",
    UpArrow: "↑",
    Uparrow: "⇑",
    uparrow: "↑",
    UpArrowBar: "⤒",
    UpArrowDownArrow: "⇅",
    UpDownArrow: "↕",
    Updownarrow: "⇕",
    updownarrow: "↕",
    UpEquilibrium: "⥮",
    upharpoonleft: "↿",
    upharpoonright: "↾",
    uplus: "⊎",
    UpperLeftArrow: "↖",
    UpperRightArrow: "↗",
    Upsi: "ϒ",
    upsi: "υ",
    upsih: "ϒ",
    Upsilon: "Υ",
    upsilon: "υ",
    UpTee: "⊥",
    UpTeeArrow: "↥",
    upuparrows: "⇈",
    urcorn: "⌝",
    urcorner: "⌝",
    urcrop: "⌎",
    Uring: "Ů",
    uring: "ů",
    urtri: "◹",
    Uscr: "𝒰",
    uscr: "𝓊",
    utdot: "⋰",
    Utilde: "Ũ",
    utilde: "ũ",
    utri: "▵",
    utrif: "▴",
    uuarr: "⇈",
    Uuml: "Ü",
    uuml: "ü",
    uwangle: "⦧",
    vangrt: "⦜",
    varepsilon: "ϵ",
    varkappa: "ϰ",
    varnothing: "∅",
    varphi: "ϕ",
    varpi: "ϖ",
    varpropto: "∝",
    vArr: "⇕",
    varr: "↕",
    varrho: "ϱ",
    varsigma: "ς",
    varsubsetneq: "⊊︀",
    varsubsetneqq: "⫋︀",
    varsupsetneq: "⊋︀",
    varsupsetneqq: "⫌︀",
    vartheta: "ϑ",
    vartriangleleft: "⊲",
    vartriangleright: "⊳",
    Vbar: "⫫",
    vBar: "⫨",
    vBarv: "⫩",
    Vcy: "В",
    vcy: "в",
    VDash: "⊫",
    Vdash: "⊩",
    vDash: "⊨",
    vdash: "⊢",
    Vdashl: "⫦",
    Vee: "⋁",
    vee: "∨",
    veebar: "⊻",
    veeeq: "≚",
    vellip: "⋮",
    Verbar: "‖",
    verbar: "|",
    Vert: "‖",
    vert: "|",
    VerticalBar: "∣",
    VerticalLine: "|",
    VerticalSeparator: "❘",
    VerticalTilde: "≀",
    VeryThinSpace: " ",
    Vfr: "𝔙",
    vfr: "𝔳",
    vltri: "⊲",
    vnsub: "⊂⃒",
    vnsup: "⊃⃒",
    Vopf: "𝕍",
    vopf: "𝕧",
    vprop: "∝",
    vrtri: "⊳",
    Vscr: "𝒱",
    vscr: "𝓋",
    vsubnE: "⫋︀",
    vsubne: "⊊︀",
    vsupnE: "⫌︀",
    vsupne: "⊋︀",
    Vvdash: "⊪",
    vzigzag: "⦚",
    Wcirc: "Ŵ",
    wcirc: "ŵ",
    wedbar: "⩟",
    Wedge: "⋀",
    wedge: "∧",
    wedgeq: "≙",
    weierp: "℘",
    Wfr: "𝔚",
    wfr: "𝔴",
    Wopf: "𝕎",
    wopf: "𝕨",
    wp: "℘",
    wr: "≀",
    wreath: "≀",
    Wscr: "𝒲",
    wscr: "𝓌",
    xcap: "⋂",
    xcirc: "◯",
    xcup: "⋃",
    xdtri: "▽",
    Xfr: "𝔛",
    xfr: "𝔵",
    xhArr: "⟺",
    xharr: "⟷",
    Xi: "Ξ",
    xi: "ξ",
    xlArr: "⟸",
    xlarr: "⟵",
    xmap: "⟼",
    xnis: "⋻",
    xodot: "⨀",
    Xopf: "𝕏",
    xopf: "𝕩",
    xoplus: "⨁",
    xotime: "⨂",
    xrArr: "⟹",
    xrarr: "⟶",
    Xscr: "𝒳",
    xscr: "𝓍",
    xsqcup: "⨆",
    xuplus: "⨄",
    xutri: "△",
    xvee: "⋁",
    xwedge: "⋀",
    Yacute: "Ý",
    yacute: "ý",
    YAcy: "Я",
    yacy: "я",
    Ycirc: "Ŷ",
    ycirc: "ŷ",
    Ycy: "Ы",
    ycy: "ы",
    yen: "¥",
    Yfr: "𝔜",
    yfr: "𝔶",
    YIcy: "Ї",
    yicy: "ї",
    Yopf: "𝕐",
    yopf: "𝕪",
    Yscr: "𝒴",
    yscr: "𝓎",
    YUcy: "Ю",
    yucy: "ю",
    Yuml: "Ÿ",
    yuml: "ÿ",
    Zacute: "Ź",
    zacute: "ź",
    Zcaron: "Ž",
    zcaron: "ž",
    Zcy: "З",
    zcy: "з",
    Zdot: "Ż",
    zdot: "ż",
    zeetrf: "ℨ",
    ZeroWidthSpace: "​",
    Zeta: "Ζ",
    zeta: "ζ",
    Zfr: "ℨ",
    zfr: "𝔷",
    ZHcy: "Ж",
    zhcy: "ж",
    zigrarr: "⇝",
    Zopf: "ℤ",
    zopf: "𝕫",
    Zscr: "𝒵",
    zscr: "𝓏",
    zwj: "‍",
    zwnj: "‌"
  }), t.entityMap = t.HTML_ENTITIES;
})(RL);
var wC = {}, Am = bs.NAMESPACE, FT = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, F8 = new RegExp("[\\-\\.0-9" + FT.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), U8 = new RegExp("^" + FT.source + F8.source + "*(?::" + FT.source + F8.source + "*)?$"), up = 0, el = 1, Od = 2, dp = 3, Fd = 4, Ud = 5, fp = 6, vy = 7;
function Bf(t, e) {
  this.message = t, this.locator = e, Error.captureStackTrace && Error.captureStackTrace(this, Bf);
}
Bf.prototype = new Error();
Bf.prototype.name = Bf.name;
function IL() {
}
IL.prototype = {
  parse: function(t, e, n) {
    var r = this.domBuilder;
    r.startDocument(), OL(e, e = {}), ihe(
      t,
      e,
      n,
      r,
      this.errorHandler
    ), r.endDocument();
  }
};
function ihe(t, e, n, r, i) {
  function o(ee) {
    if (ee > 65535) {
      ee -= 65536;
      var Z = 55296 + (ee >> 10), oe = 56320 + (ee & 1023);
      return String.fromCharCode(Z, oe);
    } else
      return String.fromCharCode(ee);
  }
  function a(ee) {
    var Z = ee.slice(1, -1);
    return Object.hasOwnProperty.call(n, Z) ? n[Z] : Z.charAt(0) === "#" ? o(parseInt(Z.substr(1).replace("x", "0x"))) : (i.error("entity not found:" + ee), ee);
  }
  function s(ee) {
    if (ee > g) {
      var Z = t.substring(g, ee).replace(/&#?\w+;/g, a);
      f && l(g), r.characters(Z, 0, ee - g), g = ee;
    }
  }
  function l(ee, Z) {
    for (; ee >= u && (Z = d.exec(t)); )
      c = Z.index, u = c + Z[0].length, f.lineNumber++;
    f.columnNumber = ee - c + 1;
  }
  for (var c = 0, u = 0, d = /.*(?:\r\n?|\n)|.*$/g, f = r.locator, p = [{ currentNSMap: e }], m = {}, g = 0; ; ) {
    try {
      var b = t.indexOf("<", g);
      if (b < 0) {
        if (!t.substr(g).match(/^\s*$/)) {
          var y = r.doc, w = y.createTextNode(t.substr(g));
          y.appendChild(w), r.currentElement = w;
        }
        return;
      }
      switch (b > g && s(b), t.charAt(b + 1)) {
        case "/":
          var be = t.indexOf(">", b + 3), x = t.substring(b + 2, be).replace(/[ \t\n\r]+$/g, ""), k = p.pop();
          be < 0 ? (x = t.substring(b + 2).replace(/[\s<].*/, ""), i.error("end tag name: " + x + " is not complete:" + k.tagName), be = b + 1 + x.length) : x.match(/\s</) && (x = x.replace(/[\s<].*/, ""), i.error("end tag name: " + x + " maybe not complete"), be = b + 1 + x.length);
          var A = k.localNSMap, U = k.tagName == x, P = U || k.tagName && k.tagName.toLowerCase() == x.toLowerCase();
          if (P) {
            if (r.endElement(k.uri, k.localName, x), A)
              for (var V in A)
                Object.prototype.hasOwnProperty.call(A, V) && r.endPrefixMapping(V);
            U || i.fatalError("end tag name: " + x + " is not match the current start tagName:" + k.tagName);
          } else
            p.push(k);
          be++;
          break;
        case "?":
          f && l(b), be = che(t, b, r);
          break;
        case "!":
          f && l(b), be = lhe(t, b, r, i);
          break;
        default:
          f && l(b);
          var I = new FL(), le = p[p.length - 1].currentNSMap, be = ohe(t, b, I, le, a, i), F = I.length;
          if (!I.closed && she(t, be, I.tagName, m) && (I.closed = !0, n.nbsp || i.warning("unclosed xml attribute")), f && F) {
            for (var G = N8(f, {}), C = 0; C < F; C++) {
              var ie = I[C];
              l(ie.offset), ie.locator = N8(f, {});
            }
            r.locator = G, M8(I, r, le) && p.push(I), r.locator = f;
          } else
            M8(I, r, le) && p.push(I);
          Am.isHTML(I.uri) && !I.closed ? be = ahe(t, be, I.tagName, a, r) : be++;
      }
    } catch (ee) {
      if (ee instanceof Bf)
        throw ee;
      i.error("element parse error: " + ee), be = -1;
    }
    be > g ? g = be : s(Math.max(b, g) + 1);
  }
}
function N8(t, e) {
  return e.lineNumber = t.lineNumber, e.columnNumber = t.columnNumber, e;
}
function ohe(t, e, n, r, i, o) {
  function a(f, p, m) {
    n.attributeNames.hasOwnProperty(f) && o.fatalError("Attribute " + f + " redefined"), n.addValue(
      f,
      // @see https://www.w3.org/TR/xml/#AVNormalize
      // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
      // - recursive replacement of (DTD) entity references
      // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
      p.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, i),
      m
    );
  }
  for (var s, l, c = ++e, u = up; ; ) {
    var d = t.charAt(c);
    switch (d) {
      case "=":
        if (u === el)
          s = t.slice(e, c), u = dp;
        else if (u === Od)
          u = dp;
        else
          throw new Error("attribute equal must after attrName");
        break;
      case "'":
      case '"':
        if (u === dp || u === el)
          if (u === el && (o.warning('attribute value must after "="'), s = t.slice(e, c)), e = c + 1, c = t.indexOf(d, e), c > 0)
            l = t.slice(e, c), a(s, l, e - 1), u = Ud;
          else
            throw new Error("attribute value no end '" + d + "' match");
        else if (u == Fd)
          l = t.slice(e, c), a(s, l, e), o.warning('attribute "' + s + '" missed start quot(' + d + ")!!"), e = c + 1, u = Ud;
        else
          throw new Error('attribute value must after "="');
        break;
      case "/":
        switch (u) {
          case up:
            n.setTagName(t.slice(e, c));
          case Ud:
          case fp:
          case vy:
            u = vy, n.closed = !0;
          case Fd:
          case el:
            break;
          case Od:
            n.closed = !0;
            break;
          default:
            throw new Error("attribute invalid close char('/')");
        }
        break;
      case "":
        return o.error("unexpected end of input"), u == up && n.setTagName(t.slice(e, c)), c;
      case ">":
        switch (u) {
          case up:
            n.setTagName(t.slice(e, c));
          case Ud:
          case fp:
          case vy:
            break;
          case Fd:
          case el:
            l = t.slice(e, c), l.slice(-1) === "/" && (n.closed = !0, l = l.slice(0, -1));
          case Od:
            u === Od && (l = s), u == Fd ? (o.warning('attribute "' + l + '" missed quot(")!'), a(s, l, e)) : ((!Am.isHTML(r[""]) || !l.match(/^(?:disabled|checked|selected)$/i)) && o.warning('attribute "' + l + '" missed value!! "' + l + '" instead!!'), a(l, l, e));
            break;
          case dp:
            throw new Error("attribute value missed!!");
        }
        return c;
      case "":
        d = " ";
      default:
        if (d <= " ")
          switch (u) {
            case up:
              n.setTagName(t.slice(e, c)), u = fp;
              break;
            case el:
              s = t.slice(e, c), u = Od;
              break;
            case Fd:
              var l = t.slice(e, c);
              o.warning('attribute "' + l + '" missed quot(")!!'), a(s, l, e);
            case Ud:
              u = fp;
              break;
          }
        else
          switch (u) {
            case Od:
              n.tagName, (!Am.isHTML(r[""]) || !s.match(/^(?:disabled|checked|selected)$/i)) && o.warning('attribute "' + s + '" missed value!! "' + s + '" instead2!!'), a(s, s, e), e = c, u = el;
              break;
            case Ud:
              o.warning('attribute space is required"' + s + '"!!');
            case fp:
              u = el, e = c;
              break;
            case dp:
              u = Fd, e = c;
              break;
            case vy:
              throw new Error("elements closed character '/' and '>' must be connected to");
          }
    }
    c++;
  }
}
function M8(t, e, n) {
  for (var r = t.tagName, i = null, d = t.length; d--; ) {
    var o = t[d], a = o.qName, s = o.value, f = a.indexOf(":");
    if (f > 0)
      var l = o.prefix = a.slice(0, f), c = a.slice(f + 1), u = l === "xmlns" && c;
    else
      c = a, l = null, u = a === "xmlns" && "";
    o.localName = c, u !== !1 && (i == null && (i = {}, OL(n, n = {})), n[u] = i[u] = s, o.uri = Am.XMLNS, e.startPrefixMapping(u, s));
  }
  for (var d = t.length; d--; ) {
    o = t[d];
    var l = o.prefix;
    l && (l === "xml" && (o.uri = Am.XML), l !== "xmlns" && (o.uri = n[l || ""]));
  }
  var f = r.indexOf(":");
  f > 0 ? (l = t.prefix = r.slice(0, f), c = t.localName = r.slice(f + 1)) : (l = null, c = t.localName = r);
  var p = t.uri = n[l || ""];
  if (e.startElement(p, c, r, t), t.closed) {
    if (e.endElement(p, c, r), i)
      for (l in i)
        Object.prototype.hasOwnProperty.call(i, l) && e.endPrefixMapping(l);
  } else
    return t.currentNSMap = n, t.localNSMap = i, !0;
}
function ahe(t, e, n, r, i) {
  if (/^(?:script|textarea)$/i.test(n)) {
    var o = t.indexOf("</" + n + ">", e), a = t.substring(e + 1, o);
    if (/[&<]/.test(a))
      return /^script$/i.test(n) ? (i.characters(a, 0, a.length), o) : (a = a.replace(/&#?\w+;/g, r), i.characters(a, 0, a.length), o);
  }
  return e + 1;
}
function she(t, e, n, r) {
  var i = r[n];
  return i == null && (i = t.lastIndexOf("</" + n + ">"), i < e && (i = t.lastIndexOf("</" + n)), r[n] = i), i < e;
}
function OL(t, e) {
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
}
function lhe(t, e, n, r) {
  var i = t.charAt(e + 2);
  switch (i) {
    case "-":
      if (t.charAt(e + 3) === "-") {
        var o = t.indexOf("-->", e + 4);
        return o > e ? (n.comment(t, e + 4, o - e - 4), o + 3) : (r.error("Unclosed comment"), -1);
      } else
        return -1;
    default:
      if (t.substr(e + 3, 6) == "CDATA[") {
        var o = t.indexOf("]]>", e + 9);
        return n.startCDATA(), n.characters(t, e + 9, o - e - 9), n.endCDATA(), o + 3;
      }
      var a = uhe(t, e), s = a.length;
      if (s > 1 && /!doctype/i.test(a[0][0])) {
        var l = a[1][0], c = !1, u = !1;
        s > 3 && (/^public$/i.test(a[2][0]) ? (c = a[3][0], u = s > 4 && a[4][0]) : /^system$/i.test(a[2][0]) && (u = a[3][0]));
        var d = a[s - 1];
        return n.startDTD(l, c, u), n.endDTD(), d.index + d[0].length;
      }
  }
  return -1;
}
function che(t, e, n) {
  var r = t.indexOf("?>", e);
  if (r) {
    var i = t.substring(e, r).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
    return i ? (i[0].length, n.processingInstruction(i[1], i[2]), r + 2) : -1;
  }
  return -1;
}
function FL() {
  this.attributeNames = {};
}
FL.prototype = {
  setTagName: function(t) {
    if (!U8.test(t))
      throw new Error("invalid tagName:" + t);
    this.tagName = t;
  },
  addValue: function(t, e, n) {
    if (!U8.test(t))
      throw new Error("invalid attribute:" + t);
    this.attributeNames[t] = this.length, this[this.length++] = { qName: t, value: e, offset: n };
  },
  length: 0,
  getLocalName: function(t) {
    return this[t].localName;
  },
  getLocator: function(t) {
    return this[t].locator;
  },
  getQName: function(t) {
    return this[t].qName;
  },
  getURI: function(t) {
    return this[t].uri;
  },
  getValue: function(t) {
    return this[t].value;
  }
  //	,getIndex:function(uri, localName)){
  //		if(localName){
  //
  //		}else{
  //			var qName = uri
  //		}
  //	},
  //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
  //	getType:function(uri,localName){}
  //	getType:function(i){},
};
function uhe(t, e) {
  var n, r = [], i = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
  for (i.lastIndex = e, i.exec(t); n = i.exec(t); )
    if (r.push(n), n[1]) return r;
}
wC.XMLReader = IL;
wC.ParseError = Bf;
var dhe = bs, fhe = wa, B8 = RL, UL = wC, hhe = fhe.DOMImplementation, L8 = dhe.NAMESPACE, phe = UL.ParseError, mhe = UL.XMLReader;
function NL(t) {
  return t.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028]/g, `
`);
}
function ML(t) {
  this.options = t || { locator: {} };
}
ML.prototype.parseFromString = function(t, e) {
  var n = this.options, r = new mhe(), i = n.domBuilder || new Qm(), o = n.errorHandler, a = n.locator, s = n.xmlns || {}, l = /\/x?html?$/.test(e), c = l ? B8.HTML_ENTITIES : B8.XML_ENTITIES;
  a && i.setDocumentLocator(a), r.errorHandler = ghe(o, i, a), r.domBuilder = n.domBuilder || i, l && (s[""] = L8.HTML), s.xml = s.xml || L8.XML;
  var u = n.normalizeLineEndings || NL;
  return t && typeof t == "string" ? r.parse(
    u(t),
    s,
    c
  ) : r.errorHandler.error("invalid doc source"), i.doc;
};
function ghe(t, e, n) {
  if (!t) {
    if (e instanceof Qm)
      return e;
    t = e;
  }
  var r = {}, i = t instanceof Function;
  n = n || {};
  function o(a) {
    var s = t[a];
    !s && i && (s = t.length == 2 ? function(l) {
      t(a, l);
    } : t), r[a] = s && function(l) {
      s("[xmldom " + a + "]	" + l + UT(n));
    } || function() {
    };
  }
  return o("warning"), o("error"), o("fatalError"), r;
}
function Qm() {
  this.cdata = !1;
}
function Nd(t, e) {
  e.lineNumber = t.lineNumber, e.columnNumber = t.columnNumber;
}
Qm.prototype = {
  startDocument: function() {
    this.doc = new hhe().createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId);
  },
  startElement: function(t, e, n, r) {
    var i = this.doc, o = i.createElementNS(t, n || e), a = r.length;
    wy(this, o), this.currentElement = o, this.locator && Nd(this.locator, o);
    for (var s = 0; s < a; s++) {
      var t = r.getURI(s), l = r.getValue(s), n = r.getQName(s), c = i.createAttributeNS(t, n);
      this.locator && Nd(r.getLocator(s), c), c.value = c.nodeValue = l, o.setAttributeNode(c);
    }
  },
  endElement: function(t, e, n) {
    var r = this.currentElement;
    r.tagName, this.currentElement = r.parentNode;
  },
  startPrefixMapping: function(t, e) {
  },
  endPrefixMapping: function(t) {
  },
  processingInstruction: function(t, e) {
    var n = this.doc.createProcessingInstruction(t, e);
    this.locator && Nd(this.locator, n), wy(this, n);
  },
  ignorableWhitespace: function(t, e, n) {
  },
  characters: function(t, e, n) {
    if (t = P8.apply(this, arguments), t) {
      if (this.cdata)
        var r = this.doc.createCDATASection(t);
      else
        var r = this.doc.createTextNode(t);
      this.currentElement ? this.currentElement.appendChild(r) : /^\s*$/.test(t) && this.doc.appendChild(r), this.locator && Nd(this.locator, r);
    }
  },
  skippedEntity: function(t) {
  },
  endDocument: function() {
    this.doc.normalize();
  },
  setDocumentLocator: function(t) {
    (this.locator = t) && (t.lineNumber = 0);
  },
  //LexicalHandler
  comment: function(t, e, n) {
    t = P8.apply(this, arguments);
    var r = this.doc.createComment(t);
    this.locator && Nd(this.locator, r), wy(this, r);
  },
  startCDATA: function() {
    this.cdata = !0;
  },
  endCDATA: function() {
    this.cdata = !1;
  },
  startDTD: function(t, e, n) {
    var r = this.doc.implementation;
    if (r && r.createDocumentType) {
      var i = r.createDocumentType(t, e, n);
      this.locator && Nd(this.locator, i), wy(this, i), this.doc.doctype = i;
    }
  },
  /**
   * @see org.xml.sax.ErrorHandler
   * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
   */
  warning: function(t) {
    console.warn("[xmldom warning]	" + t, UT(this.locator));
  },
  error: function(t) {
    console.error("[xmldom error]	" + t, UT(this.locator));
  },
  fatalError: function(t) {
    throw new phe(t, this.locator);
  }
};
function UT(t) {
  if (t)
    return `
@` + (t.systemId || "") + "#[line:" + t.lineNumber + ",col:" + t.columnNumber + "]";
}
function P8(t, e, n) {
  return typeof t == "string" ? t.substr(e, n) : t.length >= e + n || e ? new java.lang.String(t, e, n) + "" : t;
}
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(t) {
  Qm.prototype[t] = function() {
    return null;
  };
});
function wy(t, e) {
  t.currentElement ? t.currentElement.appendChild(e) : t.doc.appendChild(e);
}
Z1.__DOMHandler = Qm;
Z1.normalizeLineEndings = NL;
Z1.DOMParser = ML;
var BL = wa;
X1.DOMImplementation = BL.DOMImplementation;
X1.XMLSerializer = BL.XMLSerializer;
X1.DOMParser = Z1.DOMParser;
var yhe = X1, bhe = wa;
function vhe(t) {
  var e = null, n = new yhe.DOMParser({
    errorHandler: function(i, o) {
      e = { level: i, message: o };
    }
  }), r = n.parseFromString(t);
  if (e === null)
    return r;
  throw new Error(e.level + ": " + e.message);
}
uC.parseFromString = vhe;
uC.Node = bhe.Node;
var C2 = Zn, W8 = Rn, LL = uC, PL = rh, whe = PL.Element;
sL.readString = xhe;
var z8 = LL.Node;
function xhe(t, e) {
  e = e || {};
  try {
    var n = LL.parseFromString(t, "text/xml");
  } catch (a) {
    return C2.reject(a);
  }
  if (n.documentElement.tagName === "parsererror")
    return C2.resolve(new Error(n.documentElement.textContent));
  function r(a) {
    switch (a.nodeType) {
      case z8.ELEMENT_NODE:
        return i(a);
      case z8.TEXT_NODE:
        return PL.text(a.nodeValue);
    }
  }
  function i(a) {
    var s = o(a), l = [];
    W8.forEach(a.childNodes, function(u) {
      var d = r(u);
      d && l.push(d);
    });
    var c = {};
    return W8.forEach(a.attributes, function(u) {
      c[o(u)] = u.value;
    }), new whe(s, c, l);
  }
  function o(a) {
    if (a.namespaceURI) {
      var s = e[a.namespaceURI], l;
      return s ? l = s + ":" : l = "{" + a.namespaceURI + "}", l + a.localName;
    } else
      return a.localName;
  }
  return C2.resolve(r(n.documentElement));
}
var WL = {}, Tp = {}, ja = {}, $8;
function Hl() {
  return $8 || ($8 = 1, (function() {
    var t, e, n, r, i, o, a, s = [].slice, l = {}.hasOwnProperty;
    t = function() {
      var c, u, d, f, p, m;
      if (m = arguments[0], p = 2 <= arguments.length ? s.call(arguments, 1) : [], i(Object.assign))
        Object.assign.apply(null, arguments);
      else
        for (c = 0, d = p.length; c < d; c++)
          if (f = p[c], f != null)
            for (u in f)
              l.call(f, u) && (m[u] = f[u]);
      return m;
    }, i = function(c) {
      return !!c && Object.prototype.toString.call(c) === "[object Function]";
    }, o = function(c) {
      var u;
      return !!c && ((u = typeof c) == "function" || u === "object");
    }, n = function(c) {
      return i(Array.isArray) ? Array.isArray(c) : Object.prototype.toString.call(c) === "[object Array]";
    }, r = function(c) {
      var u;
      if (n(c))
        return !c.length;
      for (u in c)
        if (l.call(c, u))
          return !1;
      return !0;
    }, a = function(c) {
      var u, d;
      return o(c) && (d = Object.getPrototypeOf(c)) && (u = d.constructor) && typeof u == "function" && u instanceof u && Function.prototype.toString.call(u) === Function.prototype.toString.call(Object);
    }, e = function(c) {
      return i(c.valueOf) ? c.valueOf() : c;
    }, ja.assign = t, ja.isFunction = i, ja.isObject = o, ja.isArray = n, ja.isEmpty = r, ja.isPlainObject = a, ja.getValue = e;
  }).call(wt)), ja;
}
var k2 = { exports: {} }, A2 = { exports: {} }, R2 = { exports: {} }, I2 = { exports: {} }, H8;
function zL() {
  return H8 || (H8 = 1, (function() {
    I2.exports = function() {
      function t(e, n, r) {
        if (this.options = e.options, this.stringify = e.stringify, this.parent = e, n == null)
          throw new Error("Missing attribute name. " + this.debugInfo(n));
        if (r == null)
          throw new Error("Missing attribute value. " + this.debugInfo(n));
        this.name = this.stringify.attName(n), this.value = this.stringify.attValue(r);
      }
      return t.prototype.clone = function() {
        return Object.create(this);
      }, t.prototype.toString = function(e) {
        return this.options.writer.set(e).attribute(this);
      }, t.prototype.debugInfo = function(e) {
        return e = e || this.name, e == null ? "parent: <" + this.parent.name + ">" : "attribute: {" + e + "}, parent: <" + this.parent.name + ">";
      }, t;
    }();
  }).call(wt)), I2.exports;
}
var j8;
function Q1() {
  return j8 || (j8 = 1, (function() {
    var t, e, n, r, i, o, a = function(l, c) {
      for (var u in c)
        s.call(c, u) && (l[u] = c[u]);
      function d() {
        this.constructor = l;
      }
      return d.prototype = c.prototype, l.prototype = new d(), l.__super__ = c.prototype, l;
    }, s = {}.hasOwnProperty;
    o = Hl(), i = o.isObject, r = o.isFunction, n = o.getValue, e = pi(), t = zL(), R2.exports = function(l) {
      a(c, l);
      function c(u, d, f) {
        if (c.__super__.constructor.call(this, u), d == null)
          throw new Error("Missing element name. " + this.debugInfo());
        this.name = this.stringify.eleName(d), this.attributes = {}, f != null && this.attribute(f), u.isDocument && (this.isRoot = !0, this.documentObject = u, u.rootObject = this);
      }
      return c.prototype.clone = function() {
        var u, d, f, p;
        f = Object.create(this), f.isRoot && (f.documentObject = null), f.attributes = {}, p = this.attributes;
        for (d in p)
          s.call(p, d) && (u = p[d], f.attributes[d] = u.clone());
        return f.children = [], this.children.forEach(function(m) {
          var g;
          return g = m.clone(), g.parent = f, f.children.push(g);
        }), f;
      }, c.prototype.attribute = function(u, d) {
        var f, p;
        if (u != null && (u = n(u)), i(u))
          for (f in u)
            s.call(u, f) && (p = u[f], this.attribute(f, p));
        else
          r(d) && (d = d.apply()), (!this.options.skipNullAttributes || d != null) && (this.attributes[u] = new t(this, u, d));
        return this;
      }, c.prototype.removeAttribute = function(u) {
        var d, f, p;
        if (u == null)
          throw new Error("Missing attribute name. " + this.debugInfo());
        if (u = n(u), Array.isArray(u))
          for (f = 0, p = u.length; f < p; f++)
            d = u[f], delete this.attributes[d];
        else
          delete this.attributes[u];
        return this;
      }, c.prototype.toString = function(u) {
        return this.options.writer.set(u).element(this);
      }, c.prototype.att = function(u, d) {
        return this.attribute(u, d);
      }, c.prototype.a = function(u, d) {
        return this.attribute(u, d);
      }, c;
    }(e);
  }).call(wt)), R2.exports;
}
var O2 = { exports: {} }, V8;
function e0() {
  return V8 || (V8 = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = pi(), O2.exports = function(r) {
      e(i, r);
      function i(o, a) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing CDATA text. " + this.debugInfo());
        this.text = this.stringify.cdata(a);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(o) {
        return this.options.writer.set(o).cdata(this);
      }, i;
    }(t);
  }).call(wt)), O2.exports;
}
var F2 = { exports: {} }, q8;
function t0() {
  return q8 || (q8 = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = pi(), F2.exports = function(r) {
      e(i, r);
      function i(o, a) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing comment text. " + this.debugInfo());
        this.text = this.stringify.comment(a);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(o) {
        return this.options.writer.set(o).comment(this);
      }, i;
    }(t);
  }).call(wt)), F2.exports;
}
var U2 = { exports: {} }, G8;
function n0() {
  return G8 || (G8 = 1, (function() {
    var t, e, n = function(i, o) {
      for (var a in o)
        r.call(o, a) && (i[a] = o[a]);
      function s() {
        this.constructor = i;
      }
      return s.prototype = o.prototype, i.prototype = new s(), i.__super__ = o.prototype, i;
    }, r = {}.hasOwnProperty;
    e = Hl().isObject, t = pi(), U2.exports = function(i) {
      n(o, i);
      function o(a, s, l, c) {
        var u;
        o.__super__.constructor.call(this, a), e(s) && (u = s, s = u.version, l = u.encoding, c = u.standalone), s || (s = "1.0"), this.version = this.stringify.xmlVersion(s), l != null && (this.encoding = this.stringify.xmlEncoding(l)), c != null && (this.standalone = this.stringify.xmlStandalone(c));
      }
      return o.prototype.toString = function(a) {
        return this.options.writer.set(a).declaration(this);
      }, o;
    }(t);
  }).call(wt)), U2.exports;
}
var N2 = { exports: {} }, M2 = { exports: {} }, K8;
function r0() {
  return K8 || (K8 = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = pi(), M2.exports = function(r) {
      e(i, r);
      function i(o, a, s, l, c, u) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        if (s == null)
          throw new Error("Missing DTD attribute name. " + this.debugInfo(a));
        if (!l)
          throw new Error("Missing DTD attribute type. " + this.debugInfo(a));
        if (!c)
          throw new Error("Missing DTD attribute default. " + this.debugInfo(a));
        if (c.indexOf("#") !== 0 && (c = "#" + c), !c.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/))
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(a));
        if (u && !c.match(/^(#FIXED|#DEFAULT)$/))
          throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(a));
        this.elementName = this.stringify.eleName(a), this.attributeName = this.stringify.attName(s), this.attributeType = this.stringify.dtdAttType(l), this.defaultValue = this.stringify.dtdAttDefault(u), this.defaultValueType = c;
      }
      return i.prototype.toString = function(o) {
        return this.options.writer.set(o).dtdAttList(this);
      }, i;
    }(t);
  }).call(wt)), M2.exports;
}
var B2 = { exports: {} }, X8;
function i0() {
  return X8 || (X8 = 1, (function() {
    var t, e, n = function(i, o) {
      for (var a in o)
        r.call(o, a) && (i[a] = o[a]);
      function s() {
        this.constructor = i;
      }
      return s.prototype = o.prototype, i.prototype = new s(), i.__super__ = o.prototype, i;
    }, r = {}.hasOwnProperty;
    e = Hl().isObject, t = pi(), B2.exports = function(i) {
      n(o, i);
      function o(a, s, l, c) {
        if (o.__super__.constructor.call(this, a), l == null)
          throw new Error("Missing DTD entity name. " + this.debugInfo(l));
        if (c == null)
          throw new Error("Missing DTD entity value. " + this.debugInfo(l));
        if (this.pe = !!s, this.name = this.stringify.eleName(l), !e(c))
          this.value = this.stringify.dtdEntityValue(c);
        else {
          if (!c.pubID && !c.sysID)
            throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(l));
          if (c.pubID && !c.sysID)
            throw new Error("System identifier is required for a public external entity. " + this.debugInfo(l));
          if (c.pubID != null && (this.pubID = this.stringify.dtdPubID(c.pubID)), c.sysID != null && (this.sysID = this.stringify.dtdSysID(c.sysID)), c.nData != null && (this.nData = this.stringify.dtdNData(c.nData)), this.pe && this.nData)
            throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(l));
        }
      }
      return o.prototype.toString = function(a) {
        return this.options.writer.set(a).dtdEntity(this);
      }, o;
    }(t);
  }).call(wt)), B2.exports;
}
var L2 = { exports: {} }, Y8;
function o0() {
  return Y8 || (Y8 = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = pi(), L2.exports = function(r) {
      e(i, r);
      function i(o, a, s) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        s || (s = "(#PCDATA)"), Array.isArray(s) && (s = "(" + s.join(",") + ")"), this.name = this.stringify.eleName(a), this.value = this.stringify.dtdElementValue(s);
      }
      return i.prototype.toString = function(o) {
        return this.options.writer.set(o).dtdElement(this);
      }, i;
    }(t);
  }).call(wt)), L2.exports;
}
var P2 = { exports: {} }, J8;
function a0() {
  return J8 || (J8 = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = pi(), P2.exports = function(r) {
      e(i, r);
      function i(o, a, s) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing DTD notation name. " + this.debugInfo(a));
        if (!s.pubID && !s.sysID)
          throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(a));
        this.name = this.stringify.eleName(a), s.pubID != null && (this.pubID = this.stringify.dtdPubID(s.pubID)), s.sysID != null && (this.sysID = this.stringify.dtdSysID(s.sysID));
      }
      return i.prototype.toString = function(o) {
        return this.options.writer.set(o).dtdNotation(this);
      }, i;
    }(t);
  }).call(wt)), P2.exports;
}
var Z8;
function s0() {
  return Z8 || (Z8 = 1, (function() {
    var t, e, n, r, i, o, a = function(l, c) {
      for (var u in c)
        s.call(c, u) && (l[u] = c[u]);
      function d() {
        this.constructor = l;
      }
      return d.prototype = c.prototype, l.prototype = new d(), l.__super__ = c.prototype, l;
    }, s = {}.hasOwnProperty;
    o = Hl().isObject, i = pi(), t = r0(), n = i0(), e = o0(), r = a0(), N2.exports = function(l) {
      a(c, l);
      function c(u, d, f) {
        var p, m;
        c.__super__.constructor.call(this, u), this.name = "!DOCTYPE", this.documentObject = u, o(d) && (p = d, d = p.pubID, f = p.sysID), f == null && (m = [d, f], f = m[0], d = m[1]), d != null && (this.pubID = this.stringify.dtdPubID(d)), f != null && (this.sysID = this.stringify.dtdSysID(f));
      }
      return c.prototype.element = function(u, d) {
        var f;
        return f = new e(this, u, d), this.children.push(f), this;
      }, c.prototype.attList = function(u, d, f, p, m) {
        var g;
        return g = new t(this, u, d, f, p, m), this.children.push(g), this;
      }, c.prototype.entity = function(u, d) {
        var f;
        return f = new n(this, !1, u, d), this.children.push(f), this;
      }, c.prototype.pEntity = function(u, d) {
        var f;
        return f = new n(this, !0, u, d), this.children.push(f), this;
      }, c.prototype.notation = function(u, d) {
        var f;
        return f = new r(this, u, d), this.children.push(f), this;
      }, c.prototype.toString = function(u) {
        return this.options.writer.set(u).docType(this);
      }, c.prototype.ele = function(u, d) {
        return this.element(u, d);
      }, c.prototype.att = function(u, d, f, p, m) {
        return this.attList(u, d, f, p, m);
      }, c.prototype.ent = function(u, d) {
        return this.entity(u, d);
      }, c.prototype.pent = function(u, d) {
        return this.pEntity(u, d);
      }, c.prototype.not = function(u, d) {
        return this.notation(u, d);
      }, c.prototype.up = function() {
        return this.root() || this.documentObject;
      }, c;
    }(i);
  }).call(wt)), N2.exports;
}
var W2 = { exports: {} }, Q8;
function l0() {
  return Q8 || (Q8 = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = pi(), W2.exports = function(r) {
      e(i, r);
      function i(o, a) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing raw text. " + this.debugInfo());
        this.value = this.stringify.raw(a);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(o) {
        return this.options.writer.set(o).raw(this);
      }, i;
    }(t);
  }).call(wt)), W2.exports;
}
var z2 = { exports: {} }, eI;
function c0() {
  return eI || (eI = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = pi(), z2.exports = function(r) {
      e(i, r);
      function i(o, a) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing element text. " + this.debugInfo());
        this.value = this.stringify.eleText(a);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(o) {
        return this.options.writer.set(o).text(this);
      }, i;
    }(t);
  }).call(wt)), z2.exports;
}
var $2 = { exports: {} }, tI;
function u0() {
  return tI || (tI = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = pi(), $2.exports = function(r) {
      e(i, r);
      function i(o, a, s) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing instruction target. " + this.debugInfo());
        this.target = this.stringify.insTarget(a), s && (this.value = this.stringify.insValue(s));
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(o) {
        return this.options.writer.set(o).processingInstruction(this);
      }, i;
    }(t);
  }).call(wt)), $2.exports;
}
var H2 = { exports: {} }, nI;
function xC() {
  return nI || (nI = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = pi(), H2.exports = function(r) {
      e(i, r);
      function i(o) {
        i.__super__.constructor.call(this, o), this.isDummy = !0;
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(o) {
        return "";
      }, i;
    }(t);
  }).call(wt)), H2.exports;
}
var rI;
function pi() {
  return rI || (rI = 1, (function() {
    var t, e, n, r, i, o, a, s, l, c, u, d, f, p, m = {}.hasOwnProperty;
    p = Hl(), f = p.isObject, d = p.isFunction, u = p.isEmpty, c = p.getValue, o = null, t = null, e = null, n = null, r = null, s = null, l = null, a = null, i = null, A2.exports = function() {
      function g(b) {
        this.parent = b, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), this.children = [], o || (o = Q1(), t = e0(), e = t0(), n = n0(), r = s0(), s = l0(), l = c0(), a = u0(), i = xC());
      }
      return g.prototype.element = function(b, y, w) {
        var x, k, A, U, P, V, I, le, be, F, G;
        if (V = null, y === null && w == null && (be = [{}, null], y = be[0], w = be[1]), y == null && (y = {}), y = c(y), f(y) || (F = [y, w], w = F[0], y = F[1]), b != null && (b = c(b)), Array.isArray(b))
          for (A = 0, I = b.length; A < I; A++)
            k = b[A], V = this.element(k);
        else if (d(b))
          V = this.element(b.apply());
        else if (f(b)) {
          for (P in b)
            if (m.call(b, P))
              if (G = b[P], d(G) && (G = G.apply()), f(G) && u(G) && (G = null), !this.options.ignoreDecorators && this.stringify.convertAttKey && P.indexOf(this.stringify.convertAttKey) === 0)
                V = this.attribute(P.substr(this.stringify.convertAttKey.length), G);
              else if (!this.options.separateArrayItems && Array.isArray(G))
                for (U = 0, le = G.length; U < le; U++)
                  k = G[U], x = {}, x[P] = k, V = this.element(x);
              else f(G) ? (V = this.element(P), V.element(G)) : V = this.element(P, G);
        } else this.options.skipNullNodes && w === null ? V = this.dummy() : !this.options.ignoreDecorators && this.stringify.convertTextKey && b.indexOf(this.stringify.convertTextKey) === 0 ? V = this.text(w) : !this.options.ignoreDecorators && this.stringify.convertCDataKey && b.indexOf(this.stringify.convertCDataKey) === 0 ? V = this.cdata(w) : !this.options.ignoreDecorators && this.stringify.convertCommentKey && b.indexOf(this.stringify.convertCommentKey) === 0 ? V = this.comment(w) : !this.options.ignoreDecorators && this.stringify.convertRawKey && b.indexOf(this.stringify.convertRawKey) === 0 ? V = this.raw(w) : !this.options.ignoreDecorators && this.stringify.convertPIKey && b.indexOf(this.stringify.convertPIKey) === 0 ? V = this.instruction(b.substr(this.stringify.convertPIKey.length), w) : V = this.node(b, y, w);
        if (V == null)
          throw new Error("Could not create any elements with: " + b + ". " + this.debugInfo());
        return V;
      }, g.prototype.insertBefore = function(b, y, w) {
        var x, k, A;
        if (this.isRoot)
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(b));
        return k = this.parent.children.indexOf(this), A = this.parent.children.splice(k), x = this.parent.element(b, y, w), Array.prototype.push.apply(this.parent.children, A), x;
      }, g.prototype.insertAfter = function(b, y, w) {
        var x, k, A;
        if (this.isRoot)
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(b));
        return k = this.parent.children.indexOf(this), A = this.parent.children.splice(k + 1), x = this.parent.element(b, y, w), Array.prototype.push.apply(this.parent.children, A), x;
      }, g.prototype.remove = function() {
        var b;
        if (this.isRoot)
          throw new Error("Cannot remove the root element. " + this.debugInfo());
        return b = this.parent.children.indexOf(this), [].splice.apply(this.parent.children, [b, b - b + 1].concat([])), this.parent;
      }, g.prototype.node = function(b, y, w) {
        var x, k;
        return b != null && (b = c(b)), y || (y = {}), y = c(y), f(y) || (k = [y, w], w = k[0], y = k[1]), x = new o(this, b, y), w != null && x.text(w), this.children.push(x), x;
      }, g.prototype.text = function(b) {
        var y;
        return y = new l(this, b), this.children.push(y), this;
      }, g.prototype.cdata = function(b) {
        var y;
        return y = new t(this, b), this.children.push(y), this;
      }, g.prototype.comment = function(b) {
        var y;
        return y = new e(this, b), this.children.push(y), this;
      }, g.prototype.commentBefore = function(b) {
        var y, w;
        return y = this.parent.children.indexOf(this), w = this.parent.children.splice(y), this.parent.comment(b), Array.prototype.push.apply(this.parent.children, w), this;
      }, g.prototype.commentAfter = function(b) {
        var y, w;
        return y = this.parent.children.indexOf(this), w = this.parent.children.splice(y + 1), this.parent.comment(b), Array.prototype.push.apply(this.parent.children, w), this;
      }, g.prototype.raw = function(b) {
        var y;
        return y = new s(this, b), this.children.push(y), this;
      }, g.prototype.dummy = function() {
        var b;
        return b = new i(this), this.children.push(b), b;
      }, g.prototype.instruction = function(b, y) {
        var w, x, k, A, U;
        if (b != null && (b = c(b)), y != null && (y = c(y)), Array.isArray(b))
          for (A = 0, U = b.length; A < U; A++)
            w = b[A], this.instruction(w);
        else if (f(b))
          for (w in b)
            m.call(b, w) && (x = b[w], this.instruction(w, x));
        else
          d(y) && (y = y.apply()), k = new a(this, b, y), this.children.push(k);
        return this;
      }, g.prototype.instructionBefore = function(b, y) {
        var w, x;
        return w = this.parent.children.indexOf(this), x = this.parent.children.splice(w), this.parent.instruction(b, y), Array.prototype.push.apply(this.parent.children, x), this;
      }, g.prototype.instructionAfter = function(b, y) {
        var w, x;
        return w = this.parent.children.indexOf(this), x = this.parent.children.splice(w + 1), this.parent.instruction(b, y), Array.prototype.push.apply(this.parent.children, x), this;
      }, g.prototype.declaration = function(b, y, w) {
        var x, k;
        return x = this.document(), k = new n(x, b, y, w), x.children[0] instanceof n ? x.children[0] = k : x.children.unshift(k), x.root() || x;
      }, g.prototype.doctype = function(b, y) {
        var w, x, k, A, U, P, V, I, le, be;
        for (x = this.document(), k = new r(x, b, y), le = x.children, A = U = 0, V = le.length; U < V; A = ++U)
          if (w = le[A], w instanceof r)
            return x.children[A] = k, k;
        for (be = x.children, A = P = 0, I = be.length; P < I; A = ++P)
          if (w = be[A], w.isRoot)
            return x.children.splice(A, 0, k), k;
        return x.children.push(k), k;
      }, g.prototype.up = function() {
        if (this.isRoot)
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
        return this.parent;
      }, g.prototype.root = function() {
        var b;
        for (b = this; b; ) {
          if (b.isDocument)
            return b.rootObject;
          if (b.isRoot)
            return b;
          b = b.parent;
        }
      }, g.prototype.document = function() {
        var b;
        for (b = this; b; ) {
          if (b.isDocument)
            return b;
          b = b.parent;
        }
      }, g.prototype.end = function(b) {
        return this.document().end(b);
      }, g.prototype.prev = function() {
        var b;
        for (b = this.parent.children.indexOf(this); b > 0 && this.parent.children[b - 1].isDummy; )
          b = b - 1;
        if (b < 1)
          throw new Error("Already at the first node. " + this.debugInfo());
        return this.parent.children[b - 1];
      }, g.prototype.next = function() {
        var b;
        for (b = this.parent.children.indexOf(this); b < this.parent.children.length - 1 && this.parent.children[b + 1].isDummy; )
          b = b + 1;
        if (b === -1 || b === this.parent.children.length - 1)
          throw new Error("Already at the last node. " + this.debugInfo());
        return this.parent.children[b + 1];
      }, g.prototype.importDocument = function(b) {
        var y;
        return y = b.root().clone(), y.parent = this, y.isRoot = !1, this.children.push(y), this;
      }, g.prototype.debugInfo = function(b) {
        var y, w;
        return b = b || this.name, b == null && !((y = this.parent) != null && y.name) ? "" : b == null ? "parent: <" + this.parent.name + ">" : (w = this.parent) != null && w.name ? "node: <" + b + ">, parent: <" + this.parent.name + ">" : "node: <" + b + ">";
      }, g.prototype.ele = function(b, y, w) {
        return this.element(b, y, w);
      }, g.prototype.nod = function(b, y, w) {
        return this.node(b, y, w);
      }, g.prototype.txt = function(b) {
        return this.text(b);
      }, g.prototype.dat = function(b) {
        return this.cdata(b);
      }, g.prototype.com = function(b) {
        return this.comment(b);
      }, g.prototype.ins = function(b, y) {
        return this.instruction(b, y);
      }, g.prototype.doc = function() {
        return this.document();
      }, g.prototype.dec = function(b, y, w) {
        return this.declaration(b, y, w);
      }, g.prototype.dtd = function(b, y) {
        return this.doctype(b, y);
      }, g.prototype.e = function(b, y, w) {
        return this.element(b, y, w);
      }, g.prototype.n = function(b, y, w) {
        return this.node(b, y, w);
      }, g.prototype.t = function(b) {
        return this.text(b);
      }, g.prototype.d = function(b) {
        return this.cdata(b);
      }, g.prototype.c = function(b) {
        return this.comment(b);
      }, g.prototype.r = function(b) {
        return this.raw(b);
      }, g.prototype.i = function(b, y) {
        return this.instruction(b, y);
      }, g.prototype.u = function() {
        return this.up();
      }, g.prototype.importXMLBuilder = function(b) {
        return this.importDocument(b);
      }, g;
    }();
  }).call(wt)), A2.exports;
}
var j2 = { exports: {} }, iI;
function $L() {
  return iI || (iI = 1, (function() {
    var t = function(n, r) {
      return function() {
        return n.apply(r, arguments);
      };
    }, e = {}.hasOwnProperty;
    j2.exports = function() {
      function n(r) {
        this.assertLegalChar = t(this.assertLegalChar, this);
        var i, o, a;
        r || (r = {}), this.noDoubleEncoding = r.noDoubleEncoding, o = r.stringify || {};
        for (i in o)
          e.call(o, i) && (a = o[i], this[i] = a);
      }
      return n.prototype.eleName = function(r) {
        return r = "" + r || "", this.assertLegalChar(r);
      }, n.prototype.eleText = function(r) {
        return r = "" + r || "", this.assertLegalChar(this.elEscape(r));
      }, n.prototype.cdata = function(r) {
        return r = "" + r || "", r = r.replace("]]>", "]]]]><![CDATA[>"), this.assertLegalChar(r);
      }, n.prototype.comment = function(r) {
        if (r = "" + r || "", r.match(/--/))
          throw new Error("Comment text cannot contain double-hypen: " + r);
        return this.assertLegalChar(r);
      }, n.prototype.raw = function(r) {
        return "" + r || "";
      }, n.prototype.attName = function(r) {
        return r = "" + r || "";
      }, n.prototype.attValue = function(r) {
        return r = "" + r || "", this.attEscape(r);
      }, n.prototype.insTarget = function(r) {
        return "" + r || "";
      }, n.prototype.insValue = function(r) {
        if (r = "" + r || "", r.match(/\?>/))
          throw new Error("Invalid processing instruction value: " + r);
        return r;
      }, n.prototype.xmlVersion = function(r) {
        if (r = "" + r || "", !r.match(/1\.[0-9]+/))
          throw new Error("Invalid version number: " + r);
        return r;
      }, n.prototype.xmlEncoding = function(r) {
        if (r = "" + r || "", !r.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/))
          throw new Error("Invalid encoding: " + r);
        return r;
      }, n.prototype.xmlStandalone = function(r) {
        return r ? "yes" : "no";
      }, n.prototype.dtdPubID = function(r) {
        return "" + r || "";
      }, n.prototype.dtdSysID = function(r) {
        return "" + r || "";
      }, n.prototype.dtdElementValue = function(r) {
        return "" + r || "";
      }, n.prototype.dtdAttType = function(r) {
        return "" + r || "";
      }, n.prototype.dtdAttDefault = function(r) {
        return r != null ? "" + r || "" : r;
      }, n.prototype.dtdEntityValue = function(r) {
        return "" + r || "";
      }, n.prototype.dtdNData = function(r) {
        return "" + r || "";
      }, n.prototype.convertAttKey = "@", n.prototype.convertPIKey = "?", n.prototype.convertTextKey = "#text", n.prototype.convertCDataKey = "#cdata", n.prototype.convertCommentKey = "#comment", n.prototype.convertRawKey = "#raw", n.prototype.assertLegalChar = function(r) {
        var i;
        if (i = r.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), i)
          throw new Error("Invalid character in string: " + r + " at index " + i.index);
        return r;
      }, n.prototype.elEscape = function(r) {
        var i;
        return i = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, r.replace(i, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
      }, n.prototype.attEscape = function(r) {
        var i;
        return i = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, r.replace(i, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
      }, n;
    }();
  }).call(wt)), j2.exports;
}
var V2 = { exports: {} }, q2 = { exports: {} }, oI;
function HL() {
  return oI || (oI = 1, (function() {
    var t = {}.hasOwnProperty;
    q2.exports = function() {
      function e(n) {
        var r, i, o, a, s, l, c, u, d;
        n || (n = {}), this.pretty = n.pretty || !1, this.allowEmpty = (i = n.allowEmpty) != null ? i : !1, this.pretty ? (this.indent = (o = n.indent) != null ? o : "  ", this.newline = (a = n.newline) != null ? a : `
`, this.offset = (s = n.offset) != null ? s : 0, this.dontprettytextnodes = (l = n.dontprettytextnodes) != null ? l : 0) : (this.indent = "", this.newline = "", this.offset = 0, this.dontprettytextnodes = 0), this.spacebeforeslash = (c = n.spacebeforeslash) != null ? c : "", this.spacebeforeslash === !0 && (this.spacebeforeslash = " "), this.newlinedefault = this.newline, this.prettydefault = this.pretty, u = n.writer || {};
        for (r in u)
          t.call(u, r) && (d = u[r], this[r] = d);
      }
      return e.prototype.set = function(n) {
        var r, i, o;
        n || (n = {}), "pretty" in n && (this.pretty = n.pretty), "allowEmpty" in n && (this.allowEmpty = n.allowEmpty), this.pretty ? (this.indent = "indent" in n ? n.indent : "  ", this.newline = "newline" in n ? n.newline : `
`, this.offset = "offset" in n ? n.offset : 0, this.dontprettytextnodes = "dontprettytextnodes" in n ? n.dontprettytextnodes : 0) : (this.indent = "", this.newline = "", this.offset = 0, this.dontprettytextnodes = 0), this.spacebeforeslash = "spacebeforeslash" in n ? n.spacebeforeslash : "", this.spacebeforeslash === !0 && (this.spacebeforeslash = " "), this.newlinedefault = this.newline, this.prettydefault = this.pretty, i = n.writer || {};
        for (r in i)
          t.call(i, r) && (o = i[r], this[r] = o);
        return this;
      }, e.prototype.space = function(n) {
        var r;
        return this.pretty ? (r = (n || 0) + this.offset + 1, r > 0 ? new Array(r).join(this.indent) : "") : "";
      }, e;
    }();
  }).call(wt)), q2.exports;
}
var aI;
function _C() {
  return aI || (aI = 1, (function() {
    var t, e, n, r, i, o, a, s, l, c, u, d, f, p, m = function(b, y) {
      for (var w in y)
        g.call(y, w) && (b[w] = y[w]);
      function x() {
        this.constructor = b;
      }
      return x.prototype = y.prototype, b.prototype = new x(), b.__super__ = y.prototype, b;
    }, g = {}.hasOwnProperty;
    a = n0(), s = s0(), t = e0(), e = t0(), c = Q1(), d = l0(), f = c0(), u = u0(), l = xC(), n = r0(), r = o0(), i = i0(), o = a0(), p = HL(), V2.exports = function(b) {
      m(y, b);
      function y(w) {
        y.__super__.constructor.call(this, w);
      }
      return y.prototype.document = function(w) {
        var x, k, A, U, P;
        for (this.textispresent = !1, U = "", P = w.children, k = 0, A = P.length; k < A; k++)
          x = P[k], !(x instanceof l) && (U += (function() {
            switch (!1) {
              case !(x instanceof a):
                return this.declaration(x);
              case !(x instanceof s):
                return this.docType(x);
              case !(x instanceof e):
                return this.comment(x);
              case !(x instanceof u):
                return this.processingInstruction(x);
              default:
                return this.element(x, 0);
            }
          }).call(this));
        return this.pretty && U.slice(-this.newline.length) === this.newline && (U = U.slice(0, -this.newline.length)), U;
      }, y.prototype.attribute = function(w) {
        return " " + w.name + '="' + w.value + '"';
      }, y.prototype.cdata = function(w, x) {
        return this.space(x) + "<![CDATA[" + w.text + "]]>" + this.newline;
      }, y.prototype.comment = function(w, x) {
        return this.space(x) + "<!-- " + w.text + " -->" + this.newline;
      }, y.prototype.declaration = function(w, x) {
        var k;
        return k = this.space(x), k += '<?xml version="' + w.version + '"', w.encoding != null && (k += ' encoding="' + w.encoding + '"'), w.standalone != null && (k += ' standalone="' + w.standalone + '"'), k += this.spacebeforeslash + "?>", k += this.newline, k;
      }, y.prototype.docType = function(w, x) {
        var k, A, U, P, V;
        if (x || (x = 0), P = this.space(x), P += "<!DOCTYPE " + w.root().name, w.pubID && w.sysID ? P += ' PUBLIC "' + w.pubID + '" "' + w.sysID + '"' : w.sysID && (P += ' SYSTEM "' + w.sysID + '"'), w.children.length > 0) {
          for (P += " [", P += this.newline, V = w.children, A = 0, U = V.length; A < U; A++)
            k = V[A], P += (function() {
              switch (!1) {
                case !(k instanceof n):
                  return this.dtdAttList(k, x + 1);
                case !(k instanceof r):
                  return this.dtdElement(k, x + 1);
                case !(k instanceof i):
                  return this.dtdEntity(k, x + 1);
                case !(k instanceof o):
                  return this.dtdNotation(k, x + 1);
                case !(k instanceof t):
                  return this.cdata(k, x + 1);
                case !(k instanceof e):
                  return this.comment(k, x + 1);
                case !(k instanceof u):
                  return this.processingInstruction(k, x + 1);
                default:
                  throw new Error("Unknown DTD node type: " + k.constructor.name);
              }
            }).call(this);
          P += "]";
        }
        return P += this.spacebeforeslash + ">", P += this.newline, P;
      }, y.prototype.element = function(w, x) {
        var k, A, U, P, V, I, le, be, F, G, C, ie, ee;
        x || (x = 0), ee = !1, this.textispresent ? (this.newline = "", this.pretty = !1) : (this.newline = this.newlinedefault, this.pretty = this.prettydefault), ie = this.space(x), be = "", be += ie + "<" + w.name, F = w.attributes;
        for (le in F)
          g.call(F, le) && (k = F[le], be += this.attribute(k));
        if (w.children.length === 0 || w.children.every(function(Z) {
          return Z.value === "";
        }))
          this.allowEmpty ? be += "></" + w.name + ">" + this.newline : be += this.spacebeforeslash + "/>" + this.newline;
        else if (this.pretty && w.children.length === 1 && w.children[0].value != null)
          be += ">", be += w.children[0].value, be += "</" + w.name + ">" + this.newline;
        else {
          if (this.dontprettytextnodes) {
            for (G = w.children, U = 0, V = G.length; U < V; U++)
              if (A = G[U], A.value != null) {
                this.textispresent++, ee = !0;
                break;
              }
          }
          for (this.textispresent && (this.newline = "", this.pretty = !1, ie = this.space(x)), be += ">" + this.newline, C = w.children, P = 0, I = C.length; P < I; P++)
            A = C[P], be += (function() {
              switch (!1) {
                case !(A instanceof t):
                  return this.cdata(A, x + 1);
                case !(A instanceof e):
                  return this.comment(A, x + 1);
                case !(A instanceof c):
                  return this.element(A, x + 1);
                case !(A instanceof d):
                  return this.raw(A, x + 1);
                case !(A instanceof f):
                  return this.text(A, x + 1);
                case !(A instanceof u):
                  return this.processingInstruction(A, x + 1);
                case !(A instanceof l):
                  return "";
                default:
                  throw new Error("Unknown XML node type: " + A.constructor.name);
              }
            }).call(this);
          ee && this.textispresent--, this.textispresent || (this.newline = this.newlinedefault, this.pretty = this.prettydefault), be += ie + "</" + w.name + ">" + this.newline;
        }
        return be;
      }, y.prototype.processingInstruction = function(w, x) {
        var k;
        return k = this.space(x) + "<?" + w.target, w.value && (k += " " + w.value), k += this.spacebeforeslash + "?>" + this.newline, k;
      }, y.prototype.raw = function(w, x) {
        return this.space(x) + w.value + this.newline;
      }, y.prototype.text = function(w, x) {
        return this.space(x) + w.value + this.newline;
      }, y.prototype.dtdAttList = function(w, x) {
        var k;
        return k = this.space(x) + "<!ATTLIST " + w.elementName + " " + w.attributeName + " " + w.attributeType, w.defaultValueType !== "#DEFAULT" && (k += " " + w.defaultValueType), w.defaultValue && (k += ' "' + w.defaultValue + '"'), k += this.spacebeforeslash + ">" + this.newline, k;
      }, y.prototype.dtdElement = function(w, x) {
        return this.space(x) + "<!ELEMENT " + w.name + " " + w.value + this.spacebeforeslash + ">" + this.newline;
      }, y.prototype.dtdEntity = function(w, x) {
        var k;
        return k = this.space(x) + "<!ENTITY", w.pe && (k += " %"), k += " " + w.name, w.value ? k += ' "' + w.value + '"' : (w.pubID && w.sysID ? k += ' PUBLIC "' + w.pubID + '" "' + w.sysID + '"' : w.sysID && (k += ' SYSTEM "' + w.sysID + '"'), w.nData && (k += " NDATA " + w.nData)), k += this.spacebeforeslash + ">" + this.newline, k;
      }, y.prototype.dtdNotation = function(w, x) {
        var k;
        return k = this.space(x) + "<!NOTATION " + w.name, w.pubID && w.sysID ? k += ' PUBLIC "' + w.pubID + '" "' + w.sysID + '"' : w.pubID ? k += ' PUBLIC "' + w.pubID + '"' : w.sysID && (k += ' SYSTEM "' + w.sysID + '"'), k += this.spacebeforeslash + ">" + this.newline, k;
      }, y.prototype.openNode = function(w, x) {
        var k, A, U, P;
        if (x || (x = 0), w instanceof c) {
          U = this.space(x) + "<" + w.name, P = w.attributes;
          for (A in P)
            g.call(P, A) && (k = P[A], U += this.attribute(k));
          return U += (w.children ? ">" : "/>") + this.newline, U;
        } else
          return U = this.space(x) + "<!DOCTYPE " + w.rootNodeName, w.pubID && w.sysID ? U += ' PUBLIC "' + w.pubID + '" "' + w.sysID + '"' : w.sysID && (U += ' SYSTEM "' + w.sysID + '"'), U += (w.children ? " [" : ">") + this.newline, U;
      }, y.prototype.closeNode = function(w, x) {
        switch (x || (x = 0), !1) {
          case !(w instanceof c):
            return this.space(x) + "</" + w.name + ">" + this.newline;
          case !(w instanceof s):
            return this.space(x) + "]>" + this.newline;
        }
      }, y;
    }(p);
  }).call(wt)), V2.exports;
}
var sI;
function _he() {
  return sI || (sI = 1, (function() {
    var t, e, n, r, i = function(a, s) {
      for (var l in s)
        o.call(s, l) && (a[l] = s[l]);
      function c() {
        this.constructor = a;
      }
      return c.prototype = s.prototype, a.prototype = new c(), a.__super__ = s.prototype, a;
    }, o = {}.hasOwnProperty;
    r = Hl().isPlainObject, t = pi(), n = $L(), e = _C(), k2.exports = function(a) {
      i(s, a);
      function s(l) {
        s.__super__.constructor.call(this, null), this.name = "?xml", l || (l = {}), l.writer || (l.writer = new e()), this.options = l, this.stringify = new n(l), this.isDocument = !0;
      }
      return s.prototype.end = function(l) {
        var c;
        return l ? r(l) && (c = l, l = this.options.writer.set(c)) : l = this.options.writer, l.document(this);
      }, s.prototype.toString = function(l) {
        return this.options.writer.set(l).document(this);
      }, s;
    }(t);
  }).call(wt)), k2.exports;
}
var G2 = { exports: {} }, lI;
function She() {
  return lI || (lI = 1, (function() {
    var t, e, n, r, i, o, a, s, l, c, u, d, f, p, m, g, b, y, w, x, k = {}.hasOwnProperty;
    x = Hl(), y = x.isObject, b = x.isFunction, w = x.isPlainObject, g = x.getValue, c = Q1(), e = e0(), n = t0(), d = l0(), m = c0(), u = u0(), s = n0(), l = s0(), r = r0(), o = i0(), i = o0(), a = a0(), t = zL(), p = $L(), f = _C(), G2.exports = function() {
      function A(U, P, V) {
        var I;
        this.name = "?xml", U || (U = {}), U.writer ? w(U.writer) && (I = U.writer, U.writer = new f(I)) : U.writer = new f(U), this.options = U, this.writer = U.writer, this.stringify = new p(U), this.onDataCallback = P || function() {
        }, this.onEndCallback = V || function() {
        }, this.currentNode = null, this.currentLevel = -1, this.openTags = {}, this.documentStarted = !1, this.documentCompleted = !1, this.root = null;
      }
      return A.prototype.node = function(U, P, V) {
        var I, le;
        if (U == null)
          throw new Error("Missing node name.");
        if (this.root && this.currentLevel === -1)
          throw new Error("Document can only have one root node. " + this.debugInfo(U));
        return this.openCurrent(), U = g(U), P === null && V == null && (I = [{}, null], P = I[0], V = I[1]), P == null && (P = {}), P = g(P), y(P) || (le = [P, V], V = le[0], P = le[1]), this.currentNode = new c(this, U, P), this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, V != null && this.text(V), this;
      }, A.prototype.element = function(U, P, V) {
        return this.currentNode && this.currentNode instanceof l ? this.dtdElement.apply(this, arguments) : this.node(U, P, V);
      }, A.prototype.attribute = function(U, P) {
        var V, I;
        if (!this.currentNode || this.currentNode.children)
          throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(U));
        if (U != null && (U = g(U)), y(U))
          for (V in U)
            k.call(U, V) && (I = U[V], this.attribute(V, I));
        else
          b(P) && (P = P.apply()), (!this.options.skipNullAttributes || P != null) && (this.currentNode.attributes[U] = new t(this, U, P));
        return this;
      }, A.prototype.text = function(U) {
        var P;
        return this.openCurrent(), P = new m(this, U), this.onData(this.writer.text(P, this.currentLevel + 1), this.currentLevel + 1), this;
      }, A.prototype.cdata = function(U) {
        var P;
        return this.openCurrent(), P = new e(this, U), this.onData(this.writer.cdata(P, this.currentLevel + 1), this.currentLevel + 1), this;
      }, A.prototype.comment = function(U) {
        var P;
        return this.openCurrent(), P = new n(this, U), this.onData(this.writer.comment(P, this.currentLevel + 1), this.currentLevel + 1), this;
      }, A.prototype.raw = function(U) {
        var P;
        return this.openCurrent(), P = new d(this, U), this.onData(this.writer.raw(P, this.currentLevel + 1), this.currentLevel + 1), this;
      }, A.prototype.instruction = function(U, P) {
        var V, I, le, be, F;
        if (this.openCurrent(), U != null && (U = g(U)), P != null && (P = g(P)), Array.isArray(U))
          for (V = 0, be = U.length; V < be; V++)
            I = U[V], this.instruction(I);
        else if (y(U))
          for (I in U)
            k.call(U, I) && (le = U[I], this.instruction(I, le));
        else
          b(P) && (P = P.apply()), F = new u(this, U, P), this.onData(this.writer.processingInstruction(F, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      }, A.prototype.declaration = function(U, P, V) {
        var I;
        if (this.openCurrent(), this.documentStarted)
          throw new Error("declaration() must be the first node.");
        return I = new s(this, U, P, V), this.onData(this.writer.declaration(I, this.currentLevel + 1), this.currentLevel + 1), this;
      }, A.prototype.doctype = function(U, P, V) {
        if (this.openCurrent(), U == null)
          throw new Error("Missing root node name.");
        if (this.root)
          throw new Error("dtd() must come before the root node.");
        return this.currentNode = new l(this, P, V), this.currentNode.rootNodeName = U, this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, this;
      }, A.prototype.dtdElement = function(U, P) {
        var V;
        return this.openCurrent(), V = new i(this, U, P), this.onData(this.writer.dtdElement(V, this.currentLevel + 1), this.currentLevel + 1), this;
      }, A.prototype.attList = function(U, P, V, I, le) {
        var be;
        return this.openCurrent(), be = new r(this, U, P, V, I, le), this.onData(this.writer.dtdAttList(be, this.currentLevel + 1), this.currentLevel + 1), this;
      }, A.prototype.entity = function(U, P) {
        var V;
        return this.openCurrent(), V = new o(this, !1, U, P), this.onData(this.writer.dtdEntity(V, this.currentLevel + 1), this.currentLevel + 1), this;
      }, A.prototype.pEntity = function(U, P) {
        var V;
        return this.openCurrent(), V = new o(this, !0, U, P), this.onData(this.writer.dtdEntity(V, this.currentLevel + 1), this.currentLevel + 1), this;
      }, A.prototype.notation = function(U, P) {
        var V;
        return this.openCurrent(), V = new a(this, U, P), this.onData(this.writer.dtdNotation(V, this.currentLevel + 1), this.currentLevel + 1), this;
      }, A.prototype.up = function() {
        if (this.currentLevel < 0)
          throw new Error("The document node has no parent.");
        return this.currentNode ? (this.currentNode.children ? this.closeNode(this.currentNode) : this.openNode(this.currentNode), this.currentNode = null) : this.closeNode(this.openTags[this.currentLevel]), delete this.openTags[this.currentLevel], this.currentLevel--, this;
      }, A.prototype.end = function() {
        for (; this.currentLevel >= 0; )
          this.up();
        return this.onEnd();
      }, A.prototype.openCurrent = function() {
        if (this.currentNode)
          return this.currentNode.children = !0, this.openNode(this.currentNode);
      }, A.prototype.openNode = function(U) {
        if (!U.isOpen)
          return !this.root && this.currentLevel === 0 && U instanceof c && (this.root = U), this.onData(this.writer.openNode(U, this.currentLevel), this.currentLevel), U.isOpen = !0;
      }, A.prototype.closeNode = function(U) {
        if (!U.isClosed)
          return this.onData(this.writer.closeNode(U, this.currentLevel), this.currentLevel), U.isClosed = !0;
      }, A.prototype.onData = function(U, P) {
        return this.documentStarted = !0, this.onDataCallback(U, P + 1);
      }, A.prototype.onEnd = function() {
        return this.documentCompleted = !0, this.onEndCallback();
      }, A.prototype.debugInfo = function(U) {
        return U == null ? "" : "node: <" + U + ">";
      }, A.prototype.ele = function() {
        return this.element.apply(this, arguments);
      }, A.prototype.nod = function(U, P, V) {
        return this.node(U, P, V);
      }, A.prototype.txt = function(U) {
        return this.text(U);
      }, A.prototype.dat = function(U) {
        return this.cdata(U);
      }, A.prototype.com = function(U) {
        return this.comment(U);
      }, A.prototype.ins = function(U, P) {
        return this.instruction(U, P);
      }, A.prototype.dec = function(U, P, V) {
        return this.declaration(U, P, V);
      }, A.prototype.dtd = function(U, P, V) {
        return this.doctype(U, P, V);
      }, A.prototype.e = function(U, P, V) {
        return this.element(U, P, V);
      }, A.prototype.n = function(U, P, V) {
        return this.node(U, P, V);
      }, A.prototype.t = function(U) {
        return this.text(U);
      }, A.prototype.d = function(U) {
        return this.cdata(U);
      }, A.prototype.c = function(U) {
        return this.comment(U);
      }, A.prototype.r = function(U) {
        return this.raw(U);
      }, A.prototype.i = function(U, P) {
        return this.instruction(U, P);
      }, A.prototype.att = function() {
        return this.currentNode && this.currentNode instanceof l ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
      }, A.prototype.a = function() {
        return this.currentNode && this.currentNode instanceof l ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
      }, A.prototype.ent = function(U, P) {
        return this.entity(U, P);
      }, A.prototype.pent = function(U, P) {
        return this.pEntity(U, P);
      }, A.prototype.not = function(U, P) {
        return this.notation(U, P);
      }, A;
    }();
  }).call(wt)), G2.exports;
}
var K2 = { exports: {} }, cI;
function The() {
  return cI || (cI = 1, (function() {
    var t, e, n, r, i, o, a, s, l, c, u, d, f, p, m = function(b, y) {
      for (var w in y)
        g.call(y, w) && (b[w] = y[w]);
      function x() {
        this.constructor = b;
      }
      return x.prototype = y.prototype, b.prototype = new x(), b.__super__ = y.prototype, b;
    }, g = {}.hasOwnProperty;
    a = n0(), s = s0(), t = e0(), e = t0(), c = Q1(), d = l0(), f = c0(), u = u0(), l = xC(), n = r0(), r = o0(), i = i0(), o = a0(), p = HL(), K2.exports = function(b) {
      m(y, b);
      function y(w, x) {
        y.__super__.constructor.call(this, x), this.stream = w;
      }
      return y.prototype.document = function(w) {
        var x, k, A, U, P, V, I, le;
        for (V = w.children, k = 0, U = V.length; k < U; k++)
          x = V[k], x.isLastRootNode = !1;
        for (w.children[w.children.length - 1].isLastRootNode = !0, I = w.children, le = [], A = 0, P = I.length; A < P; A++)
          if (x = I[A], !(x instanceof l))
            switch (!1) {
              case !(x instanceof a):
                le.push(this.declaration(x));
                break;
              case !(x instanceof s):
                le.push(this.docType(x));
                break;
              case !(x instanceof e):
                le.push(this.comment(x));
                break;
              case !(x instanceof u):
                le.push(this.processingInstruction(x));
                break;
              default:
                le.push(this.element(x));
            }
        return le;
      }, y.prototype.attribute = function(w) {
        return this.stream.write(" " + w.name + '="' + w.value + '"');
      }, y.prototype.cdata = function(w, x) {
        return this.stream.write(this.space(x) + "<![CDATA[" + w.text + "]]>" + this.endline(w));
      }, y.prototype.comment = function(w, x) {
        return this.stream.write(this.space(x) + "<!-- " + w.text + " -->" + this.endline(w));
      }, y.prototype.declaration = function(w, x) {
        return this.stream.write(this.space(x)), this.stream.write('<?xml version="' + w.version + '"'), w.encoding != null && this.stream.write(' encoding="' + w.encoding + '"'), w.standalone != null && this.stream.write(' standalone="' + w.standalone + '"'), this.stream.write(this.spacebeforeslash + "?>"), this.stream.write(this.endline(w));
      }, y.prototype.docType = function(w, x) {
        var k, A, U, P;
        if (x || (x = 0), this.stream.write(this.space(x)), this.stream.write("<!DOCTYPE " + w.root().name), w.pubID && w.sysID ? this.stream.write(' PUBLIC "' + w.pubID + '" "' + w.sysID + '"') : w.sysID && this.stream.write(' SYSTEM "' + w.sysID + '"'), w.children.length > 0) {
          for (this.stream.write(" ["), this.stream.write(this.endline(w)), P = w.children, A = 0, U = P.length; A < U; A++)
            switch (k = P[A], !1) {
              case !(k instanceof n):
                this.dtdAttList(k, x + 1);
                break;
              case !(k instanceof r):
                this.dtdElement(k, x + 1);
                break;
              case !(k instanceof i):
                this.dtdEntity(k, x + 1);
                break;
              case !(k instanceof o):
                this.dtdNotation(k, x + 1);
                break;
              case !(k instanceof t):
                this.cdata(k, x + 1);
                break;
              case !(k instanceof e):
                this.comment(k, x + 1);
                break;
              case !(k instanceof u):
                this.processingInstruction(k, x + 1);
                break;
              default:
                throw new Error("Unknown DTD node type: " + k.constructor.name);
            }
          this.stream.write("]");
        }
        return this.stream.write(this.spacebeforeslash + ">"), this.stream.write(this.endline(w));
      }, y.prototype.element = function(w, x) {
        var k, A, U, P, V, I, le, be;
        x || (x = 0), be = this.space(x), this.stream.write(be + "<" + w.name), I = w.attributes;
        for (V in I)
          g.call(I, V) && (k = I[V], this.attribute(k));
        if (w.children.length === 0 || w.children.every(function(F) {
          return F.value === "";
        }))
          this.allowEmpty ? this.stream.write("></" + w.name + ">") : this.stream.write(this.spacebeforeslash + "/>");
        else if (this.pretty && w.children.length === 1 && w.children[0].value != null)
          this.stream.write(">"), this.stream.write(w.children[0].value), this.stream.write("</" + w.name + ">");
        else {
          for (this.stream.write(">" + this.newline), le = w.children, U = 0, P = le.length; U < P; U++)
            switch (A = le[U], !1) {
              case !(A instanceof t):
                this.cdata(A, x + 1);
                break;
              case !(A instanceof e):
                this.comment(A, x + 1);
                break;
              case !(A instanceof c):
                this.element(A, x + 1);
                break;
              case !(A instanceof d):
                this.raw(A, x + 1);
                break;
              case !(A instanceof f):
                this.text(A, x + 1);
                break;
              case !(A instanceof u):
                this.processingInstruction(A, x + 1);
                break;
              case !(A instanceof l):
                break;
              default:
                throw new Error("Unknown XML node type: " + A.constructor.name);
            }
          this.stream.write(be + "</" + w.name + ">");
        }
        return this.stream.write(this.endline(w));
      }, y.prototype.processingInstruction = function(w, x) {
        return this.stream.write(this.space(x) + "<?" + w.target), w.value && this.stream.write(" " + w.value), this.stream.write(this.spacebeforeslash + "?>" + this.endline(w));
      }, y.prototype.raw = function(w, x) {
        return this.stream.write(this.space(x) + w.value + this.endline(w));
      }, y.prototype.text = function(w, x) {
        return this.stream.write(this.space(x) + w.value + this.endline(w));
      }, y.prototype.dtdAttList = function(w, x) {
        return this.stream.write(this.space(x) + "<!ATTLIST " + w.elementName + " " + w.attributeName + " " + w.attributeType), w.defaultValueType !== "#DEFAULT" && this.stream.write(" " + w.defaultValueType), w.defaultValue && this.stream.write(' "' + w.defaultValue + '"'), this.stream.write(this.spacebeforeslash + ">" + this.endline(w));
      }, y.prototype.dtdElement = function(w, x) {
        return this.stream.write(this.space(x) + "<!ELEMENT " + w.name + " " + w.value), this.stream.write(this.spacebeforeslash + ">" + this.endline(w));
      }, y.prototype.dtdEntity = function(w, x) {
        return this.stream.write(this.space(x) + "<!ENTITY"), w.pe && this.stream.write(" %"), this.stream.write(" " + w.name), w.value ? this.stream.write(' "' + w.value + '"') : (w.pubID && w.sysID ? this.stream.write(' PUBLIC "' + w.pubID + '" "' + w.sysID + '"') : w.sysID && this.stream.write(' SYSTEM "' + w.sysID + '"'), w.nData && this.stream.write(" NDATA " + w.nData)), this.stream.write(this.spacebeforeslash + ">" + this.endline(w));
      }, y.prototype.dtdNotation = function(w, x) {
        return this.stream.write(this.space(x) + "<!NOTATION " + w.name), w.pubID && w.sysID ? this.stream.write(' PUBLIC "' + w.pubID + '" "' + w.sysID + '"') : w.pubID ? this.stream.write(' PUBLIC "' + w.pubID + '"') : w.sysID && this.stream.write(' SYSTEM "' + w.sysID + '"'), this.stream.write(this.spacebeforeslash + ">" + this.endline(w));
      }, y.prototype.endline = function(w) {
        return w.isLastRootNode ? "" : this.newline;
      }, y;
    }(p);
  }).call(wt)), K2.exports;
}
(function() {
  var t, e, n, r, i, o, a;
  a = Hl(), i = a.assign, o = a.isFunction, t = _he(), e = She(), r = _C(), n = The(), Tp.create = function(s, l, c, u) {
    var d, f;
    if (s == null)
      throw new Error("Root element needs a name.");
    return u = i({}, l, c, u), d = new t(u), f = d.element(s), u.headless || (d.declaration(u), (u.pubID != null || u.sysID != null) && d.doctype(u)), f;
  }, Tp.begin = function(s, l, c) {
    var u;
    return o(s) && (u = [s, l], l = u[0], c = u[1], s = {}), l ? new e(s, l, c) : new t(s);
  }, Tp.stringWriter = function(s) {
    return new r(s);
  }, Tp.streamWriter = function(s, l) {
    return new n(s, l);
  };
}).call(wt);
var uI = Rn, Dhe = Tp;
WL.writeString = Ehe;
function Ehe(t, e) {
  var n = uI.invert(e), r = {
    element: o,
    text: Che
  };
  function i(l, c) {
    return r[c.type](l, c);
  }
  function o(l, c) {
    var u = l.element(a(c.name), c.attributes);
    c.children.forEach(function(d) {
      i(u, d);
    });
  }
  function a(l) {
    var c = /^\{(.*)\}(.*)$/.exec(l);
    if (c) {
      var u = n[c[1]];
      return u + (u === "" ? "" : ":") + c[2];
    } else
      return l;
  }
  function s(l) {
    var c = Dhe.create(a(l.name), {
      version: "1.0",
      encoding: "UTF-8",
      standalone: !0
    });
    return uI.forEach(e, function(u, d) {
      var f = "xmlns" + (d === "" ? "" : ":" + d);
      c.attribute(f, u);
    }), l.children.forEach(function(u) {
      i(c, u);
    }), c.end();
  }
  return s(t);
}
function Che(t, e) {
  t.text(e.value);
}
var d0 = rh;
ys.Element = d0.Element;
ys.element = d0.element;
ys.emptyElement = d0.emptyElement;
ys.text = d0.text;
ys.readString = sL.readString;
ys.writeString = WL.writeString;
var khe = Rn, Ahe = Zn, Rhe = ys;
cC.read = jL;
cC.readXmlFromZipFile = Ohe;
var Ihe = {
  // Transitional format
  "http://schemas.openxmlformats.org/wordprocessingml/2006/main": "w",
  "http://schemas.openxmlformats.org/officeDocument/2006/relationships": "r",
  "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing": "wp",
  "http://schemas.openxmlformats.org/drawingml/2006/main": "a",
  "http://schemas.openxmlformats.org/drawingml/2006/picture": "pic",
  // Strict format
  "http://purl.oclc.org/ooxml/wordprocessingml/main": "w",
  "http://purl.oclc.org/ooxml/officeDocument/relationships": "r",
  "http://purl.oclc.org/ooxml/drawingml/wordprocessingDrawing": "wp",
  "http://purl.oclc.org/ooxml/drawingml/main": "a",
  "http://purl.oclc.org/ooxml/drawingml/picture": "pic",
  // Common
  "http://schemas.openxmlformats.org/package/2006/content-types": "content-types",
  "http://schemas.openxmlformats.org/package/2006/relationships": "relationships",
  "http://schemas.openxmlformats.org/markup-compatibility/2006": "mc",
  "urn:schemas-microsoft-com:vml": "v",
  "urn:schemas-microsoft-com:office:word": "office-word",
  // [MS-DOCX]: Word Extensions to the Office Open XML (.docx) File Format
  // https://learn.microsoft.com/en-us/openspecs/office_standards/ms-docx/b839fe1f-e1ca-4fa6-8c26-5954d0abbccd
  "http://schemas.microsoft.com/office/word/2010/wordml": "wordml"
};
function jL(t) {
  return Rhe.readString(t, Ihe).then(function(e) {
    return VL(e)[0];
  });
}
function Ohe(t, e) {
  return t.exists(e) ? t.read(e, "utf-8").then(Fhe).then(jL) : Ahe.resolve(null);
}
function Fhe(t) {
  return t.replace(/^\uFEFF/g, "");
}
function VL(t) {
  return t.type === "element" ? t.name === "mc:AlternateContent" ? t.first("mc:Fallback").children : (t.children = khe.flatten(t.children.map(VL, !0)), [t]) : [t];
}
var SC = {}, _l = {}, TC = {};
Object.defineProperty(TC, "__esModule", { value: !0 });
var Uhe = [
  { "Typeface name": "Symbol", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
  { "Typeface name": "Symbol", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "33", "Unicode hex": "21" },
  { "Typeface name": "Symbol", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "8704", "Unicode hex": "2200" },
  { "Typeface name": "Symbol", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "35", "Unicode hex": "23" },
  { "Typeface name": "Symbol", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "8707", "Unicode hex": "2203" },
  { "Typeface name": "Symbol", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "37", "Unicode hex": "25" },
  { "Typeface name": "Symbol", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "38", "Unicode hex": "26" },
  { "Typeface name": "Symbol", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "8717", "Unicode hex": "220D" },
  { "Typeface name": "Symbol", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "40", "Unicode hex": "28" },
  { "Typeface name": "Symbol", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "41", "Unicode hex": "29" },
  { "Typeface name": "Symbol", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "42", "Unicode hex": "2A" },
  { "Typeface name": "Symbol", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "43", "Unicode hex": "2B" },
  { "Typeface name": "Symbol", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "44", "Unicode hex": "2C" },
  { "Typeface name": "Symbol", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "8722", "Unicode hex": "2212" },
  { "Typeface name": "Symbol", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "46", "Unicode hex": "2E" },
  { "Typeface name": "Symbol", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "47", "Unicode hex": "2F" },
  { "Typeface name": "Symbol", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "48", "Unicode hex": "30" },
  { "Typeface name": "Symbol", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "49", "Unicode hex": "31" },
  { "Typeface name": "Symbol", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "50", "Unicode hex": "32" },
  { "Typeface name": "Symbol", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "51", "Unicode hex": "33" },
  { "Typeface name": "Symbol", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "52", "Unicode hex": "34" },
  { "Typeface name": "Symbol", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "53", "Unicode hex": "35" },
  { "Typeface name": "Symbol", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "54", "Unicode hex": "36" },
  { "Typeface name": "Symbol", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "55", "Unicode hex": "37" },
  { "Typeface name": "Symbol", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "56", "Unicode hex": "38" },
  { "Typeface name": "Symbol", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "57", "Unicode hex": "39" },
  { "Typeface name": "Symbol", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "58", "Unicode hex": "3A" },
  { "Typeface name": "Symbol", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "59", "Unicode hex": "3B" },
  { "Typeface name": "Symbol", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "60", "Unicode hex": "3C" },
  { "Typeface name": "Symbol", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "61", "Unicode hex": "3D" },
  { "Typeface name": "Symbol", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "62", "Unicode hex": "3E" },
  { "Typeface name": "Symbol", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "63", "Unicode hex": "3F" },
  { "Typeface name": "Symbol", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "8773", "Unicode hex": "2245" },
  { "Typeface name": "Symbol", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "913", "Unicode hex": "391" },
  { "Typeface name": "Symbol", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "914", "Unicode hex": "392" },
  { "Typeface name": "Symbol", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "935", "Unicode hex": "3A7" },
  { "Typeface name": "Symbol", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "916", "Unicode hex": "394" },
  { "Typeface name": "Symbol", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "917", "Unicode hex": "395" },
  { "Typeface name": "Symbol", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "934", "Unicode hex": "3A6" },
  { "Typeface name": "Symbol", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "915", "Unicode hex": "393" },
  { "Typeface name": "Symbol", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "919", "Unicode hex": "397" },
  { "Typeface name": "Symbol", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "921", "Unicode hex": "399" },
  { "Typeface name": "Symbol", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "977", "Unicode hex": "3D1" },
  { "Typeface name": "Symbol", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "922", "Unicode hex": "39A" },
  { "Typeface name": "Symbol", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "923", "Unicode hex": "39B" },
  { "Typeface name": "Symbol", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "924", "Unicode hex": "39C" },
  { "Typeface name": "Symbol", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "925", "Unicode hex": "39D" },
  { "Typeface name": "Symbol", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "927", "Unicode hex": "39F" },
  { "Typeface name": "Symbol", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "928", "Unicode hex": "3A0" },
  { "Typeface name": "Symbol", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "920", "Unicode hex": "398" },
  { "Typeface name": "Symbol", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "929", "Unicode hex": "3A1" },
  { "Typeface name": "Symbol", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "931", "Unicode hex": "3A3" },
  { "Typeface name": "Symbol", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "932", "Unicode hex": "3A4" },
  { "Typeface name": "Symbol", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "933", "Unicode hex": "3A5" },
  { "Typeface name": "Symbol", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "962", "Unicode hex": "3C2" },
  { "Typeface name": "Symbol", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "937", "Unicode hex": "3A9" },
  { "Typeface name": "Symbol", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "926", "Unicode hex": "39E" },
  { "Typeface name": "Symbol", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "936", "Unicode hex": "3A8" },
  { "Typeface name": "Symbol", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "918", "Unicode hex": "396" },
  { "Typeface name": "Symbol", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "91", "Unicode hex": "5B" },
  { "Typeface name": "Symbol", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "8756", "Unicode hex": "2234" },
  { "Typeface name": "Symbol", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "93", "Unicode hex": "5D" },
  { "Typeface name": "Symbol", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "8869", "Unicode hex": "22A5" },
  { "Typeface name": "Symbol", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "95", "Unicode hex": "5F" },
  { "Typeface name": "Symbol", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "8254", "Unicode hex": "203E" },
  { "Typeface name": "Symbol", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "945", "Unicode hex": "3B1" },
  { "Typeface name": "Symbol", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "946", "Unicode hex": "3B2" },
  { "Typeface name": "Symbol", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "967", "Unicode hex": "3C7" },
  { "Typeface name": "Symbol", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "948", "Unicode hex": "3B4" },
  { "Typeface name": "Symbol", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "949", "Unicode hex": "3B5" },
  { "Typeface name": "Symbol", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "966", "Unicode hex": "3C6" },
  { "Typeface name": "Symbol", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "947", "Unicode hex": "3B3" },
  { "Typeface name": "Symbol", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "951", "Unicode hex": "3B7" },
  { "Typeface name": "Symbol", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "953", "Unicode hex": "3B9" },
  { "Typeface name": "Symbol", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "981", "Unicode hex": "3D5" },
  { "Typeface name": "Symbol", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "954", "Unicode hex": "3BA" },
  { "Typeface name": "Symbol", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "955", "Unicode hex": "3BB" },
  { "Typeface name": "Symbol", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "956", "Unicode hex": "3BC" },
  { "Typeface name": "Symbol", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "957", "Unicode hex": "3BD" },
  { "Typeface name": "Symbol", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "959", "Unicode hex": "3BF" },
  { "Typeface name": "Symbol", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "960", "Unicode hex": "3C0" },
  { "Typeface name": "Symbol", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "952", "Unicode hex": "3B8" },
  { "Typeface name": "Symbol", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "961", "Unicode hex": "3C1" },
  { "Typeface name": "Symbol", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "963", "Unicode hex": "3C3" },
  { "Typeface name": "Symbol", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "964", "Unicode hex": "3C4" },
  { "Typeface name": "Symbol", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "965", "Unicode hex": "3C5" },
  { "Typeface name": "Symbol", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "982", "Unicode hex": "3D6" },
  { "Typeface name": "Symbol", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "969", "Unicode hex": "3C9" },
  { "Typeface name": "Symbol", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "958", "Unicode hex": "3BE" },
  { "Typeface name": "Symbol", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "968", "Unicode hex": "3C8" },
  { "Typeface name": "Symbol", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "950", "Unicode hex": "3B6" },
  { "Typeface name": "Symbol", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "123", "Unicode hex": "7B" },
  { "Typeface name": "Symbol", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "124", "Unicode hex": "7C" },
  { "Typeface name": "Symbol", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "125", "Unicode hex": "7D" },
  { "Typeface name": "Symbol", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "126", "Unicode hex": "7E" },
  { "Typeface name": "Symbol", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "8364", "Unicode hex": "20AC" },
  { "Typeface name": "Symbol", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "978", "Unicode hex": "3D2" },
  { "Typeface name": "Symbol", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "8242", "Unicode hex": "2032" },
  { "Typeface name": "Symbol", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "8804", "Unicode hex": "2264" },
  { "Typeface name": "Symbol", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "8260", "Unicode hex": "2044" },
  { "Typeface name": "Symbol", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "8734", "Unicode hex": "221E" },
  { "Typeface name": "Symbol", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "402", "Unicode hex": "192" },
  { "Typeface name": "Symbol", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9827", "Unicode hex": "2663" },
  { "Typeface name": "Symbol", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9830", "Unicode hex": "2666" },
  { "Typeface name": "Symbol", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "9829", "Unicode hex": "2665" },
  { "Typeface name": "Symbol", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "9824", "Unicode hex": "2660" },
  { "Typeface name": "Symbol", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "8596", "Unicode hex": "2194" },
  { "Typeface name": "Symbol", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "8592", "Unicode hex": "2190" },
  { "Typeface name": "Symbol", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "8593", "Unicode hex": "2191" },
  { "Typeface name": "Symbol", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "8594", "Unicode hex": "2192" },
  { "Typeface name": "Symbol", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "8595", "Unicode hex": "2193" },
  { "Typeface name": "Symbol", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "176", "Unicode hex": "B0" },
  { "Typeface name": "Symbol", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "177", "Unicode hex": "B1" },
  { "Typeface name": "Symbol", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "8243", "Unicode hex": "2033" },
  { "Typeface name": "Symbol", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "8805", "Unicode hex": "2265" },
  { "Typeface name": "Symbol", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "215", "Unicode hex": "D7" },
  { "Typeface name": "Symbol", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "8733", "Unicode hex": "221D" },
  { "Typeface name": "Symbol", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "8706", "Unicode hex": "2202" },
  { "Typeface name": "Symbol", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "8226", "Unicode hex": "2022" },
  { "Typeface name": "Symbol", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "247", "Unicode hex": "F7" },
  { "Typeface name": "Symbol", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "8800", "Unicode hex": "2260" },
  { "Typeface name": "Symbol", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "8801", "Unicode hex": "2261" },
  { "Typeface name": "Symbol", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "8776", "Unicode hex": "2248" },
  { "Typeface name": "Symbol", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "8230", "Unicode hex": "2026" },
  { "Typeface name": "Symbol", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "9168", "Unicode hex": "23D0" },
  { "Typeface name": "Symbol", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "9135", "Unicode hex": "23AF" },
  { "Typeface name": "Symbol", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "8629", "Unicode hex": "21B5" },
  { "Typeface name": "Symbol", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "8501", "Unicode hex": "2135" },
  { "Typeface name": "Symbol", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "8465", "Unicode hex": "2111" },
  { "Typeface name": "Symbol", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "8476", "Unicode hex": "211C" },
  { "Typeface name": "Symbol", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "8472", "Unicode hex": "2118" },
  { "Typeface name": "Symbol", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "8855", "Unicode hex": "2297" },
  { "Typeface name": "Symbol", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "8853", "Unicode hex": "2295" },
  { "Typeface name": "Symbol", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "8709", "Unicode hex": "2205" },
  { "Typeface name": "Symbol", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "8745", "Unicode hex": "2229" },
  { "Typeface name": "Symbol", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "8746", "Unicode hex": "222A" },
  { "Typeface name": "Symbol", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "8835", "Unicode hex": "2283" },
  { "Typeface name": "Symbol", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "8839", "Unicode hex": "2287" },
  { "Typeface name": "Symbol", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "8836", "Unicode hex": "2284" },
  { "Typeface name": "Symbol", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "8834", "Unicode hex": "2282" },
  { "Typeface name": "Symbol", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "8838", "Unicode hex": "2286" },
  { "Typeface name": "Symbol", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "8712", "Unicode hex": "2208" },
  { "Typeface name": "Symbol", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "8713", "Unicode hex": "2209" },
  { "Typeface name": "Symbol", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "8736", "Unicode hex": "2220" },
  { "Typeface name": "Symbol", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "8711", "Unicode hex": "2207" },
  { "Typeface name": "Symbol", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "174", "Unicode hex": "AE" },
  { "Typeface name": "Symbol", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "169", "Unicode hex": "A9" },
  { "Typeface name": "Symbol", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "8482", "Unicode hex": "2122" },
  { "Typeface name": "Symbol", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "8719", "Unicode hex": "220F" },
  { "Typeface name": "Symbol", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8730", "Unicode hex": "221A" },
  { "Typeface name": "Symbol", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "8901", "Unicode hex": "22C5" },
  { "Typeface name": "Symbol", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "172", "Unicode hex": "AC" },
  { "Typeface name": "Symbol", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "8743", "Unicode hex": "2227" },
  { "Typeface name": "Symbol", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "8744", "Unicode hex": "2228" },
  { "Typeface name": "Symbol", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "8660", "Unicode hex": "21D4" },
  { "Typeface name": "Symbol", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "8656", "Unicode hex": "21D0" },
  { "Typeface name": "Symbol", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "8657", "Unicode hex": "21D1" },
  { "Typeface name": "Symbol", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "8658", "Unicode hex": "21D2" },
  { "Typeface name": "Symbol", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "8659", "Unicode hex": "21D3" },
  { "Typeface name": "Symbol", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "9674", "Unicode hex": "25CA" },
  { "Typeface name": "Symbol", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "12296", "Unicode hex": "3008" },
  { "Typeface name": "Symbol", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "174", "Unicode hex": "AE" },
  { "Typeface name": "Symbol", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "169", "Unicode hex": "A9" },
  { "Typeface name": "Symbol", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "8482", "Unicode hex": "2122" },
  { "Typeface name": "Symbol", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "8721", "Unicode hex": "2211" },
  { "Typeface name": "Symbol", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "9115", "Unicode hex": "239B" },
  { "Typeface name": "Symbol", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "9116", "Unicode hex": "239C" },
  { "Typeface name": "Symbol", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9117", "Unicode hex": "239D" },
  { "Typeface name": "Symbol", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9121", "Unicode hex": "23A1" },
  { "Typeface name": "Symbol", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "9122", "Unicode hex": "23A2" },
  { "Typeface name": "Symbol", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "9123", "Unicode hex": "23A3" },
  { "Typeface name": "Symbol", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "9127", "Unicode hex": "23A7" },
  { "Typeface name": "Symbol", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "9128", "Unicode hex": "23A8" },
  { "Typeface name": "Symbol", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "9129", "Unicode hex": "23A9" },
  { "Typeface name": "Symbol", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "9130", "Unicode hex": "23AA" },
  { "Typeface name": "Symbol", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "63743", "Unicode hex": "F8FF" },
  { "Typeface name": "Symbol", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "12297", "Unicode hex": "3009" },
  { "Typeface name": "Symbol", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8747", "Unicode hex": "222B" },
  { "Typeface name": "Symbol", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "8992", "Unicode hex": "2320" },
  { "Typeface name": "Symbol", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "9134", "Unicode hex": "23AE" },
  { "Typeface name": "Symbol", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "8993", "Unicode hex": "2321" },
  { "Typeface name": "Symbol", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "9118", "Unicode hex": "239E" },
  { "Typeface name": "Symbol", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "9119", "Unicode hex": "239F" },
  { "Typeface name": "Symbol", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "9120", "Unicode hex": "23A0" },
  { "Typeface name": "Symbol", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "9124", "Unicode hex": "23A4" },
  { "Typeface name": "Symbol", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "9125", "Unicode hex": "23A5" },
  { "Typeface name": "Symbol", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "9126", "Unicode hex": "23A6" },
  { "Typeface name": "Symbol", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "9131", "Unicode hex": "23AB" },
  { "Typeface name": "Symbol", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "9132", "Unicode hex": "23AC" },
  { "Typeface name": "Symbol", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "9133", "Unicode hex": "23AD" },
  { "Typeface name": "Webdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
  { "Typeface name": "Webdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128375", "Unicode hex": "1F577" },
  { "Typeface name": "Webdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128376", "Unicode hex": "1F578" },
  { "Typeface name": "Webdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128370", "Unicode hex": "1F572" },
  { "Typeface name": "Webdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128374", "Unicode hex": "1F576" },
  { "Typeface name": "Webdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "127942", "Unicode hex": "1F3C6" },
  { "Typeface name": "Webdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "127894", "Unicode hex": "1F396" },
  { "Typeface name": "Webdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128391", "Unicode hex": "1F587" },
  { "Typeface name": "Webdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128488", "Unicode hex": "1F5E8" },
  { "Typeface name": "Webdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128489", "Unicode hex": "1F5E9" },
  { "Typeface name": "Webdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128496", "Unicode hex": "1F5F0" },
  { "Typeface name": "Webdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128497", "Unicode hex": "1F5F1" },
  { "Typeface name": "Webdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "127798", "Unicode hex": "1F336" },
  { "Typeface name": "Webdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "127895", "Unicode hex": "1F397" },
  { "Typeface name": "Webdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128638", "Unicode hex": "1F67E" },
  { "Typeface name": "Webdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128636", "Unicode hex": "1F67C" },
  { "Typeface name": "Webdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128469", "Unicode hex": "1F5D5" },
  { "Typeface name": "Webdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128470", "Unicode hex": "1F5D6" },
  { "Typeface name": "Webdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128471", "Unicode hex": "1F5D7" },
  { "Typeface name": "Webdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "9204", "Unicode hex": "23F4" },
  { "Typeface name": "Webdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "9205", "Unicode hex": "23F5" },
  { "Typeface name": "Webdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "9206", "Unicode hex": "23F6" },
  { "Typeface name": "Webdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "9207", "Unicode hex": "23F7" },
  { "Typeface name": "Webdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "9194", "Unicode hex": "23EA" },
  { "Typeface name": "Webdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "9193", "Unicode hex": "23E9" },
  { "Typeface name": "Webdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "9198", "Unicode hex": "23EE" },
  { "Typeface name": "Webdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "9197", "Unicode hex": "23ED" },
  { "Typeface name": "Webdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "9208", "Unicode hex": "23F8" },
  { "Typeface name": "Webdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "9209", "Unicode hex": "23F9" },
  { "Typeface name": "Webdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "9210", "Unicode hex": "23FA" },
  { "Typeface name": "Webdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128474", "Unicode hex": "1F5DA" },
  { "Typeface name": "Webdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128499", "Unicode hex": "1F5F3" },
  { "Typeface name": "Webdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128736", "Unicode hex": "1F6E0" },
  { "Typeface name": "Webdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "127959", "Unicode hex": "1F3D7" },
  { "Typeface name": "Webdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "127960", "Unicode hex": "1F3D8" },
  { "Typeface name": "Webdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "127961", "Unicode hex": "1F3D9" },
  { "Typeface name": "Webdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "127962", "Unicode hex": "1F3DA" },
  { "Typeface name": "Webdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "127964", "Unicode hex": "1F3DC" },
  { "Typeface name": "Webdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "127981", "Unicode hex": "1F3ED" },
  { "Typeface name": "Webdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "127963", "Unicode hex": "1F3DB" },
  { "Typeface name": "Webdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "127968", "Unicode hex": "1F3E0" },
  { "Typeface name": "Webdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "127958", "Unicode hex": "1F3D6" },
  { "Typeface name": "Webdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "127965", "Unicode hex": "1F3DD" },
  { "Typeface name": "Webdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128739", "Unicode hex": "1F6E3" },
  { "Typeface name": "Webdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128269", "Unicode hex": "1F50D" },
  { "Typeface name": "Webdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "127956", "Unicode hex": "1F3D4" },
  { "Typeface name": "Webdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128065", "Unicode hex": "1F441" },
  { "Typeface name": "Webdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128066", "Unicode hex": "1F442" },
  { "Typeface name": "Webdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127966", "Unicode hex": "1F3DE" },
  { "Typeface name": "Webdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "127957", "Unicode hex": "1F3D5" },
  { "Typeface name": "Webdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "128740", "Unicode hex": "1F6E4" },
  { "Typeface name": "Webdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127967", "Unicode hex": "1F3DF" },
  { "Typeface name": "Webdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "128755", "Unicode hex": "1F6F3" },
  { "Typeface name": "Webdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128364", "Unicode hex": "1F56C" },
  { "Typeface name": "Webdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "128363", "Unicode hex": "1F56B" },
  { "Typeface name": "Webdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128360", "Unicode hex": "1F568" },
  { "Typeface name": "Webdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "128264", "Unicode hex": "1F508" },
  { "Typeface name": "Webdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "127892", "Unicode hex": "1F394" },
  { "Typeface name": "Webdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "127893", "Unicode hex": "1F395" },
  { "Typeface name": "Webdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128492", "Unicode hex": "1F5EC" },
  { "Typeface name": "Webdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128637", "Unicode hex": "1F67D" },
  { "Typeface name": "Webdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "128493", "Unicode hex": "1F5ED" },
  { "Typeface name": "Webdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128490", "Unicode hex": "1F5EA" },
  { "Typeface name": "Webdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128491", "Unicode hex": "1F5EB" },
  { "Typeface name": "Webdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "11156", "Unicode hex": "2B94" },
  { "Typeface name": "Webdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "10004", "Unicode hex": "2714" },
  { "Typeface name": "Webdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128690", "Unicode hex": "1F6B2" },
  { "Typeface name": "Webdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "11036", "Unicode hex": "2B1C" },
  { "Typeface name": "Webdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128737", "Unicode hex": "1F6E1" },
  { "Typeface name": "Webdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128230", "Unicode hex": "1F4E6" },
  { "Typeface name": "Webdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128753", "Unicode hex": "1F6F1" },
  { "Typeface name": "Webdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "11035", "Unicode hex": "2B1B" },
  { "Typeface name": "Webdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128657", "Unicode hex": "1F691" },
  { "Typeface name": "Webdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "128712", "Unicode hex": "1F6C8" },
  { "Typeface name": "Webdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128745", "Unicode hex": "1F6E9" },
  { "Typeface name": "Webdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128752", "Unicode hex": "1F6F0" },
  { "Typeface name": "Webdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "128968", "Unicode hex": "1F7C8" },
  { "Typeface name": "Webdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128372", "Unicode hex": "1F574" },
  { "Typeface name": "Webdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "11044", "Unicode hex": "2B24" },
  { "Typeface name": "Webdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128741", "Unicode hex": "1F6E5" },
  { "Typeface name": "Webdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128660", "Unicode hex": "1F694" },
  { "Typeface name": "Webdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "128472", "Unicode hex": "1F5D8" },
  { "Typeface name": "Webdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "128473", "Unicode hex": "1F5D9" },
  { "Typeface name": "Webdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "10067", "Unicode hex": "2753" },
  { "Typeface name": "Webdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "128754", "Unicode hex": "1F6F2" },
  { "Typeface name": "Webdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "128647", "Unicode hex": "1F687" },
  { "Typeface name": "Webdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "128653", "Unicode hex": "1F68D" },
  { "Typeface name": "Webdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9971", "Unicode hex": "26F3" },
  { "Typeface name": "Webdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10680", "Unicode hex": "29B8" },
  { "Typeface name": "Webdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "8854", "Unicode hex": "2296" },
  { "Typeface name": "Webdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "128685", "Unicode hex": "1F6AD" },
  { "Typeface name": "Webdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "128494", "Unicode hex": "1F5EE" },
  { "Typeface name": "Webdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "9168", "Unicode hex": "23D0" },
  { "Typeface name": "Webdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128495", "Unicode hex": "1F5EF" },
  { "Typeface name": "Webdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128498", "Unicode hex": "1F5F2" },
  { "Typeface name": "Webdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128697", "Unicode hex": "1F6B9" },
  { "Typeface name": "Webdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "128698", "Unicode hex": "1F6BA" },
  { "Typeface name": "Webdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "128713", "Unicode hex": "1F6C9" },
  { "Typeface name": "Webdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "128714", "Unicode hex": "1F6CA" },
  { "Typeface name": "Webdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "128700", "Unicode hex": "1F6BC" },
  { "Typeface name": "Webdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "128125", "Unicode hex": "1F47D" },
  { "Typeface name": "Webdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "127947", "Unicode hex": "1F3CB" },
  { "Typeface name": "Webdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "9975", "Unicode hex": "26F7" },
  { "Typeface name": "Webdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "127938", "Unicode hex": "1F3C2" },
  { "Typeface name": "Webdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "127948", "Unicode hex": "1F3CC" },
  { "Typeface name": "Webdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "127946", "Unicode hex": "1F3CA" },
  { "Typeface name": "Webdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127940", "Unicode hex": "1F3C4" },
  { "Typeface name": "Webdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "127949", "Unicode hex": "1F3CD" },
  { "Typeface name": "Webdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "127950", "Unicode hex": "1F3CE" },
  { "Typeface name": "Webdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128664", "Unicode hex": "1F698" },
  { "Typeface name": "Webdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128480", "Unicode hex": "1F5E0" },
  { "Typeface name": "Webdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128738", "Unicode hex": "1F6E2" },
  { "Typeface name": "Webdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128176", "Unicode hex": "1F4B0" },
  { "Typeface name": "Webdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "127991", "Unicode hex": "1F3F7" },
  { "Typeface name": "Webdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128179", "Unicode hex": "1F4B3" },
  { "Typeface name": "Webdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128106", "Unicode hex": "1F46A" },
  { "Typeface name": "Webdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "128481", "Unicode hex": "1F5E1" },
  { "Typeface name": "Webdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128482", "Unicode hex": "1F5E2" },
  { "Typeface name": "Webdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128483", "Unicode hex": "1F5E3" },
  { "Typeface name": "Webdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "10031", "Unicode hex": "272F" },
  { "Typeface name": "Webdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128388", "Unicode hex": "1F584" },
  { "Typeface name": "Webdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128389", "Unicode hex": "1F585" },
  { "Typeface name": "Webdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128387", "Unicode hex": "1F583" },
  { "Typeface name": "Webdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128390", "Unicode hex": "1F586" },
  { "Typeface name": "Webdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128441", "Unicode hex": "1F5B9" },
  { "Typeface name": "Webdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "128442", "Unicode hex": "1F5BA" },
  { "Typeface name": "Webdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128443", "Unicode hex": "1F5BB" },
  { "Typeface name": "Webdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128373", "Unicode hex": "1F575" },
  { "Typeface name": "Webdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "128368", "Unicode hex": "1F570" },
  { "Typeface name": "Webdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128445", "Unicode hex": "1F5BD" },
  { "Typeface name": "Webdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128446", "Unicode hex": "1F5BE" },
  { "Typeface name": "Webdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
  { "Typeface name": "Webdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128466", "Unicode hex": "1F5D2" },
  { "Typeface name": "Webdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128467", "Unicode hex": "1F5D3" },
  { "Typeface name": "Webdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128366", "Unicode hex": "1F56E" },
  { "Typeface name": "Webdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128218", "Unicode hex": "1F4DA" },
  { "Typeface name": "Webdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128478", "Unicode hex": "1F5DE" },
  { "Typeface name": "Webdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128479", "Unicode hex": "1F5DF" },
  { "Typeface name": "Webdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128451", "Unicode hex": "1F5C3" },
  { "Typeface name": "Webdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128450", "Unicode hex": "1F5C2" },
  { "Typeface name": "Webdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128444", "Unicode hex": "1F5BC" },
  { "Typeface name": "Webdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "127917", "Unicode hex": "1F3AD" },
  { "Typeface name": "Webdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "127900", "Unicode hex": "1F39C" },
  { "Typeface name": "Webdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "127896", "Unicode hex": "1F398" },
  { "Typeface name": "Webdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "127897", "Unicode hex": "1F399" },
  { "Typeface name": "Webdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "127911", "Unicode hex": "1F3A7" },
  { "Typeface name": "Webdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128191", "Unicode hex": "1F4BF" },
  { "Typeface name": "Webdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "127902", "Unicode hex": "1F39E" },
  { "Typeface name": "Webdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128247", "Unicode hex": "1F4F7" },
  { "Typeface name": "Webdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "127903", "Unicode hex": "1F39F" },
  { "Typeface name": "Webdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "127916", "Unicode hex": "1F3AC" },
  { "Typeface name": "Webdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128253", "Unicode hex": "1F4FD" },
  { "Typeface name": "Webdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128249", "Unicode hex": "1F4F9" },
  { "Typeface name": "Webdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128254", "Unicode hex": "1F4FE" },
  { "Typeface name": "Webdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128251", "Unicode hex": "1F4FB" },
  { "Typeface name": "Webdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "127898", "Unicode hex": "1F39A" },
  { "Typeface name": "Webdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "127899", "Unicode hex": "1F39B" },
  { "Typeface name": "Webdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128250", "Unicode hex": "1F4FA" },
  { "Typeface name": "Webdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128187", "Unicode hex": "1F4BB" },
  { "Typeface name": "Webdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128421", "Unicode hex": "1F5A5" },
  { "Typeface name": "Webdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128422", "Unicode hex": "1F5A6" },
  { "Typeface name": "Webdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128423", "Unicode hex": "1F5A7" },
  { "Typeface name": "Webdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "128377", "Unicode hex": "1F579" },
  { "Typeface name": "Webdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "127918", "Unicode hex": "1F3AE" },
  { "Typeface name": "Webdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "128379", "Unicode hex": "1F57B" },
  { "Typeface name": "Webdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128380", "Unicode hex": "1F57C" },
  { "Typeface name": "Webdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128223", "Unicode hex": "1F4DF" },
  { "Typeface name": "Webdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128385", "Unicode hex": "1F581" },
  { "Typeface name": "Webdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128384", "Unicode hex": "1F580" },
  { "Typeface name": "Webdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128424", "Unicode hex": "1F5A8" },
  { "Typeface name": "Webdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128425", "Unicode hex": "1F5A9" },
  { "Typeface name": "Webdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128447", "Unicode hex": "1F5BF" },
  { "Typeface name": "Webdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128426", "Unicode hex": "1F5AA" },
  { "Typeface name": "Webdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128476", "Unicode hex": "1F5DC" },
  { "Typeface name": "Webdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128274", "Unicode hex": "1F512" },
  { "Typeface name": "Webdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128275", "Unicode hex": "1F513" },
  { "Typeface name": "Webdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128477", "Unicode hex": "1F5DD" },
  { "Typeface name": "Webdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128229", "Unicode hex": "1F4E5" },
  { "Typeface name": "Webdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128228", "Unicode hex": "1F4E4" },
  { "Typeface name": "Webdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128371", "Unicode hex": "1F573" },
  { "Typeface name": "Webdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "127779", "Unicode hex": "1F323" },
  { "Typeface name": "Webdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "127780", "Unicode hex": "1F324" },
  { "Typeface name": "Webdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "127781", "Unicode hex": "1F325" },
  { "Typeface name": "Webdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "127782", "Unicode hex": "1F326" },
  { "Typeface name": "Webdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "9729", "Unicode hex": "2601" },
  { "Typeface name": "Webdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "127784", "Unicode hex": "1F328" },
  { "Typeface name": "Webdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "127783", "Unicode hex": "1F327" },
  { "Typeface name": "Webdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "127785", "Unicode hex": "1F329" },
  { "Typeface name": "Webdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "127786", "Unicode hex": "1F32A" },
  { "Typeface name": "Webdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "127788", "Unicode hex": "1F32C" },
  { "Typeface name": "Webdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "127787", "Unicode hex": "1F32B" },
  { "Typeface name": "Webdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "127772", "Unicode hex": "1F31C" },
  { "Typeface name": "Webdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "127777", "Unicode hex": "1F321" },
  { "Typeface name": "Webdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128715", "Unicode hex": "1F6CB" },
  { "Typeface name": "Webdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128719", "Unicode hex": "1F6CF" },
  { "Typeface name": "Webdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "127869", "Unicode hex": "1F37D" },
  { "Typeface name": "Webdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "127864", "Unicode hex": "1F378" },
  { "Typeface name": "Webdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128718", "Unicode hex": "1F6CE" },
  { "Typeface name": "Webdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128717", "Unicode hex": "1F6CD" },
  { "Typeface name": "Webdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9413", "Unicode hex": "24C5" },
  { "Typeface name": "Webdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9855", "Unicode hex": "267F" },
  { "Typeface name": "Webdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128710", "Unicode hex": "1F6C6" },
  { "Typeface name": "Webdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "128392", "Unicode hex": "1F588" },
  { "Typeface name": "Webdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "127891", "Unicode hex": "1F393" },
  { "Typeface name": "Webdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128484", "Unicode hex": "1F5E4" },
  { "Typeface name": "Webdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128485", "Unicode hex": "1F5E5" },
  { "Typeface name": "Webdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128486", "Unicode hex": "1F5E6" },
  { "Typeface name": "Webdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "128487", "Unicode hex": "1F5E7" },
  { "Typeface name": "Webdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128746", "Unicode hex": "1F6EA" },
  { "Typeface name": "Webdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128063", "Unicode hex": "1F43F" },
  { "Typeface name": "Webdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "128038", "Unicode hex": "1F426" },
  { "Typeface name": "Webdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128031", "Unicode hex": "1F41F" },
  { "Typeface name": "Webdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128021", "Unicode hex": "1F415" },
  { "Typeface name": "Webdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "128008", "Unicode hex": "1F408" },
  { "Typeface name": "Webdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "128620", "Unicode hex": "1F66C" },
  { "Typeface name": "Webdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "128622", "Unicode hex": "1F66E" },
  { "Typeface name": "Webdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "128621", "Unicode hex": "1F66D" },
  { "Typeface name": "Webdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "128623", "Unicode hex": "1F66F" },
  { "Typeface name": "Webdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128506", "Unicode hex": "1F5FA" },
  { "Typeface name": "Webdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "127757", "Unicode hex": "1F30D" },
  { "Typeface name": "Webdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "127759", "Unicode hex": "1F30F" },
  { "Typeface name": "Webdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "127758", "Unicode hex": "1F30E" },
  { "Typeface name": "Webdings", "Dingbat dec": "255", "Dingbat hex": "FF", "Unicode dec": "128330", "Unicode hex": "1F54A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
  { "Typeface name": "Wingdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128393", "Unicode hex": "1F589" },
  { "Typeface name": "Wingdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "9986", "Unicode hex": "2702" },
  { "Typeface name": "Wingdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "9985", "Unicode hex": "2701" },
  { "Typeface name": "Wingdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128083", "Unicode hex": "1F453" },
  { "Typeface name": "Wingdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "128365", "Unicode hex": "1F56D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "128366", "Unicode hex": "1F56E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128367", "Unicode hex": "1F56F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128383", "Unicode hex": "1F57F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "9990", "Unicode hex": "2706" },
  { "Typeface name": "Wingdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128386", "Unicode hex": "1F582" },
  { "Typeface name": "Wingdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128387", "Unicode hex": "1F583" },
  { "Typeface name": "Wingdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128234", "Unicode hex": "1F4EA" },
  { "Typeface name": "Wingdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128235", "Unicode hex": "1F4EB" },
  { "Typeface name": "Wingdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128236", "Unicode hex": "1F4EC" },
  { "Typeface name": "Wingdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128237", "Unicode hex": "1F4ED" },
  { "Typeface name": "Wingdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128448", "Unicode hex": "1F5C0" },
  { "Typeface name": "Wingdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128449", "Unicode hex": "1F5C1" },
  { "Typeface name": "Wingdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128462", "Unicode hex": "1F5CE" },
  { "Typeface name": "Wingdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128463", "Unicode hex": "1F5CF" },
  { "Typeface name": "Wingdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128464", "Unicode hex": "1F5D0" },
  { "Typeface name": "Wingdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128452", "Unicode hex": "1F5C4" },
  { "Typeface name": "Wingdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "8987", "Unicode hex": "231B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128430", "Unicode hex": "1F5AE" },
  { "Typeface name": "Wingdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128432", "Unicode hex": "1F5B0" },
  { "Typeface name": "Wingdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128434", "Unicode hex": "1F5B2" },
  { "Typeface name": "Wingdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128435", "Unicode hex": "1F5B3" },
  { "Typeface name": "Wingdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128436", "Unicode hex": "1F5B4" },
  { "Typeface name": "Wingdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128427", "Unicode hex": "1F5AB" },
  { "Typeface name": "Wingdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128428", "Unicode hex": "1F5AC" },
  { "Typeface name": "Wingdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "9991", "Unicode hex": "2707" },
  { "Typeface name": "Wingdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "9997", "Unicode hex": "270D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128398", "Unicode hex": "1F58E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "9996", "Unicode hex": "270C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128399", "Unicode hex": "1F58F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128077", "Unicode hex": "1F44D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128078", "Unicode hex": "1F44E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "9756", "Unicode hex": "261C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "9758", "Unicode hex": "261E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "9757", "Unicode hex": "261D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "9759", "Unicode hex": "261F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128400", "Unicode hex": "1F590" },
  { "Typeface name": "Wingdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "9786", "Unicode hex": "263A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128528", "Unicode hex": "1F610" },
  { "Typeface name": "Wingdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "9785", "Unicode hex": "2639" },
  { "Typeface name": "Wingdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128163", "Unicode hex": "1F4A3" },
  { "Typeface name": "Wingdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128369", "Unicode hex": "1F571" },
  { "Typeface name": "Wingdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "127987", "Unicode hex": "1F3F3" },
  { "Typeface name": "Wingdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127985", "Unicode hex": "1F3F1" },
  { "Typeface name": "Wingdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "9992", "Unicode hex": "2708" },
  { "Typeface name": "Wingdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9788", "Unicode hex": "263C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127778", "Unicode hex": "1F322" },
  { "Typeface name": "Wingdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "10052", "Unicode hex": "2744" },
  { "Typeface name": "Wingdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128326", "Unicode hex": "1F546" },
  { "Typeface name": "Wingdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "10014", "Unicode hex": "271E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128328", "Unicode hex": "1F548" },
  { "Typeface name": "Wingdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10016", "Unicode hex": "2720" },
  { "Typeface name": "Wingdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "10017", "Unicode hex": "2721" },
  { "Typeface name": "Wingdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "9770", "Unicode hex": "262A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "9775", "Unicode hex": "262F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128329", "Unicode hex": "1F549" },
  { "Typeface name": "Wingdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "9784", "Unicode hex": "2638" },
  { "Typeface name": "Wingdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "9800", "Unicode hex": "2648" },
  { "Typeface name": "Wingdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "9801", "Unicode hex": "2649" },
  { "Typeface name": "Wingdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "9802", "Unicode hex": "264A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "9803", "Unicode hex": "264B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "9804", "Unicode hex": "264C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "9805", "Unicode hex": "264D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "9806", "Unicode hex": "264E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "9807", "Unicode hex": "264F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "9808", "Unicode hex": "2650" },
  { "Typeface name": "Wingdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "9809", "Unicode hex": "2651" },
  { "Typeface name": "Wingdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "9810", "Unicode hex": "2652" },
  { "Typeface name": "Wingdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9811", "Unicode hex": "2653" },
  { "Typeface name": "Wingdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128624", "Unicode hex": "1F670" },
  { "Typeface name": "Wingdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128629", "Unicode hex": "1F675" },
  { "Typeface name": "Wingdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9899", "Unicode hex": "26AB" },
  { "Typeface name": "Wingdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128318", "Unicode hex": "1F53E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9724", "Unicode hex": "25FC" },
  { "Typeface name": "Wingdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128911", "Unicode hex": "1F78F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128912", "Unicode hex": "1F790" },
  { "Typeface name": "Wingdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "10065", "Unicode hex": "2751" },
  { "Typeface name": "Wingdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "10066", "Unicode hex": "2752" },
  { "Typeface name": "Wingdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "128927", "Unicode hex": "1F79F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "10731", "Unicode hex": "29EB" },
  { "Typeface name": "Wingdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9670", "Unicode hex": "25C6" },
  { "Typeface name": "Wingdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10070", "Unicode hex": "2756" },
  { "Typeface name": "Wingdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "11049", "Unicode hex": "2B29" },
  { "Typeface name": "Wingdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "8999", "Unicode hex": "2327" },
  { "Typeface name": "Wingdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "11193", "Unicode hex": "2BB9" },
  { "Typeface name": "Wingdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "8984", "Unicode hex": "2318" },
  { "Typeface name": "Wingdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "127989", "Unicode hex": "1F3F5" },
  { "Typeface name": "Wingdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "127990", "Unicode hex": "1F3F6" },
  { "Typeface name": "Wingdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128630", "Unicode hex": "1F676" },
  { "Typeface name": "Wingdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128631", "Unicode hex": "1F677" },
  { "Typeface name": "Wingdings", "Dingbat dec": "127", "Dingbat hex": "7F", "Unicode dec": "9647", "Unicode hex": "25AF" },
  { "Typeface name": "Wingdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "127243", "Unicode hex": "1F10B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "10112", "Unicode hex": "2780" },
  { "Typeface name": "Wingdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "10113", "Unicode hex": "2781" },
  { "Typeface name": "Wingdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "10114", "Unicode hex": "2782" },
  { "Typeface name": "Wingdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "10115", "Unicode hex": "2783" },
  { "Typeface name": "Wingdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10116", "Unicode hex": "2784" },
  { "Typeface name": "Wingdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "10117", "Unicode hex": "2785" },
  { "Typeface name": "Wingdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "10118", "Unicode hex": "2786" },
  { "Typeface name": "Wingdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "10119", "Unicode hex": "2787" },
  { "Typeface name": "Wingdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "10120", "Unicode hex": "2788" },
  { "Typeface name": "Wingdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "10121", "Unicode hex": "2789" },
  { "Typeface name": "Wingdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127244", "Unicode hex": "1F10C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "10122", "Unicode hex": "278A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "10123", "Unicode hex": "278B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "10124", "Unicode hex": "278C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "10125", "Unicode hex": "278D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "10126", "Unicode hex": "278E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "10127", "Unicode hex": "278F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "10128", "Unicode hex": "2790" },
  { "Typeface name": "Wingdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "10129", "Unicode hex": "2791" },
  { "Typeface name": "Wingdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "10130", "Unicode hex": "2792" },
  { "Typeface name": "Wingdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "10131", "Unicode hex": "2793" },
  { "Typeface name": "Wingdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128610", "Unicode hex": "1F662" },
  { "Typeface name": "Wingdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128608", "Unicode hex": "1F660" },
  { "Typeface name": "Wingdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "128609", "Unicode hex": "1F661" },
  { "Typeface name": "Wingdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128611", "Unicode hex": "1F663" },
  { "Typeface name": "Wingdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128606", "Unicode hex": "1F65E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128604", "Unicode hex": "1F65C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128605", "Unicode hex": "1F65D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128607", "Unicode hex": "1F65F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "8729", "Unicode hex": "2219" },
  { "Typeface name": "Wingdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "8226", "Unicode hex": "2022" },
  { "Typeface name": "Wingdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "11037", "Unicode hex": "2B1D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "11096", "Unicode hex": "2B58" },
  { "Typeface name": "Wingdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128902", "Unicode hex": "1F786" },
  { "Typeface name": "Wingdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128904", "Unicode hex": "1F788" },
  { "Typeface name": "Wingdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128906", "Unicode hex": "1F78A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128907", "Unicode hex": "1F78B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128319", "Unicode hex": "1F53F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9642", "Unicode hex": "25AA" },
  { "Typeface name": "Wingdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128910", "Unicode hex": "1F78E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128961", "Unicode hex": "1F7C1" },
  { "Typeface name": "Wingdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128965", "Unicode hex": "1F7C5" },
  { "Typeface name": "Wingdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "9733", "Unicode hex": "2605" },
  { "Typeface name": "Wingdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128971", "Unicode hex": "1F7CB" },
  { "Typeface name": "Wingdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128975", "Unicode hex": "1F7CF" },
  { "Typeface name": "Wingdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "128979", "Unicode hex": "1F7D3" },
  { "Typeface name": "Wingdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "128977", "Unicode hex": "1F7D1" },
  { "Typeface name": "Wingdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "11216", "Unicode hex": "2BD0" },
  { "Typeface name": "Wingdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "8982", "Unicode hex": "2316" },
  { "Typeface name": "Wingdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "11214", "Unicode hex": "2BCE" },
  { "Typeface name": "Wingdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "11215", "Unicode hex": "2BCF" },
  { "Typeface name": "Wingdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "11217", "Unicode hex": "2BD1" },
  { "Typeface name": "Wingdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "10026", "Unicode hex": "272A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "10032", "Unicode hex": "2730" },
  { "Typeface name": "Wingdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "128336", "Unicode hex": "1F550" },
  { "Typeface name": "Wingdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128337", "Unicode hex": "1F551" },
  { "Typeface name": "Wingdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128338", "Unicode hex": "1F552" },
  { "Typeface name": "Wingdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128339", "Unicode hex": "1F553" },
  { "Typeface name": "Wingdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128340", "Unicode hex": "1F554" },
  { "Typeface name": "Wingdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "128341", "Unicode hex": "1F555" },
  { "Typeface name": "Wingdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "128342", "Unicode hex": "1F556" },
  { "Typeface name": "Wingdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128343", "Unicode hex": "1F557" },
  { "Typeface name": "Wingdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128344", "Unicode hex": "1F558" },
  { "Typeface name": "Wingdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128345", "Unicode hex": "1F559" },
  { "Typeface name": "Wingdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128346", "Unicode hex": "1F55A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128347", "Unicode hex": "1F55B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11184", "Unicode hex": "2BB0" },
  { "Typeface name": "Wingdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11185", "Unicode hex": "2BB1" },
  { "Typeface name": "Wingdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11186", "Unicode hex": "2BB2" },
  { "Typeface name": "Wingdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "11187", "Unicode hex": "2BB3" },
  { "Typeface name": "Wingdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "11188", "Unicode hex": "2BB4" },
  { "Typeface name": "Wingdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "11189", "Unicode hex": "2BB5" },
  { "Typeface name": "Wingdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11190", "Unicode hex": "2BB6" },
  { "Typeface name": "Wingdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11191", "Unicode hex": "2BB7" },
  { "Typeface name": "Wingdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128618", "Unicode hex": "1F66A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128619", "Unicode hex": "1F66B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128597", "Unicode hex": "1F655" },
  { "Typeface name": "Wingdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128596", "Unicode hex": "1F654" },
  { "Typeface name": "Wingdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128599", "Unicode hex": "1F657" },
  { "Typeface name": "Wingdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128598", "Unicode hex": "1F656" },
  { "Typeface name": "Wingdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128592", "Unicode hex": "1F650" },
  { "Typeface name": "Wingdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128593", "Unicode hex": "1F651" },
  { "Typeface name": "Wingdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128594", "Unicode hex": "1F652" },
  { "Typeface name": "Wingdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128595", "Unicode hex": "1F653" },
  { "Typeface name": "Wingdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "9003", "Unicode hex": "232B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8998", "Unicode hex": "2326" },
  { "Typeface name": "Wingdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "11160", "Unicode hex": "2B98" },
  { "Typeface name": "Wingdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "11162", "Unicode hex": "2B9A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "11161", "Unicode hex": "2B99" },
  { "Typeface name": "Wingdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "11163", "Unicode hex": "2B9B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "11144", "Unicode hex": "2B88" },
  { "Typeface name": "Wingdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "11146", "Unicode hex": "2B8A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "11145", "Unicode hex": "2B89" },
  { "Typeface name": "Wingdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "11147", "Unicode hex": "2B8B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129128", "Unicode hex": "1F868" },
  { "Typeface name": "Wingdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129130", "Unicode hex": "1F86A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129129", "Unicode hex": "1F869" },
  { "Typeface name": "Wingdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129131", "Unicode hex": "1F86B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129132", "Unicode hex": "1F86C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129133", "Unicode hex": "1F86D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129135", "Unicode hex": "1F86F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129134", "Unicode hex": "1F86E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129144", "Unicode hex": "1F878" },
  { "Typeface name": "Wingdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129146", "Unicode hex": "1F87A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129145", "Unicode hex": "1F879" },
  { "Typeface name": "Wingdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129147", "Unicode hex": "1F87B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129148", "Unicode hex": "1F87C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129149", "Unicode hex": "1F87D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129151", "Unicode hex": "1F87F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129150", "Unicode hex": "1F87E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "8678", "Unicode hex": "21E6" },
  { "Typeface name": "Wingdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "8680", "Unicode hex": "21E8" },
  { "Typeface name": "Wingdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "8679", "Unicode hex": "21E7" },
  { "Typeface name": "Wingdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8681", "Unicode hex": "21E9" },
  { "Typeface name": "Wingdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "11012", "Unicode hex": "2B04" },
  { "Typeface name": "Wingdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "8691", "Unicode hex": "21F3" },
  { "Typeface name": "Wingdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "11009", "Unicode hex": "2B01" },
  { "Typeface name": "Wingdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11008", "Unicode hex": "2B00" },
  { "Typeface name": "Wingdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11011", "Unicode hex": "2B03" },
  { "Typeface name": "Wingdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "11010", "Unicode hex": "2B02" },
  { "Typeface name": "Wingdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "129196", "Unicode hex": "1F8AC" },
  { "Typeface name": "Wingdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "129197", "Unicode hex": "1F8AD" },
  { "Typeface name": "Wingdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128502", "Unicode hex": "1F5F6" },
  { "Typeface name": "Wingdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "10003", "Unicode hex": "2713" },
  { "Typeface name": "Wingdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "128503", "Unicode hex": "1F5F7" },
  { "Typeface name": "Wingdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "128505", "Unicode hex": "1F5F9" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128394", "Unicode hex": "1F58A" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128395", "Unicode hex": "1F58B" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128396", "Unicode hex": "1F58C" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128397", "Unicode hex": "1F58D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "9988", "Unicode hex": "2704" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "9984", "Unicode hex": "2700" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128382", "Unicode hex": "1F57E" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128381", "Unicode hex": "1F57D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128453", "Unicode hex": "1F5C5" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128454", "Unicode hex": "1F5C6" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128455", "Unicode hex": "1F5C7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128456", "Unicode hex": "1F5C8" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128457", "Unicode hex": "1F5C9" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128458", "Unicode hex": "1F5CA" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128459", "Unicode hex": "1F5CB" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128460", "Unicode hex": "1F5CC" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128461", "Unicode hex": "1F5CD" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128465", "Unicode hex": "1F5D1" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128468", "Unicode hex": "1F5D4" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128437", "Unicode hex": "1F5B5" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "128438", "Unicode hex": "1F5B6" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128439", "Unicode hex": "1F5B7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128440", "Unicode hex": "1F5B8" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128429", "Unicode hex": "1F5AD" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128431", "Unicode hex": "1F5AF" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128433", "Unicode hex": "1F5B1" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128402", "Unicode hex": "1F592" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128403", "Unicode hex": "1F593" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128408", "Unicode hex": "1F598" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128409", "Unicode hex": "1F599" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128410", "Unicode hex": "1F59A" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "128411", "Unicode hex": "1F59B" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128072", "Unicode hex": "1F448" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128073", "Unicode hex": "1F449" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128412", "Unicode hex": "1F59C" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "128413", "Unicode hex": "1F59D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "128414", "Unicode hex": "1F59E" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "128415", "Unicode hex": "1F59F" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "128416", "Unicode hex": "1F5A0" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128417", "Unicode hex": "1F5A1" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "128070", "Unicode hex": "1F446" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128071", "Unicode hex": "1F447" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128418", "Unicode hex": "1F5A2" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128419", "Unicode hex": "1F5A3" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128401", "Unicode hex": "1F591" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128500", "Unicode hex": "1F5F4" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "128504", "Unicode hex": "1F5F8" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "128501", "Unicode hex": "1F5F5" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9745", "Unicode hex": "2611" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "11197", "Unicode hex": "2BBD" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "9746", "Unicode hex": "2612" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "11198", "Unicode hex": "2BBE" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "11199", "Unicode hex": "2BBF" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128711", "Unicode hex": "1F6C7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10680", "Unicode hex": "29B8" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "128625", "Unicode hex": "1F671" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "128628", "Unicode hex": "1F674" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128626", "Unicode hex": "1F672" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128627", "Unicode hex": "1F673" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "8253", "Unicode hex": "203D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128633", "Unicode hex": "1F679" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128634", "Unicode hex": "1F67A" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "128635", "Unicode hex": "1F67B" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "128614", "Unicode hex": "1F666" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128612", "Unicode hex": "1F664" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "128613", "Unicode hex": "1F665" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128615", "Unicode hex": "1F667" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128602", "Unicode hex": "1F65A" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128600", "Unicode hex": "1F658" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "128601", "Unicode hex": "1F659" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128603", "Unicode hex": "1F65B" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9450", "Unicode hex": "24EA" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "9312", "Unicode hex": "2460" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "9313", "Unicode hex": "2461" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9314", "Unicode hex": "2462" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "9315", "Unicode hex": "2463" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9316", "Unicode hex": "2464" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "9317", "Unicode hex": "2465" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9318", "Unicode hex": "2466" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9319", "Unicode hex": "2467" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9320", "Unicode hex": "2468" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9321", "Unicode hex": "2469" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9471", "Unicode hex": "24FF" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "10102", "Unicode hex": "2776" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10103", "Unicode hex": "2777" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "10104", "Unicode hex": "2778" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10105", "Unicode hex": "2779" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "10106", "Unicode hex": "277A" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "10107", "Unicode hex": "277B" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "10108", "Unicode hex": "277C" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "10109", "Unicode hex": "277D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "10110", "Unicode hex": "277E" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "10111", "Unicode hex": "277F" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "9737", "Unicode hex": "2609" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "127765", "Unicode hex": "1F315" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "9789", "Unicode hex": "263D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "9790", "Unicode hex": "263E" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11839", "Unicode hex": "2E3F" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10013", "Unicode hex": "271D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "128327", "Unicode hex": "1F547" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "128348", "Unicode hex": "1F55C" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "128349", "Unicode hex": "1F55D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "128350", "Unicode hex": "1F55E" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "128351", "Unicode hex": "1F55F" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "128352", "Unicode hex": "1F560" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "128353", "Unicode hex": "1F561" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "128354", "Unicode hex": "1F562" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128355", "Unicode hex": "1F563" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128356", "Unicode hex": "1F564" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128357", "Unicode hex": "1F565" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128358", "Unicode hex": "1F566" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "128359", "Unicode hex": "1F567" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128616", "Unicode hex": "1F668" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128617", "Unicode hex": "1F669" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "8901", "Unicode hex": "22C5" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128900", "Unicode hex": "1F784" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "10625", "Unicode hex": "2981" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "9679", "Unicode hex": "25CF" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "9675", "Unicode hex": "25CB" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128901", "Unicode hex": "1F785" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128903", "Unicode hex": "1F787" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128905", "Unicode hex": "1F789" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "8857", "Unicode hex": "2299" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "10687", "Unicode hex": "29BF" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128908", "Unicode hex": "1F78C" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128909", "Unicode hex": "1F78D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "9726", "Unicode hex": "25FE" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "9632", "Unicode hex": "25A0" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "9633", "Unicode hex": "25A1" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128913", "Unicode hex": "1F791" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128914", "Unicode hex": "1F792" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128915", "Unicode hex": "1F793" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128916", "Unicode hex": "1F794" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9635", "Unicode hex": "25A3" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128917", "Unicode hex": "1F795" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128918", "Unicode hex": "1F796" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128919", "Unicode hex": "1F797" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128920", "Unicode hex": "1F798" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "11049", "Unicode hex": "2B29" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "11045", "Unicode hex": "2B25" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "9671", "Unicode hex": "25C7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "128922", "Unicode hex": "1F79A" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "9672", "Unicode hex": "25C8" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "128923", "Unicode hex": "1F79B" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128924", "Unicode hex": "1F79C" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "128925", "Unicode hex": "1F79D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128926", "Unicode hex": "1F79E" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "11050", "Unicode hex": "2B2A" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "11047", "Unicode hex": "2B27" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "9674", "Unicode hex": "25CA" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128928", "Unicode hex": "1F7A0" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "9686", "Unicode hex": "25D6" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "9687", "Unicode hex": "25D7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "11210", "Unicode hex": "2BCA" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "11211", "Unicode hex": "2BCB" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "11200", "Unicode hex": "2BC0" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "11201", "Unicode hex": "2BC1" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "11039", "Unicode hex": "2B1F" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "11202", "Unicode hex": "2BC2" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "11043", "Unicode hex": "2B23" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11042", "Unicode hex": "2B22" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11203", "Unicode hex": "2BC3" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11204", "Unicode hex": "2BC4" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128929", "Unicode hex": "1F7A1" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128930", "Unicode hex": "1F7A2" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128931", "Unicode hex": "1F7A3" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128932", "Unicode hex": "1F7A4" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128933", "Unicode hex": "1F7A5" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128934", "Unicode hex": "1F7A6" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128935", "Unicode hex": "1F7A7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128936", "Unicode hex": "1F7A8" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128937", "Unicode hex": "1F7A9" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128938", "Unicode hex": "1F7AA" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128939", "Unicode hex": "1F7AB" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128940", "Unicode hex": "1F7AC" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128941", "Unicode hex": "1F7AD" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128942", "Unicode hex": "1F7AE" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128943", "Unicode hex": "1F7AF" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "128944", "Unicode hex": "1F7B0" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "128945", "Unicode hex": "1F7B1" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "128946", "Unicode hex": "1F7B2" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "128947", "Unicode hex": "1F7B3" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "128948", "Unicode hex": "1F7B4" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "128949", "Unicode hex": "1F7B5" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "128950", "Unicode hex": "1F7B6" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "128951", "Unicode hex": "1F7B7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "128952", "Unicode hex": "1F7B8" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "128953", "Unicode hex": "1F7B9" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "128954", "Unicode hex": "1F7BA" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "128955", "Unicode hex": "1F7BB" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "128956", "Unicode hex": "1F7BC" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128957", "Unicode hex": "1F7BD" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128958", "Unicode hex": "1F7BE" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "128959", "Unicode hex": "1F7BF" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "128960", "Unicode hex": "1F7C0" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128962", "Unicode hex": "1F7C2" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128964", "Unicode hex": "1F7C4" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "128966", "Unicode hex": "1F7C6" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "128969", "Unicode hex": "1F7C9" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128970", "Unicode hex": "1F7CA" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "10038", "Unicode hex": "2736" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "128972", "Unicode hex": "1F7CC" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128974", "Unicode hex": "1F7CE" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128976", "Unicode hex": "1F7D0" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128978", "Unicode hex": "1F7D2" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "10041", "Unicode hex": "2739" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128963", "Unicode hex": "1F7C3" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128967", "Unicode hex": "1F7C7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "10031", "Unicode hex": "272F" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128973", "Unicode hex": "1F7CD" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128980", "Unicode hex": "1F7D4" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11212", "Unicode hex": "2BCC" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11213", "Unicode hex": "2BCD" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "8251", "Unicode hex": "203B" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "8258", "Unicode hex": "2042" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "11104", "Unicode hex": "2B60" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "11106", "Unicode hex": "2B62" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "11105", "Unicode hex": "2B61" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "11107", "Unicode hex": "2B63" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "11110", "Unicode hex": "2B66" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "11111", "Unicode hex": "2B67" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "11113", "Unicode hex": "2B69" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "11112", "Unicode hex": "2B68" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "11120", "Unicode hex": "2B70" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "11122", "Unicode hex": "2B72" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "11121", "Unicode hex": "2B71" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "11123", "Unicode hex": "2B73" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "11126", "Unicode hex": "2B76" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "11128", "Unicode hex": "2B78" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "11131", "Unicode hex": "2B7B" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "11133", "Unicode hex": "2B7D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "11108", "Unicode hex": "2B64" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "11109", "Unicode hex": "2B65" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "11114", "Unicode hex": "2B6A" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "11116", "Unicode hex": "2B6C" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "11115", "Unicode hex": "2B6B" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "11117", "Unicode hex": "2B6D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "11085", "Unicode hex": "2B4D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "11168", "Unicode hex": "2BA0" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "11169", "Unicode hex": "2BA1" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "11170", "Unicode hex": "2BA2" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "11171", "Unicode hex": "2BA3" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "11172", "Unicode hex": "2BA4" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "11173", "Unicode hex": "2BA5" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "11174", "Unicode hex": "2BA6" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "11175", "Unicode hex": "2BA7" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "11152", "Unicode hex": "2B90" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "11153", "Unicode hex": "2B91" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "11154", "Unicode hex": "2B92" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "11155", "Unicode hex": "2B93" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "11136", "Unicode hex": "2B80" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "11139", "Unicode hex": "2B83" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "11134", "Unicode hex": "2B7E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "11135", "Unicode hex": "2B7F" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "11140", "Unicode hex": "2B84" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "11142", "Unicode hex": "2B86" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "11141", "Unicode hex": "2B85" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "11143", "Unicode hex": "2B87" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "11151", "Unicode hex": "2B8F" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "11149", "Unicode hex": "2B8D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "11150", "Unicode hex": "2B8E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "11148", "Unicode hex": "2B8C" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "11118", "Unicode hex": "2B6E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "11119", "Unicode hex": "2B6F" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9099", "Unicode hex": "238B" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "8996", "Unicode hex": "2324" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "8963", "Unicode hex": "2303" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "8997", "Unicode hex": "2325" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "9251", "Unicode hex": "2423" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "9085", "Unicode hex": "237D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "8682", "Unicode hex": "21EA" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "11192", "Unicode hex": "2BB8" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "129184", "Unicode hex": "1F8A0" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "129185", "Unicode hex": "1F8A1" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "129186", "Unicode hex": "1F8A2" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "129187", "Unicode hex": "1F8A3" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "129188", "Unicode hex": "1F8A4" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "129189", "Unicode hex": "1F8A5" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "129190", "Unicode hex": "1F8A6" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "129191", "Unicode hex": "1F8A7" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "129192", "Unicode hex": "1F8A8" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "129193", "Unicode hex": "1F8A9" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "129194", "Unicode hex": "1F8AA" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "129195", "Unicode hex": "1F8AB" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "129104", "Unicode hex": "1F850" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "129106", "Unicode hex": "1F852" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "129105", "Unicode hex": "1F851" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "129107", "Unicode hex": "1F853" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "129108", "Unicode hex": "1F854" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "129109", "Unicode hex": "1F855" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "129111", "Unicode hex": "1F857" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "129110", "Unicode hex": "1F856" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "129112", "Unicode hex": "1F858" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "129113", "Unicode hex": "1F859" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9650", "Unicode hex": "25B2" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9660", "Unicode hex": "25BC" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9651", "Unicode hex": "25B3" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9661", "Unicode hex": "25BD" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9664", "Unicode hex": "25C0" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9654", "Unicode hex": "25B6" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "9665", "Unicode hex": "25C1" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9655", "Unicode hex": "25B7" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "9699", "Unicode hex": "25E3" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "9698", "Unicode hex": "25E2" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "9700", "Unicode hex": "25E4" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "9701", "Unicode hex": "25E5" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "128896", "Unicode hex": "1F780" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128898", "Unicode hex": "1F782" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128897", "Unicode hex": "1F781" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128899", "Unicode hex": "1F783" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "11205", "Unicode hex": "2BC5" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "11206", "Unicode hex": "2BC6" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "11207", "Unicode hex": "2BC7" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11208", "Unicode hex": "2BC8" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "11164", "Unicode hex": "2B9C" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "11166", "Unicode hex": "2B9E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "11165", "Unicode hex": "2B9D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "11167", "Unicode hex": "2B9F" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "129040", "Unicode hex": "1F810" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "129042", "Unicode hex": "1F812" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "129041", "Unicode hex": "1F811" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "129043", "Unicode hex": "1F813" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "129044", "Unicode hex": "1F814" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "129046", "Unicode hex": "1F816" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "129045", "Unicode hex": "1F815" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "129047", "Unicode hex": "1F817" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "129048", "Unicode hex": "1F818" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "129050", "Unicode hex": "1F81A" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "129049", "Unicode hex": "1F819" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "129051", "Unicode hex": "1F81B" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "129052", "Unicode hex": "1F81C" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "129054", "Unicode hex": "1F81E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "129053", "Unicode hex": "1F81D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "129055", "Unicode hex": "1F81F" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "129024", "Unicode hex": "1F800" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "129026", "Unicode hex": "1F802" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "129025", "Unicode hex": "1F801" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "129027", "Unicode hex": "1F803" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "129028", "Unicode hex": "1F804" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "129030", "Unicode hex": "1F806" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "129029", "Unicode hex": "1F805" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "129031", "Unicode hex": "1F807" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "129032", "Unicode hex": "1F808" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "129034", "Unicode hex": "1F80A" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "129033", "Unicode hex": "1F809" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "129035", "Unicode hex": "1F80B" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "129056", "Unicode hex": "1F820" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "129058", "Unicode hex": "1F822" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "129060", "Unicode hex": "1F824" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "129062", "Unicode hex": "1F826" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "129064", "Unicode hex": "1F828" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "129066", "Unicode hex": "1F82A" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "129068", "Unicode hex": "1F82C" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "129180", "Unicode hex": "1F89C" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "129181", "Unicode hex": "1F89D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "129182", "Unicode hex": "1F89E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "129183", "Unicode hex": "1F89F" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "129070", "Unicode hex": "1F82E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "129072", "Unicode hex": "1F830" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "129074", "Unicode hex": "1F832" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "129076", "Unicode hex": "1F834" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "129078", "Unicode hex": "1F836" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "129080", "Unicode hex": "1F838" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "129082", "Unicode hex": "1F83A" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "129081", "Unicode hex": "1F839" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "129083", "Unicode hex": "1F83B" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "129176", "Unicode hex": "1F898" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "129178", "Unicode hex": "1F89A" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "129177", "Unicode hex": "1F899" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "129179", "Unicode hex": "1F89B" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "129084", "Unicode hex": "1F83C" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "129086", "Unicode hex": "1F83E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "129085", "Unicode hex": "1F83D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "129087", "Unicode hex": "1F83F" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "129088", "Unicode hex": "1F840" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "129090", "Unicode hex": "1F842" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "129089", "Unicode hex": "1F841" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "129091", "Unicode hex": "1F843" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "129092", "Unicode hex": "1F844" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "129094", "Unicode hex": "1F846" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "129093", "Unicode hex": "1F845" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "129095", "Unicode hex": "1F847" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11176", "Unicode hex": "2BA8" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11177", "Unicode hex": "2BA9" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "11178", "Unicode hex": "2BAA" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "11179", "Unicode hex": "2BAB" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "11180", "Unicode hex": "2BAC" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "11181", "Unicode hex": "2BAD" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "11182", "Unicode hex": "2BAE" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "11183", "Unicode hex": "2BAF" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "129120", "Unicode hex": "1F860" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "129122", "Unicode hex": "1F862" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "129121", "Unicode hex": "1F861" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "129123", "Unicode hex": "1F863" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "129124", "Unicode hex": "1F864" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "129125", "Unicode hex": "1F865" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "129127", "Unicode hex": "1F867" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "129126", "Unicode hex": "1F866" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "129136", "Unicode hex": "1F870" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "129138", "Unicode hex": "1F872" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "129137", "Unicode hex": "1F871" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "129139", "Unicode hex": "1F873" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "129140", "Unicode hex": "1F874" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "129141", "Unicode hex": "1F875" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129143", "Unicode hex": "1F877" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129142", "Unicode hex": "1F876" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129152", "Unicode hex": "1F880" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129154", "Unicode hex": "1F882" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129153", "Unicode hex": "1F881" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129155", "Unicode hex": "1F883" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129156", "Unicode hex": "1F884" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129157", "Unicode hex": "1F885" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129159", "Unicode hex": "1F887" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129158", "Unicode hex": "1F886" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129168", "Unicode hex": "1F890" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129170", "Unicode hex": "1F892" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129169", "Unicode hex": "1F891" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129171", "Unicode hex": "1F893" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129172", "Unicode hex": "1F894" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129174", "Unicode hex": "1F896" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "129173", "Unicode hex": "1F895" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "129175", "Unicode hex": "1F897" }
];
TC.default = Uhe;
var Nhe = wt && wt.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(_l, "__esModule", { value: !0 });
_l.hex = _l.dec = _l.codePoint = void 0;
var Mhe = Nhe(TC), qL = {}, Bhe = String.fromCodePoint ? String.fromCodePoint : zhe;
for (var X2 = 0, dI = Mhe.default; X2 < dI.length; X2++) {
  var Y2 = dI[X2], fI = parseInt(Y2["Unicode dec"], 10), Lhe = {
    codePoint: fI,
    string: Bhe(fI)
  };
  qL[Y2["Typeface name"].toUpperCase() + "_" + Y2["Dingbat dec"]] = Lhe;
}
function DC(t, e) {
  return qL[t.toUpperCase() + "_" + e];
}
_l.codePoint = DC;
function Phe(t, e) {
  return DC(t, parseInt(e, 10));
}
_l.dec = Phe;
function Whe(t, e) {
  return DC(t, parseInt(e, 16));
}
_l.hex = Whe;
function zhe(t) {
  if (t <= 65535)
    return String.fromCharCode(t);
  var e = Math.floor((t - 65536) / 1024) + 55296, n = (t - 65536) % 1024 + 56320;
  return String.fromCharCode(e, n);
}
var EC = {};
EC.uriToZipEntryName = $he;
EC.replaceFragment = Hhe;
function $he(t, e) {
  return e.charAt(0) === "/" ? e.substr(1) : t + "/" + e;
}
function Hhe(t, e) {
  var n = t.indexOf("#");
  return n !== -1 && (t = t.substring(0, n)), t + "#" + e;
}
SC.createBodyReader = Vhe;
SC._readNumberingProperties = KL;
var hI = _l, Ji = Rn, yn = At, GL = Ri.Result, Va = Ri.warning, jhe = ys, pI = EC;
function Vhe(t) {
  return {
    readXmlElement: function(e) {
      return new mI(t).readXmlElement(e);
    },
    readXmlElements: function(e) {
      return new mI(t).readXmlElements(e);
    }
  };
}
function mI(t) {
  var e = [], n = [], r = [], i = t.relationships, o = t.contentTypes, a = t.docxFile, s = t.files, l = t.numbering, c = t.styles;
  function u(j) {
    var Q = j.map(d);
    return gI(Q);
  }
  function d(j) {
    if (j.type === "element") {
      var Q = ee[j.name];
      if (Q)
        return Q(j);
      if (!Object.prototype.hasOwnProperty.call(Ghe, j.name)) {
        var De = Va("An unrecognised element was ignored: " + j.name);
        return hp([De]);
      }
    }
    return pp();
  }
  function f(j) {
    return x(j).map(function(Q) {
      return {
        type: "paragraphProperties",
        styleId: Q.styleId,
        styleName: Q.name,
        alignment: j.firstOrEmpty("w:jc").attributes["w:val"],
        numbering: KL(Q.styleId, j.firstOrEmpty("w:numPr"), l),
        indent: p(j.firstOrEmpty("w:ind"))
      };
    });
  }
  function p(j) {
    return {
      start: j.attributes["w:start"] || j.attributes["w:left"],
      end: j.attributes["w:end"] || j.attributes["w:right"],
      firstLine: j.attributes["w:firstLine"],
      hanging: j.attributes["w:hanging"]
    };
  }
  function m(j) {
    return k(j).map(function(Q) {
      var De = j.firstOrEmpty("w:sz").attributes["w:val"], T = /^[0-9]+$/.test(De) ? parseInt(De, 10) / 2 : null;
      return {
        type: "runProperties",
        styleId: Q.styleId,
        styleName: Q.name,
        verticalAlignment: j.firstOrEmpty("w:vertAlign").attributes["w:val"],
        font: j.firstOrEmpty("w:rFonts").attributes["w:ascii"],
        fontSize: T,
        isBold: b(j.first("w:b")),
        isUnderline: g(j.first("w:u")),
        isItalic: b(j.first("w:i")),
        isStrikethrough: b(j.first("w:strike")),
        isAllCaps: b(j.first("w:caps")),
        isSmallCaps: b(j.first("w:smallCaps")),
        highlight: w(j.firstOrEmpty("w:highlight").attributes["w:val"])
      };
    });
  }
  function g(j) {
    if (j) {
      var Q = j.attributes["w:val"];
      return Q !== void 0 && Q !== "false" && Q !== "0" && Q !== "none";
    } else
      return !1;
  }
  function b(j) {
    if (j) {
      var Q = j.attributes["w:val"];
      return Q !== "false" && Q !== "0";
    } else
      return !1;
  }
  function y(j) {
    return j !== "false" && j !== "0";
  }
  function w(j) {
    return !j || j === "none" ? null : j;
  }
  function x(j) {
    return U(j, "w:pStyle", "Paragraph", c.findParagraphStyleById);
  }
  function k(j) {
    return U(j, "w:rStyle", "Run", c.findCharacterStyleById);
  }
  function A(j) {
    return U(j, "w:tblStyle", "Table", c.findTableStyleById);
  }
  function U(j, Q, De, T) {
    var pe = [], M = j.first(Q), _ = null, S = null;
    if (M && (_ = M.attributes["w:val"], _)) {
      var O = T(_);
      O ? S = O.name : pe.push(ye(De, _));
    }
    return xy({ styleId: _, name: S }, pe);
  }
  function P(j) {
    var Q = j.attributes["w:fldCharType"];
    if (Q === "begin")
      e.push({ type: "begin", fldChar: j }), n = [];
    else if (Q === "end") {
      var De = e.pop();
      if (De.type === "begin" && (De = I(De)), De.type === "checkbox")
        return ni(yn.checkbox({
          checked: De.checked
        }));
    } else if (Q === "separate") {
      var T = e.pop(), pe = I(T);
      e.push(pe);
    }
    return pp();
  }
  function V() {
    var j = Ji.last(e.filter(function(Q) {
      return Q.type === "hyperlink";
    }));
    return j ? j.options : null;
  }
  function I(j) {
    return le(
      n.join(""),
      j.type === "begin" ? j.fldChar : jhe.emptyElement
    );
  }
  function le(j, Q) {
    var De = /\s*HYPERLINK "(.*)"/.exec(j);
    if (De)
      return { type: "hyperlink", options: { href: De[1] } };
    var T = /\s*HYPERLINK\s+\\l\s+"(.*)"/.exec(j);
    if (T)
      return { type: "hyperlink", options: { anchor: T[1] } };
    var pe = /\s*FORMCHECKBOX\s*/.exec(j);
    if (pe) {
      var M = Q.firstOrEmpty("w:ffData").firstOrEmpty("w:checkBox"), _ = M.first("w:checked"), S = _ == null ? b(M.first("w:default")) : b(_);
      return { type: "checkbox", checked: S };
    }
    return { type: "unknown" };
  }
  function be(j) {
    return n.push(j.text()), pp();
  }
  function F(j) {
    var Q = j.attributes["w:font"], De = j.attributes["w:char"], T = hI.hex(Q, De);
    return T == null && /^F0..$/.test(De) && (T = hI.hex(Q, De.substring(2))), T == null ? hp([Va(
      "A w:sym element with an unsupported character was ignored: char " + De + " in font " + Q
    )]) : ni(new yn.Text(T.string));
  }
  function G(j) {
    return function(Q) {
      var De = Q.attributes["w:id"];
      return ni(new yn.NoteReference({
        noteType: j,
        noteId: De
      }));
    };
  }
  function C(j) {
    return ni(yn.commentReference({
      commentId: j.attributes["w:id"]
    }));
  }
  function ie(j) {
    return u(j.children);
  }
  var ee = {
    "w:p": function(j) {
      var Q = j.firstOrEmpty("w:pPr"), De = !!Q.firstOrEmpty("w:rPr").first("w:del");
      if (De)
        return j.children.forEach(function(pe) {
          r.push(pe);
        }), pp();
      var T = j.children;
      return r.length > 0 && (T = r.concat(T), r = []), ur.map(
        f(Q),
        u(T),
        function(pe, M) {
          return new yn.Paragraph(M, pe);
        }
      ).insertExtra();
    },
    "w:r": function(j) {
      return ur.map(
        m(j.firstOrEmpty("w:rPr")),
        u(j.children),
        function(Q, De) {
          var T = V();
          return T !== null && (De = [new yn.Hyperlink(De, T)]), new yn.Run(De, Q);
        }
      );
    },
    "w:fldChar": P,
    "w:instrText": be,
    "w:t": function(j) {
      return ni(new yn.Text(j.text()));
    },
    "w:tab": function(j) {
      return ni(new yn.Tab());
    },
    "w:noBreakHyphen": function() {
      return ni(new yn.Text("‑"));
    },
    "w:softHyphen": function(j) {
      return ni(new yn.Text("­"));
    },
    "w:sym": F,
    "w:hyperlink": function(j) {
      var Q = j.attributes["r:id"], De = j.attributes["w:anchor"];
      return u(j.children).map(function(T) {
        function pe(_) {
          var S = j.attributes["w:tgtFrame"] || null;
          return new yn.Hyperlink(
            T,
            Ji.extend({ targetFrame: S }, _)
          );
        }
        if (Q) {
          var M = i.findTargetByRelationshipId(Q);
          return De && (M = pI.replaceFragment(M, De)), pe({ href: M });
        } else return De ? pe({ anchor: De }) : T;
      });
    },
    "w:tbl": Z,
    "w:tr": te,
    "w:tc": _e,
    "w:footnoteReference": G("footnote"),
    "w:endnoteReference": G("endnote"),
    "w:commentReference": C,
    "w:br": function(j) {
      var Q = j.attributes["w:type"];
      return Q == null || Q === "textWrapping" ? ni(yn.lineBreak) : Q === "page" ? ni(yn.pageBreak) : Q === "column" ? ni(yn.columnBreak) : hp([Va("Unsupported break type: " + Q)]);
    },
    "w:bookmarkStart": function(j) {
      var Q = j.attributes["w:name"];
      return Q === "_GoBack" ? pp() : ni(new yn.BookmarkStart({ name: Q }));
    },
    "mc:AlternateContent": function(j) {
      return ie(j.first("mc:Fallback"));
    },
    "w:sdt": function(j) {
      var Q = j.firstOrEmpty("w:sdtPr").first("wordml:checkbox");
      if (Q) {
        var De = Q.first("wordml:checked"), T = !!De && y(
          De.attributes["wordml:val"]
        );
        return ni(yn.checkbox({
          checked: T
        }));
      } else
        return u(j.firstOrEmpty("w:sdtContent").children);
    },
    "w:ins": ie,
    "w:object": ie,
    "w:smartTag": ie,
    "w:drawing": ie,
    "w:pict": function(j) {
      return ie(j).toExtra();
    },
    "v:roundrect": ie,
    "v:shape": ie,
    "v:textbox": ie,
    "w:txbxContent": ie,
    "wp:inline": ce,
    "wp:anchor": ce,
    "v:imagedata": H,
    "v:group": ie,
    "v:rect": ie
  };
  return {
    readXmlElement: d,
    readXmlElements: u
  };
  function Z(j) {
    var Q = oe(j.firstOrEmpty("w:tblPr"));
    return u(j.children).flatMap(N).flatMap(function(De) {
      return Q.map(function(T) {
        return yn.Table(De, T);
      });
    });
  }
  function oe(j) {
    return A(j).map(function(Q) {
      return {
        styleId: Q.styleId,
        styleName: Q.name
      };
    });
  }
  function te(j) {
    var Q = j.firstOrEmpty("w:trPr"), De = !!Q.first("w:tblHeader");
    return u(j.children).map(function(T) {
      return yn.TableRow(T, { isHeader: De });
    });
  }
  function _e(j) {
    return u(j.children).map(function(Q) {
      var De = j.firstOrEmpty("w:tcPr"), T = De.firstOrEmpty("w:gridSpan").attributes["w:val"], pe = T ? parseInt(T, 10) : 1, M = yn.TableCell(Q, { colSpan: pe });
      return M._vMerge = q(De), M;
    });
  }
  function q(j) {
    var Q = j.first("w:vMerge");
    if (Q) {
      var De = Q.attributes["w:val"];
      return De === "continue" || !De;
    } else
      return null;
  }
  function N(j) {
    var Q = Ji.any(j, function(pe) {
      return pe.type !== yn.types.tableRow;
    });
    if (Q)
      return xy(j, [Va(
        "unexpected non-row element in table, cell merging may be incorrect"
      )]);
    var De = Ji.any(j, function(pe) {
      return Ji.any(pe.children, function(M) {
        return M.type !== yn.types.tableCell;
      });
    });
    if (De)
      return xy(j, [Va(
        "unexpected non-cell element in table row, cell merging may be incorrect"
      )]);
    var T = {};
    return j.forEach(function(pe) {
      var M = 0;
      pe.children.forEach(function(_) {
        _._vMerge && T[M] ? T[M].rowSpan++ : (T[M] = _, _._vMerge = !1), M += _.colSpan;
      });
    }), j.forEach(function(pe) {
      pe.children = pe.children.filter(function(M) {
        return !M._vMerge;
      }), pe.children.forEach(function(M) {
        delete M._vMerge;
      });
    }), ni(j);
  }
  function ce(j) {
    var Q = j.getElementsByTagName("a:graphic").getElementsByTagName("a:graphicData").getElementsByTagName("pic:pic").getElementsByTagName("pic:blipFill").getElementsByTagName("a:blip");
    return gI(Q.map(me.bind(null, j)));
  }
  function me(j, Q) {
    var De = j.first("wp:docPr").attributes, T = ve(De.descr) ? De.title : De.descr, pe = he(Q);
    return pe === null ? hp([Va("Could not find image file for a:blip element")]) : we(pe, T);
  }
  function ve(j) {
    return j == null || /^\s*$/.test(j);
  }
  function he(j) {
    var Q = j.attributes["r:embed"], De = j.attributes["r:link"];
    if (Q)
      return W(Q);
    if (De) {
      var T = i.findTargetByRelationshipId(De);
      return {
        path: T,
        read: s.read.bind(s, T)
      };
    } else
      return null;
  }
  function H(j) {
    var Q = j.attributes["r:id"];
    return Q ? we(
      W(Q),
      j.attributes["o:title"]
    ) : hp([Va("A v:imagedata element without a relationship ID was ignored")]);
  }
  function W(j) {
    var Q = pI.uriToZipEntryName("word", i.findTargetByRelationshipId(j));
    return {
      path: Q,
      read: a.read.bind(a, Q)
    };
  }
  function we(j, Q) {
    var De = o.findContentType(j.path), T = yn.Image({
      readImage: j.read,
      altText: Q,
      contentType: De
    }), pe = qhe[De] ? [] : Va("Image of type " + De + " is unlikely to display in web browsers");
    return xy(T, pe);
  }
  function ye(j, Q) {
    return Va(
      j + " style with ID " + Q + " was referenced but not defined in the document"
    );
  }
}
function KL(t, e, n) {
  var r = e.firstOrEmpty("w:ilvl").attributes["w:val"], i = e.firstOrEmpty("w:numId").attributes["w:val"];
  if (r !== void 0 && i !== void 0)
    return n.findLevel(i, r);
  if (t != null) {
    var o = n.findLevelByParagraphStyleId(t);
    if (o != null)
      return o;
  }
  return null;
}
var qhe = {
  "image/png": !0,
  "image/gif": !0,
  "image/jpeg": !0,
  "image/svg+xml": !0,
  "image/tiff": !0
}, Ghe = {
  "office-word:wrap": !0,
  "v:shadow": !0,
  "v:shapetype": !0,
  "w:annotationRef": !0,
  "w:bookmarkEnd": !0,
  "w:sectPr": !0,
  "w:proofErr": !0,
  "w:lastRenderedPageBreak": !0,
  "w:commentRangeStart": !0,
  "w:commentRangeEnd": !0,
  "w:del": !0,
  "w:footnoteRef": !0,
  "w:endnoteRef": !0,
  "w:pPr": !0,
  "w:rPr": !0,
  "w:tblPr": !0,
  "w:tblGrid": !0,
  "w:trPr": !0,
  "w:tcPr": !0
};
function hp(t) {
  return new ur(null, null, t);
}
function pp() {
  return new ur(null);
}
function ni(t) {
  return new ur(t);
}
function xy(t, e) {
  return new ur(t, null, e);
}
function ur(t, e, n) {
  this.value = t || [], this.extra = e || [], this._result = new GL({
    element: this.value,
    extra: e
  }, n), this.messages = this._result.messages;
}
ur.prototype.toExtra = function() {
  return new ur(null, f0(this.extra, this.value), this.messages);
};
ur.prototype.insertExtra = function() {
  var t = this.extra;
  return t && t.length ? new ur(f0(this.value, t), null, this.messages) : this;
};
ur.prototype.map = function(t) {
  var e = this._result.map(function(n) {
    return t(n.element);
  });
  return new ur(e.value, this.extra, e.messages);
};
ur.prototype.flatMap = function(t) {
  var e = this._result.flatMap(function(n) {
    return t(n.element)._result;
  });
  return new ur(e.value.element, f0(this.extra, e.value.extra), e.messages);
};
ur.map = function(t, e, n) {
  return new ur(
    n(t.value, e.value),
    f0(t.extra, e.extra),
    t.messages.concat(e.messages)
  );
};
function gI(t) {
  var e = GL.combine(Ji.pluck(t, "_result"));
  return new ur(
    Ji.flatten(Ji.pluck(e.value, "element")),
    Ji.filter(Ji.flatten(Ji.pluck(e.value, "extra")), Khe),
    e.messages
  );
}
function f0(t, e) {
  return Ji.flatten([t, e]);
}
function Khe(t) {
  return t;
}
var XL = {};
XL.DocumentXmlReader = Jhe;
var Xhe = At, Yhe = Ri.Result;
function Jhe(t) {
  var e = t.bodyReader;
  function n(r) {
    var i = r.first("w:body");
    if (i == null)
      throw new Error("Could not find the body element: are you sure this is a docx file?");
    var o = e.readXmlElements(i.children).map(function(a) {
      return new Xhe.Document(a, {
        notes: t.notes,
        comments: t.comments
      });
    });
    return new Yhe(o.value, o.messages);
  }
  return {
    convertXmlToDocument: n
  };
}
var h0 = {};
h0.readRelationships = Zhe;
h0.defaultValue = new CC([]);
h0.Relationships = CC;
function Zhe(t) {
  var e = [];
  return t.children.forEach(function(n) {
    if (n.name === "relationships:Relationship") {
      var r = {
        relationshipId: n.attributes.Id,
        target: n.attributes.Target,
        type: n.attributes.Type
      };
      e.push(r);
    }
  }), new CC(e);
}
function CC(t) {
  var e = {};
  t.forEach(function(r) {
    e[r.relationshipId] = r.target;
  });
  var n = {};
  return t.forEach(function(r) {
    n[r.type] || (n[r.type] = []), n[r.type].push(r.target);
  }), {
    findTargetByRelationshipId: function(r) {
      return e[r];
    },
    findTargetsByType: function(r) {
      return n[r] || [];
    }
  };
}
var kC = {};
kC.readContentTypesFromXml = epe;
var Qhe = {
  png: "png",
  gif: "gif",
  jpeg: "jpeg",
  jpg: "jpeg",
  tif: "tiff",
  tiff: "tiff",
  bmp: "bmp"
};
kC.defaultContentTypes = YL({}, {});
function epe(t) {
  var e = {}, n = {};
  return t.children.forEach(function(r) {
    if (r.name === "content-types:Default" && (e[r.attributes.Extension] = r.attributes.ContentType), r.name === "content-types:Override") {
      var i = r.attributes.PartName;
      i.charAt(0) === "/" && (i = i.substring(1)), n[i] = r.attributes.ContentType;
    }
  }), YL(n, e);
}
function YL(t, e) {
  return {
    findContentType: function(n) {
      var r = t[n];
      if (r)
        return r;
      var i = n.split("."), o = i[i.length - 1];
      if (e.hasOwnProperty(o))
        return e[o];
      var a = Qhe[o.toLowerCase()];
      return a ? "image/" + a : null;
    }
  };
}
var p0 = {}, _y = Rn;
p0.readNumberingXml = tpe;
p0.Numbering = AC;
p0.defaultNumbering = new AC({}, {});
function AC(t, e, n) {
  var r = _y.flatten(_y.values(e).map(function(s) {
    return _y.values(s.levels);
  })), i = _y.indexBy(
    r.filter(function(s) {
      return s.paragraphStyleId != null;
    }),
    "paragraphStyleId"
  );
  function o(s, l) {
    var c = t[s];
    if (c) {
      var u = e[c.abstractNumId];
      if (u) {
        if (u.numStyleLink == null)
          return e[c.abstractNumId].levels[l];
        var d = n.findNumberingStyleById(u.numStyleLink);
        return o(d.numId, l);
      } else return null;
    } else
      return null;
  }
  function a(s) {
    return i[s] || null;
  }
  return {
    findLevel: o,
    findLevelByParagraphStyleId: a
  };
}
function tpe(t, e) {
  if (!e || !e.styles)
    throw new Error("styles is missing");
  var n = npe(t), r = ipe(t);
  return new AC(r, n, e.styles);
}
function npe(t) {
  var e = {};
  return t.getElementsByTagName("w:abstractNum").forEach(function(n) {
    var r = n.attributes["w:abstractNumId"];
    e[r] = rpe(n);
  }), e;
}
function rpe(t) {
  var e = {};
  t.getElementsByTagName("w:lvl").forEach(function(r) {
    var i = r.attributes["w:ilvl"], o = r.firstOrEmpty("w:numFmt").attributes["w:val"], a = r.firstOrEmpty("w:pStyle").attributes["w:val"];
    e[i] = {
      isOrdered: o !== "bullet",
      level: i,
      paragraphStyleId: a
    };
  });
  var n = t.firstOrEmpty("w:numStyleLink").attributes["w:val"];
  return { levels: e, numStyleLink: n };
}
function ipe(t) {
  var e = {};
  return t.getElementsByTagName("w:num").forEach(function(n) {
    var r = n.attributes["w:numId"], i = n.first("w:abstractNumId").attributes["w:val"];
    e[r] = { abstractNumId: i };
  }), e;
}
var m0 = {};
m0.readStylesXml = ope;
m0.Styles = Rm;
m0.defaultStyles = new Rm({}, {});
function Rm(t, e, n, r) {
  return {
    findParagraphStyleById: function(i) {
      return t[i];
    },
    findCharacterStyleById: function(i) {
      return e[i];
    },
    findTableStyleById: function(i) {
      return n[i];
    },
    findNumberingStyleById: function(i) {
      return r[i];
    }
  };
}
Rm.EMPTY = new Rm({}, {}, {}, {});
function ope(t) {
  var e = {}, n = {}, r = {}, i = {}, o = {
    paragraph: e,
    character: n,
    table: r
  };
  return t.getElementsByTagName("w:style").forEach(function(a) {
    var s = ape(a);
    if (s.type === "numbering")
      i[s.styleId] = lpe(a);
    else {
      var l = o[s.type];
      l && (l[s.styleId] = s);
    }
  }), new Rm(e, n, r, i);
}
function ape(t) {
  var e = t.attributes["w:type"], n = t.attributes["w:styleId"], r = spe(t);
  return { type: e, styleId: n, name: r };
}
function spe(t) {
  var e = t.first("w:name");
  return e ? e.attributes["w:val"] : null;
}
function lpe(t) {
  var e = t.firstOrEmpty("w:pPr").firstOrEmpty("w:numPr").firstOrEmpty("w:numId").attributes["w:val"];
  return { numId: e };
}
var RC = {}, cpe = At, upe = Ri.Result;
RC.createFootnotesReader = JL.bind(wt, "footnote");
RC.createEndnotesReader = JL.bind(wt, "endnote");
function JL(t, e) {
  function n(o) {
    return upe.combine(o.getElementsByTagName("w:" + t).filter(r).map(i));
  }
  function r(o) {
    var a = o.attributes["w:type"];
    return a !== "continuationSeparator" && a !== "separator";
  }
  function i(o) {
    var a = o.attributes["w:id"];
    return e.readXmlElements(o.children).map(function(s) {
      return cpe.Note({ noteType: t, noteId: a, body: s });
    });
  }
  return n;
}
var ZL = {}, dpe = At, fpe = Ri.Result;
function hpe(t) {
  function e(r) {
    return fpe.combine(r.getElementsByTagName("w:comment").map(n));
  }
  function n(r) {
    var i = r.attributes["w:id"];
    function o(a) {
      return (r.attributes[a] || "").trim() || null;
    }
    return t.readXmlElements(r.children).map(function(a) {
      return dpe.comment({
        commentId: i,
        body: a,
        authorName: o("w:author"),
        authorInitials: o("w:initials")
      });
    });
  }
  return e;
}
ZL.createCommentsReader = hpe;
var QL = {}, ppe = Zn;
QL.Files = mpe;
function mpe() {
  function t(e) {
    return ppe.reject(new Error("could not open external image: '" + e + `'
cannot open linked files from a web browser`));
  }
  return {
    read: t
  };
}
aC.read = xpe;
aC._findPartPaths = t9;
var gpe = Zn, ype = At, J2 = Ri.Result, Wv = Xm, e9 = cC.readXmlFromZipFile, bpe = SC.createBodyReader, vpe = XL.DocumentXmlReader, Lf = h0, yI = kC, bI = p0, vI = m0, wI = RC, wpe = ZL, xI = QL.Files;
function xpe(t, e) {
  return e = e || {}, gpe.props({
    contentTypes: Spe(t),
    partPaths: t9(t),
    docxFile: t,
    files: e.path ? xI.relativeToFile(e.path) : new xI(null)
  }).also(function(n) {
    return {
      styles: Dpe(t, n.partPaths.styles)
    };
  }).also(function(n) {
    return {
      numbering: Tpe(t, n.partPaths.numbering, n.styles)
    };
  }).also(function(n) {
    return {
      footnotes: Sy(n.partPaths.footnotes, n, function(r, i) {
        return i ? wI.createFootnotesReader(r)(i) : new J2([]);
      }),
      endnotes: Sy(n.partPaths.endnotes, n, function(r, i) {
        return i ? wI.createEndnotesReader(r)(i) : new J2([]);
      }),
      comments: Sy(n.partPaths.comments, n, function(r, i) {
        return i ? wpe.createCommentsReader(r)(i) : new J2([]);
      })
    };
  }).also(function(n) {
    return {
      notes: n.footnotes.flatMap(function(r) {
        return n.endnotes.map(function(i) {
          return new ype.Notes(r.concat(i));
        });
      })
    };
  }).then(function(n) {
    return Sy(n.partPaths.mainDocument, n, function(r, i) {
      return n.notes.flatMap(function(o) {
        return n.comments.flatMap(function(a) {
          var s = new vpe({
            bodyReader: r,
            notes: o,
            comments: a
          });
          return s.convertXmlToDocument(i);
        });
      });
    });
  });
}
function t9(t) {
  return Epe(t).then(function(e) {
    var n = _I({
      docxFile: t,
      relationships: e,
      relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
      basePath: "",
      fallbackPath: "word/document.xml"
    });
    if (!t.exists(n))
      throw new Error("Could not find main document part. Are you sure this is a valid .docx file?");
    return oh({
      filename: n9(n),
      readElement: Lf.readRelationships,
      defaultValue: Lf.defaultValue
    })(t).then(function(r) {
      function i(o) {
        return _I({
          docxFile: t,
          relationships: r,
          relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/" + o,
          basePath: Wv.splitPath(n).dirname,
          fallbackPath: "word/" + o + ".xml"
        });
      }
      return {
        mainDocument: n,
        comments: i("comments"),
        endnotes: i("endnotes"),
        footnotes: i("footnotes"),
        numbering: i("numbering"),
        styles: i("styles")
      };
    });
  });
}
function _I(t) {
  var e = t.docxFile, n = t.relationships, r = t.relationshipType, i = t.basePath, o = t.fallbackPath, a = n.findTargetsByType(r), s = a.map(function(c) {
    return _pe(Wv.joinPath(i, c), "/");
  }), l = s.filter(function(c) {
    return e.exists(c);
  });
  return l.length === 0 ? o : l[0];
}
function _pe(t, e) {
  return t.substring(0, e.length) === e ? t.substring(e.length) : t;
}
function oh(t) {
  return function(e) {
    return e9(e, t.filename).then(function(n) {
      return n ? t.readElement(n) : t.defaultValue;
    });
  };
}
function Sy(t, e, n) {
  var r = oh({
    filename: n9(t),
    readElement: Lf.readRelationships,
    defaultValue: Lf.defaultValue
  });
  return r(e.docxFile).then(function(i) {
    var o = new bpe({
      relationships: i,
      contentTypes: e.contentTypes,
      docxFile: e.docxFile,
      numbering: e.numbering,
      styles: e.styles,
      files: e.files
    });
    return e9(e.docxFile, t).then(function(a) {
      return n(o, a);
    });
  });
}
function n9(t) {
  var e = Wv.splitPath(t);
  return Wv.joinPath(e.dirname, "_rels", e.basename + ".rels");
}
var Spe = oh({
  filename: "[Content_Types].xml",
  readElement: yI.readContentTypesFromXml,
  defaultValue: yI.defaultContentTypes
});
function Tpe(t, e, n) {
  return oh({
    filename: e,
    readElement: function(r) {
      return bI.readNumberingXml(r, { styles: n });
    },
    defaultValue: bI.defaultNumbering
  })(t);
}
function Dpe(t, e) {
  return oh({
    filename: e,
    readElement: vI.readStylesXml,
    defaultValue: vI.defaultStyles
  })(t);
}
var Epe = oh({
  filename: "_rels/.rels",
  readElement: Lf.readRelationships,
  defaultValue: Lf.defaultValue
}), IC = {}, Cpe = Rn, kpe = Zn, Im = ys;
IC.writeStyleMap = Rpe;
IC.readStyleMap = Fpe;
var Ape = "http://schemas.zwobble.org/mammoth/style-map", zv = "mammoth/style-map", r9 = "/" + zv;
function Rpe(t, e) {
  return t.write(zv, e), Ipe(t).then(function() {
    return Ope(t);
  });
}
function Ipe(t) {
  var e = "word/_rels/document.xml.rels", n = "http://schemas.openxmlformats.org/package/2006/relationships", r = "{" + n + "}Relationship";
  return t.read(e, "utf8").then(Im.readString).then(function(i) {
    var o = i.children;
    i9(o, r, "Id", {
      Id: "rMammothStyleMap",
      Type: Ape,
      Target: r9
    });
    var a = { "": n };
    return t.write(e, Im.writeString(i, a));
  });
}
function Ope(t) {
  var e = "[Content_Types].xml", n = "http://schemas.openxmlformats.org/package/2006/content-types", r = "{" + n + "}Override";
  return t.read(e, "utf8").then(Im.readString).then(function(i) {
    var o = i.children;
    i9(o, r, "PartName", {
      PartName: r9,
      ContentType: "text/prs.mammoth.style-map"
    });
    var a = { "": n };
    return t.write(e, Im.writeString(i, a));
  });
}
function i9(t, e, n, r) {
  var i = Cpe.find(t, function(o) {
    return o.name === e && o.attributes[n] === r[n];
  });
  i ? i.attributes = r : t.push(Im.element(e, r));
}
function Fpe(t) {
  return t.exists(zv) ? t.read(zv, "utf8") : kpe.resolve(null);
}
var OC = {}, Ec = {}, qa = {}, tl = {}, SI;
function o9() {
  if (SI) return tl;
  SI = 1;
  var t = y0();
  function e(l, c, u) {
    return r(
      t.element(l, c, { fresh: !1 }),
      u
    );
  }
  function n(l, c, u) {
    var d = t.element(l, c, { fresh: !0 });
    return r(d, u);
  }
  function r(l, c) {
    return {
      type: "element",
      tag: l,
      children: c || []
    };
  }
  function i(l) {
    return {
      type: "text",
      value: l
    };
  }
  var o = {
    type: "forceWrite"
  };
  tl.freshElement = n, tl.nonFreshElement = e, tl.elementWithTag = r, tl.text = i, tl.forceWrite = o;
  var a = {
    br: !0,
    hr: !0,
    img: !0,
    input: !0
  };
  function s(l) {
    return l.children.length === 0 && a[l.tag.tagName];
  }
  return tl.isVoidElement = s, tl;
}
var Z2, TI;
function Upe() {
  if (TI) return Z2;
  TI = 1;
  var t = Rn, e = o9();
  function n(g) {
    return r(c(g));
  }
  function r(g) {
    var b = [];
    return g.map(i).forEach(function(y) {
      l(b, y);
    }), b;
  }
  function i(g) {
    return o[g.type](g);
  }
  var o = {
    element: a,
    text: s,
    forceWrite: s
  };
  function a(g) {
    return e.elementWithTag(g.tag, r(g.children));
  }
  function s(g) {
    return g;
  }
  function l(g, b) {
    var y = g[g.length - 1];
    b.type === "element" && !b.tag.fresh && y && y.type === "element" && b.tag.matchesElement(y.tag) ? (b.tag.separator && l(y.children, e.text(b.tag.separator)), b.children.forEach(function(w) {
      l(y.children, w);
    })) : g.push(b);
  }
  function c(g) {
    return u(g, function(b) {
      return d[b.type](b);
    });
  }
  function u(g, b) {
    return t.flatten(t.map(g, b), !0);
  }
  var d = {
    element: p,
    text: m,
    forceWrite: f
  };
  function f(g) {
    return [g];
  }
  function p(g) {
    var b = c(g.children);
    return b.length === 0 && !e.isVoidElement(g) ? [] : [e.elementWithTag(g.tag, b)];
  }
  function m(g) {
    return g.value.length === 0 ? [] : [g];
  }
  return Z2 = n, Z2;
}
var DI;
function g0() {
  if (DI) return qa;
  DI = 1;
  var t = o9();
  qa.freshElement = t.freshElement, qa.nonFreshElement = t.nonFreshElement, qa.elementWithTag = t.elementWithTag, qa.text = t.text, qa.forceWrite = t.forceWrite, qa.simplify = Upe();
  function e(a, s) {
    s.forEach(function(l) {
      n(a, l);
    });
  }
  function n(a, s) {
    r[s.type](a, s);
  }
  var r = {
    element: i,
    text: o,
    forceWrite: function() {
    }
  };
  function i(a, s) {
    t.isVoidElement(s) ? a.selfClosing(s.tag.tagName, s.tag.attributes) : (a.open(s.tag.tagName, s.tag.attributes), e(a, s.children), a.close(s.tag.tagName));
  }
  function o(a, s) {
    a.text(s.value);
  }
  return qa.write = e, qa;
}
var EI;
function y0() {
  if (EI) return Ec;
  EI = 1;
  var t = Rn, e = g0();
  Ec.topLevelElement = n, Ec.elements = r, Ec.element = o;
  function n(s, l) {
    return r([o(s, l, { fresh: !0 })]);
  }
  function r(s) {
    return new i(s.map(function(l) {
      return t.isString(l) ? o(l) : l;
    }));
  }
  function i(s) {
    this._elements = s;
  }
  i.prototype.wrap = function(l) {
    for (var c = l(), u = this._elements.length - 1; u >= 0; u--)
      c = this._elements[u].wrapNodes(c);
    return c;
  };
  function o(s, l, c) {
    return c = c || {}, new a(s, l, c);
  }
  function a(s, l, c) {
    var u = {};
    t.isArray(s) ? (s.forEach(function(d) {
      u[d] = !0;
    }), s = s[0]) : u[s] = !0, this.tagName = s, this.tagNames = u, this.attributes = l || {}, this.fresh = c.fresh, this.separator = c.separator;
  }
  return a.prototype.matchesElement = function(s) {
    return this.tagNames[s.tagName] && t.isEqual(this.attributes || {}, s.attributes || {});
  }, a.prototype.wrap = function(l) {
    return this.wrapNodes(l());
  }, a.prototype.wrapNodes = function(l) {
    return [e.elementWithTag(this, l)];
  }, Ec.empty = r([]), Ec.ignore = {
    wrap: function() {
      return [];
    }
  }, Ec;
}
var FC = {};
(function(t) {
  var e = Rn, n = Zn, r = g0();
  t.imgElement = i;
  function i(o) {
    return function(a, s) {
      return n.when(o(a)).then(function(l) {
        var c = {};
        return a.altText && (c.alt = a.altText), e.extend(c, l), [r.freshElement("img", c)];
      });
    };
  }
  t.inline = t.imgElement, t.dataUri = i(function(o) {
    return o.readAsBase64String().then(function(a) {
      return {
        src: "data:" + o.contentType + ";base64," + a
      };
    });
  });
})(FC);
var a9 = {}, s9 = {}, l9 = Rn;
s9.writer = Npe;
function Npe(t) {
  return t = t || {}, t.prettyPrint ? Mpe() : c9();
}
var Ty = {
  div: !0,
  p: !0,
  ul: !0,
  li: !0
};
function Mpe() {
  var t = 0, e = "  ", n = [], r = !0, i = !1, o = c9();
  function a(m, g) {
    Ty[m] && f(), n.push(m), o.open(m, g), Ty[m] && t++, r = !1;
  }
  function s(m) {
    Ty[m] && (t--, f()), n.pop(), o.close(m);
  }
  function l(m) {
    d();
    var g = p() ? m : m.replace(`
`, `
` + e);
    o.text(g);
  }
  function c(m, g) {
    f(), o.selfClosing(m, g);
  }
  function u() {
    return n.length === 0 || Ty[n[n.length - 1]];
  }
  function d() {
    i || (f(), i = !0);
  }
  function f() {
    if (i = !1, !r && u() && !p()) {
      o._append(`
`);
      for (var m = 0; m < t; m++)
        o._append(e);
    }
  }
  function p() {
    return l9.some(n, function(m) {
      return m === "pre";
    });
  }
  return {
    asString: o.asString,
    open: a,
    close: s,
    text: l,
    selfClosing: c
  };
}
function c9() {
  var t = [];
  function e(l, c) {
    var u = i(c);
    t.push("<" + l + u + ">");
  }
  function n(l) {
    t.push("</" + l + ">");
  }
  function r(l, c) {
    var u = i(c);
    t.push("<" + l + u + " />");
  }
  function i(l) {
    return l9.map(l, function(c, u) {
      return " " + u + '="' + Lpe(c) + '"';
    }).join("");
  }
  function o(l) {
    t.push(Bpe(l));
  }
  function a(l) {
    t.push(l);
  }
  function s() {
    return t.join("");
  }
  return {
    asString: s,
    open: e,
    close: n,
    text: o,
    selfClosing: r,
    _append: a
  };
}
function Bpe(t) {
  return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function Lpe(t) {
  return t.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
var u9 = {}, Ppe = Rn;
function CI(t) {
  return $v(t, t);
}
function $v(t, e) {
  return function() {
    return { start: t, end: e };
  };
}
function Wpe(t) {
  var e = t.href || "";
  return e ? {
    start: "[",
    end: "](" + e + ")",
    anchorPosition: "before"
  } : {};
}
function zpe(t) {
  var e = t.src || "", n = t.alt || "";
  return e || n ? { start: "![" + n + "](" + e + ")" } : {};
}
function kI(t) {
  return function(e, n) {
    return {
      start: n ? `
` : "",
      end: n ? "" : `
`,
      list: {
        isOrdered: t.isOrdered,
        indent: n ? n.indent + 1 : 0,
        count: 0
      }
    };
  };
}
function $pe(t, e, n) {
  e = e || { indent: 0, isOrdered: !1, count: 0 }, e.count++, n.hasClosed = !1;
  var r = e.isOrdered ? e.count + "." : "-", i = f9("	", e.indent) + r + " ";
  return {
    start: i,
    end: function() {
      if (!n.hasClosed)
        return n.hasClosed = !0, `
`;
    }
  };
}
var d9 = {
  p: $v("", `

`),
  br: $v("", `  
`),
  ul: kI({ isOrdered: !1 }),
  ol: kI({ isOrdered: !0 }),
  li: $pe,
  strong: CI("__"),
  em: CI("*"),
  a: Wpe,
  img: zpe
};
(function() {
  for (var t = 1; t <= 6; t++)
    d9["h" + t] = $v(f9("#", t) + " ", `

`);
})();
function f9(t, e) {
  return new Array(e + 1).join(t);
}
function Hpe() {
  var t = [], e = [], n = null, r = {};
  function i(u, d) {
    d = d || {};
    var f = d9[u] || function() {
      return {};
    }, p = f(d, n, r);
    e.push({ end: p.end, list: n }), p.list && (n = p.list);
    var m = p.anchorPosition === "before";
    m && o(d), t.push(p.start || ""), m || o(d);
  }
  function o(u) {
    u.id && t.push('<a id="' + u.id + '"></a>');
  }
  function a(u) {
    var d = e.pop();
    n = d.list;
    var f = Ppe.isFunction(d.end) ? d.end() : d.end;
    t.push(f || "");
  }
  function s(u, d) {
    i(u, d), a();
  }
  function l(u) {
    t.push(jpe(u));
  }
  function c() {
    return t.join("");
  }
  return {
    asString: c,
    open: i,
    close: a,
    text: l,
    selfClosing: s
  };
}
u9.writer = Hpe;
function jpe(t) {
  return t.replace(/\\/g, "\\\\").replace(/([\`\*_\{\}\[\]\(\)\#\+\-\.\!])/g, "\\$1");
}
var Vpe = s9, qpe = u9;
a9.writer = Gpe;
function Gpe(t) {
  return t = t || {}, t.outputFormat === "markdown" ? qpe.writer() : Vpe.writer(t);
}
var ll = Rn, AI = Zn, lb = At, qi = y0(), NT = Ri, Kpe = FC, Ot = g0(), Xpe = a9;
OC.DocumentConverter = Ype;
function Ype(t) {
  return {
    convertToHtml: function(e) {
      var n = ll.indexBy(
        e.type === lb.types.document ? e.comments : [],
        "commentId"
      ), r = new Jpe(t, n);
      return r.convertToHtml(e);
    }
  };
}
function Jpe(t, e) {
  var n = 1, r = [], i = [];
  t = ll.extend({ ignoreEmptyParagraphs: !0 }, t);
  var o = t.idPrefix === void 0 ? "" : t.idPrefix, a = t.ignoreEmptyParagraphs, s = qi.topLevelElement("p"), l = t.styleMap || [];
  function c(oe) {
    var te = [], _e = d(oe, te, {}), q = [];
    h9(_e, function(ce) {
      ce.type === "deferred" && q.push(ce);
    });
    var N = {};
    return AI.mapSeries(q, function(ce) {
      return ce.value().then(function(me) {
        N[ce.id] = me;
      });
    }).then(function() {
      function ce(ve) {
        return Q2(ve, function(he) {
          return he.type === "deferred" ? N[he.id] : he.children ? [
            ll.extend({}, he, {
              children: ce(he.children)
            })
          ] : [he];
        });
      }
      var me = Xpe.writer({
        prettyPrint: t.prettyPrint,
        outputFormat: t.outputFormat
      });
      return Ot.write(me, Ot.simplify(ce(_e))), new NT.Result(me.asString(), te);
    });
  }
  function u(oe, te, _e) {
    return Q2(oe, function(q) {
      return d(q, te, _e);
    });
  }
  function d(oe, te, _e) {
    if (!_e)
      throw new Error("options not set");
    var q = Z[oe.type];
    return q ? q(oe, te, _e) : [];
  }
  function f(oe, te, _e) {
    return p(oe, te).wrap(function() {
      var q = u(oe.children, te, _e);
      return a ? q : [Ot.forceWrite].concat(q);
    });
  }
  function p(oe, te) {
    var _e = y(oe);
    return _e ? _e.to : (oe.styleId && te.push(RI("paragraph", oe)), s);
  }
  function m(oe, te, _e) {
    var q = function() {
      return u(oe.children, te, _e);
    }, N = [];
    if (oe.highlight !== null) {
      var ce = b({ type: "highlight", color: oe.highlight });
      ce && N.push(ce);
    }
    oe.isSmallCaps && N.push(g("smallCaps")), oe.isAllCaps && N.push(g("allCaps")), oe.isStrikethrough && N.push(g("strikethrough", "s")), oe.isUnderline && N.push(g("underline")), oe.verticalAlignment === lb.verticalAlignment.subscript && N.push(qi.element("sub", {}, { fresh: !1 })), oe.verticalAlignment === lb.verticalAlignment.superscript && N.push(qi.element("sup", {}, { fresh: !1 })), oe.isItalic && N.push(g("italic", "em")), oe.isBold && N.push(g("bold", "strong"));
    var me = qi.empty, ve = y(oe);
    return ve ? me = ve.to : oe.styleId && te.push(RI("run", oe)), N.push(me), N.forEach(function(he) {
      q = he.wrap.bind(he, q);
    }), q();
  }
  function g(oe, te) {
    var _e = b({ type: oe });
    return _e || (te ? qi.element(te, {}, { fresh: !1 }) : qi.empty);
  }
  function b(oe, te) {
    var _e = y(oe);
    return _e ? _e.to : te;
  }
  function y(oe) {
    for (var te = 0; te < l.length; te++)
      if (l[te].from.matches(oe))
        return l[te];
  }
  function w(oe) {
    return function(te, _e) {
      return AI.attempt(function() {
        return oe(te, _e);
      }).caught(function(q) {
        return _e.push(NT.error(q)), [];
      });
    };
  }
  function x(oe) {
    return A(oe.noteType, oe.noteId);
  }
  function k(oe) {
    return U(oe.noteType, oe.noteId);
  }
  function A(oe, te) {
    return P(oe + "-" + te);
  }
  function U(oe, te) {
    return P(oe + "-ref-" + te);
  }
  function P(oe) {
    return o + oe;
  }
  var V = qi.elements([
    qi.element("table", {}, { fresh: !0 })
  ]);
  function I(oe, te, _e) {
    return b(oe, V).wrap(function() {
      return le(oe, te, _e);
    });
  }
  function le(oe, te, _e) {
    var q = ll.findIndex(oe.children, function(ve) {
      return !ve.type === lb.types.tableRow || !ve.isHeader;
    });
    q === -1 && (q = oe.children.length);
    var N;
    if (q === 0)
      N = u(
        oe.children,
        te,
        ll.extend({}, _e, { isTableHeader: !1 })
      );
    else {
      var ce = u(
        oe.children.slice(0, q),
        te,
        ll.extend({}, _e, { isTableHeader: !0 })
      ), me = u(
        oe.children.slice(q),
        te,
        ll.extend({}, _e, { isTableHeader: !1 })
      );
      N = [
        Ot.freshElement("thead", {}, ce),
        Ot.freshElement("tbody", {}, me)
      ];
    }
    return [Ot.forceWrite].concat(N);
  }
  function be(oe, te, _e) {
    var q = u(oe.children, te, _e);
    return [
      Ot.freshElement("tr", {}, [Ot.forceWrite].concat(q))
    ];
  }
  function F(oe, te, _e) {
    var q = _e.isTableHeader ? "th" : "td", N = u(oe.children, te, _e), ce = {};
    return oe.colSpan !== 1 && (ce.colspan = oe.colSpan.toString()), oe.rowSpan !== 1 && (ce.rowspan = oe.rowSpan.toString()), [
      Ot.freshElement(q, ce, [Ot.forceWrite].concat(N))
    ];
  }
  function G(oe, te, _e) {
    return b(oe, qi.ignore).wrap(function() {
      var q = e[oe.commentId], N = i.length + 1, ce = "[" + eme(q) + N + "]";
      return i.push({ label: ce, comment: q }), [
        Ot.freshElement("a", {
          href: "#" + A("comment", oe.commentId),
          id: U("comment", oe.commentId)
        }, [Ot.text(ce)])
      ];
    });
  }
  function C(oe, te, _e) {
    var q = oe.label, N = oe.comment, ce = u(N.body, te, _e).concat([
      Ot.nonFreshElement("p", {}, [
        Ot.text(" "),
        Ot.freshElement("a", { href: "#" + U("comment", N.commentId) }, [
          Ot.text("↑")
        ])
      ])
    ]);
    return [
      Ot.freshElement(
        "dt",
        { id: A("comment", N.commentId) },
        [Ot.text("Comment " + q)]
      ),
      Ot.freshElement("dd", {}, ce)
    ];
  }
  function ie(oe, te, _e) {
    return ee(oe).wrap(function() {
      return [];
    });
  }
  function ee(oe) {
    var te = y(oe);
    return te ? te.to : oe.breakType === "line" ? qi.topLevelElement("br") : qi.empty;
  }
  var Z = {
    document: function(oe, te, _e) {
      var q = u(oe.children, te, _e), N = r.map(function(me) {
        return oe.notes.resolve(me);
      }), ce = u(N, te, _e);
      return q.concat([
        Ot.freshElement("ol", {}, ce),
        Ot.freshElement("dl", {}, Q2(i, function(me) {
          return C(me, te, _e);
        }))
      ]);
    },
    paragraph: f,
    run: m,
    text: function(oe, te, _e) {
      return [Ot.text(oe.value)];
    },
    tab: function(oe, te, _e) {
      return [Ot.text("	")];
    },
    hyperlink: function(oe, te, _e) {
      var q = oe.anchor ? "#" + P(oe.anchor) : oe.href, N = { href: q };
      oe.targetFrame != null && (N.target = oe.targetFrame);
      var ce = u(oe.children, te, _e);
      return [Ot.nonFreshElement("a", N, ce)];
    },
    checkbox: function(oe) {
      var te = { type: "checkbox" };
      return oe.checked && (te.checked = "checked"), [Ot.freshElement("input", te)];
    },
    bookmarkStart: function(oe, te, _e) {
      var q = Ot.freshElement("a", {
        id: P(oe.name)
      }, [Ot.forceWrite]);
      return [q];
    },
    noteReference: function(oe, te, _e) {
      r.push(oe);
      var q = Ot.freshElement("a", {
        href: "#" + x(oe),
        id: k(oe)
      }, [Ot.text("[" + n++ + "]")]);
      return [Ot.freshElement("sup", {}, [q])];
    },
    note: function(oe, te, _e) {
      var q = u(oe.body, te, _e), N = Ot.elementWithTag(qi.element("p", {}, { fresh: !1 }), [
        Ot.text(" "),
        Ot.freshElement("a", { href: "#" + k(oe) }, [Ot.text("↑")])
      ]), ce = q.concat([N]);
      return Ot.freshElement("li", { id: x(oe) }, ce);
    },
    commentReference: G,
    comment: C,
    image: Qpe(w(t.convertImage || Kpe.dataUri)),
    table: I,
    tableRow: be,
    tableCell: F,
    break: ie
  };
  return {
    convertToHtml: c
  };
}
var Zpe = 1;
function Qpe(t) {
  return function(e, n, r) {
    return [
      {
        type: "deferred",
        id: Zpe++,
        value: function() {
          return t(e, n, r);
        }
      }
    ];
  };
}
function RI(t, e) {
  return NT.warning(
    "Unrecognised " + t + " style: '" + e.styleName + "' (Style ID: " + e.styleId + ")"
  );
}
function Q2(t, e) {
  return ll.flatten(t.map(e), !0);
}
function h9(t, e) {
  t.forEach(function(n) {
    e(n), n.children && h9(n.children, e);
  });
}
var eme = OC.commentAuthorLabel = function(e) {
  return e.authorInitials || "";
}, p9 = {}, tme = At;
function m9(t) {
  if (t.type === "text")
    return t.value;
  if (t.type === tme.types.tab)
    return "	";
  var e = t.type === "paragraph" ? `

` : "";
  return (t.children || []).map(m9).join("") + e;
}
p9.convertElementToRawText = m9;
var b0 = {}, Ro = {}, g9 = {}, y9 = { exports: {} }, Pf = y9.exports = function(t, e) {
  this._tokens = t, this._startIndex = e || 0;
};
Pf.prototype.head = function() {
  return this._tokens[this._startIndex];
};
Pf.prototype.tail = function(t) {
  return new Pf(this._tokens, this._startIndex + 1);
};
Pf.prototype.toArray = function() {
  return this._tokens.slice(this._startIndex);
};
Pf.prototype.end = function() {
  return this._tokens[this._tokens.length - 1];
};
Pf.prototype.to = function(t) {
  var e = this.head().source, n = t.head() || t.end();
  return e.to(n.source);
};
var nme = y9.exports, rme = nme;
g9.Parser = function(t) {
  var e = function(n, r) {
    return n(new rme(r));
  };
  return {
    parseTokens: e
  };
};
var UC = {}, b9 = {};
(function(t) {
  t.none = /* @__PURE__ */ Object.create({
    value: function() {
      throw new Error("Called value on none");
    },
    isNone: function() {
      return !0;
    },
    isSome: function() {
      return !1;
    },
    map: function() {
      return t.none;
    },
    flatMap: function() {
      return t.none;
    },
    filter: function() {
      return t.none;
    },
    toArray: function() {
      return [];
    },
    orElse: e,
    valueOrElse: e
  });
  function e(r) {
    return typeof r == "function" ? r() : r;
  }
  t.some = function(r) {
    return new n(r);
  };
  var n = function(r) {
    this._value = r;
  };
  n.prototype.value = function() {
    return this._value;
  }, n.prototype.isNone = function() {
    return !1;
  }, n.prototype.isSome = function() {
    return !0;
  }, n.prototype.map = function(r) {
    return new n(r(this._value));
  }, n.prototype.flatMap = function(r) {
    return r(this._value);
  }, n.prototype.filter = function(r) {
    return r(this._value) ? this : t.none;
  }, n.prototype.toArray = function() {
    return [this._value];
  }, n.prototype.orElse = function(r) {
    return this;
  }, n.prototype.valueOrElse = function(r) {
    return this._value;
  }, t.isOption = function(r) {
    return r === t.none || r instanceof n;
  }, t.fromNullable = function(r) {
    return r == null ? t.none : new n(r);
  };
})(b9);
var NC = {
  failure: function(t, e) {
    if (t.length < 1)
      throw new Error("Failure must have errors");
    return new br({
      status: "failure",
      remaining: e,
      errors: t
    });
  },
  error: function(t, e) {
    if (t.length < 1)
      throw new Error("Failure must have errors");
    return new br({
      status: "error",
      remaining: e,
      errors: t
    });
  },
  success: function(t, e, n) {
    return new br({
      status: "success",
      value: t,
      source: n,
      remaining: e,
      errors: []
    });
  },
  cut: function(t) {
    return new br({
      status: "cut",
      remaining: t,
      errors: []
    });
  }
}, br = function(t) {
  this._value = t.value, this._status = t.status, this._hasValue = t.value !== void 0, this._remaining = t.remaining, this._source = t.source, this._errors = t.errors;
};
br.prototype.map = function(t) {
  return this._hasValue ? new br({
    value: t(this._value, this._source),
    status: this._status,
    remaining: this._remaining,
    source: this._source,
    errors: this._errors
  }) : this;
};
br.prototype.changeRemaining = function(t) {
  return new br({
    value: this._value,
    status: this._status,
    remaining: t,
    source: this._source,
    errors: this._errors
  });
};
br.prototype.isSuccess = function() {
  return this._status === "success" || this._status === "cut";
};
br.prototype.isFailure = function() {
  return this._status === "failure";
};
br.prototype.isError = function() {
  return this._status === "error";
};
br.prototype.isCut = function() {
  return this._status === "cut";
};
br.prototype.value = function() {
  return this._value;
};
br.prototype.remaining = function() {
  return this._remaining;
};
br.prototype.source = function() {
  return this._source;
};
br.prototype.errors = function() {
  return this._errors;
};
var MC = {};
MC.error = function(t) {
  return new v0(t);
};
var v0 = function(t) {
  this.expected = t.expected, this.actual = t.actual, this._location = t.location;
};
v0.prototype.describe = function() {
  var t = this._location ? this._location.describe() + `:
` : "";
  return t + "Expected " + this.expected + `
but got ` + this.actual;
};
v0.prototype.lineNumber = function() {
  return this._location.lineNumber();
};
v0.prototype.characterNumber = function() {
  return this._location.characterNumber();
};
var v9 = {};
v9.fromArray = function(t) {
  var e = 0, n = function() {
    return e < t.length;
  };
  return new iu({
    hasNext: n,
    next: function() {
      if (n())
        return t[e++];
      throw new Error("No more elements");
    }
  });
};
var iu = function(t) {
  this._iterator = t;
};
iu.prototype.map = function(t) {
  var e = this._iterator;
  return new iu({
    hasNext: function() {
      return e.hasNext();
    },
    next: function() {
      return t(e.next());
    }
  });
};
iu.prototype.filter = function(t) {
  var e = this._iterator, n = !1, r = !1, i, o = function() {
    if (!n)
      for (n = !0, r = !1; e.hasNext() && !r; )
        i = e.next(), r = t(i);
  };
  return new iu({
    hasNext: function() {
      return o(), r;
    },
    next: function() {
      o();
      var a = i;
      return n = !1, a;
    }
  });
};
iu.prototype.first = function() {
  var t = this._iterator;
  return this._iterator.hasNext() ? t.next() : null;
};
iu.prototype.toArray = function() {
  for (var t = []; this._iterator.hasNext(); )
    t.push(this._iterator.next());
  return t;
};
(function(t) {
  var e = Rn, n = b9, r = NC, i = MC, o = v9;
  t.token = function(f, p) {
    var m = p !== void 0;
    return function(g) {
      var b = g.head();
      if (b && b.name === f && (!m || b.value === p))
        return r.success(b.value, g.tail(), b.source);
      var y = u({ name: f, value: p });
      return d(g, y);
    };
  }, t.tokenOfType = function(f) {
    return t.token(f);
  }, t.firstOf = function(f, p) {
    return e.isArray(p) || (p = Array.prototype.slice.call(arguments, 1)), function(m) {
      return o.fromArray(p).map(function(g) {
        return g(m);
      }).filter(function(g) {
        return g.isSuccess() || g.isError();
      }).first() || d(m, f);
    };
  }, t.then = function(f, p) {
    return function(m) {
      var g = f(m);
      return g.map || console.log(g), g.map(p);
    };
  }, t.sequence = function() {
    var f = Array.prototype.slice.call(arguments, 0), p = function(g) {
      var b = e.foldl(f, function(w, x) {
        var k = w.result, A = w.hasCut;
        if (!k.isSuccess())
          return { result: k, hasCut: A };
        var U = x(k.remaining());
        if (U.isCut())
          return { result: k, hasCut: !0 };
        if (U.isSuccess()) {
          var P;
          x.isCaptured ? P = k.value().withValue(x, U.value()) : P = k.value();
          var V = U.remaining(), I = g.to(V);
          return {
            result: r.success(P, V, I),
            hasCut: A
          };
        } else return A ? { result: r.error(U.errors(), U.remaining()), hasCut: A } : { result: U, hasCut: A };
      }, { result: r.success(new a(), g), hasCut: !1 }).result, y = g.to(b.remaining());
      return b.map(function(w) {
        return w.withValue(t.sequence.source, y);
      });
    };
    p.head = function() {
      var g = e.find(f, m);
      return t.then(
        p,
        t.sequence.extract(g)
      );
    }, p.map = function(g) {
      return t.then(
        p,
        function(b) {
          return g.apply(this, b.toArray());
        }
      );
    };
    function m(g) {
      return g.isCaptured;
    }
    return p;
  };
  var a = function(f, p) {
    this._values = f || {}, this._valuesArray = p || [];
  };
  a.prototype.withValue = function(f, p) {
    if (f.captureName && f.captureName in this._values)
      throw new Error('Cannot add second value for capture "' + f.captureName + '"');
    var m = e.clone(this._values);
    m[f.captureName] = p;
    var g = this._valuesArray.concat([p]);
    return new a(m, g);
  }, a.prototype.get = function(f) {
    if (f.captureName in this._values)
      return this._values[f.captureName];
    throw new Error('No value for capture "' + f.captureName + '"');
  }, a.prototype.toArray = function() {
    return this._valuesArray;
  }, t.sequence.capture = function(f, p) {
    var m = function() {
      return f.apply(this, arguments);
    };
    return m.captureName = p, m.isCaptured = !0, m;
  }, t.sequence.extract = function(f) {
    return function(p) {
      return p.get(f);
    };
  }, t.sequence.applyValues = function(f) {
    var p = Array.prototype.slice.call(arguments, 1);
    return function(m) {
      var g = p.map(function(b) {
        return m.get(b);
      });
      return f.apply(this, g);
    };
  }, t.sequence.source = {
    captureName: "☃source☃"
  }, t.sequence.cut = function() {
    return function(f) {
      return r.cut(f);
    };
  }, t.optional = function(f) {
    return function(p) {
      var m = f(p);
      return m.isSuccess() ? m.map(n.some) : m.isFailure() ? r.success(n.none, p) : m;
    };
  }, t.zeroOrMoreWithSeparator = function(f, p) {
    return c(f, p, !1);
  }, t.oneOrMoreWithSeparator = function(f, p) {
    return c(f, p, !0);
  };
  var s = t.zeroOrMore = function(f) {
    return function(p) {
      for (var m = [], g; (g = f(p)) && g.isSuccess(); )
        p = g.remaining(), m.push(g.value());
      return g.isError() ? g : r.success(m, p);
    };
  };
  t.oneOrMore = function(f) {
    return t.oneOrMoreWithSeparator(f, l);
  };
  function l(f) {
    return r.success(null, f);
  }
  var c = function(f, p, m) {
    return function(g) {
      var b = f(g);
      if (b.isSuccess()) {
        var y = t.sequence.capture(f, "main"), w = s(t.then(
          t.sequence(p, y),
          t.sequence.extract(y)
        )), x = w(b.remaining());
        return r.success([b.value()].concat(x.value()), x.remaining());
      } else return m || b.isError() ? b : r.success([], g);
    };
  };
  t.leftAssociative = function(f, p, m) {
    var g;
    m ? g = [{ func: m, rule: p }] : g = p, g = g.map(function(y) {
      return t.then(y.rule, function(w) {
        return function(x, k) {
          return y.func(x, w, k);
        };
      });
    });
    var b = t.firstOf.apply(null, ["rules"].concat(g));
    return function(y) {
      var w = y, x = f(y);
      if (!x.isSuccess())
        return x;
      for (var k = b(x.remaining()); k.isSuccess(); ) {
        var A = k.remaining(), U = w.to(k.remaining()), P = k.value();
        x = r.success(
          P(x.value(), U),
          A,
          U
        ), k = b(x.remaining());
      }
      return k.isError() ? k : x;
    };
  }, t.leftAssociative.firstOf = function() {
    return Array.prototype.slice.call(arguments, 0);
  }, t.nonConsuming = function(f) {
    return function(p) {
      return f(p).changeRemaining(p);
    };
  };
  var u = function(f) {
    return f.value ? f.name + ' "' + f.value + '"' : f.name;
  };
  function d(f, p) {
    var m, g = f.head();
    return g ? m = i.error({
      expected: p,
      actual: u(g),
      location: g.source
    }) : m = i.error({
      expected: p,
      actual: "end of tokens"
    }), r.failure([m], f);
  }
})(UC);
var w9 = { exports: {} };
w9.exports = function(t, e) {
  var n = {
    asString: function() {
      return t;
    },
    range: function(r, i) {
      return new ou(t, e, r, i);
    }
  };
  return n;
};
var ou = function(t, e, n, r) {
  this._string = t, this._description = e, this._startIndex = n, this._endIndex = r;
};
ou.prototype.to = function(t) {
  return new ou(this._string, this._description, this._startIndex, t._endIndex);
};
ou.prototype.describe = function() {
  var t = this._position(), e = this._description ? this._description + `
` : "";
  return e + "Line number: " + t.lineNumber + `
Character number: ` + t.characterNumber;
};
ou.prototype.lineNumber = function() {
  return this._position().lineNumber;
};
ou.prototype.characterNumber = function() {
  return this._position().characterNumber;
};
ou.prototype._position = function() {
  for (var t = this, e = 0, n = function() {
    return t._string.indexOf(`
`, e);
  }, r = 1; n() !== -1 && n() < this._startIndex; )
    e = n() + 1, r += 1;
  var i = this._startIndex - e + 1;
  return { lineNumber: r, characterNumber: i };
};
var x9 = w9.exports, _9 = function(t, e, n) {
  this.name = t, this.value = e, n && (this.source = n);
}, S9 = {};
(function(t) {
  var e = UC, n = NC;
  t.parser = function(o, a, s) {
    var l = {
      rule: f,
      leftAssociative: p,
      rightAssociative: m
    }, c = new r(s.map(d)), u = e.firstOf(o, a);
    function d(y) {
      return {
        name: y.name,
        rule: i(y.ruleBuilder.bind(null, l))
      };
    }
    function f() {
      return g(c);
    }
    function p(y) {
      return g(c.untilExclusive(y));
    }
    function m(y) {
      return g(c.untilInclusive(y));
    }
    function g(y) {
      return b.bind(null, y);
    }
    function b(y, w) {
      var x = u(w);
      return x.isSuccess() ? y.apply(x) : x;
    }
    return l;
  };
  function r(o) {
    function a(d) {
      return new r(o.slice(0, l().indexOf(d)));
    }
    function s(d) {
      return new r(o.slice(0, l().indexOf(d) + 1));
    }
    function l() {
      return o.map(function(d) {
        return d.name;
      });
    }
    function c(d) {
      for (var f, p; ; )
        if (f = u(d.remaining()), f.isSuccess())
          p = d.source().to(f.source()), d = n.success(
            f.value()(d.value(), p),
            f.remaining(),
            p
          );
        else return f.isFailure() ? d : f;
    }
    function u(d) {
      return e.firstOf("infix", o.map(function(f) {
        return f.rule;
      }))(d);
    }
    return {
      apply: c,
      untilExclusive: a,
      untilInclusive: s
    };
  }
  t.infix = function(o, a) {
    function s(l) {
      return t.infix(o, function(c) {
        var u = a(c);
        return function(d) {
          var f = u(d);
          return f.map(function(p) {
            return function(m, g) {
              return l(m, p, g);
            };
          });
        };
      });
    }
    return {
      name: o,
      ruleBuilder: a,
      map: s
    };
  };
  var i = function(o) {
    var a;
    return function(s) {
      return a || (a = o()), a(s);
    };
  };
})(S9);
var T9 = {}, e_ = _9, ime = x9;
T9.RegexTokeniser = ome;
function ome(t) {
  t = t.map(function(i) {
    return {
      name: i.name,
      regex: new RegExp(i.regex.source, "g")
    };
  });
  function e(i, o) {
    for (var a = new ime(i, o), s = 0, l = []; s < i.length; ) {
      var c = n(i, s, a);
      s = c.endIndex, l.push(c.token);
    }
    return l.push(r(i, a)), l;
  }
  function n(i, o, a) {
    for (var s = 0; s < t.length; s++) {
      var l = t[s].regex;
      l.lastIndex = o;
      var c = l.exec(i);
      if (c) {
        var d = o + c[0].length;
        if (c.index === o && d > o) {
          var u = c[1], f = new e_(
            t[s].name,
            u,
            a.range(o, d)
          );
          return { token: f, endIndex: d };
        }
      }
    }
    var d = o + 1, f = new e_(
      "unrecognisedCharacter",
      i.substring(o, d),
      a.range(o, d)
    );
    return { token: f, endIndex: d };
  }
  function r(i, o) {
    return new e_(
      "end",
      null,
      o.range(i.length, i.length)
    );
  }
  return {
    tokenise: e
  };
}
Ro.Parser = g9.Parser;
Ro.rules = UC;
Ro.errors = MC;
Ro.results = NC;
Ro.StringSource = x9;
Ro.Token = _9;
Ro.bottomUp = S9;
Ro.RegexTokeniser = T9.RegexTokeniser;
Ro.rule = function(t) {
  var e;
  return function(n) {
    return e || (e = t()), e(n);
  };
};
var fr = {};
fr.paragraph = ame;
fr.run = sme;
fr.table = lme;
fr.bold = new Io("bold");
fr.italic = new Io("italic");
fr.underline = new Io("underline");
fr.strikethrough = new Io("strikethrough");
fr.allCaps = new Io("allCaps");
fr.smallCaps = new Io("smallCaps");
fr.highlight = cme;
fr.commentReference = new Io("commentReference");
fr.lineBreak = new w0({ breakType: "line" });
fr.pageBreak = new w0({ breakType: "page" });
fr.columnBreak = new w0({ breakType: "column" });
fr.equalTo = dme;
fr.startsWith = fme;
function ame(t) {
  return new Io("paragraph", t);
}
function sme(t) {
  return new Io("run", t);
}
function lme(t) {
  return new Io("table", t);
}
function cme(t) {
  return new D9(t);
}
function Io(t, e) {
  e = e || {}, this._elementType = t, this._styleId = e.styleId, this._styleName = e.styleName, e.list && (this._listIndex = e.list.levelIndex, this._listIsOrdered = e.list.isOrdered);
}
Io.prototype.matches = function(t) {
  return t.type === this._elementType && (this._styleId === void 0 || t.styleId === this._styleId) && (this._styleName === void 0 || t.styleName && this._styleName.operator(this._styleName.operand, t.styleName)) && (this._listIndex === void 0 || ume(t, this._listIndex, this._listIsOrdered)) && (this._breakType === void 0 || this._breakType === t.breakType);
};
function D9(t) {
  t = t || {}, this._color = t.color;
}
D9.prototype.matches = function(t) {
  return t.type === "highlight" && (this._color === void 0 || t.color === this._color);
};
function w0(t) {
  t = t || {}, this._breakType = t.breakType;
}
w0.prototype.matches = function(t) {
  return t.type === "break" && (this._breakType === void 0 || t.breakType === this._breakType);
};
function ume(t, e, n) {
  return t.numbering && t.numbering.level == e && t.numbering.isOrdered == n;
}
function dme(t) {
  return {
    operator: hme,
    operand: t
  };
}
function fme(t) {
  return {
    operator: pme,
    operand: t
  };
}
function hme(t, e) {
  return t.toUpperCase() === e.toUpperCase();
}
function pme(t, e) {
  return e.toUpperCase().indexOf(t.toUpperCase()) === 0;
}
var E9 = {}, mme = Ro, gme = mme.RegexTokeniser;
E9.tokenise = yme;
var II = "'((?:\\\\.|[^'])*)";
function yme(t) {
  var e = "(?:[a-zA-Z\\-_]|\\\\.)", n = new gme([
    { name: "identifier", regex: new RegExp("(" + e + "(?:" + e + "|[0-9])*)") },
    { name: "dot", regex: /\./ },
    { name: "colon", regex: /:/ },
    { name: "gt", regex: />/ },
    { name: "whitespace", regex: /\s+/ },
    { name: "arrow", regex: /=>/ },
    { name: "equals", regex: /=/ },
    { name: "startsWith", regex: /\^=/ },
    { name: "open-paren", regex: /\(/ },
    { name: "close-paren", regex: /\)/ },
    { name: "open-square-bracket", regex: /\[/ },
    { name: "close-square-bracket", regex: /\]/ },
    { name: "string", regex: new RegExp(II + "'") },
    { name: "unterminated-string", regex: new RegExp(II) },
    { name: "integer", regex: /([0-9]+)/ },
    { name: "choice", regex: /\|/ },
    { name: "bang", regex: /(!)/ }
  ]);
  return n.tokenise(t);
}
var bme = Rn, $e = Ro, mr = fr, cb = y0(), vme = E9.tokenise, t_ = Ri;
b0.readHtmlPath = Sme;
b0.readDocumentMatcher = _me;
b0.readStyle = wme;
function wme(t) {
  return BC(Ime, t);
}
function xme() {
  return $e.rules.sequence(
    $e.rules.sequence.capture(C9()),
    $e.rules.tokenOfType("whitespace"),
    $e.rules.tokenOfType("arrow"),
    $e.rules.sequence.capture($e.rules.optional($e.rules.sequence(
      $e.rules.tokenOfType("whitespace"),
      $e.rules.sequence.capture(k9())
    ).head())),
    $e.rules.tokenOfType("end")
  ).map(function(t, e) {
    return {
      from: t,
      to: e.valueOrElse(cb.empty)
    };
  });
}
function _me(t) {
  return BC(C9(), t);
}
function C9() {
  var t = $e.rules.sequence, e = function(U, P) {
    return $e.rules.then(
      $e.rules.token("identifier", U),
      function() {
        return P;
      }
    );
  }, n = e("p", mr.paragraph), r = e("r", mr.run), i = $e.rules.firstOf(
    "p or r or table",
    n,
    r
  ), o = $e.rules.sequence(
    $e.rules.tokenOfType("dot"),
    $e.rules.sequence.cut(),
    $e.rules.sequence.capture(x0)
  ).map(function(U) {
    return { styleId: U };
  }), a = $e.rules.firstOf(
    "style name matcher",
    $e.rules.then(
      $e.rules.sequence(
        $e.rules.tokenOfType("equals"),
        $e.rules.sequence.cut(),
        $e.rules.sequence.capture(Zd)
      ).head(),
      function(U) {
        return { styleName: mr.equalTo(U) };
      }
    ),
    $e.rules.then(
      $e.rules.sequence(
        $e.rules.tokenOfType("startsWith"),
        $e.rules.sequence.cut(),
        $e.rules.sequence.capture(Zd)
      ).head(),
      function(U) {
        return { styleName: mr.startsWith(U) };
      }
    )
  ), s = $e.rules.sequence(
    $e.rules.tokenOfType("open-square-bracket"),
    $e.rules.sequence.cut(),
    $e.rules.token("identifier", "style-name"),
    $e.rules.sequence.capture(a),
    $e.rules.tokenOfType("close-square-bracket")
  ).head(), l = $e.rules.firstOf(
    "list type",
    e("ordered-list", { isOrdered: !0 }),
    e("unordered-list", { isOrdered: !1 })
  ), c = t(
    $e.rules.tokenOfType("colon"),
    t.capture(l),
    t.cut(),
    $e.rules.tokenOfType("open-paren"),
    t.capture(Tme),
    $e.rules.tokenOfType("close-paren")
  ).map(function(U, P) {
    return {
      list: {
        isOrdered: U.isOrdered,
        levelIndex: P - 1
      }
    };
  });
  function u(U) {
    var P = $e.rules.firstOf.apply(
      $e.rules.firstOf,
      ["matcher suffix"].concat(U)
    ), V = $e.rules.zeroOrMore(P);
    return $e.rules.then(V, function(I) {
      var le = {};
      return I.forEach(function(be) {
        bme.extend(le, be);
      }), le;
    });
  }
  var d = t(
    t.capture(i),
    t.capture(u([
      o,
      s,
      c
    ]))
  ).map(function(U, P) {
    return U(P);
  }), f = t(
    $e.rules.token("identifier", "table"),
    t.capture(u([
      o,
      s
    ]))
  ).map(function(U) {
    return mr.table(U);
  }), p = e("b", mr.bold), m = e("i", mr.italic), g = e("u", mr.underline), b = e("strike", mr.strikethrough), y = e("all-caps", mr.allCaps), w = e("small-caps", mr.smallCaps), x = t(
    $e.rules.token("identifier", "highlight"),
    $e.rules.sequence.capture($e.rules.optional($e.rules.sequence(
      $e.rules.tokenOfType("open-square-bracket"),
      $e.rules.sequence.cut(),
      $e.rules.token("identifier", "color"),
      $e.rules.tokenOfType("equals"),
      $e.rules.sequence.capture(Zd),
      $e.rules.tokenOfType("close-square-bracket")
    ).head()))
  ).map(function(U) {
    return mr.highlight({
      color: U.valueOrElse(void 0)
    });
  }), k = e("comment-reference", mr.commentReference), A = t(
    $e.rules.token("identifier", "br"),
    t.cut(),
    $e.rules.tokenOfType("open-square-bracket"),
    $e.rules.token("identifier", "type"),
    $e.rules.tokenOfType("equals"),
    t.capture(Zd),
    $e.rules.tokenOfType("close-square-bracket")
  ).map(function(U) {
    switch (U) {
      case "line":
        return mr.lineBreak;
      case "page":
        return mr.pageBreak;
      case "column":
        return mr.columnBreak;
    }
  });
  return $e.rules.firstOf(
    "element type",
    d,
    f,
    p,
    m,
    g,
    b,
    y,
    w,
    x,
    k,
    A
  );
}
function Sme(t) {
  return BC(k9(), t);
}
function k9() {
  var t = $e.rules.sequence.capture, e = $e.rules.tokenOfType("whitespace"), n = $e.rules.then(
    $e.rules.optional($e.rules.sequence(
      $e.rules.tokenOfType("colon"),
      $e.rules.token("identifier", "fresh")
    )),
    function(a) {
      return a.map(function() {
        return !0;
      }).valueOrElse(!1);
    }
  ), r = $e.rules.then(
    $e.rules.optional($e.rules.sequence(
      $e.rules.tokenOfType("colon"),
      $e.rules.token("identifier", "separator"),
      $e.rules.tokenOfType("open-paren"),
      t(Zd),
      $e.rules.tokenOfType("close-paren")
    ).head()),
    function(a) {
      return a.valueOrElse("");
    }
  ), i = $e.rules.oneOrMoreWithSeparator(
    x0,
    $e.rules.tokenOfType("choice")
  ), o = $e.rules.sequence(
    t(i),
    t($e.rules.zeroOrMore(kme)),
    t(n),
    t(r)
  ).map(function(a, s, l, c) {
    var u = {}, d = {};
    return s.forEach(function(f) {
      f.append && u[f.name] ? u[f.name] += " " + f.value : u[f.name] = f.value;
    }), l && (d.fresh = !0), c && (d.separator = c), cb.element(a, u, d);
  });
  return $e.rules.firstOf(
    "html path",
    $e.rules.then($e.rules.tokenOfType("bang"), function() {
      return cb.ignore;
    }),
    $e.rules.then(
      $e.rules.zeroOrMoreWithSeparator(
        o,
        $e.rules.sequence(
          e,
          $e.rules.tokenOfType("gt"),
          e
        )
      ),
      cb.elements
    )
  );
}
var x0 = $e.rules.then(
  $e.rules.tokenOfType("identifier"),
  A9
), Tme = $e.rules.tokenOfType("integer"), Zd = $e.rules.then(
  $e.rules.tokenOfType("string"),
  A9
), Dme = {
  n: `
`,
  r: "\r",
  t: "	"
};
function A9(t) {
  return t.replace(/\\(.)/g, function(e, n) {
    return Dme[n] || n;
  });
}
var Eme = $e.rules.sequence(
  $e.rules.tokenOfType("open-square-bracket"),
  $e.rules.sequence.cut(),
  $e.rules.sequence.capture(x0),
  $e.rules.tokenOfType("equals"),
  $e.rules.sequence.capture(Zd),
  $e.rules.tokenOfType("close-square-bracket")
).map(function(t, e) {
  return { name: t, value: e, append: !1 };
}), Cme = $e.rules.sequence(
  $e.rules.tokenOfType("dot"),
  $e.rules.sequence.cut(),
  $e.rules.sequence.capture(x0)
).map(function(t) {
  return { name: "class", value: t, append: !0 };
}), kme = $e.rules.firstOf(
  "attribute or class",
  Eme,
  Cme
);
function BC(t, e) {
  var n = vme(e), r = $e.Parser(), i = r.parseTokens(t, n);
  return i.isSuccess() ? t_.success(i.value()) : new t_.Result(null, [t_.warning(Ame(e, i))]);
}
function Ame(t, e) {
  return "Did not understand this style mapping, so ignored it: " + t + `
` + e.errors().map(Rme).join(`
`);
}
function Rme(t) {
  return "Error was at character number " + t.characterNumber() + ": Expected " + t.expected + " but got " + t.actual;
}
var Ime = xme(), _0 = {};
_0.readOptions = Ume;
var R9 = Rn, Ome = _0._defaultStyleMap = [
  "p.Heading1 => h1:fresh",
  "p.Heading2 => h2:fresh",
  "p.Heading3 => h3:fresh",
  "p.Heading4 => h4:fresh",
  "p.Heading5 => h5:fresh",
  "p.Heading6 => h6:fresh",
  "p[style-name='Heading 1'] => h1:fresh",
  "p[style-name='Heading 2'] => h2:fresh",
  "p[style-name='Heading 3'] => h3:fresh",
  "p[style-name='Heading 4'] => h4:fresh",
  "p[style-name='Heading 5'] => h5:fresh",
  "p[style-name='Heading 6'] => h6:fresh",
  "p[style-name='heading 1'] => h1:fresh",
  "p[style-name='heading 2'] => h2:fresh",
  "p[style-name='heading 3'] => h3:fresh",
  "p[style-name='heading 4'] => h4:fresh",
  "p[style-name='heading 5'] => h5:fresh",
  "p[style-name='heading 6'] => h6:fresh",
  "r[style-name='Strong'] => strong",
  "p[style-name='footnote text'] => p:fresh",
  "r[style-name='footnote reference'] =>",
  "p[style-name='endnote text'] => p:fresh",
  "r[style-name='endnote reference'] =>",
  "p[style-name='annotation text'] => p:fresh",
  "r[style-name='annotation reference'] =>",
  // LibreOffice
  "p[style-name='Footnote'] => p:fresh",
  "r[style-name='Footnote anchor'] =>",
  "p[style-name='Endnote'] => p:fresh",
  "r[style-name='Endnote anchor'] =>",
  "p:unordered-list(1) => ul > li:fresh",
  "p:unordered-list(2) => ul|ol > li > ul > li:fresh",
  "p:unordered-list(3) => ul|ol > li > ul|ol > li > ul > li:fresh",
  "p:unordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
  "p:unordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
  "p:ordered-list(1) => ol > li:fresh",
  "p:ordered-list(2) => ul|ol > li > ol > li:fresh",
  "p:ordered-list(3) => ul|ol > li > ul|ol > li > ol > li:fresh",
  "p:ordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
  "p:ordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
  "r[style-name='Hyperlink'] =>",
  "p[style-name='Normal'] => p:fresh"
], Fme = _0._standardOptions = {
  transformDocument: Nme,
  includeDefaultStyleMap: !0,
  includeEmbeddedStyleMap: !0
};
function Ume(t) {
  return t = t || {}, R9.extend({}, Fme, t, {
    customStyleMap: OI(t.styleMap),
    readStyleMap: function() {
      var e = this.customStyleMap;
      return this.includeEmbeddedStyleMap && (e = e.concat(OI(this.embeddedStyleMap))), this.includeDefaultStyleMap && (e = e.concat(Ome)), e;
    }
  });
}
function OI(t) {
  return t ? R9.isString(t) ? t.split(`
`).map(function(e) {
    return e.trim();
  }).filter(function(e) {
    return e !== "" && e.charAt(0) !== "#";
  }) : t : [];
}
function Nme(t) {
  return t;
}
var I9 = {}, FI = Zn, Mme = Xm;
I9.openZip = Bme;
function Bme(t) {
  return t.arrayBuffer ? FI.resolve(Mme.openArrayBuffer(t.arrayBuffer)) : FI.reject(new Error("Could not find file in options"));
}
var ah = {}, UI = Rn;
ah.paragraph = Lme;
ah.run = Pme;
ah._elements = F9;
ah.getDescendantsOfType = Wme;
ah.getDescendants = U9;
function Lme(t) {
  return O9("paragraph", t);
}
function Pme(t) {
  return O9("run", t);
}
function O9(t, e) {
  return F9(function(n) {
    return n.type === t ? e(n) : n;
  });
}
function F9(t) {
  return function e(n) {
    if (n.children) {
      var r = UI.map(n.children, e);
      n = UI.extend(n, { children: r });
    }
    return t(n);
  };
}
function Wme(t, e) {
  return U9(t).filter(function(n) {
    return n.type === e;
  });
}
function U9(t) {
  var e = [];
  return N9(t, function(n) {
    e.push(n);
  }), e;
}
function N9(t, e) {
  t.children && t.children.forEach(function(n) {
    N9(n, e), e(n);
  });
}
var M9 = {}, zme = y0(), $me = g0();
M9.element = Hme;
function Hme(t) {
  return function(e) {
    return $me.elementWithTag(zme.element(t), [e]);
  };
}
var jme = Rn, B9 = aC, LC = IC, Vme = OC.DocumentConverter, qme = p9.convertElementToRawText, Gme = b0.readStyle, Kme = _0.readOptions, S0 = I9, Xme = Ri.Result;
Ao.convertToHtml = Yme;
Ao.convertToMarkdown = Jme;
Ao.convert = PC;
Ao.extractRawText = tge;
Ao.images = FC;
Ao.transforms = ah;
Ao.underline = M9;
Ao.embedStyleMap = nge;
Ao.readEmbeddedStyleMap = Zme;
function Yme(t, e) {
  return PC(t, e);
}
function Jme(t, e) {
  var n = Object.create(e || {});
  return n.outputFormat = "markdown", PC(t, n);
}
function PC(t, e) {
  return e = Kme(e), S0.openZip(t).tap(function(n) {
    return LC.readStyleMap(n).then(function(r) {
      e.embeddedStyleMap = r;
    });
  }).then(function(n) {
    return B9.read(n, t).then(function(r) {
      return r.map(e.transformDocument);
    }).then(function(r) {
      return Qme(r, e);
    });
  });
}
function Zme(t) {
  return S0.openZip(t).then(LC.readStyleMap);
}
function Qme(t, e) {
  var n = ege(e.readStyleMap()), r = jme.extend({}, e, {
    styleMap: n.value
  }), i = new Vme(r);
  return t.flatMapThen(function(o) {
    return n.flatMapThen(function(a) {
      return i.convertToHtml(o);
    });
  });
}
function ege(t) {
  return Xme.combine((t || []).map(Gme)).map(function(e) {
    return e.filter(function(n) {
      return !!n;
    });
  });
}
function tge(t) {
  return S0.openZip(t).then(B9.read).then(function(e) {
    return e.map(qme);
  });
}
function nge(t, e) {
  return S0.openZip(t).tap(function(n) {
    return LC.writeStyleMap(n, e);
  }).then(function(n) {
    return n.toArrayBuffer();
  }).then(function(n) {
    return {
      toArrayBuffer: function() {
        return n;
      },
      toBuffer: function() {
        return Buffer.from(n);
      }
    };
  });
}
Ao.styleMapping = function() {
  throw new Error(`Use a raw string instead of mammoth.styleMapping e.g. "p[style-name='Title'] => h1" instead of mammoth.styleMapping("p[style-name='Title'] => h1")`);
};
function rge(t, e) {
  const n = atob(t.split(",")[1]), r = Array.from({ length: n.length });
  for (let o = 0; o < n.length; o++)
    r[o] = n.charCodeAt(o);
  const i = new Uint8Array(r);
  return new Blob([i], { type: e });
}
function ige(t, e) {
  return new File([t], e, { type: t.type });
}
function oge(t) {
  const { toast: e } = f4(), { t: n } = Wt(), [r, i] = nt(!1), o = Wr(null);
  function a() {
    var d;
    (d = o.current) == null || d.click();
  }
  function s(d) {
    const f = d.target.files[0];
    if (f) {
      if (f.size > t.limit) {
        e({
          variant: "destructive",
          title: n("editor.importWord.limitSize")
        });
        return;
      }
      c(f);
    }
  }
  async function l(d) {
    var b;
    const p = new DOMParser().parseFromString(d, "text/html"), m = p.querySelectorAll("img");
    if (!m.length)
      return p.body.innerHTML;
    if (tN(t.editor, "image")) {
      const y = (b = t.editor.extensionManager.extensions.find(
        (w) => w.name === "importWord"
      )) == null ? void 0 : b.options;
      if (y && typeof y.upload == "function") {
        const w = [];
        for (const k of m) {
          const A = k.getAttribute("src"), U = rge(A, "image/jpeg"), P = ige(U, "image.jpeg");
          w.push(P);
        }
        const x = await y.upload(w);
        for (let k = 0; k < m.length; k++) {
          const A = m[k];
          A.setAttribute("src", x[k].src);
          const U = A.parentElement;
          (U == null ? void 0 : U.tagName) === "P" && (U.insertAdjacentElement("beforebegin", A), !U.hasChildNodes() && U.textContent === "" && U.remove());
        }
        return p.body.innerHTML;
      } else
        return console.warn("Image Upload method found, skip image conversion"), p.body.innerHTML;
    } else
      return console.error("Image extension not found, unable to convert image"), p.body.innerHTML;
  }
  async function c(d) {
    i(!0);
    try {
      if (t.convert) {
        const f = await t.convert(d);
        u(f);
      } else {
        const f = await d.arrayBuffer(), { value: p } = await Ao.convertToHtml(
          { arrayBuffer: f },
          t == null ? void 0 : t.mammothOptions
        );
        u(p);
      }
    } finally {
      i(!1);
    }
  }
  async function u(d) {
    const f = await l(d);
    t.editor.chain().setContent(f, !0).run();
  }
  return /* @__PURE__ */ Fe("div", { children: [
    /* @__PURE__ */ z(Je, { loading: r, disabled: t == null ? void 0 : t.disabled, icon: t == null ? void 0 : t.icon, tooltip: t == null ? void 0 : t.tooltip, action: a }),
    /* @__PURE__ */ z(
      "input",
      {
        type: "file",
        accept: ".docx",
        ref: o,
        style: {
          display: "none"
        },
        onChange: s
      }
    )
  ] });
}
const Z2e = St.create({
  name: "importWord",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      upload: void 0,
      convert: void 0,
      limit: 1024 * 1024 * 10,
      // 10 MB
      button: ({ editor: e, extension: n, t: r }) => {
        const { convert: i, limit: o, mammothOptions: a } = n.options;
        return {
          component: oge,
          componentProps: {
            editor: e,
            convert: i,
            limit: o,
            mammothOptions: a,
            action: () => e.commands.setHorizontalRule(),
            disabled: !e.can().setHorizontalRule(),
            icon: "Word",
            shortcutKeys: ["alt", "mod", "S"],
            tooltip: r("editor.importWord.tooltip")
          }
        };
      }
    };
  }
});
var age = Object.defineProperty, sge = Object.defineProperties, lge = Object.getOwnPropertyDescriptors, NI = Object.getOwnPropertySymbols, cge = Object.prototype.hasOwnProperty, uge = Object.prototype.propertyIsEnumerable, MT = (t, e, n) => e in t ? age(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Dt = (t, e) => {
  for (var n in e || (e = {}))
    cge.call(e, n) && MT(t, n, e[n]);
  if (NI)
    for (var n of NI(e))
      uge.call(e, n) && MT(t, n, e[n]);
  return t;
}, Il = (t, e) => sge(t, lge(e)), Ue = (t, e, n) => (MT(t, typeof e != "symbol" ? e + "" : e, n), n), Dy = (t, e, n) => new Promise((r, i) => {
  var o = (l) => {
    try {
      s(n.next(l));
    } catch (c) {
      i(c);
    }
  }, a = (l) => {
    try {
      s(n.throw(l));
    } catch (c) {
      i(c);
    }
  }, s = (l) => l.done ? r(l.value) : Promise.resolve(l.value).then(o, a);
  s((n = n.apply(t, e)).next());
});
class Hv {
  constructor(e) {
    Ue(this, "rootKey"), this.rootKey = e;
  }
}
const dge = Object.seal({});
class Oe extends Hv {
  constructor(e) {
    super(e), Ue(this, "root"), this.root = new Array();
  }
  // This method is called by the formatter to get the XML representation of this component.
  // It is called recursively for all child components.
  // It is a serializer to be used in the xml library.
  // https://www.npmjs.com/package/xml
  // Child components can override this method to customize the XML representation, or execute side effects.
  prepForXml(e) {
    var n;
    e.stack.push(this);
    const r = this.root.map((i) => i instanceof Hv ? i.prepForXml(e) : i).filter((i) => i !== void 0);
    return e.stack.pop(), {
      [this.rootKey]: r.length ? r.length === 1 && ((n = r[0]) != null && n._attr) ? r[0] : r : dge
    };
  }
  /**
   * @deprecated Do not use this method. It is only used internally by the library. It will be removed in a future version.
   */
  addChildElement(e) {
    return this.root.push(e), this;
  }
}
class vs extends Oe {
  prepForXml(e) {
    const n = super.prepForXml(e);
    if (n && (typeof n[this.rootKey] != "object" || Object.keys(n[this.rootKey]).length))
      return n;
  }
}
class Ye extends Hv {
  constructor(e) {
    super("_attr"), Ue(this, "xmlKeys"), this.root = e;
  }
  prepForXml(e) {
    const n = {};
    return Object.keys(this.root).forEach((r) => {
      const i = this.root[r];
      if (i !== void 0) {
        const o = this.xmlKeys && this.xmlKeys[r] || r;
        n[o] = i;
      }
    }), { _attr: n };
  }
}
class ws extends Hv {
  constructor(e) {
    super("_attr"), this.root = e;
  }
  prepForXml(e) {
    return { _attr: Object.values(this.root).filter(({ value: r }) => r !== void 0).reduce((r, { key: i, value: o }) => Il(Dt({}, r), { [i]: o }), {}) };
  }
}
class En extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      val: "w:val",
      color: "w:color",
      fill: "w:fill",
      space: "w:space",
      sz: "w:sz",
      type: "w:type",
      rsidR: "w:rsidR",
      rsidRPr: "w:rsidRPr",
      rsidSect: "w:rsidSect",
      w: "w:w",
      h: "w:h",
      top: "w:top",
      right: "w:right",
      bottom: "w:bottom",
      left: "w:left",
      header: "w:header",
      footer: "w:footer",
      gutter: "w:gutter",
      linePitch: "w:linePitch",
      pos: "w:pos"
    });
  }
}
var oa = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function L9(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var P9 = {}, WC = { exports: {} }, ff = typeof Reflect == "object" ? Reflect : null, MI = ff && typeof ff.apply == "function" ? ff.apply : function(e, n, r) {
  return Function.prototype.apply.call(e, n, r);
}, ub;
ff && typeof ff.ownKeys == "function" ? ub = ff.ownKeys : Object.getOwnPropertySymbols ? ub = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : ub = function(e) {
  return Object.getOwnPropertyNames(e);
};
function fge(t) {
  console && console.warn && console.warn(t);
}
var W9 = Number.isNaN || function(e) {
  return e !== e;
};
function Jt() {
  Jt.init.call(this);
}
WC.exports = Jt;
WC.exports.once = gge;
Jt.EventEmitter = Jt;
Jt.prototype._events = void 0;
Jt.prototype._eventsCount = 0;
Jt.prototype._maxListeners = void 0;
var BI = 10;
function T0(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
Object.defineProperty(Jt, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return BI;
  },
  set: function(t) {
    if (typeof t != "number" || t < 0 || W9(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    BI = t;
  }
});
Jt.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Jt.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || W9(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function z9(t) {
  return t._maxListeners === void 0 ? Jt.defaultMaxListeners : t._maxListeners;
}
Jt.prototype.getMaxListeners = function() {
  return z9(this);
};
Jt.prototype.emit = function(e) {
  for (var n = [], r = 1; r < arguments.length; r++)
    n.push(arguments[r]);
  var i = e === "error", o = this._events;
  if (o !== void 0)
    i = i && o.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var a;
    if (n.length > 0 && (a = n[0]), a instanceof Error)
      throw a;
    var s = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
    throw s.context = a, s;
  }
  var l = o[e];
  if (l === void 0)
    return !1;
  if (typeof l == "function")
    MI(l, this, n);
  else
    for (var c = l.length, u = q9(l, c), r = 0; r < c; ++r)
      MI(u[r], this, n);
  return !0;
};
function $9(t, e, n, r) {
  var i, o, a;
  if (T0(n), o = t._events, o === void 0 ? (o = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (o.newListener !== void 0 && (t.emit(
    "newListener",
    e,
    n.listener ? n.listener : n
  ), o = t._events), a = o[e]), a === void 0)
    a = o[e] = n, ++t._eventsCount;
  else if (typeof a == "function" ? a = o[e] = r ? [n, a] : [a, n] : r ? a.unshift(n) : a.push(n), i = z9(t), i > 0 && a.length > i && !a.warned) {
    a.warned = !0;
    var s = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    s.name = "MaxListenersExceededWarning", s.emitter = t, s.type = e, s.count = a.length, fge(s);
  }
  return t;
}
Jt.prototype.addListener = function(e, n) {
  return $9(this, e, n, !1);
};
Jt.prototype.on = Jt.prototype.addListener;
Jt.prototype.prependListener = function(e, n) {
  return $9(this, e, n, !0);
};
function hge() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function H9(t, e, n) {
  var r = { fired: !1, wrapFn: void 0, target: t, type: e, listener: n }, i = hge.bind(r);
  return i.listener = n, r.wrapFn = i, i;
}
Jt.prototype.once = function(e, n) {
  return T0(n), this.on(e, H9(this, e, n)), this;
};
Jt.prototype.prependOnceListener = function(e, n) {
  return T0(n), this.prependListener(e, H9(this, e, n)), this;
};
Jt.prototype.removeListener = function(e, n) {
  var r, i, o, a, s;
  if (T0(n), i = this._events, i === void 0)
    return this;
  if (r = i[e], r === void 0)
    return this;
  if (r === n || r.listener === n)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, r.listener || n));
  else if (typeof r != "function") {
    for (o = -1, a = r.length - 1; a >= 0; a--)
      if (r[a] === n || r[a].listener === n) {
        s = r[a].listener, o = a;
        break;
      }
    if (o < 0)
      return this;
    o === 0 ? r.shift() : pge(r, o), r.length === 1 && (i[e] = r[0]), i.removeListener !== void 0 && this.emit("removeListener", e, s || n);
  }
  return this;
};
Jt.prototype.off = Jt.prototype.removeListener;
Jt.prototype.removeAllListeners = function(e) {
  var n, r, i;
  if (r = this._events, r === void 0)
    return this;
  if (r.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[e]), this;
  if (arguments.length === 0) {
    var o = Object.keys(r), a;
    for (i = 0; i < o.length; ++i)
      a = o[i], a !== "removeListener" && this.removeAllListeners(a);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (n = r[e], typeof n == "function")
    this.removeListener(e, n);
  else if (n !== void 0)
    for (i = n.length - 1; i >= 0; i--)
      this.removeListener(e, n[i]);
  return this;
};
function j9(t, e, n) {
  var r = t._events;
  if (r === void 0)
    return [];
  var i = r[e];
  return i === void 0 ? [] : typeof i == "function" ? n ? [i.listener || i] : [i] : n ? mge(i) : q9(i, i.length);
}
Jt.prototype.listeners = function(e) {
  return j9(this, e, !0);
};
Jt.prototype.rawListeners = function(e) {
  return j9(this, e, !1);
};
Jt.listenerCount = function(t, e) {
  return typeof t.listenerCount == "function" ? t.listenerCount(e) : V9.call(t, e);
};
Jt.prototype.listenerCount = V9;
function V9(t) {
  var e = this._events;
  if (e !== void 0) {
    var n = e[t];
    if (typeof n == "function")
      return 1;
    if (n !== void 0)
      return n.length;
  }
  return 0;
}
Jt.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ub(this._events) : [];
};
function q9(t, e) {
  for (var n = new Array(e), r = 0; r < e; ++r)
    n[r] = t[r];
  return n;
}
function pge(t, e) {
  for (; e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function mge(t) {
  for (var e = new Array(t.length), n = 0; n < e.length; ++n)
    e[n] = t[n].listener || t[n];
  return e;
}
function gge(t, e) {
  return new Promise(function(n, r) {
    function i(a) {
      t.removeListener(e, o), r(a);
    }
    function o() {
      typeof t.removeListener == "function" && t.removeListener("error", i), n([].slice.call(arguments));
    }
    G9(t, e, o, { once: !0 }), e !== "error" && yge(t, i, { once: !0 });
  });
}
function yge(t, e, n) {
  typeof t.on == "function" && G9(t, "error", e, n);
}
function G9(t, e, n, r) {
  if (typeof t.on == "function")
    r.once ? t.once(e, n) : t.on(e, n);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function i(o) {
      r.once && t.removeEventListener(e, i), n(o);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var zC = WC.exports, BT = { exports: {} };
typeof Object.create == "function" ? BT.exports = function(e, n) {
  n && (e.super_ = n, e.prototype = Object.create(n.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : BT.exports = function(e, n) {
  if (n) {
    e.super_ = n;
    var r = function() {
    };
    r.prototype = n.prototype, e.prototype = new r(), e.prototype.constructor = e;
  }
};
var _u = BT.exports;
function bge(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var K9 = { exports: {} }, In = K9.exports = {}, Qo, ea;
function LT() {
  throw new Error("setTimeout has not been defined");
}
function PT() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Qo = setTimeout : Qo = LT;
  } catch {
    Qo = LT;
  }
  try {
    typeof clearTimeout == "function" ? ea = clearTimeout : ea = PT;
  } catch {
    ea = PT;
  }
})();
function X9(t) {
  if (Qo === setTimeout)
    return setTimeout(t, 0);
  if ((Qo === LT || !Qo) && setTimeout)
    return Qo = setTimeout, setTimeout(t, 0);
  try {
    return Qo(t, 0);
  } catch {
    try {
      return Qo.call(null, t, 0);
    } catch {
      return Qo.call(this, t, 0);
    }
  }
}
function vge(t) {
  if (ea === clearTimeout)
    return clearTimeout(t);
  if ((ea === PT || !ea) && clearTimeout)
    return ea = clearTimeout, clearTimeout(t);
  try {
    return ea(t);
  } catch {
    try {
      return ea.call(null, t);
    } catch {
      return ea.call(this, t);
    }
  }
}
var es = [], hf = !1, Bc, db = -1;
function wge() {
  !hf || !Bc || (hf = !1, Bc.length ? es = Bc.concat(es) : db = -1, es.length && Y9());
}
function Y9() {
  if (!hf) {
    var t = X9(wge);
    hf = !0;
    for (var e = es.length; e; ) {
      for (Bc = es, es = []; ++db < e; )
        Bc && Bc[db].run();
      db = -1, e = es.length;
    }
    Bc = null, hf = !1, vge(t);
  }
}
In.nextTick = function(t) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n = 1; n < arguments.length; n++)
      e[n - 1] = arguments[n];
  es.push(new J9(t, e)), es.length === 1 && !hf && X9(Y9);
};
function J9(t, e) {
  this.fun = t, this.array = e;
}
J9.prototype.run = function() {
  this.fun.apply(null, this.array);
};
In.title = "browser";
In.browser = !0;
In.env = {};
In.argv = [];
In.version = "";
In.versions = {};
function xs() {
}
In.on = xs;
In.addListener = xs;
In.once = xs;
In.off = xs;
In.removeListener = xs;
In.removeAllListeners = xs;
In.emit = xs;
In.prependListener = xs;
In.prependOnceListener = xs;
In.listeners = function(t) {
  return [];
};
In.binding = function(t) {
  throw new Error("process.binding is not supported");
};
In.cwd = function() {
  return "/";
};
In.chdir = function(t) {
  throw new Error("process.chdir is not supported");
};
In.umask = function() {
  return 0;
};
var xge = K9.exports;
const _t = /* @__PURE__ */ bge(xge);
var n_, LI;
function Z9() {
  return LI || (LI = 1, n_ = zC.EventEmitter), n_;
}
var r_ = {}, mp = {}, PI;
function _ge() {
  if (PI)
    return mp;
  PI = 1, mp.byteLength = s, mp.toByteArray = c, mp.fromByteArray = f;
  for (var t = [], e = [], n = typeof Uint8Array < "u" ? Uint8Array : Array, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, o = r.length; i < o; ++i)
    t[i] = r[i], e[r.charCodeAt(i)] = i;
  e[45] = 62, e[95] = 63;
  function a(p) {
    var m = p.length;
    if (m % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var g = p.indexOf("=");
    g === -1 && (g = m);
    var b = g === m ? 0 : 4 - g % 4;
    return [g, b];
  }
  function s(p) {
    var m = a(p), g = m[0], b = m[1];
    return (g + b) * 3 / 4 - b;
  }
  function l(p, m, g) {
    return (m + g) * 3 / 4 - g;
  }
  function c(p) {
    var m, g = a(p), b = g[0], y = g[1], w = new n(l(p, b, y)), x = 0, k = y > 0 ? b - 4 : b, A;
    for (A = 0; A < k; A += 4)
      m = e[p.charCodeAt(A)] << 18 | e[p.charCodeAt(A + 1)] << 12 | e[p.charCodeAt(A + 2)] << 6 | e[p.charCodeAt(A + 3)], w[x++] = m >> 16 & 255, w[x++] = m >> 8 & 255, w[x++] = m & 255;
    return y === 2 && (m = e[p.charCodeAt(A)] << 2 | e[p.charCodeAt(A + 1)] >> 4, w[x++] = m & 255), y === 1 && (m = e[p.charCodeAt(A)] << 10 | e[p.charCodeAt(A + 1)] << 4 | e[p.charCodeAt(A + 2)] >> 2, w[x++] = m >> 8 & 255, w[x++] = m & 255), w;
  }
  function u(p) {
    return t[p >> 18 & 63] + t[p >> 12 & 63] + t[p >> 6 & 63] + t[p & 63];
  }
  function d(p, m, g) {
    for (var b, y = [], w = m; w < g; w += 3)
      b = (p[w] << 16 & 16711680) + (p[w + 1] << 8 & 65280) + (p[w + 2] & 255), y.push(u(b));
    return y.join("");
  }
  function f(p) {
    for (var m, g = p.length, b = g % 3, y = [], w = 16383, x = 0, k = g - b; x < k; x += w)
      y.push(d(p, x, x + w > k ? k : x + w));
    return b === 1 ? (m = p[g - 1], y.push(
      t[m >> 2] + t[m << 4 & 63] + "=="
    )) : b === 2 && (m = (p[g - 2] << 8) + p[g - 1], y.push(
      t[m >> 10] + t[m >> 4 & 63] + t[m << 2 & 63] + "="
    )), y.join("");
  }
  return mp;
}
var Ey = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var WI;
function Sge() {
  return WI || (WI = 1, Ey.read = function(t, e, n, r, i) {
    var o, a, s = i * 8 - r - 1, l = (1 << s) - 1, c = l >> 1, u = -7, d = n ? i - 1 : 0, f = n ? -1 : 1, p = t[e + d];
    for (d += f, o = p & (1 << -u) - 1, p >>= -u, u += s; u > 0; o = o * 256 + t[e + d], d += f, u -= 8)
      ;
    for (a = o & (1 << -u) - 1, o >>= -u, u += r; u > 0; a = a * 256 + t[e + d], d += f, u -= 8)
      ;
    if (o === 0)
      o = 1 - c;
    else {
      if (o === l)
        return a ? NaN : (p ? -1 : 1) * (1 / 0);
      a = a + Math.pow(2, r), o = o - c;
    }
    return (p ? -1 : 1) * a * Math.pow(2, o - r);
  }, Ey.write = function(t, e, n, r, i, o) {
    var a, s, l, c = o * 8 - i - 1, u = (1 << c) - 1, d = u >> 1, f = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = r ? 0 : o - 1, m = r ? 1 : -1, g = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, a = u) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), a + d >= 1 ? e += f / l : e += f * Math.pow(2, 1 - d), e * l >= 2 && (a++, l /= 2), a + d >= u ? (s = 0, a = u) : a + d >= 1 ? (s = (e * l - 1) * Math.pow(2, i), a = a + d) : (s = e * Math.pow(2, d - 1) * Math.pow(2, i), a = 0)); i >= 8; t[n + p] = s & 255, p += m, s /= 256, i -= 8)
      ;
    for (a = a << i | s, c += i; c > 0; t[n + p] = a & 255, p += m, a /= 256, c -= 8)
      ;
    t[n + p - m] |= g * 128;
  }), Ey;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var zI;
function D0() {
  return zI || (zI = 1, function(t) {
    var e = _ge(), n = Sge(), r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    t.Buffer = s, t.SlowBuffer = w, t.INSPECT_MAX_BYTES = 50;
    var i = 2147483647;
    t.kMaxLength = i, s.TYPED_ARRAY_SUPPORT = o(), !s.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function o() {
      try {
        var M = new Uint8Array(1), _ = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(_, Uint8Array.prototype), Object.setPrototypeOf(M, _), M.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(s.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (s.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(s.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (s.isBuffer(this))
          return this.byteOffset;
      }
    });
    function a(M) {
      if (M > i)
        throw new RangeError('The value "' + M + '" is invalid for option "size"');
      var _ = new Uint8Array(M);
      return Object.setPrototypeOf(_, s.prototype), _;
    }
    function s(M, _, S) {
      if (typeof M == "number") {
        if (typeof _ == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return d(M);
      }
      return l(M, _, S);
    }
    s.poolSize = 8192;
    function l(M, _, S) {
      if (typeof M == "string")
        return f(M, _);
      if (ArrayBuffer.isView(M))
        return m(M);
      if (M == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof M
        );
      if (De(M, ArrayBuffer) || M && De(M.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (De(M, SharedArrayBuffer) || M && De(M.buffer, SharedArrayBuffer)))
        return g(M, _, S);
      if (typeof M == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      var O = M.valueOf && M.valueOf();
      if (O != null && O !== M)
        return s.from(O, _, S);
      var ne = b(M);
      if (ne)
        return ne;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof M[Symbol.toPrimitive] == "function")
        return s.from(
          M[Symbol.toPrimitive]("string"),
          _,
          S
        );
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof M
      );
    }
    s.from = function(M, _, S) {
      return l(M, _, S);
    }, Object.setPrototypeOf(s.prototype, Uint8Array.prototype), Object.setPrototypeOf(s, Uint8Array);
    function c(M) {
      if (typeof M != "number")
        throw new TypeError('"size" argument must be of type number');
      if (M < 0)
        throw new RangeError('The value "' + M + '" is invalid for option "size"');
    }
    function u(M, _, S) {
      return c(M), M <= 0 ? a(M) : _ !== void 0 ? typeof S == "string" ? a(M).fill(_, S) : a(M).fill(_) : a(M);
    }
    s.alloc = function(M, _, S) {
      return u(M, _, S);
    };
    function d(M) {
      return c(M), a(M < 0 ? 0 : y(M) | 0);
    }
    s.allocUnsafe = function(M) {
      return d(M);
    }, s.allocUnsafeSlow = function(M) {
      return d(M);
    };
    function f(M, _) {
      if ((typeof _ != "string" || _ === "") && (_ = "utf8"), !s.isEncoding(_))
        throw new TypeError("Unknown encoding: " + _);
      var S = x(M, _) | 0, O = a(S), ne = O.write(M, _);
      return ne !== S && (O = O.slice(0, ne)), O;
    }
    function p(M) {
      for (var _ = M.length < 0 ? 0 : y(M.length) | 0, S = a(_), O = 0; O < _; O += 1)
        S[O] = M[O] & 255;
      return S;
    }
    function m(M) {
      if (De(M, Uint8Array)) {
        var _ = new Uint8Array(M);
        return g(_.buffer, _.byteOffset, _.byteLength);
      }
      return p(M);
    }
    function g(M, _, S) {
      if (_ < 0 || M.byteLength < _)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (M.byteLength < _ + (S || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      var O;
      return _ === void 0 && S === void 0 ? O = new Uint8Array(M) : S === void 0 ? O = new Uint8Array(M, _) : O = new Uint8Array(M, _, S), Object.setPrototypeOf(O, s.prototype), O;
    }
    function b(M) {
      if (s.isBuffer(M)) {
        var _ = y(M.length) | 0, S = a(_);
        return S.length === 0 || M.copy(S, 0, 0, _), S;
      }
      if (M.length !== void 0)
        return typeof M.length != "number" || T(M.length) ? a(0) : p(M);
      if (M.type === "Buffer" && Array.isArray(M.data))
        return p(M.data);
    }
    function y(M) {
      if (M >= i)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
      return M | 0;
    }
    function w(M) {
      return +M != M && (M = 0), s.alloc(+M);
    }
    s.isBuffer = function(_) {
      return _ != null && _._isBuffer === !0 && _ !== s.prototype;
    }, s.compare = function(_, S) {
      if (De(_, Uint8Array) && (_ = s.from(_, _.offset, _.byteLength)), De(S, Uint8Array) && (S = s.from(S, S.offset, S.byteLength)), !s.isBuffer(_) || !s.isBuffer(S))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (_ === S)
        return 0;
      for (var O = _.length, ne = S.length, fe = 0, J = Math.min(O, ne); fe < J; ++fe)
        if (_[fe] !== S[fe]) {
          O = _[fe], ne = S[fe];
          break;
        }
      return O < ne ? -1 : ne < O ? 1 : 0;
    }, s.isEncoding = function(_) {
      switch (String(_).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, s.concat = function(_, S) {
      if (!Array.isArray(_))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (_.length === 0)
        return s.alloc(0);
      var O;
      if (S === void 0)
        for (S = 0, O = 0; O < _.length; ++O)
          S += _[O].length;
      var ne = s.allocUnsafe(S), fe = 0;
      for (O = 0; O < _.length; ++O) {
        var J = _[O];
        if (De(J, Uint8Array))
          fe + J.length > ne.length ? s.from(J).copy(ne, fe) : Uint8Array.prototype.set.call(
            ne,
            J,
            fe
          );
        else if (s.isBuffer(J))
          J.copy(ne, fe);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        fe += J.length;
      }
      return ne;
    };
    function x(M, _) {
      if (s.isBuffer(M))
        return M.length;
      if (ArrayBuffer.isView(M) || De(M, ArrayBuffer))
        return M.byteLength;
      if (typeof M != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof M
        );
      var S = M.length, O = arguments.length > 2 && arguments[2] === !0;
      if (!O && S === 0)
        return 0;
      for (var ne = !1; ; )
        switch (_) {
          case "ascii":
          case "latin1":
          case "binary":
            return S;
          case "utf8":
          case "utf-8":
            return W(M).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return S * 2;
          case "hex":
            return S >>> 1;
          case "base64":
            return j(M).length;
          default:
            if (ne)
              return O ? -1 : W(M).length;
            _ = ("" + _).toLowerCase(), ne = !0;
        }
    }
    s.byteLength = x;
    function k(M, _, S) {
      var O = !1;
      if ((_ === void 0 || _ < 0) && (_ = 0), _ > this.length || ((S === void 0 || S > this.length) && (S = this.length), S <= 0) || (S >>>= 0, _ >>>= 0, S <= _))
        return "";
      for (M || (M = "utf8"); ; )
        switch (M) {
          case "hex":
            return te(this, _, S);
          case "utf8":
          case "utf-8":
            return C(this, _, S);
          case "ascii":
            return Z(this, _, S);
          case "latin1":
          case "binary":
            return oe(this, _, S);
          case "base64":
            return G(this, _, S);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return _e(this, _, S);
          default:
            if (O)
              throw new TypeError("Unknown encoding: " + M);
            M = (M + "").toLowerCase(), O = !0;
        }
    }
    s.prototype._isBuffer = !0;
    function A(M, _, S) {
      var O = M[_];
      M[_] = M[S], M[S] = O;
    }
    s.prototype.swap16 = function() {
      var _ = this.length;
      if (_ % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var S = 0; S < _; S += 2)
        A(this, S, S + 1);
      return this;
    }, s.prototype.swap32 = function() {
      var _ = this.length;
      if (_ % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var S = 0; S < _; S += 4)
        A(this, S, S + 3), A(this, S + 1, S + 2);
      return this;
    }, s.prototype.swap64 = function() {
      var _ = this.length;
      if (_ % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var S = 0; S < _; S += 8)
        A(this, S, S + 7), A(this, S + 1, S + 6), A(this, S + 2, S + 5), A(this, S + 3, S + 4);
      return this;
    }, s.prototype.toString = function() {
      var _ = this.length;
      return _ === 0 ? "" : arguments.length === 0 ? C(this, 0, _) : k.apply(this, arguments);
    }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(_) {
      if (!s.isBuffer(_))
        throw new TypeError("Argument must be a Buffer");
      return this === _ ? !0 : s.compare(this, _) === 0;
    }, s.prototype.inspect = function() {
      var _ = "", S = t.INSPECT_MAX_BYTES;
      return _ = this.toString("hex", 0, S).replace(/(.{2})/g, "$1 ").trim(), this.length > S && (_ += " ... "), "<Buffer " + _ + ">";
    }, r && (s.prototype[r] = s.prototype.inspect), s.prototype.compare = function(_, S, O, ne, fe) {
      if (De(_, Uint8Array) && (_ = s.from(_, _.offset, _.byteLength)), !s.isBuffer(_))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof _
        );
      if (S === void 0 && (S = 0), O === void 0 && (O = _ ? _.length : 0), ne === void 0 && (ne = 0), fe === void 0 && (fe = this.length), S < 0 || O > _.length || ne < 0 || fe > this.length)
        throw new RangeError("out of range index");
      if (ne >= fe && S >= O)
        return 0;
      if (ne >= fe)
        return -1;
      if (S >= O)
        return 1;
      if (S >>>= 0, O >>>= 0, ne >>>= 0, fe >>>= 0, this === _)
        return 0;
      for (var J = fe - ne, re = O - S, de = Math.min(J, re), ge = this.slice(ne, fe), Ee = _.slice(S, O), Ne = 0; Ne < de; ++Ne)
        if (ge[Ne] !== Ee[Ne]) {
          J = ge[Ne], re = Ee[Ne];
          break;
        }
      return J < re ? -1 : re < J ? 1 : 0;
    };
    function U(M, _, S, O, ne) {
      if (M.length === 0)
        return -1;
      if (typeof S == "string" ? (O = S, S = 0) : S > 2147483647 ? S = 2147483647 : S < -2147483648 && (S = -2147483648), S = +S, T(S) && (S = ne ? 0 : M.length - 1), S < 0 && (S = M.length + S), S >= M.length) {
        if (ne)
          return -1;
        S = M.length - 1;
      } else if (S < 0)
        if (ne)
          S = 0;
        else
          return -1;
      if (typeof _ == "string" && (_ = s.from(_, O)), s.isBuffer(_))
        return _.length === 0 ? -1 : P(M, _, S, O, ne);
      if (typeof _ == "number")
        return _ = _ & 255, typeof Uint8Array.prototype.indexOf == "function" ? ne ? Uint8Array.prototype.indexOf.call(M, _, S) : Uint8Array.prototype.lastIndexOf.call(M, _, S) : P(M, [_], S, O, ne);
      throw new TypeError("val must be string, number or Buffer");
    }
    function P(M, _, S, O, ne) {
      var fe = 1, J = M.length, re = _.length;
      if (O !== void 0 && (O = String(O).toLowerCase(), O === "ucs2" || O === "ucs-2" || O === "utf16le" || O === "utf-16le")) {
        if (M.length < 2 || _.length < 2)
          return -1;
        fe = 2, J /= 2, re /= 2, S /= 2;
      }
      function de(Qe, Ze) {
        return fe === 1 ? Qe[Ze] : Qe.readUInt16BE(Ze * fe);
      }
      var ge;
      if (ne) {
        var Ee = -1;
        for (ge = S; ge < J; ge++)
          if (de(M, ge) === de(_, Ee === -1 ? 0 : ge - Ee)) {
            if (Ee === -1 && (Ee = ge), ge - Ee + 1 === re)
              return Ee * fe;
          } else
            Ee !== -1 && (ge -= ge - Ee), Ee = -1;
      } else
        for (S + re > J && (S = J - re), ge = S; ge >= 0; ge--) {
          for (var Ne = !0, Le = 0; Le < re; Le++)
            if (de(M, ge + Le) !== de(_, Le)) {
              Ne = !1;
              break;
            }
          if (Ne)
            return ge;
        }
      return -1;
    }
    s.prototype.includes = function(_, S, O) {
      return this.indexOf(_, S, O) !== -1;
    }, s.prototype.indexOf = function(_, S, O) {
      return U(this, _, S, O, !0);
    }, s.prototype.lastIndexOf = function(_, S, O) {
      return U(this, _, S, O, !1);
    };
    function V(M, _, S, O) {
      S = Number(S) || 0;
      var ne = M.length - S;
      O ? (O = Number(O), O > ne && (O = ne)) : O = ne;
      var fe = _.length;
      O > fe / 2 && (O = fe / 2);
      for (var J = 0; J < O; ++J) {
        var re = parseInt(_.substr(J * 2, 2), 16);
        if (T(re))
          return J;
        M[S + J] = re;
      }
      return J;
    }
    function I(M, _, S, O) {
      return Q(W(_, M.length - S), M, S, O);
    }
    function le(M, _, S, O) {
      return Q(we(_), M, S, O);
    }
    function be(M, _, S, O) {
      return Q(j(_), M, S, O);
    }
    function F(M, _, S, O) {
      return Q(ye(_, M.length - S), M, S, O);
    }
    s.prototype.write = function(_, S, O, ne) {
      if (S === void 0)
        ne = "utf8", O = this.length, S = 0;
      else if (O === void 0 && typeof S == "string")
        ne = S, O = this.length, S = 0;
      else if (isFinite(S))
        S = S >>> 0, isFinite(O) ? (O = O >>> 0, ne === void 0 && (ne = "utf8")) : (ne = O, O = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      var fe = this.length - S;
      if ((O === void 0 || O > fe) && (O = fe), _.length > 0 && (O < 0 || S < 0) || S > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      ne || (ne = "utf8");
      for (var J = !1; ; )
        switch (ne) {
          case "hex":
            return V(this, _, S, O);
          case "utf8":
          case "utf-8":
            return I(this, _, S, O);
          case "ascii":
          case "latin1":
          case "binary":
            return le(this, _, S, O);
          case "base64":
            return be(this, _, S, O);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return F(this, _, S, O);
          default:
            if (J)
              throw new TypeError("Unknown encoding: " + ne);
            ne = ("" + ne).toLowerCase(), J = !0;
        }
    }, s.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function G(M, _, S) {
      return _ === 0 && S === M.length ? e.fromByteArray(M) : e.fromByteArray(M.slice(_, S));
    }
    function C(M, _, S) {
      S = Math.min(M.length, S);
      for (var O = [], ne = _; ne < S; ) {
        var fe = M[ne], J = null, re = fe > 239 ? 4 : fe > 223 ? 3 : fe > 191 ? 2 : 1;
        if (ne + re <= S) {
          var de, ge, Ee, Ne;
          switch (re) {
            case 1:
              fe < 128 && (J = fe);
              break;
            case 2:
              de = M[ne + 1], (de & 192) === 128 && (Ne = (fe & 31) << 6 | de & 63, Ne > 127 && (J = Ne));
              break;
            case 3:
              de = M[ne + 1], ge = M[ne + 2], (de & 192) === 128 && (ge & 192) === 128 && (Ne = (fe & 15) << 12 | (de & 63) << 6 | ge & 63, Ne > 2047 && (Ne < 55296 || Ne > 57343) && (J = Ne));
              break;
            case 4:
              de = M[ne + 1], ge = M[ne + 2], Ee = M[ne + 3], (de & 192) === 128 && (ge & 192) === 128 && (Ee & 192) === 128 && (Ne = (fe & 15) << 18 | (de & 63) << 12 | (ge & 63) << 6 | Ee & 63, Ne > 65535 && Ne < 1114112 && (J = Ne));
          }
        }
        J === null ? (J = 65533, re = 1) : J > 65535 && (J -= 65536, O.push(J >>> 10 & 1023 | 55296), J = 56320 | J & 1023), O.push(J), ne += re;
      }
      return ee(O);
    }
    var ie = 4096;
    function ee(M) {
      var _ = M.length;
      if (_ <= ie)
        return String.fromCharCode.apply(String, M);
      for (var S = "", O = 0; O < _; )
        S += String.fromCharCode.apply(
          String,
          M.slice(O, O += ie)
        );
      return S;
    }
    function Z(M, _, S) {
      var O = "";
      S = Math.min(M.length, S);
      for (var ne = _; ne < S; ++ne)
        O += String.fromCharCode(M[ne] & 127);
      return O;
    }
    function oe(M, _, S) {
      var O = "";
      S = Math.min(M.length, S);
      for (var ne = _; ne < S; ++ne)
        O += String.fromCharCode(M[ne]);
      return O;
    }
    function te(M, _, S) {
      var O = M.length;
      (!_ || _ < 0) && (_ = 0), (!S || S < 0 || S > O) && (S = O);
      for (var ne = "", fe = _; fe < S; ++fe)
        ne += pe[M[fe]];
      return ne;
    }
    function _e(M, _, S) {
      for (var O = M.slice(_, S), ne = "", fe = 0; fe < O.length - 1; fe += 2)
        ne += String.fromCharCode(O[fe] + O[fe + 1] * 256);
      return ne;
    }
    s.prototype.slice = function(_, S) {
      var O = this.length;
      _ = ~~_, S = S === void 0 ? O : ~~S, _ < 0 ? (_ += O, _ < 0 && (_ = 0)) : _ > O && (_ = O), S < 0 ? (S += O, S < 0 && (S = 0)) : S > O && (S = O), S < _ && (S = _);
      var ne = this.subarray(_, S);
      return Object.setPrototypeOf(ne, s.prototype), ne;
    };
    function q(M, _, S) {
      if (M % 1 !== 0 || M < 0)
        throw new RangeError("offset is not uint");
      if (M + _ > S)
        throw new RangeError("Trying to access beyond buffer length");
    }
    s.prototype.readUintLE = s.prototype.readUIntLE = function(_, S, O) {
      _ = _ >>> 0, S = S >>> 0, O || q(_, S, this.length);
      for (var ne = this[_], fe = 1, J = 0; ++J < S && (fe *= 256); )
        ne += this[_ + J] * fe;
      return ne;
    }, s.prototype.readUintBE = s.prototype.readUIntBE = function(_, S, O) {
      _ = _ >>> 0, S = S >>> 0, O || q(_, S, this.length);
      for (var ne = this[_ + --S], fe = 1; S > 0 && (fe *= 256); )
        ne += this[_ + --S] * fe;
      return ne;
    }, s.prototype.readUint8 = s.prototype.readUInt8 = function(_, S) {
      return _ = _ >>> 0, S || q(_, 1, this.length), this[_];
    }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function(_, S) {
      return _ = _ >>> 0, S || q(_, 2, this.length), this[_] | this[_ + 1] << 8;
    }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function(_, S) {
      return _ = _ >>> 0, S || q(_, 2, this.length), this[_] << 8 | this[_ + 1];
    }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function(_, S) {
      return _ = _ >>> 0, S || q(_, 4, this.length), (this[_] | this[_ + 1] << 8 | this[_ + 2] << 16) + this[_ + 3] * 16777216;
    }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function(_, S) {
      return _ = _ >>> 0, S || q(_, 4, this.length), this[_] * 16777216 + (this[_ + 1] << 16 | this[_ + 2] << 8 | this[_ + 3]);
    }, s.prototype.readIntLE = function(_, S, O) {
      _ = _ >>> 0, S = S >>> 0, O || q(_, S, this.length);
      for (var ne = this[_], fe = 1, J = 0; ++J < S && (fe *= 256); )
        ne += this[_ + J] * fe;
      return fe *= 128, ne >= fe && (ne -= Math.pow(2, 8 * S)), ne;
    }, s.prototype.readIntBE = function(_, S, O) {
      _ = _ >>> 0, S = S >>> 0, O || q(_, S, this.length);
      for (var ne = S, fe = 1, J = this[_ + --ne]; ne > 0 && (fe *= 256); )
        J += this[_ + --ne] * fe;
      return fe *= 128, J >= fe && (J -= Math.pow(2, 8 * S)), J;
    }, s.prototype.readInt8 = function(_, S) {
      return _ = _ >>> 0, S || q(_, 1, this.length), this[_] & 128 ? (255 - this[_] + 1) * -1 : this[_];
    }, s.prototype.readInt16LE = function(_, S) {
      _ = _ >>> 0, S || q(_, 2, this.length);
      var O = this[_] | this[_ + 1] << 8;
      return O & 32768 ? O | 4294901760 : O;
    }, s.prototype.readInt16BE = function(_, S) {
      _ = _ >>> 0, S || q(_, 2, this.length);
      var O = this[_ + 1] | this[_] << 8;
      return O & 32768 ? O | 4294901760 : O;
    }, s.prototype.readInt32LE = function(_, S) {
      return _ = _ >>> 0, S || q(_, 4, this.length), this[_] | this[_ + 1] << 8 | this[_ + 2] << 16 | this[_ + 3] << 24;
    }, s.prototype.readInt32BE = function(_, S) {
      return _ = _ >>> 0, S || q(_, 4, this.length), this[_] << 24 | this[_ + 1] << 16 | this[_ + 2] << 8 | this[_ + 3];
    }, s.prototype.readFloatLE = function(_, S) {
      return _ = _ >>> 0, S || q(_, 4, this.length), n.read(this, _, !0, 23, 4);
    }, s.prototype.readFloatBE = function(_, S) {
      return _ = _ >>> 0, S || q(_, 4, this.length), n.read(this, _, !1, 23, 4);
    }, s.prototype.readDoubleLE = function(_, S) {
      return _ = _ >>> 0, S || q(_, 8, this.length), n.read(this, _, !0, 52, 8);
    }, s.prototype.readDoubleBE = function(_, S) {
      return _ = _ >>> 0, S || q(_, 8, this.length), n.read(this, _, !1, 52, 8);
    };
    function N(M, _, S, O, ne, fe) {
      if (!s.isBuffer(M))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (_ > ne || _ < fe)
        throw new RangeError('"value" argument is out of bounds');
      if (S + O > M.length)
        throw new RangeError("Index out of range");
    }
    s.prototype.writeUintLE = s.prototype.writeUIntLE = function(_, S, O, ne) {
      if (_ = +_, S = S >>> 0, O = O >>> 0, !ne) {
        var fe = Math.pow(2, 8 * O) - 1;
        N(this, _, S, O, fe, 0);
      }
      var J = 1, re = 0;
      for (this[S] = _ & 255; ++re < O && (J *= 256); )
        this[S + re] = _ / J & 255;
      return S + O;
    }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function(_, S, O, ne) {
      if (_ = +_, S = S >>> 0, O = O >>> 0, !ne) {
        var fe = Math.pow(2, 8 * O) - 1;
        N(this, _, S, O, fe, 0);
      }
      var J = O - 1, re = 1;
      for (this[S + J] = _ & 255; --J >= 0 && (re *= 256); )
        this[S + J] = _ / re & 255;
      return S + O;
    }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function(_, S, O) {
      return _ = +_, S = S >>> 0, O || N(this, _, S, 1, 255, 0), this[S] = _ & 255, S + 1;
    }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function(_, S, O) {
      return _ = +_, S = S >>> 0, O || N(this, _, S, 2, 65535, 0), this[S] = _ & 255, this[S + 1] = _ >>> 8, S + 2;
    }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function(_, S, O) {
      return _ = +_, S = S >>> 0, O || N(this, _, S, 2, 65535, 0), this[S] = _ >>> 8, this[S + 1] = _ & 255, S + 2;
    }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function(_, S, O) {
      return _ = +_, S = S >>> 0, O || N(this, _, S, 4, 4294967295, 0), this[S + 3] = _ >>> 24, this[S + 2] = _ >>> 16, this[S + 1] = _ >>> 8, this[S] = _ & 255, S + 4;
    }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function(_, S, O) {
      return _ = +_, S = S >>> 0, O || N(this, _, S, 4, 4294967295, 0), this[S] = _ >>> 24, this[S + 1] = _ >>> 16, this[S + 2] = _ >>> 8, this[S + 3] = _ & 255, S + 4;
    }, s.prototype.writeIntLE = function(_, S, O, ne) {
      if (_ = +_, S = S >>> 0, !ne) {
        var fe = Math.pow(2, 8 * O - 1);
        N(this, _, S, O, fe - 1, -fe);
      }
      var J = 0, re = 1, de = 0;
      for (this[S] = _ & 255; ++J < O && (re *= 256); )
        _ < 0 && de === 0 && this[S + J - 1] !== 0 && (de = 1), this[S + J] = (_ / re >> 0) - de & 255;
      return S + O;
    }, s.prototype.writeIntBE = function(_, S, O, ne) {
      if (_ = +_, S = S >>> 0, !ne) {
        var fe = Math.pow(2, 8 * O - 1);
        N(this, _, S, O, fe - 1, -fe);
      }
      var J = O - 1, re = 1, de = 0;
      for (this[S + J] = _ & 255; --J >= 0 && (re *= 256); )
        _ < 0 && de === 0 && this[S + J + 1] !== 0 && (de = 1), this[S + J] = (_ / re >> 0) - de & 255;
      return S + O;
    }, s.prototype.writeInt8 = function(_, S, O) {
      return _ = +_, S = S >>> 0, O || N(this, _, S, 1, 127, -128), _ < 0 && (_ = 255 + _ + 1), this[S] = _ & 255, S + 1;
    }, s.prototype.writeInt16LE = function(_, S, O) {
      return _ = +_, S = S >>> 0, O || N(this, _, S, 2, 32767, -32768), this[S] = _ & 255, this[S + 1] = _ >>> 8, S + 2;
    }, s.prototype.writeInt16BE = function(_, S, O) {
      return _ = +_, S = S >>> 0, O || N(this, _, S, 2, 32767, -32768), this[S] = _ >>> 8, this[S + 1] = _ & 255, S + 2;
    }, s.prototype.writeInt32LE = function(_, S, O) {
      return _ = +_, S = S >>> 0, O || N(this, _, S, 4, 2147483647, -2147483648), this[S] = _ & 255, this[S + 1] = _ >>> 8, this[S + 2] = _ >>> 16, this[S + 3] = _ >>> 24, S + 4;
    }, s.prototype.writeInt32BE = function(_, S, O) {
      return _ = +_, S = S >>> 0, O || N(this, _, S, 4, 2147483647, -2147483648), _ < 0 && (_ = 4294967295 + _ + 1), this[S] = _ >>> 24, this[S + 1] = _ >>> 16, this[S + 2] = _ >>> 8, this[S + 3] = _ & 255, S + 4;
    };
    function ce(M, _, S, O, ne, fe) {
      if (S + O > M.length)
        throw new RangeError("Index out of range");
      if (S < 0)
        throw new RangeError("Index out of range");
    }
    function me(M, _, S, O, ne) {
      return _ = +_, S = S >>> 0, ne || ce(M, _, S, 4), n.write(M, _, S, O, 23, 4), S + 4;
    }
    s.prototype.writeFloatLE = function(_, S, O) {
      return me(this, _, S, !0, O);
    }, s.prototype.writeFloatBE = function(_, S, O) {
      return me(this, _, S, !1, O);
    };
    function ve(M, _, S, O, ne) {
      return _ = +_, S = S >>> 0, ne || ce(M, _, S, 8), n.write(M, _, S, O, 52, 8), S + 8;
    }
    s.prototype.writeDoubleLE = function(_, S, O) {
      return ve(this, _, S, !0, O);
    }, s.prototype.writeDoubleBE = function(_, S, O) {
      return ve(this, _, S, !1, O);
    }, s.prototype.copy = function(_, S, O, ne) {
      if (!s.isBuffer(_))
        throw new TypeError("argument should be a Buffer");
      if (O || (O = 0), !ne && ne !== 0 && (ne = this.length), S >= _.length && (S = _.length), S || (S = 0), ne > 0 && ne < O && (ne = O), ne === O || _.length === 0 || this.length === 0)
        return 0;
      if (S < 0)
        throw new RangeError("targetStart out of bounds");
      if (O < 0 || O >= this.length)
        throw new RangeError("Index out of range");
      if (ne < 0)
        throw new RangeError("sourceEnd out of bounds");
      ne > this.length && (ne = this.length), _.length - S < ne - O && (ne = _.length - S + O);
      var fe = ne - O;
      return this === _ && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(S, O, ne) : Uint8Array.prototype.set.call(
        _,
        this.subarray(O, ne),
        S
      ), fe;
    }, s.prototype.fill = function(_, S, O, ne) {
      if (typeof _ == "string") {
        if (typeof S == "string" ? (ne = S, S = 0, O = this.length) : typeof O == "string" && (ne = O, O = this.length), ne !== void 0 && typeof ne != "string")
          throw new TypeError("encoding must be a string");
        if (typeof ne == "string" && !s.isEncoding(ne))
          throw new TypeError("Unknown encoding: " + ne);
        if (_.length === 1) {
          var fe = _.charCodeAt(0);
          (ne === "utf8" && fe < 128 || ne === "latin1") && (_ = fe);
        }
      } else typeof _ == "number" ? _ = _ & 255 : typeof _ == "boolean" && (_ = Number(_));
      if (S < 0 || this.length < S || this.length < O)
        throw new RangeError("Out of range index");
      if (O <= S)
        return this;
      S = S >>> 0, O = O === void 0 ? this.length : O >>> 0, _ || (_ = 0);
      var J;
      if (typeof _ == "number")
        for (J = S; J < O; ++J)
          this[J] = _;
      else {
        var re = s.isBuffer(_) ? _ : s.from(_, ne), de = re.length;
        if (de === 0)
          throw new TypeError('The value "' + _ + '" is invalid for argument "value"');
        for (J = 0; J < O - S; ++J)
          this[J + S] = re[J % de];
      }
      return this;
    };
    var he = /[^+/0-9A-Za-z-_]/g;
    function H(M) {
      if (M = M.split("=")[0], M = M.trim().replace(he, ""), M.length < 2)
        return "";
      for (; M.length % 4 !== 0; )
        M = M + "=";
      return M;
    }
    function W(M, _) {
      _ = _ || 1 / 0;
      for (var S, O = M.length, ne = null, fe = [], J = 0; J < O; ++J) {
        if (S = M.charCodeAt(J), S > 55295 && S < 57344) {
          if (!ne) {
            if (S > 56319) {
              (_ -= 3) > -1 && fe.push(239, 191, 189);
              continue;
            } else if (J + 1 === O) {
              (_ -= 3) > -1 && fe.push(239, 191, 189);
              continue;
            }
            ne = S;
            continue;
          }
          if (S < 56320) {
            (_ -= 3) > -1 && fe.push(239, 191, 189), ne = S;
            continue;
          }
          S = (ne - 55296 << 10 | S - 56320) + 65536;
        } else ne && (_ -= 3) > -1 && fe.push(239, 191, 189);
        if (ne = null, S < 128) {
          if ((_ -= 1) < 0)
            break;
          fe.push(S);
        } else if (S < 2048) {
          if ((_ -= 2) < 0)
            break;
          fe.push(
            S >> 6 | 192,
            S & 63 | 128
          );
        } else if (S < 65536) {
          if ((_ -= 3) < 0)
            break;
          fe.push(
            S >> 12 | 224,
            S >> 6 & 63 | 128,
            S & 63 | 128
          );
        } else if (S < 1114112) {
          if ((_ -= 4) < 0)
            break;
          fe.push(
            S >> 18 | 240,
            S >> 12 & 63 | 128,
            S >> 6 & 63 | 128,
            S & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return fe;
    }
    function we(M) {
      for (var _ = [], S = 0; S < M.length; ++S)
        _.push(M.charCodeAt(S) & 255);
      return _;
    }
    function ye(M, _) {
      for (var S, O, ne, fe = [], J = 0; J < M.length && !((_ -= 2) < 0); ++J)
        S = M.charCodeAt(J), O = S >> 8, ne = S % 256, fe.push(ne), fe.push(O);
      return fe;
    }
    function j(M) {
      return e.toByteArray(H(M));
    }
    function Q(M, _, S, O) {
      for (var ne = 0; ne < O && !(ne + S >= _.length || ne >= M.length); ++ne)
        _[ne + S] = M[ne];
      return ne;
    }
    function De(M, _) {
      return M instanceof _ || M != null && M.constructor != null && M.constructor.name != null && M.constructor.name === _.name;
    }
    function T(M) {
      return M !== M;
    }
    var pe = function() {
      for (var M = "0123456789abcdef", _ = new Array(256), S = 0; S < 16; ++S)
        for (var O = S * 16, ne = 0; ne < 16; ++ne)
          _[O + ne] = M[S] + M[ne];
      return _;
    }();
  }(r_)), r_;
}
var i_ = {}, o_ = {}, a_, $I;
function Q9() {
  return $I || ($I = 1, a_ = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var e = {}, n = Symbol("test"), r = Object(n);
    if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
      return !1;
    var i = 42;
    e[n] = i;
    for (n in e)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
      return !1;
    var o = Object.getOwnPropertySymbols(e);
    if (o.length !== 1 || o[0] !== n || !Object.prototype.propertyIsEnumerable.call(e, n))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var a = Object.getOwnPropertyDescriptor(e, n);
      if (a.value !== i || a.enumerable !== !0)
        return !1;
    }
    return !0;
  }), a_;
}
var s_, HI;
function $C() {
  if (HI)
    return s_;
  HI = 1;
  var t = Q9();
  return s_ = function() {
    return t() && !!Symbol.toStringTag;
  }, s_;
}
var l_, jI;
function Tge() {
  if (jI)
    return l_;
  jI = 1;
  var t = typeof Symbol < "u" && Symbol, e = Q9();
  return l_ = function() {
    return typeof t != "function" || typeof Symbol != "function" || typeof t("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : e();
  }, l_;
}
var c_, VI;
function Dge() {
  if (VI)
    return c_;
  VI = 1;
  var t = {
    foo: {}
  }, e = Object;
  return c_ = function() {
    return { __proto__: t }.foo === t.foo && !({ __proto__: null } instanceof e);
  }, c_;
}
var u_, qI;
function Ege() {
  if (qI)
    return u_;
  qI = 1;
  var t = "Function.prototype.bind called on incompatible ", e = Object.prototype.toString, n = Math.max, r = "[object Function]", i = function(l, c) {
    for (var u = [], d = 0; d < l.length; d += 1)
      u[d] = l[d];
    for (var f = 0; f < c.length; f += 1)
      u[f + l.length] = c[f];
    return u;
  }, o = function(l, c) {
    for (var u = [], d = c, f = 0; d < l.length; d += 1, f += 1)
      u[f] = l[d];
    return u;
  }, a = function(s, l) {
    for (var c = "", u = 0; u < s.length; u += 1)
      c += s[u], u + 1 < s.length && (c += l);
    return c;
  };
  return u_ = function(l) {
    var c = this;
    if (typeof c != "function" || e.apply(c) !== r)
      throw new TypeError(t + c);
    for (var u = o(arguments, 1), d, f = function() {
      if (this instanceof d) {
        var y = c.apply(
          this,
          i(u, arguments)
        );
        return Object(y) === y ? y : this;
      }
      return c.apply(
        l,
        i(u, arguments)
      );
    }, p = n(0, c.length - u.length), m = [], g = 0; g < p; g++)
      m[g] = "$" + g;
    if (d = Function("binder", "return function (" + a(m, ",") + "){ return binder.apply(this,arguments); }")(f), c.prototype) {
      var b = function() {
      };
      b.prototype = c.prototype, d.prototype = new b(), b.prototype = null;
    }
    return d;
  }, u_;
}
var d_, GI;
function HC() {
  if (GI)
    return d_;
  GI = 1;
  var t = Ege();
  return d_ = Function.prototype.bind || t, d_;
}
var f_, KI;
function Cge() {
  if (KI)
    return f_;
  KI = 1;
  var t = Function.prototype.call, e = Object.prototype.hasOwnProperty, n = HC();
  return f_ = n.call(t, e), f_;
}
var h_, XI;
function sh() {
  if (XI)
    return h_;
  XI = 1;
  var t, e = SyntaxError, n = Function, r = TypeError, i = function(F) {
    try {
      return n('"use strict"; return (' + F + ").constructor;")();
    } catch {
    }
  }, o = Object.getOwnPropertyDescriptor;
  if (o)
    try {
      o({}, "");
    } catch {
      o = null;
    }
  var a = function() {
    throw new r();
  }, s = o ? function() {
    try {
      return arguments.callee, a;
    } catch {
      try {
        return o(arguments, "callee").get;
      } catch {
        return a;
      }
    }
  }() : a, l = Tge()(), c = Dge()(), u = Object.getPrototypeOf || (c ? function(F) {
    return F.__proto__;
  } : null), d = {}, f = typeof Uint8Array > "u" || !u ? t : u(Uint8Array), p = {
    "%AggregateError%": typeof AggregateError > "u" ? t : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? t : ArrayBuffer,
    "%ArrayIteratorPrototype%": l && u ? u([][Symbol.iterator]()) : t,
    "%AsyncFromSyncIteratorPrototype%": t,
    "%AsyncFunction%": d,
    "%AsyncGenerator%": d,
    "%AsyncGeneratorFunction%": d,
    "%AsyncIteratorPrototype%": d,
    "%Atomics%": typeof Atomics > "u" ? t : Atomics,
    "%BigInt%": typeof BigInt > "u" ? t : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? t : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? t : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? t : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array > "u" ? t : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? t : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? t : FinalizationRegistry,
    "%Function%": n,
    "%GeneratorFunction%": d,
    "%Int8Array%": typeof Int8Array > "u" ? t : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? t : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? t : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": l && u ? u(u([][Symbol.iterator]())) : t,
    "%JSON%": typeof JSON == "object" ? JSON : t,
    "%Map%": typeof Map > "u" ? t : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !l || !u ? t : u((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? t : Promise,
    "%Proxy%": typeof Proxy > "u" ? t : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect > "u" ? t : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? t : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !l || !u ? t : u((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? t : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": l && u ? u(""[Symbol.iterator]()) : t,
    "%Symbol%": l ? Symbol : t,
    "%SyntaxError%": e,
    "%ThrowTypeError%": s,
    "%TypedArray%": f,
    "%TypeError%": r,
    "%Uint8Array%": typeof Uint8Array > "u" ? t : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? t : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? t : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? t : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap > "u" ? t : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? t : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? t : WeakSet
  };
  if (u)
    try {
      null.error;
    } catch (F) {
      var m = u(u(F));
      p["%Error.prototype%"] = m;
    }
  var g = function F(G) {
    var C;
    if (G === "%AsyncFunction%")
      C = i("async function () {}");
    else if (G === "%GeneratorFunction%")
      C = i("function* () {}");
    else if (G === "%AsyncGeneratorFunction%")
      C = i("async function* () {}");
    else if (G === "%AsyncGenerator%") {
      var ie = F("%AsyncGeneratorFunction%");
      ie && (C = ie.prototype);
    } else if (G === "%AsyncIteratorPrototype%") {
      var ee = F("%AsyncGenerator%");
      ee && u && (C = u(ee.prototype));
    }
    return p[G] = C, C;
  }, b = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, y = HC(), w = Cge(), x = y.call(Function.call, Array.prototype.concat), k = y.call(Function.apply, Array.prototype.splice), A = y.call(Function.call, String.prototype.replace), U = y.call(Function.call, String.prototype.slice), P = y.call(Function.call, RegExp.prototype.exec), V = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, I = /\\(\\)?/g, le = function(G) {
    var C = U(G, 0, 1), ie = U(G, -1);
    if (C === "%" && ie !== "%")
      throw new e("invalid intrinsic syntax, expected closing `%`");
    if (ie === "%" && C !== "%")
      throw new e("invalid intrinsic syntax, expected opening `%`");
    var ee = [];
    return A(G, V, function(Z, oe, te, _e) {
      ee[ee.length] = te ? A(_e, I, "$1") : oe || Z;
    }), ee;
  }, be = function(G, C) {
    var ie = G, ee;
    if (w(b, ie) && (ee = b[ie], ie = "%" + ee[0] + "%"), w(p, ie)) {
      var Z = p[ie];
      if (Z === d && (Z = g(ie)), typeof Z > "u" && !C)
        throw new r("intrinsic " + G + " exists, but is not available. Please file an issue!");
      return {
        alias: ee,
        name: ie,
        value: Z
      };
    }
    throw new e("intrinsic " + G + " does not exist!");
  };
  return h_ = function(G, C) {
    if (typeof G != "string" || G.length === 0)
      throw new r("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof C != "boolean")
      throw new r('"allowMissing" argument must be a boolean');
    if (P(/^%?[^%]*%?$/, G) === null)
      throw new e("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var ie = le(G), ee = ie.length > 0 ? ie[0] : "", Z = be("%" + ee + "%", C), oe = Z.name, te = Z.value, _e = !1, q = Z.alias;
    q && (ee = q[0], k(ie, x([0, 1], q)));
    for (var N = 1, ce = !0; N < ie.length; N += 1) {
      var me = ie[N], ve = U(me, 0, 1), he = U(me, -1);
      if ((ve === '"' || ve === "'" || ve === "`" || he === '"' || he === "'" || he === "`") && ve !== he)
        throw new e("property names with quotes must have matching quotes");
      if ((me === "constructor" || !ce) && (_e = !0), ee += "." + me, oe = "%" + ee + "%", w(p, oe))
        te = p[oe];
      else if (te != null) {
        if (!(me in te)) {
          if (!C)
            throw new r("base intrinsic for " + G + " exists, but the property is not available.");
          return;
        }
        if (o && N + 1 >= ie.length) {
          var H = o(te, me);
          ce = !!H, ce && "get" in H && !("originalValue" in H.get) ? te = H.get : te = te[me];
        } else
          ce = w(te, me), te = te[me];
        ce && !_e && (p[oe] = te);
      }
    }
    return te;
  }, h_;
}
var p_ = { exports: {} }, m_, YI;
function eP() {
  if (YI)
    return m_;
  YI = 1;
  var t = sh(), e = t("%Object.defineProperty%", !0), n = function() {
    if (e)
      try {
        return e({}, "a", { value: 1 }), !0;
      } catch {
        return !1;
      }
    return !1;
  };
  return n.hasArrayLengthDefineBug = function() {
    if (!n())
      return null;
    try {
      return e([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, m_ = n, m_;
}
var g_, JI;
function jC() {
  if (JI)
    return g_;
  JI = 1;
  var t = sh(), e = t("%Object.getOwnPropertyDescriptor%", !0);
  if (e)
    try {
      e([], "length");
    } catch {
      e = null;
    }
  return g_ = e, g_;
}
var y_, ZI;
function kge() {
  if (ZI)
    return y_;
  ZI = 1;
  var t = eP()(), e = sh(), n = t && e("%Object.defineProperty%", !0);
  if (n)
    try {
      n({}, "a", { value: 1 });
    } catch {
      n = !1;
    }
  var r = e("%SyntaxError%"), i = e("%TypeError%"), o = jC();
  return y_ = function(s, l, c) {
    if (!s || typeof s != "object" && typeof s != "function")
      throw new i("`obj` must be an object or a function`");
    if (typeof l != "string" && typeof l != "symbol")
      throw new i("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new i("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new i("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new i("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new i("`loose`, if provided, must be a boolean");
    var u = arguments.length > 3 ? arguments[3] : null, d = arguments.length > 4 ? arguments[4] : null, f = arguments.length > 5 ? arguments[5] : null, p = arguments.length > 6 ? arguments[6] : !1, m = !!o && o(s, l);
    if (n)
      n(s, l, {
        configurable: f === null && m ? m.configurable : !f,
        enumerable: u === null && m ? m.enumerable : !u,
        value: c,
        writable: d === null && m ? m.writable : !d
      });
    else if (p || !u && !d && !f)
      s[l] = c;
    else
      throw new r("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, y_;
}
var b_, QI;
function Age() {
  if (QI)
    return b_;
  QI = 1;
  var t = sh(), e = kge(), n = eP()(), r = jC(), i = t("%TypeError%"), o = t("%Math.floor%");
  return b_ = function(s, l) {
    if (typeof s != "function")
      throw new i("`fn` is not a function");
    if (typeof l != "number" || l < 0 || l > 4294967295 || o(l) !== l)
      throw new i("`length` must be a positive 32-bit integer");
    var c = arguments.length > 2 && !!arguments[2], u = !0, d = !0;
    if ("length" in s && r) {
      var f = r(s, "length");
      f && !f.configurable && (u = !1), f && !f.writable && (d = !1);
    }
    return (u || d || !c) && (n ? e(s, "length", l, !0, !0) : e(s, "length", l)), s;
  }, b_;
}
var eO;
function tP() {
  return eO || (eO = 1, function(t) {
    var e = HC(), n = sh(), r = Age(), i = n("%TypeError%"), o = n("%Function.prototype.apply%"), a = n("%Function.prototype.call%"), s = n("%Reflect.apply%", !0) || e.call(a, o), l = n("%Object.defineProperty%", !0), c = n("%Math.max%");
    if (l)
      try {
        l({}, "a", { value: 1 });
      } catch {
        l = null;
      }
    t.exports = function(f) {
      if (typeof f != "function")
        throw new i("a function is required");
      var p = s(e, a, arguments);
      return r(
        p,
        1 + c(0, f.length - (arguments.length - 1)),
        !0
      );
    };
    var u = function() {
      return s(e, o, arguments);
    };
    l ? l(t.exports, "apply", { value: u }) : t.exports.apply = u;
  }(p_)), p_.exports;
}
var v_, tO;
function nP() {
  if (tO)
    return v_;
  tO = 1;
  var t = sh(), e = tP(), n = e(t("String.prototype.indexOf"));
  return v_ = function(i, o) {
    var a = t(i, !!o);
    return typeof a == "function" && n(i, ".prototype.") > -1 ? e(a) : a;
  }, v_;
}
var w_, nO;
function Rge() {
  if (nO)
    return w_;
  nO = 1;
  var t = $C()(), e = nP(), n = e("Object.prototype.toString"), r = function(s) {
    return t && s && typeof s == "object" && Symbol.toStringTag in s ? !1 : n(s) === "[object Arguments]";
  }, i = function(s) {
    return r(s) ? !0 : s !== null && typeof s == "object" && typeof s.length == "number" && s.length >= 0 && n(s) !== "[object Array]" && n(s.callee) === "[object Function]";
  }, o = function() {
    return r(arguments);
  }();
  return r.isLegacyArguments = i, w_ = o ? r : i, w_;
}
var x_, rO;
function Ige() {
  if (rO)
    return x_;
  rO = 1;
  var t = Object.prototype.toString, e = Function.prototype.toString, n = /^\s*(?:function)?\*/, r = $C()(), i = Object.getPrototypeOf, o = function() {
    if (!r)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, a;
  return x_ = function(l) {
    if (typeof l != "function")
      return !1;
    if (n.test(e.call(l)))
      return !0;
    if (!r) {
      var c = t.call(l);
      return c === "[object GeneratorFunction]";
    }
    if (!i)
      return !1;
    if (typeof a > "u") {
      var u = o();
      a = u ? i(u) : !1;
    }
    return i(l) === a;
  }, x_;
}
var __, iO;
function Oge() {
  if (iO)
    return __;
  iO = 1;
  var t = Function.prototype.toString, e = typeof Reflect == "object" && Reflect !== null && Reflect.apply, n, r;
  if (typeof e == "function" && typeof Object.defineProperty == "function")
    try {
      n = Object.defineProperty({}, "length", {
        get: function() {
          throw r;
        }
      }), r = {}, e(function() {
        throw 42;
      }, null, n);
    } catch (w) {
      w !== r && (e = null);
    }
  else
    e = null;
  var i = /^\s*class\b/, o = function(x) {
    try {
      var k = t.call(x);
      return i.test(k);
    } catch {
      return !1;
    }
  }, a = function(x) {
    try {
      return o(x) ? !1 : (t.call(x), !0);
    } catch {
      return !1;
    }
  }, s = Object.prototype.toString, l = "[object Object]", c = "[object Function]", u = "[object GeneratorFunction]", d = "[object HTMLAllCollection]", f = "[object HTML document.all class]", p = "[object HTMLCollection]", m = typeof Symbol == "function" && !!Symbol.toStringTag, g = !(0 in [,]), b = function() {
    return !1;
  };
  if (typeof document == "object") {
    var y = document.all;
    s.call(y) === s.call(document.all) && (b = function(x) {
      if ((g || !x) && (typeof x > "u" || typeof x == "object"))
        try {
          var k = s.call(x);
          return (k === d || k === f || k === p || k === l) && x("") == null;
        } catch {
        }
      return !1;
    });
  }
  return __ = e ? function(x) {
    if (b(x))
      return !0;
    if (!x || typeof x != "function" && typeof x != "object")
      return !1;
    try {
      e(x, null, n);
    } catch (k) {
      if (k !== r)
        return !1;
    }
    return !o(x) && a(x);
  } : function(x) {
    if (b(x))
      return !0;
    if (!x || typeof x != "function" && typeof x != "object")
      return !1;
    if (m)
      return a(x);
    if (o(x))
      return !1;
    var k = s.call(x);
    return k !== c && k !== u && !/^\[object HTML/.test(k) ? !1 : a(x);
  }, __;
}
var S_, oO;
function Fge() {
  if (oO)
    return S_;
  oO = 1;
  var t = Oge(), e = Object.prototype.toString, n = Object.prototype.hasOwnProperty, r = function(l, c, u) {
    for (var d = 0, f = l.length; d < f; d++)
      n.call(l, d) && (u == null ? c(l[d], d, l) : c.call(u, l[d], d, l));
  }, i = function(l, c, u) {
    for (var d = 0, f = l.length; d < f; d++)
      u == null ? c(l.charAt(d), d, l) : c.call(u, l.charAt(d), d, l);
  }, o = function(l, c, u) {
    for (var d in l)
      n.call(l, d) && (u == null ? c(l[d], d, l) : c.call(u, l[d], d, l));
  }, a = function(l, c, u) {
    if (!t(c))
      throw new TypeError("iterator must be a function");
    var d;
    arguments.length >= 3 && (d = u), e.call(l) === "[object Array]" ? r(l, c, d) : typeof l == "string" ? i(l, c, d) : o(l, c, d);
  };
  return S_ = a, S_;
}
var T_, aO;
function Uge() {
  if (aO)
    return T_;
  aO = 1;
  var t = [
    "BigInt64Array",
    "BigUint64Array",
    "Float32Array",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray"
  ], e = typeof globalThis > "u" ? oa : globalThis;
  return T_ = function() {
    for (var r = [], i = 0; i < t.length; i++)
      typeof e[t[i]] == "function" && (r[r.length] = t[i]);
    return r;
  }, T_;
}
var D_, sO;
function rP() {
  if (sO)
    return D_;
  sO = 1;
  var t = Fge(), e = Uge(), n = tP(), r = nP(), i = jC(), o = r("Object.prototype.toString"), a = $C()(), s = typeof globalThis > "u" ? oa : globalThis, l = e(), c = r("String.prototype.slice"), u = Object.getPrototypeOf, d = r("Array.prototype.indexOf", !0) || function(b, y) {
    for (var w = 0; w < b.length; w += 1)
      if (b[w] === y)
        return w;
    return -1;
  }, f = { __proto__: null };
  a && i && u ? t(l, function(g) {
    var b = new s[g]();
    if (Symbol.toStringTag in b) {
      var y = u(b), w = i(y, Symbol.toStringTag);
      if (!w) {
        var x = u(y);
        w = i(x, Symbol.toStringTag);
      }
      f["$" + g] = n(w.get);
    }
  }) : t(l, function(g) {
    var b = new s[g](), y = b.slice || b.set;
    y && (f["$" + g] = n(y));
  });
  var p = function(b) {
    var y = !1;
    return t(f, function(w, x) {
      if (!y)
        try {
          "$" + w(b) === x && (y = c(x, 1));
        } catch {
        }
    }), y;
  }, m = function(b) {
    var y = !1;
    return t(f, function(w, x) {
      if (!y)
        try {
          w(b), y = c(x, 1);
        } catch {
        }
    }), y;
  };
  return D_ = function(b) {
    if (!b || typeof b != "object")
      return !1;
    if (!a) {
      var y = c(o(b), 8, -1);
      return d(l, y) > -1 ? y : y !== "Object" ? !1 : m(b);
    }
    return i ? p(b) : null;
  }, D_;
}
var E_, lO;
function Nge() {
  if (lO)
    return E_;
  lO = 1;
  var t = rP();
  return E_ = function(n) {
    return !!t(n);
  }, E_;
}
var cO;
function Mge() {
  return cO || (cO = 1, function(t) {
    var e = Rge(), n = Ige(), r = rP(), i = Nge();
    function o(O) {
      return O.call.bind(O);
    }
    var a = typeof BigInt < "u", s = typeof Symbol < "u", l = o(Object.prototype.toString), c = o(Number.prototype.valueOf), u = o(String.prototype.valueOf), d = o(Boolean.prototype.valueOf);
    if (a)
      var f = o(BigInt.prototype.valueOf);
    if (s)
      var p = o(Symbol.prototype.valueOf);
    function m(O, ne) {
      if (typeof O != "object")
        return !1;
      try {
        return ne(O), !0;
      } catch {
        return !1;
      }
    }
    t.isArgumentsObject = e, t.isGeneratorFunction = n, t.isTypedArray = i;
    function g(O) {
      return typeof Promise < "u" && O instanceof Promise || O !== null && typeof O == "object" && typeof O.then == "function" && typeof O.catch == "function";
    }
    t.isPromise = g;
    function b(O) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(O) : i(O) || ce(O);
    }
    t.isArrayBufferView = b;
    function y(O) {
      return r(O) === "Uint8Array";
    }
    t.isUint8Array = y;
    function w(O) {
      return r(O) === "Uint8ClampedArray";
    }
    t.isUint8ClampedArray = w;
    function x(O) {
      return r(O) === "Uint16Array";
    }
    t.isUint16Array = x;
    function k(O) {
      return r(O) === "Uint32Array";
    }
    t.isUint32Array = k;
    function A(O) {
      return r(O) === "Int8Array";
    }
    t.isInt8Array = A;
    function U(O) {
      return r(O) === "Int16Array";
    }
    t.isInt16Array = U;
    function P(O) {
      return r(O) === "Int32Array";
    }
    t.isInt32Array = P;
    function V(O) {
      return r(O) === "Float32Array";
    }
    t.isFloat32Array = V;
    function I(O) {
      return r(O) === "Float64Array";
    }
    t.isFloat64Array = I;
    function le(O) {
      return r(O) === "BigInt64Array";
    }
    t.isBigInt64Array = le;
    function be(O) {
      return r(O) === "BigUint64Array";
    }
    t.isBigUint64Array = be;
    function F(O) {
      return l(O) === "[object Map]";
    }
    F.working = typeof Map < "u" && F(/* @__PURE__ */ new Map());
    function G(O) {
      return typeof Map > "u" ? !1 : F.working ? F(O) : O instanceof Map;
    }
    t.isMap = G;
    function C(O) {
      return l(O) === "[object Set]";
    }
    C.working = typeof Set < "u" && C(/* @__PURE__ */ new Set());
    function ie(O) {
      return typeof Set > "u" ? !1 : C.working ? C(O) : O instanceof Set;
    }
    t.isSet = ie;
    function ee(O) {
      return l(O) === "[object WeakMap]";
    }
    ee.working = typeof WeakMap < "u" && ee(/* @__PURE__ */ new WeakMap());
    function Z(O) {
      return typeof WeakMap > "u" ? !1 : ee.working ? ee(O) : O instanceof WeakMap;
    }
    t.isWeakMap = Z;
    function oe(O) {
      return l(O) === "[object WeakSet]";
    }
    oe.working = typeof WeakSet < "u" && oe(/* @__PURE__ */ new WeakSet());
    function te(O) {
      return oe(O);
    }
    t.isWeakSet = te;
    function _e(O) {
      return l(O) === "[object ArrayBuffer]";
    }
    _e.working = typeof ArrayBuffer < "u" && _e(new ArrayBuffer());
    function q(O) {
      return typeof ArrayBuffer > "u" ? !1 : _e.working ? _e(O) : O instanceof ArrayBuffer;
    }
    t.isArrayBuffer = q;
    function N(O) {
      return l(O) === "[object DataView]";
    }
    N.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && N(new DataView(new ArrayBuffer(1), 0, 1));
    function ce(O) {
      return typeof DataView > "u" ? !1 : N.working ? N(O) : O instanceof DataView;
    }
    t.isDataView = ce;
    var me = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function ve(O) {
      return l(O) === "[object SharedArrayBuffer]";
    }
    function he(O) {
      return typeof me > "u" ? !1 : (typeof ve.working > "u" && (ve.working = ve(new me())), ve.working ? ve(O) : O instanceof me);
    }
    t.isSharedArrayBuffer = he;
    function H(O) {
      return l(O) === "[object AsyncFunction]";
    }
    t.isAsyncFunction = H;
    function W(O) {
      return l(O) === "[object Map Iterator]";
    }
    t.isMapIterator = W;
    function we(O) {
      return l(O) === "[object Set Iterator]";
    }
    t.isSetIterator = we;
    function ye(O) {
      return l(O) === "[object Generator]";
    }
    t.isGeneratorObject = ye;
    function j(O) {
      return l(O) === "[object WebAssembly.Module]";
    }
    t.isWebAssemblyCompiledModule = j;
    function Q(O) {
      return m(O, c);
    }
    t.isNumberObject = Q;
    function De(O) {
      return m(O, u);
    }
    t.isStringObject = De;
    function T(O) {
      return m(O, d);
    }
    t.isBooleanObject = T;
    function pe(O) {
      return a && m(O, f);
    }
    t.isBigIntObject = pe;
    function M(O) {
      return s && m(O, p);
    }
    t.isSymbolObject = M;
    function _(O) {
      return Q(O) || De(O) || T(O) || pe(O) || M(O);
    }
    t.isBoxedPrimitive = _;
    function S(O) {
      return typeof Uint8Array < "u" && (q(O) || he(O));
    }
    t.isAnyArrayBuffer = S, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(O) {
      Object.defineProperty(t, O, {
        enumerable: !1,
        value: function() {
          throw new Error(O + " is not supported in userland");
        }
      });
    });
  }(o_)), o_;
}
var C_, uO;
function Bge() {
  return uO || (uO = 1, C_ = function(e) {
    return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
  }), C_;
}
var dO;
function iP() {
  return dO || (dO = 1, function(t) {
    var e = Object.getOwnPropertyDescriptors || function(ce) {
      for (var me = Object.keys(ce), ve = {}, he = 0; he < me.length; he++)
        ve[me[he]] = Object.getOwnPropertyDescriptor(ce, me[he]);
      return ve;
    }, n = /%[sdj%]/g;
    t.format = function(N) {
      if (!A(N)) {
        for (var ce = [], me = 0; me < arguments.length; me++)
          ce.push(a(arguments[me]));
        return ce.join(" ");
      }
      for (var me = 1, ve = arguments, he = ve.length, H = String(N).replace(n, function(we) {
        if (we === "%%")
          return "%";
        if (me >= he)
          return we;
        switch (we) {
          case "%s":
            return String(ve[me++]);
          case "%d":
            return Number(ve[me++]);
          case "%j":
            try {
              return JSON.stringify(ve[me++]);
            } catch {
              return "[Circular]";
            }
          default:
            return we;
        }
      }), W = ve[me]; me < he; W = ve[++me])
        w(W) || !I(W) ? H += " " + W : H += " " + a(W);
      return H;
    }, t.deprecate = function(N, ce) {
      if (typeof _t < "u" && _t.noDeprecation === !0)
        return N;
      if (typeof _t > "u")
        return function() {
          return t.deprecate(N, ce).apply(this, arguments);
        };
      var me = !1;
      function ve() {
        if (!me) {
          if (_t.throwDeprecation)
            throw new Error(ce);
          _t.traceDeprecation ? console.trace(ce) : console.error(ce), me = !0;
        }
        return N.apply(this, arguments);
      }
      return ve;
    };
    var r = {}, i = /^$/;
    if (_t.env.NODE_DEBUG) {
      var o = _t.env.NODE_DEBUG;
      o = o.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), i = new RegExp("^" + o + "$", "i");
    }
    t.debuglog = function(N) {
      if (N = N.toUpperCase(), !r[N])
        if (i.test(N)) {
          var ce = _t.pid;
          r[N] = function() {
            var me = t.format.apply(t, arguments);
            console.error("%s %d: %s", N, ce, me);
          };
        } else
          r[N] = function() {
          };
      return r[N];
    };
    function a(N, ce) {
      var me = {
        seen: [],
        stylize: l
      };
      return arguments.length >= 3 && (me.depth = arguments[2]), arguments.length >= 4 && (me.colors = arguments[3]), y(ce) ? me.showHidden = ce : ce && t._extend(me, ce), P(me.showHidden) && (me.showHidden = !1), P(me.depth) && (me.depth = 2), P(me.colors) && (me.colors = !1), P(me.customInspect) && (me.customInspect = !0), me.colors && (me.stylize = s), u(me, N, me.depth);
    }
    t.inspect = a, a.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, a.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function s(N, ce) {
      var me = a.styles[ce];
      return me ? "\x1B[" + a.colors[me][0] + "m" + N + "\x1B[" + a.colors[me][1] + "m" : N;
    }
    function l(N, ce) {
      return N;
    }
    function c(N) {
      var ce = {};
      return N.forEach(function(me, ve) {
        ce[me] = !0;
      }), ce;
    }
    function u(N, ce, me) {
      if (N.customInspect && ce && F(ce.inspect) && // Filter out the util module, it's inspect function is special
      ce.inspect !== t.inspect && // Also filter out any prototype objects using the circular check.
      !(ce.constructor && ce.constructor.prototype === ce)) {
        var ve = ce.inspect(me, N);
        return A(ve) || (ve = u(N, ve, me)), ve;
      }
      var he = d(N, ce);
      if (he)
        return he;
      var H = Object.keys(ce), W = c(H);
      if (N.showHidden && (H = Object.getOwnPropertyNames(ce)), be(ce) && (H.indexOf("message") >= 0 || H.indexOf("description") >= 0))
        return f(ce);
      if (H.length === 0) {
        if (F(ce)) {
          var we = ce.name ? ": " + ce.name : "";
          return N.stylize("[Function" + we + "]", "special");
        }
        if (V(ce))
          return N.stylize(RegExp.prototype.toString.call(ce), "regexp");
        if (le(ce))
          return N.stylize(Date.prototype.toString.call(ce), "date");
        if (be(ce))
          return f(ce);
      }
      var ye = "", j = !1, Q = ["{", "}"];
      if (b(ce) && (j = !0, Q = ["[", "]"]), F(ce)) {
        var De = ce.name ? ": " + ce.name : "";
        ye = " [Function" + De + "]";
      }
      if (V(ce) && (ye = " " + RegExp.prototype.toString.call(ce)), le(ce) && (ye = " " + Date.prototype.toUTCString.call(ce)), be(ce) && (ye = " " + f(ce)), H.length === 0 && (!j || ce.length == 0))
        return Q[0] + ye + Q[1];
      if (me < 0)
        return V(ce) ? N.stylize(RegExp.prototype.toString.call(ce), "regexp") : N.stylize("[Object]", "special");
      N.seen.push(ce);
      var T;
      return j ? T = p(N, ce, me, W, H) : T = H.map(function(pe) {
        return m(N, ce, me, W, pe, j);
      }), N.seen.pop(), g(T, ye, Q);
    }
    function d(N, ce) {
      if (P(ce))
        return N.stylize("undefined", "undefined");
      if (A(ce)) {
        var me = "'" + JSON.stringify(ce).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return N.stylize(me, "string");
      }
      if (k(ce))
        return N.stylize("" + ce, "number");
      if (y(ce))
        return N.stylize("" + ce, "boolean");
      if (w(ce))
        return N.stylize("null", "null");
    }
    function f(N) {
      return "[" + Error.prototype.toString.call(N) + "]";
    }
    function p(N, ce, me, ve, he) {
      for (var H = [], W = 0, we = ce.length; W < we; ++W)
        oe(ce, String(W)) ? H.push(m(
          N,
          ce,
          me,
          ve,
          String(W),
          !0
        )) : H.push("");
      return he.forEach(function(ye) {
        ye.match(/^\d+$/) || H.push(m(
          N,
          ce,
          me,
          ve,
          ye,
          !0
        ));
      }), H;
    }
    function m(N, ce, me, ve, he, H) {
      var W, we, ye;
      if (ye = Object.getOwnPropertyDescriptor(ce, he) || { value: ce[he] }, ye.get ? ye.set ? we = N.stylize("[Getter/Setter]", "special") : we = N.stylize("[Getter]", "special") : ye.set && (we = N.stylize("[Setter]", "special")), oe(ve, he) || (W = "[" + he + "]"), we || (N.seen.indexOf(ye.value) < 0 ? (w(me) ? we = u(N, ye.value, null) : we = u(N, ye.value, me - 1), we.indexOf(`
`) > -1 && (H ? we = we.split(`
`).map(function(j) {
        return "  " + j;
      }).join(`
`).slice(2) : we = `
` + we.split(`
`).map(function(j) {
        return "   " + j;
      }).join(`
`))) : we = N.stylize("[Circular]", "special")), P(W)) {
        if (H && he.match(/^\d+$/))
          return we;
        W = JSON.stringify("" + he), W.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (W = W.slice(1, -1), W = N.stylize(W, "name")) : (W = W.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), W = N.stylize(W, "string"));
      }
      return W + ": " + we;
    }
    function g(N, ce, me) {
      var ve = N.reduce(function(he, H) {
        return H.indexOf(`
`) >= 0, he + H.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return ve > 60 ? me[0] + (ce === "" ? "" : ce + `
 `) + " " + N.join(`,
  `) + " " + me[1] : me[0] + ce + " " + N.join(", ") + " " + me[1];
    }
    t.types = Mge();
    function b(N) {
      return Array.isArray(N);
    }
    t.isArray = b;
    function y(N) {
      return typeof N == "boolean";
    }
    t.isBoolean = y;
    function w(N) {
      return N === null;
    }
    t.isNull = w;
    function x(N) {
      return N == null;
    }
    t.isNullOrUndefined = x;
    function k(N) {
      return typeof N == "number";
    }
    t.isNumber = k;
    function A(N) {
      return typeof N == "string";
    }
    t.isString = A;
    function U(N) {
      return typeof N == "symbol";
    }
    t.isSymbol = U;
    function P(N) {
      return N === void 0;
    }
    t.isUndefined = P;
    function V(N) {
      return I(N) && C(N) === "[object RegExp]";
    }
    t.isRegExp = V, t.types.isRegExp = V;
    function I(N) {
      return typeof N == "object" && N !== null;
    }
    t.isObject = I;
    function le(N) {
      return I(N) && C(N) === "[object Date]";
    }
    t.isDate = le, t.types.isDate = le;
    function be(N) {
      return I(N) && (C(N) === "[object Error]" || N instanceof Error);
    }
    t.isError = be, t.types.isNativeError = be;
    function F(N) {
      return typeof N == "function";
    }
    t.isFunction = F;
    function G(N) {
      return N === null || typeof N == "boolean" || typeof N == "number" || typeof N == "string" || typeof N == "symbol" || // ES6 symbol
      typeof N > "u";
    }
    t.isPrimitive = G, t.isBuffer = Bge();
    function C(N) {
      return Object.prototype.toString.call(N);
    }
    function ie(N) {
      return N < 10 ? "0" + N.toString(10) : N.toString(10);
    }
    var ee = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function Z() {
      var N = /* @__PURE__ */ new Date(), ce = [
        ie(N.getHours()),
        ie(N.getMinutes()),
        ie(N.getSeconds())
      ].join(":");
      return [N.getDate(), ee[N.getMonth()], ce].join(" ");
    }
    t.log = function() {
      console.log("%s - %s", Z(), t.format.apply(t, arguments));
    }, t.inherits = _u, t._extend = function(N, ce) {
      if (!ce || !I(ce))
        return N;
      for (var me = Object.keys(ce), ve = me.length; ve--; )
        N[me[ve]] = ce[me[ve]];
      return N;
    };
    function oe(N, ce) {
      return Object.prototype.hasOwnProperty.call(N, ce);
    }
    var te = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    t.promisify = function(ce) {
      if (typeof ce != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (te && ce[te]) {
        var me = ce[te];
        if (typeof me != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(me, te, {
          value: me,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), me;
      }
      function me() {
        for (var ve, he, H = new Promise(function(ye, j) {
          ve = ye, he = j;
        }), W = [], we = 0; we < arguments.length; we++)
          W.push(arguments[we]);
        W.push(function(ye, j) {
          ye ? he(ye) : ve(j);
        });
        try {
          ce.apply(this, W);
        } catch (ye) {
          he(ye);
        }
        return H;
      }
      return Object.setPrototypeOf(me, Object.getPrototypeOf(ce)), te && Object.defineProperty(me, te, {
        value: me,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        me,
        e(ce)
      );
    }, t.promisify.custom = te;
    function _e(N, ce) {
      if (!N) {
        var me = new Error("Promise was rejected with a falsy value");
        me.reason = N, N = me;
      }
      return ce(N);
    }
    function q(N) {
      if (typeof N != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function ce() {
        for (var me = [], ve = 0; ve < arguments.length; ve++)
          me.push(arguments[ve]);
        var he = me.pop();
        if (typeof he != "function")
          throw new TypeError("The last argument must be of type Function");
        var H = this, W = function() {
          return he.apply(H, arguments);
        };
        N.apply(this, me).then(
          function(we) {
            _t.nextTick(W.bind(null, null, we));
          },
          function(we) {
            _t.nextTick(_e.bind(null, we, W));
          }
        );
      }
      return Object.setPrototypeOf(ce, Object.getPrototypeOf(N)), Object.defineProperties(
        ce,
        e(N)
      ), ce;
    }
    t.callbackify = q;
  }(i_)), i_;
}
var k_, fO;
function Lge() {
  if (fO)
    return k_;
  fO = 1;
  function t(f, p) {
    var m = Object.keys(f);
    if (Object.getOwnPropertySymbols) {
      var g = Object.getOwnPropertySymbols(f);
      p && (g = g.filter(function(b) {
        return Object.getOwnPropertyDescriptor(f, b).enumerable;
      })), m.push.apply(m, g);
    }
    return m;
  }
  function e(f) {
    for (var p = 1; p < arguments.length; p++) {
      var m = arguments[p] != null ? arguments[p] : {};
      p % 2 ? t(Object(m), !0).forEach(function(g) {
        n(f, g, m[g]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(f, Object.getOwnPropertyDescriptors(m)) : t(Object(m)).forEach(function(g) {
        Object.defineProperty(f, g, Object.getOwnPropertyDescriptor(m, g));
      });
    }
    return f;
  }
  function n(f, p, m) {
    return p in f ? Object.defineProperty(f, p, { value: m, enumerable: !0, configurable: !0, writable: !0 }) : f[p] = m, f;
  }
  function r(f, p) {
    if (!(f instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function i(f, p) {
    for (var m = 0; m < p.length; m++) {
      var g = p[m];
      g.enumerable = g.enumerable || !1, g.configurable = !0, "value" in g && (g.writable = !0), Object.defineProperty(f, g.key, g);
    }
  }
  function o(f, p, m) {
    return p && i(f.prototype, p), f;
  }
  var a = D0(), s = a.Buffer, l = iP(), c = l.inspect, u = c && c.custom || "inspect";
  function d(f, p, m) {
    s.prototype.copy.call(f, p, m);
  }
  return k_ = /* @__PURE__ */ function() {
    function f() {
      r(this, f), this.head = null, this.tail = null, this.length = 0;
    }
    return o(f, [{
      key: "push",
      value: function(m) {
        var g = {
          data: m,
          next: null
        };
        this.length > 0 ? this.tail.next = g : this.head = g, this.tail = g, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(m) {
        var g = {
          data: m,
          next: this.head
        };
        this.length === 0 && (this.tail = g), this.head = g, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var m = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, m;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(m) {
        if (this.length === 0)
          return "";
        for (var g = this.head, b = "" + g.data; g = g.next; )
          b += m + g.data;
        return b;
      }
    }, {
      key: "concat",
      value: function(m) {
        if (this.length === 0)
          return s.alloc(0);
        for (var g = s.allocUnsafe(m >>> 0), b = this.head, y = 0; b; )
          d(b.data, g, y), y += b.data.length, b = b.next;
        return g;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(m, g) {
        var b;
        return m < this.head.data.length ? (b = this.head.data.slice(0, m), this.head.data = this.head.data.slice(m)) : m === this.head.data.length ? b = this.shift() : b = g ? this._getString(m) : this._getBuffer(m), b;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(m) {
        var g = this.head, b = 1, y = g.data;
        for (m -= y.length; g = g.next; ) {
          var w = g.data, x = m > w.length ? w.length : m;
          if (x === w.length ? y += w : y += w.slice(0, m), m -= x, m === 0) {
            x === w.length ? (++b, g.next ? this.head = g.next : this.head = this.tail = null) : (this.head = g, g.data = w.slice(x));
            break;
          }
          ++b;
        }
        return this.length -= b, y;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(m) {
        var g = s.allocUnsafe(m), b = this.head, y = 1;
        for (b.data.copy(g), m -= b.data.length; b = b.next; ) {
          var w = b.data, x = m > w.length ? w.length : m;
          if (w.copy(g, g.length - m, 0, x), m -= x, m === 0) {
            x === w.length ? (++y, b.next ? this.head = b.next : this.head = this.tail = null) : (this.head = b, b.data = w.slice(x));
            break;
          }
          ++y;
        }
        return this.length -= y, g;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: u,
      value: function(m, g) {
        return c(this, e({}, g, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), f;
  }(), k_;
}
var A_, hO;
function oP() {
  if (hO)
    return A_;
  hO = 1;
  function t(a, s) {
    var l = this, c = this._readableState && this._readableState.destroyed, u = this._writableState && this._writableState.destroyed;
    return c || u ? (s ? s(a) : a && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, _t.nextTick(i, this, a)) : _t.nextTick(i, this, a)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(a || null, function(d) {
      !s && d ? l._writableState ? l._writableState.errorEmitted ? _t.nextTick(n, l) : (l._writableState.errorEmitted = !0, _t.nextTick(e, l, d)) : _t.nextTick(e, l, d) : s ? (_t.nextTick(n, l), s(d)) : _t.nextTick(n, l);
    }), this);
  }
  function e(a, s) {
    i(a, s), n(a);
  }
  function n(a) {
    a._writableState && !a._writableState.emitClose || a._readableState && !a._readableState.emitClose || a.emit("close");
  }
  function r() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function i(a, s) {
    a.emit("error", s);
  }
  function o(a, s) {
    var l = a._readableState, c = a._writableState;
    l && l.autoDestroy || c && c.autoDestroy ? a.destroy(s) : a.emit("error", s);
  }
  return A_ = {
    destroy: t,
    undestroy: r,
    errorOrDestroy: o
  }, A_;
}
var R_ = {}, pO;
function lh() {
  if (pO)
    return R_;
  pO = 1;
  function t(s, l) {
    s.prototype = Object.create(l.prototype), s.prototype.constructor = s, s.__proto__ = l;
  }
  var e = {};
  function n(s, l, c) {
    c || (c = Error);
    function u(f, p, m) {
      return typeof l == "string" ? l : l(f, p, m);
    }
    var d = /* @__PURE__ */ function(f) {
      t(p, f);
      function p(m, g, b) {
        return f.call(this, u(m, g, b)) || this;
      }
      return p;
    }(c);
    d.prototype.name = c.name, d.prototype.code = s, e[s] = d;
  }
  function r(s, l) {
    if (Array.isArray(s)) {
      var c = s.length;
      return s = s.map(function(u) {
        return String(u);
      }), c > 2 ? "one of ".concat(l, " ").concat(s.slice(0, c - 1).join(", "), ", or ") + s[c - 1] : c === 2 ? "one of ".concat(l, " ").concat(s[0], " or ").concat(s[1]) : "of ".concat(l, " ").concat(s[0]);
    } else
      return "of ".concat(l, " ").concat(String(s));
  }
  function i(s, l, c) {
    return s.substr(0, l.length) === l;
  }
  function o(s, l, c) {
    return (c === void 0 || c > s.length) && (c = s.length), s.substring(c - l.length, c) === l;
  }
  function a(s, l, c) {
    return typeof c != "number" && (c = 0), c + l.length > s.length ? !1 : s.indexOf(l, c) !== -1;
  }
  return n("ERR_INVALID_OPT_VALUE", function(s, l) {
    return 'The value "' + l + '" is invalid for option "' + s + '"';
  }, TypeError), n("ERR_INVALID_ARG_TYPE", function(s, l, c) {
    var u;
    typeof l == "string" && i(l, "not ") ? (u = "must not be", l = l.replace(/^not /, "")) : u = "must be";
    var d;
    if (o(s, " argument"))
      d = "The ".concat(s, " ").concat(u, " ").concat(r(l, "type"));
    else {
      var f = a(s, ".") ? "property" : "argument";
      d = 'The "'.concat(s, '" ').concat(f, " ").concat(u, " ").concat(r(l, "type"));
    }
    return d += ". Received type ".concat(typeof c), d;
  }, TypeError), n("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), n("ERR_METHOD_NOT_IMPLEMENTED", function(s) {
    return "The " + s + " method is not implemented";
  }), n("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), n("ERR_STREAM_DESTROYED", function(s) {
    return "Cannot call " + s + " after a stream was destroyed";
  }), n("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), n("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), n("ERR_STREAM_WRITE_AFTER_END", "write after end"), n("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), n("ERR_UNKNOWN_ENCODING", function(s) {
    return "Unknown encoding: " + s;
  }, TypeError), n("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), R_.codes = e, R_;
}
var I_, mO;
function aP() {
  if (mO)
    return I_;
  mO = 1;
  var t = lh().codes.ERR_INVALID_OPT_VALUE;
  function e(r, i, o) {
    return r.highWaterMark != null ? r.highWaterMark : i ? r[o] : null;
  }
  function n(r, i, o, a) {
    var s = e(i, a, o);
    if (s != null) {
      if (!(isFinite(s) && Math.floor(s) === s) || s < 0) {
        var l = a ? o : "highWaterMark";
        throw new t(l, s);
      }
      return Math.floor(s);
    }
    return r.objectMode ? 16 : 16 * 1024;
  }
  return I_ = {
    getHighWaterMark: n
  }, I_;
}
var O_, gO;
function Pge() {
  if (gO)
    return O_;
  gO = 1, O_ = t;
  function t(n, r) {
    if (e("noDeprecation"))
      return n;
    var i = !1;
    function o() {
      if (!i) {
        if (e("throwDeprecation"))
          throw new Error(r);
        e("traceDeprecation") ? console.trace(r) : console.warn(r), i = !0;
      }
      return n.apply(this, arguments);
    }
    return o;
  }
  function e(n) {
    try {
      if (!oa.localStorage)
        return !1;
    } catch {
      return !1;
    }
    var r = oa.localStorage[n];
    return r == null ? !1 : String(r).toLowerCase() === "true";
  }
  return O_;
}
var F_, yO;
function sP() {
  if (yO)
    return F_;
  yO = 1, F_ = V;
  function t(he) {
    var H = this;
    this.next = null, this.entry = null, this.finish = function() {
      ve(H, he);
    };
  }
  var e;
  V.WritableState = U;
  var n = {
    deprecate: Pge()
  }, r = Z9(), i = D0().Buffer, o = oa.Uint8Array || function() {
  };
  function a(he) {
    return i.from(he);
  }
  function s(he) {
    return i.isBuffer(he) || he instanceof o;
  }
  var l = oP(), c = aP(), u = c.getHighWaterMark, d = lh().codes, f = d.ERR_INVALID_ARG_TYPE, p = d.ERR_METHOD_NOT_IMPLEMENTED, m = d.ERR_MULTIPLE_CALLBACK, g = d.ERR_STREAM_CANNOT_PIPE, b = d.ERR_STREAM_DESTROYED, y = d.ERR_STREAM_NULL_VALUES, w = d.ERR_STREAM_WRITE_AFTER_END, x = d.ERR_UNKNOWN_ENCODING, k = l.errorOrDestroy;
  _u(V, r);
  function A() {
  }
  function U(he, H, W) {
    e = e || Wf(), he = he || {}, typeof W != "boolean" && (W = H instanceof e), this.objectMode = !!he.objectMode, W && (this.objectMode = this.objectMode || !!he.writableObjectMode), this.highWaterMark = u(this, he, "writableHighWaterMark", W), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var we = he.decodeStrings === !1;
    this.decodeStrings = !we, this.defaultEncoding = he.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ye) {
      ee(H, ye);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = he.emitClose !== !1, this.autoDestroy = !!he.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  U.prototype.getBuffer = function() {
    for (var H = this.bufferedRequest, W = []; H; )
      W.push(H), H = H.next;
    return W;
  }, function() {
    try {
      Object.defineProperty(U.prototype, "buffer", {
        get: n.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var P;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (P = Function.prototype[Symbol.hasInstance], Object.defineProperty(V, Symbol.hasInstance, {
    value: function(H) {
      return P.call(this, H) ? !0 : this !== V ? !1 : H && H._writableState instanceof U;
    }
  })) : P = function(H) {
    return H instanceof this;
  };
  function V(he) {
    e = e || Wf();
    var H = this instanceof e;
    if (!H && !P.call(V, this))
      return new V(he);
    this._writableState = new U(he, this, H), this.writable = !0, he && (typeof he.write == "function" && (this._write = he.write), typeof he.writev == "function" && (this._writev = he.writev), typeof he.destroy == "function" && (this._destroy = he.destroy), typeof he.final == "function" && (this._final = he.final)), r.call(this);
  }
  V.prototype.pipe = function() {
    k(this, new g());
  };
  function I(he, H) {
    var W = new w();
    k(he, W), _t.nextTick(H, W);
  }
  function le(he, H, W, we) {
    var ye;
    return W === null ? ye = new y() : typeof W != "string" && !H.objectMode && (ye = new f("chunk", ["string", "Buffer"], W)), ye ? (k(he, ye), _t.nextTick(we, ye), !1) : !0;
  }
  V.prototype.write = function(he, H, W) {
    var we = this._writableState, ye = !1, j = !we.objectMode && s(he);
    return j && !i.isBuffer(he) && (he = a(he)), typeof H == "function" && (W = H, H = null), j ? H = "buffer" : H || (H = we.defaultEncoding), typeof W != "function" && (W = A), we.ending ? I(this, W) : (j || le(this, we, he, W)) && (we.pendingcb++, ye = F(this, we, j, he, H, W)), ye;
  }, V.prototype.cork = function() {
    this._writableState.corked++;
  }, V.prototype.uncork = function() {
    var he = this._writableState;
    he.corked && (he.corked--, !he.writing && !he.corked && !he.bufferProcessing && he.bufferedRequest && te(this, he));
  }, V.prototype.setDefaultEncoding = function(H) {
    if (typeof H == "string" && (H = H.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((H + "").toLowerCase()) > -1))
      throw new x(H);
    return this._writableState.defaultEncoding = H, this;
  }, Object.defineProperty(V.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function be(he, H, W) {
    return !he.objectMode && he.decodeStrings !== !1 && typeof H == "string" && (H = i.from(H, W)), H;
  }
  Object.defineProperty(V.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function F(he, H, W, we, ye, j) {
    if (!W) {
      var Q = be(H, we, ye);
      we !== Q && (W = !0, ye = "buffer", we = Q);
    }
    var De = H.objectMode ? 1 : we.length;
    H.length += De;
    var T = H.length < H.highWaterMark;
    if (T || (H.needDrain = !0), H.writing || H.corked) {
      var pe = H.lastBufferedRequest;
      H.lastBufferedRequest = {
        chunk: we,
        encoding: ye,
        isBuf: W,
        callback: j,
        next: null
      }, pe ? pe.next = H.lastBufferedRequest : H.bufferedRequest = H.lastBufferedRequest, H.bufferedRequestCount += 1;
    } else
      G(he, H, !1, De, we, ye, j);
    return T;
  }
  function G(he, H, W, we, ye, j, Q) {
    H.writelen = we, H.writecb = Q, H.writing = !0, H.sync = !0, H.destroyed ? H.onwrite(new b("write")) : W ? he._writev(ye, H.onwrite) : he._write(ye, j, H.onwrite), H.sync = !1;
  }
  function C(he, H, W, we, ye) {
    --H.pendingcb, W ? (_t.nextTick(ye, we), _t.nextTick(ce, he, H), he._writableState.errorEmitted = !0, k(he, we)) : (ye(we), he._writableState.errorEmitted = !0, k(he, we), ce(he, H));
  }
  function ie(he) {
    he.writing = !1, he.writecb = null, he.length -= he.writelen, he.writelen = 0;
  }
  function ee(he, H) {
    var W = he._writableState, we = W.sync, ye = W.writecb;
    if (typeof ye != "function")
      throw new m();
    if (ie(W), H)
      C(he, W, we, H, ye);
    else {
      var j = _e(W) || he.destroyed;
      !j && !W.corked && !W.bufferProcessing && W.bufferedRequest && te(he, W), we ? _t.nextTick(Z, he, W, j, ye) : Z(he, W, j, ye);
    }
  }
  function Z(he, H, W, we) {
    W || oe(he, H), H.pendingcb--, we(), ce(he, H);
  }
  function oe(he, H) {
    H.length === 0 && H.needDrain && (H.needDrain = !1, he.emit("drain"));
  }
  function te(he, H) {
    H.bufferProcessing = !0;
    var W = H.bufferedRequest;
    if (he._writev && W && W.next) {
      var we = H.bufferedRequestCount, ye = new Array(we), j = H.corkedRequestsFree;
      j.entry = W;
      for (var Q = 0, De = !0; W; )
        ye[Q] = W, W.isBuf || (De = !1), W = W.next, Q += 1;
      ye.allBuffers = De, G(he, H, !0, H.length, ye, "", j.finish), H.pendingcb++, H.lastBufferedRequest = null, j.next ? (H.corkedRequestsFree = j.next, j.next = null) : H.corkedRequestsFree = new t(H), H.bufferedRequestCount = 0;
    } else {
      for (; W; ) {
        var T = W.chunk, pe = W.encoding, M = W.callback, _ = H.objectMode ? 1 : T.length;
        if (G(he, H, !1, _, T, pe, M), W = W.next, H.bufferedRequestCount--, H.writing)
          break;
      }
      W === null && (H.lastBufferedRequest = null);
    }
    H.bufferedRequest = W, H.bufferProcessing = !1;
  }
  V.prototype._write = function(he, H, W) {
    W(new p("_write()"));
  }, V.prototype._writev = null, V.prototype.end = function(he, H, W) {
    var we = this._writableState;
    return typeof he == "function" ? (W = he, he = null, H = null) : typeof H == "function" && (W = H, H = null), he != null && this.write(he, H), we.corked && (we.corked = 1, this.uncork()), we.ending || me(this, we, W), this;
  }, Object.defineProperty(V.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function _e(he) {
    return he.ending && he.length === 0 && he.bufferedRequest === null && !he.finished && !he.writing;
  }
  function q(he, H) {
    he._final(function(W) {
      H.pendingcb--, W && k(he, W), H.prefinished = !0, he.emit("prefinish"), ce(he, H);
    });
  }
  function N(he, H) {
    !H.prefinished && !H.finalCalled && (typeof he._final == "function" && !H.destroyed ? (H.pendingcb++, H.finalCalled = !0, _t.nextTick(q, he, H)) : (H.prefinished = !0, he.emit("prefinish")));
  }
  function ce(he, H) {
    var W = _e(H);
    if (W && (N(he, H), H.pendingcb === 0 && (H.finished = !0, he.emit("finish"), H.autoDestroy))) {
      var we = he._readableState;
      (!we || we.autoDestroy && we.endEmitted) && he.destroy();
    }
    return W;
  }
  function me(he, H, W) {
    H.ending = !0, ce(he, H), W && (H.finished ? _t.nextTick(W) : he.once("finish", W)), H.ended = !0, he.writable = !1;
  }
  function ve(he, H, W) {
    var we = he.entry;
    for (he.entry = null; we; ) {
      var ye = we.callback;
      H.pendingcb--, ye(W), we = we.next;
    }
    H.corkedRequestsFree.next = he;
  }
  return Object.defineProperty(V.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(H) {
      this._writableState && (this._writableState.destroyed = H);
    }
  }), V.prototype.destroy = l.destroy, V.prototype._undestroy = l.undestroy, V.prototype._destroy = function(he, H) {
    H(he);
  }, F_;
}
var U_, bO;
function Wf() {
  if (bO)
    return U_;
  bO = 1;
  var t = Object.keys || function(c) {
    var u = [];
    for (var d in c)
      u.push(d);
    return u;
  };
  U_ = a;
  var e = lP(), n = sP();
  _u(a, e);
  for (var r = t(n.prototype), i = 0; i < r.length; i++) {
    var o = r[i];
    a.prototype[o] || (a.prototype[o] = n.prototype[o]);
  }
  function a(c) {
    if (!(this instanceof a))
      return new a(c);
    e.call(this, c), n.call(this, c), this.allowHalfOpen = !0, c && (c.readable === !1 && (this.readable = !1), c.writable === !1 && (this.writable = !1), c.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", s)));
  }
  Object.defineProperty(a.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(a.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(a.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function s() {
    this._writableState.ended || _t.nextTick(l, this);
  }
  function l(c) {
    c.end();
  }
  return Object.defineProperty(a.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(u) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = u, this._writableState.destroyed = u);
    }
  }), U_;
}
var N_ = {}, Cy = { exports: {} }, vO;
function Wge() {
  return vO || (vO = 1, function(t, e) {
    var n = D0(), r = n.Buffer;
    function i(a, s) {
      for (var l in a)
        s[l] = a[l];
    }
    r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? t.exports = n : (i(n, e), e.Buffer = o);
    function o(a, s, l) {
      return r(a, s, l);
    }
    i(r, o), o.from = function(a, s, l) {
      if (typeof a == "number")
        throw new TypeError("Argument must not be a number");
      return r(a, s, l);
    }, o.alloc = function(a, s, l) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      var c = r(a);
      return s !== void 0 ? typeof l == "string" ? c.fill(s, l) : c.fill(s) : c.fill(0), c;
    }, o.allocUnsafe = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return r(a);
    }, o.allocUnsafeSlow = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return n.SlowBuffer(a);
    };
  }(Cy, Cy.exports)), Cy.exports;
}
var wO;
function WT() {
  if (wO)
    return N_;
  wO = 1;
  var t = Wge().Buffer, e = t.isEncoding || function(y) {
    switch (y = "" + y, y && y.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function n(y) {
    if (!y)
      return "utf8";
    for (var w; ; )
      switch (y) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return y;
        default:
          if (w)
            return;
          y = ("" + y).toLowerCase(), w = !0;
      }
  }
  function r(y) {
    var w = n(y);
    if (typeof w != "string" && (t.isEncoding === e || !e(y)))
      throw new Error("Unknown encoding: " + y);
    return w || y;
  }
  N_.StringDecoder = i;
  function i(y) {
    this.encoding = r(y);
    var w;
    switch (this.encoding) {
      case "utf16le":
        this.text = d, this.end = f, w = 4;
        break;
      case "utf8":
        this.fillLast = l, w = 4;
        break;
      case "base64":
        this.text = p, this.end = m, w = 3;
        break;
      default:
        this.write = g, this.end = b;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = t.allocUnsafe(w);
  }
  i.prototype.write = function(y) {
    if (y.length === 0)
      return "";
    var w, x;
    if (this.lastNeed) {
      if (w = this.fillLast(y), w === void 0)
        return "";
      x = this.lastNeed, this.lastNeed = 0;
    } else
      x = 0;
    return x < y.length ? w ? w + this.text(y, x) : this.text(y, x) : w || "";
  }, i.prototype.end = u, i.prototype.text = c, i.prototype.fillLast = function(y) {
    if (this.lastNeed <= y.length)
      return y.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    y.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, y.length), this.lastNeed -= y.length;
  };
  function o(y) {
    return y <= 127 ? 0 : y >> 5 === 6 ? 2 : y >> 4 === 14 ? 3 : y >> 3 === 30 ? 4 : y >> 6 === 2 ? -1 : -2;
  }
  function a(y, w, x) {
    var k = w.length - 1;
    if (k < x)
      return 0;
    var A = o(w[k]);
    return A >= 0 ? (A > 0 && (y.lastNeed = A - 1), A) : --k < x || A === -2 ? 0 : (A = o(w[k]), A >= 0 ? (A > 0 && (y.lastNeed = A - 2), A) : --k < x || A === -2 ? 0 : (A = o(w[k]), A >= 0 ? (A > 0 && (A === 2 ? A = 0 : y.lastNeed = A - 3), A) : 0));
  }
  function s(y, w, x) {
    if ((w[0] & 192) !== 128)
      return y.lastNeed = 0, "�";
    if (y.lastNeed > 1 && w.length > 1) {
      if ((w[1] & 192) !== 128)
        return y.lastNeed = 1, "�";
      if (y.lastNeed > 2 && w.length > 2 && (w[2] & 192) !== 128)
        return y.lastNeed = 2, "�";
    }
  }
  function l(y) {
    var w = this.lastTotal - this.lastNeed, x = s(this, y);
    if (x !== void 0)
      return x;
    if (this.lastNeed <= y.length)
      return y.copy(this.lastChar, w, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    y.copy(this.lastChar, w, 0, y.length), this.lastNeed -= y.length;
  }
  function c(y, w) {
    var x = a(this, y, w);
    if (!this.lastNeed)
      return y.toString("utf8", w);
    this.lastTotal = x;
    var k = y.length - (x - this.lastNeed);
    return y.copy(this.lastChar, 0, k), y.toString("utf8", w, k);
  }
  function u(y) {
    var w = y && y.length ? this.write(y) : "";
    return this.lastNeed ? w + "�" : w;
  }
  function d(y, w) {
    if ((y.length - w) % 2 === 0) {
      var x = y.toString("utf16le", w);
      if (x) {
        var k = x.charCodeAt(x.length - 1);
        if (k >= 55296 && k <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = y[y.length - 2], this.lastChar[1] = y[y.length - 1], x.slice(0, -1);
      }
      return x;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = y[y.length - 1], y.toString("utf16le", w, y.length - 1);
  }
  function f(y) {
    var w = y && y.length ? this.write(y) : "";
    if (this.lastNeed) {
      var x = this.lastTotal - this.lastNeed;
      return w + this.lastChar.toString("utf16le", 0, x);
    }
    return w;
  }
  function p(y, w) {
    var x = (y.length - w) % 3;
    return x === 0 ? y.toString("base64", w) : (this.lastNeed = 3 - x, this.lastTotal = 3, x === 1 ? this.lastChar[0] = y[y.length - 1] : (this.lastChar[0] = y[y.length - 2], this.lastChar[1] = y[y.length - 1]), y.toString("base64", w, y.length - x));
  }
  function m(y) {
    var w = y && y.length ? this.write(y) : "";
    return this.lastNeed ? w + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : w;
  }
  function g(y) {
    return y.toString(this.encoding);
  }
  function b(y) {
    return y && y.length ? this.write(y) : "";
  }
  return N_;
}
var M_, xO;
function VC() {
  if (xO)
    return M_;
  xO = 1;
  var t = lh().codes.ERR_STREAM_PREMATURE_CLOSE;
  function e(o) {
    var a = !1;
    return function() {
      if (!a) {
        a = !0;
        for (var s = arguments.length, l = new Array(s), c = 0; c < s; c++)
          l[c] = arguments[c];
        o.apply(this, l);
      }
    };
  }
  function n() {
  }
  function r(o) {
    return o.setHeader && typeof o.abort == "function";
  }
  function i(o, a, s) {
    if (typeof a == "function")
      return i(o, null, a);
    a || (a = {}), s = e(s || n);
    var l = a.readable || a.readable !== !1 && o.readable, c = a.writable || a.writable !== !1 && o.writable, u = function() {
      o.writable || f();
    }, d = o._writableState && o._writableState.finished, f = function() {
      c = !1, d = !0, l || s.call(o);
    }, p = o._readableState && o._readableState.endEmitted, m = function() {
      l = !1, p = !0, c || s.call(o);
    }, g = function(x) {
      s.call(o, x);
    }, b = function() {
      var x;
      if (l && !p)
        return (!o._readableState || !o._readableState.ended) && (x = new t()), s.call(o, x);
      if (c && !d)
        return (!o._writableState || !o._writableState.ended) && (x = new t()), s.call(o, x);
    }, y = function() {
      o.req.on("finish", f);
    };
    return r(o) ? (o.on("complete", f), o.on("abort", b), o.req ? y() : o.on("request", y)) : c && !o._writableState && (o.on("end", u), o.on("close", u)), o.on("end", m), o.on("finish", f), a.error !== !1 && o.on("error", g), o.on("close", b), function() {
      o.removeListener("complete", f), o.removeListener("abort", b), o.removeListener("request", y), o.req && o.req.removeListener("finish", f), o.removeListener("end", u), o.removeListener("close", u), o.removeListener("finish", f), o.removeListener("end", m), o.removeListener("error", g), o.removeListener("close", b);
    };
  }
  return M_ = i, M_;
}
var B_, _O;
function zge() {
  if (_O)
    return B_;
  _O = 1;
  var t;
  function e(y, w, x) {
    return w in y ? Object.defineProperty(y, w, { value: x, enumerable: !0, configurable: !0, writable: !0 }) : y[w] = x, y;
  }
  var n = VC(), r = Symbol("lastResolve"), i = Symbol("lastReject"), o = Symbol("error"), a = Symbol("ended"), s = Symbol("lastPromise"), l = Symbol("handlePromise"), c = Symbol("stream");
  function u(y, w) {
    return {
      value: y,
      done: w
    };
  }
  function d(y) {
    var w = y[r];
    if (w !== null) {
      var x = y[c].read();
      x !== null && (y[s] = null, y[r] = null, y[i] = null, w(u(x, !1)));
    }
  }
  function f(y) {
    _t.nextTick(d, y);
  }
  function p(y, w) {
    return function(x, k) {
      y.then(function() {
        if (w[a]) {
          x(u(void 0, !0));
          return;
        }
        w[l](x, k);
      }, k);
    };
  }
  var m = Object.getPrototypeOf(function() {
  }), g = Object.setPrototypeOf((t = {
    get stream() {
      return this[c];
    },
    next: function() {
      var w = this, x = this[o];
      if (x !== null)
        return Promise.reject(x);
      if (this[a])
        return Promise.resolve(u(void 0, !0));
      if (this[c].destroyed)
        return new Promise(function(P, V) {
          _t.nextTick(function() {
            w[o] ? V(w[o]) : P(u(void 0, !0));
          });
        });
      var k = this[s], A;
      if (k)
        A = new Promise(p(k, this));
      else {
        var U = this[c].read();
        if (U !== null)
          return Promise.resolve(u(U, !1));
        A = new Promise(this[l]);
      }
      return this[s] = A, A;
    }
  }, e(t, Symbol.asyncIterator, function() {
    return this;
  }), e(t, "return", function() {
    var w = this;
    return new Promise(function(x, k) {
      w[c].destroy(null, function(A) {
        if (A) {
          k(A);
          return;
        }
        x(u(void 0, !0));
      });
    });
  }), t), m), b = function(w) {
    var x, k = Object.create(g, (x = {}, e(x, c, {
      value: w,
      writable: !0
    }), e(x, r, {
      value: null,
      writable: !0
    }), e(x, i, {
      value: null,
      writable: !0
    }), e(x, o, {
      value: null,
      writable: !0
    }), e(x, a, {
      value: w._readableState.endEmitted,
      writable: !0
    }), e(x, l, {
      value: function(U, P) {
        var V = k[c].read();
        V ? (k[s] = null, k[r] = null, k[i] = null, U(u(V, !1))) : (k[r] = U, k[i] = P);
      },
      writable: !0
    }), x));
    return k[s] = null, n(w, function(A) {
      if (A && A.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var U = k[i];
        U !== null && (k[s] = null, k[r] = null, k[i] = null, U(A)), k[o] = A;
        return;
      }
      var P = k[r];
      P !== null && (k[s] = null, k[r] = null, k[i] = null, P(u(void 0, !0))), k[a] = !0;
    }), w.on("readable", f.bind(null, k)), k;
  };
  return B_ = b, B_;
}
var L_, SO;
function $ge() {
  return SO || (SO = 1, L_ = function() {
    throw new Error("Readable.from is not available in the browser");
  }), L_;
}
var P_, TO;
function lP() {
  if (TO)
    return P_;
  TO = 1, P_ = I;
  var t;
  I.ReadableState = V, zC.EventEmitter;
  var e = function(Q, De) {
    return Q.listeners(De).length;
  }, n = Z9(), r = D0().Buffer, i = oa.Uint8Array || function() {
  };
  function o(j) {
    return r.from(j);
  }
  function a(j) {
    return r.isBuffer(j) || j instanceof i;
  }
  var s = iP(), l;
  s && s.debuglog ? l = s.debuglog("stream") : l = function() {
  };
  var c = Lge(), u = oP(), d = aP(), f = d.getHighWaterMark, p = lh().codes, m = p.ERR_INVALID_ARG_TYPE, g = p.ERR_STREAM_PUSH_AFTER_EOF, b = p.ERR_METHOD_NOT_IMPLEMENTED, y = p.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, w, x, k;
  _u(I, n);
  var A = u.errorOrDestroy, U = ["error", "close", "destroy", "pause", "resume"];
  function P(j, Q, De) {
    if (typeof j.prependListener == "function")
      return j.prependListener(Q, De);
    !j._events || !j._events[Q] ? j.on(Q, De) : Array.isArray(j._events[Q]) ? j._events[Q].unshift(De) : j._events[Q] = [De, j._events[Q]];
  }
  function V(j, Q, De) {
    t = t || Wf(), j = j || {}, typeof De != "boolean" && (De = Q instanceof t), this.objectMode = !!j.objectMode, De && (this.objectMode = this.objectMode || !!j.readableObjectMode), this.highWaterMark = f(this, j, "readableHighWaterMark", De), this.buffer = new c(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = j.emitClose !== !1, this.autoDestroy = !!j.autoDestroy, this.destroyed = !1, this.defaultEncoding = j.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, j.encoding && (w || (w = WT().StringDecoder), this.decoder = new w(j.encoding), this.encoding = j.encoding);
  }
  function I(j) {
    if (t = t || Wf(), !(this instanceof I))
      return new I(j);
    var Q = this instanceof t;
    this._readableState = new V(j, this, Q), this.readable = !0, j && (typeof j.read == "function" && (this._read = j.read), typeof j.destroy == "function" && (this._destroy = j.destroy)), n.call(this);
  }
  Object.defineProperty(I.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Q) {
      this._readableState && (this._readableState.destroyed = Q);
    }
  }), I.prototype.destroy = u.destroy, I.prototype._undestroy = u.undestroy, I.prototype._destroy = function(j, Q) {
    Q(j);
  }, I.prototype.push = function(j, Q) {
    var De = this._readableState, T;
    return De.objectMode ? T = !0 : typeof j == "string" && (Q = Q || De.defaultEncoding, Q !== De.encoding && (j = r.from(j, Q), Q = ""), T = !0), le(this, j, Q, !1, T);
  }, I.prototype.unshift = function(j) {
    return le(this, j, null, !0, !1);
  };
  function le(j, Q, De, T, pe) {
    l("readableAddChunk", Q);
    var M = j._readableState;
    if (Q === null)
      M.reading = !1, ee(j, M);
    else {
      var _;
      if (pe || (_ = F(M, Q)), _)
        A(j, _);
      else if (M.objectMode || Q && Q.length > 0)
        if (typeof Q != "string" && !M.objectMode && Object.getPrototypeOf(Q) !== r.prototype && (Q = o(Q)), T)
          M.endEmitted ? A(j, new y()) : be(j, M, Q, !0);
        else if (M.ended)
          A(j, new g());
        else {
          if (M.destroyed)
            return !1;
          M.reading = !1, M.decoder && !De ? (Q = M.decoder.write(Q), M.objectMode || Q.length !== 0 ? be(j, M, Q, !1) : te(j, M)) : be(j, M, Q, !1);
        }
      else T || (M.reading = !1, te(j, M));
    }
    return !M.ended && (M.length < M.highWaterMark || M.length === 0);
  }
  function be(j, Q, De, T) {
    Q.flowing && Q.length === 0 && !Q.sync ? (Q.awaitDrain = 0, j.emit("data", De)) : (Q.length += Q.objectMode ? 1 : De.length, T ? Q.buffer.unshift(De) : Q.buffer.push(De), Q.needReadable && Z(j)), te(j, Q);
  }
  function F(j, Q) {
    var De;
    return !a(Q) && typeof Q != "string" && Q !== void 0 && !j.objectMode && (De = new m("chunk", ["string", "Buffer", "Uint8Array"], Q)), De;
  }
  I.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, I.prototype.setEncoding = function(j) {
    w || (w = WT().StringDecoder);
    var Q = new w(j);
    this._readableState.decoder = Q, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var De = this._readableState.buffer.head, T = ""; De !== null; )
      T += Q.write(De.data), De = De.next;
    return this._readableState.buffer.clear(), T !== "" && this._readableState.buffer.push(T), this._readableState.length = T.length, this;
  };
  var G = 1073741824;
  function C(j) {
    return j >= G ? j = G : (j--, j |= j >>> 1, j |= j >>> 2, j |= j >>> 4, j |= j >>> 8, j |= j >>> 16, j++), j;
  }
  function ie(j, Q) {
    return j <= 0 || Q.length === 0 && Q.ended ? 0 : Q.objectMode ? 1 : j !== j ? Q.flowing && Q.length ? Q.buffer.head.data.length : Q.length : (j > Q.highWaterMark && (Q.highWaterMark = C(j)), j <= Q.length ? j : Q.ended ? Q.length : (Q.needReadable = !0, 0));
  }
  I.prototype.read = function(j) {
    l("read", j), j = parseInt(j, 10);
    var Q = this._readableState, De = j;
    if (j !== 0 && (Q.emittedReadable = !1), j === 0 && Q.needReadable && ((Q.highWaterMark !== 0 ? Q.length >= Q.highWaterMark : Q.length > 0) || Q.ended))
      return l("read: emitReadable", Q.length, Q.ended), Q.length === 0 && Q.ended ? W(this) : Z(this), null;
    if (j = ie(j, Q), j === 0 && Q.ended)
      return Q.length === 0 && W(this), null;
    var T = Q.needReadable;
    l("need readable", T), (Q.length === 0 || Q.length - j < Q.highWaterMark) && (T = !0, l("length less than watermark", T)), Q.ended || Q.reading ? (T = !1, l("reading or ended", T)) : T && (l("do read"), Q.reading = !0, Q.sync = !0, Q.length === 0 && (Q.needReadable = !0), this._read(Q.highWaterMark), Q.sync = !1, Q.reading || (j = ie(De, Q)));
    var pe;
    return j > 0 ? pe = H(j, Q) : pe = null, pe === null ? (Q.needReadable = Q.length <= Q.highWaterMark, j = 0) : (Q.length -= j, Q.awaitDrain = 0), Q.length === 0 && (Q.ended || (Q.needReadable = !0), De !== j && Q.ended && W(this)), pe !== null && this.emit("data", pe), pe;
  };
  function ee(j, Q) {
    if (l("onEofChunk"), !Q.ended) {
      if (Q.decoder) {
        var De = Q.decoder.end();
        De && De.length && (Q.buffer.push(De), Q.length += Q.objectMode ? 1 : De.length);
      }
      Q.ended = !0, Q.sync ? Z(j) : (Q.needReadable = !1, Q.emittedReadable || (Q.emittedReadable = !0, oe(j)));
    }
  }
  function Z(j) {
    var Q = j._readableState;
    l("emitReadable", Q.needReadable, Q.emittedReadable), Q.needReadable = !1, Q.emittedReadable || (l("emitReadable", Q.flowing), Q.emittedReadable = !0, _t.nextTick(oe, j));
  }
  function oe(j) {
    var Q = j._readableState;
    l("emitReadable_", Q.destroyed, Q.length, Q.ended), !Q.destroyed && (Q.length || Q.ended) && (j.emit("readable"), Q.emittedReadable = !1), Q.needReadable = !Q.flowing && !Q.ended && Q.length <= Q.highWaterMark, he(j);
  }
  function te(j, Q) {
    Q.readingMore || (Q.readingMore = !0, _t.nextTick(_e, j, Q));
  }
  function _e(j, Q) {
    for (; !Q.reading && !Q.ended && (Q.length < Q.highWaterMark || Q.flowing && Q.length === 0); ) {
      var De = Q.length;
      if (l("maybeReadMore read 0"), j.read(0), De === Q.length)
        break;
    }
    Q.readingMore = !1;
  }
  I.prototype._read = function(j) {
    A(this, new b("_read()"));
  }, I.prototype.pipe = function(j, Q) {
    var De = this, T = this._readableState;
    switch (T.pipesCount) {
      case 0:
        T.pipes = j;
        break;
      case 1:
        T.pipes = [T.pipes, j];
        break;
      default:
        T.pipes.push(j);
        break;
    }
    T.pipesCount += 1, l("pipe count=%d opts=%j", T.pipesCount, Q);
    var pe = (!Q || Q.end !== !1) && j !== _t.stdout && j !== _t.stderr, M = pe ? S : Ee;
    T.endEmitted ? _t.nextTick(M) : De.once("end", M), j.on("unpipe", _);
    function _(Ne, Le) {
      l("onunpipe"), Ne === De && Le && Le.hasUnpiped === !1 && (Le.hasUnpiped = !0, fe());
    }
    function S() {
      l("onend"), j.end();
    }
    var O = q(De);
    j.on("drain", O);
    var ne = !1;
    function fe() {
      l("cleanup"), j.removeListener("close", de), j.removeListener("finish", ge), j.removeListener("drain", O), j.removeListener("error", re), j.removeListener("unpipe", _), De.removeListener("end", S), De.removeListener("end", Ee), De.removeListener("data", J), ne = !0, T.awaitDrain && (!j._writableState || j._writableState.needDrain) && O();
    }
    De.on("data", J);
    function J(Ne) {
      l("ondata");
      var Le = j.write(Ne);
      l("dest.write", Le), Le === !1 && ((T.pipesCount === 1 && T.pipes === j || T.pipesCount > 1 && ye(T.pipes, j) !== -1) && !ne && (l("false write response, pause", T.awaitDrain), T.awaitDrain++), De.pause());
    }
    function re(Ne) {
      l("onerror", Ne), Ee(), j.removeListener("error", re), e(j, "error") === 0 && A(j, Ne);
    }
    P(j, "error", re);
    function de() {
      j.removeListener("finish", ge), Ee();
    }
    j.once("close", de);
    function ge() {
      l("onfinish"), j.removeListener("close", de), Ee();
    }
    j.once("finish", ge);
    function Ee() {
      l("unpipe"), De.unpipe(j);
    }
    return j.emit("pipe", De), T.flowing || (l("pipe resume"), De.resume()), j;
  };
  function q(j) {
    return function() {
      var De = j._readableState;
      l("pipeOnDrain", De.awaitDrain), De.awaitDrain && De.awaitDrain--, De.awaitDrain === 0 && e(j, "data") && (De.flowing = !0, he(j));
    };
  }
  I.prototype.unpipe = function(j) {
    var Q = this._readableState, De = {
      hasUnpiped: !1
    };
    if (Q.pipesCount === 0)
      return this;
    if (Q.pipesCount === 1)
      return j && j !== Q.pipes ? this : (j || (j = Q.pipes), Q.pipes = null, Q.pipesCount = 0, Q.flowing = !1, j && j.emit("unpipe", this, De), this);
    if (!j) {
      var T = Q.pipes, pe = Q.pipesCount;
      Q.pipes = null, Q.pipesCount = 0, Q.flowing = !1;
      for (var M = 0; M < pe; M++)
        T[M].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var _ = ye(Q.pipes, j);
    return _ === -1 ? this : (Q.pipes.splice(_, 1), Q.pipesCount -= 1, Q.pipesCount === 1 && (Q.pipes = Q.pipes[0]), j.emit("unpipe", this, De), this);
  }, I.prototype.on = function(j, Q) {
    var De = n.prototype.on.call(this, j, Q), T = this._readableState;
    return j === "data" ? (T.readableListening = this.listenerCount("readable") > 0, T.flowing !== !1 && this.resume()) : j === "readable" && !T.endEmitted && !T.readableListening && (T.readableListening = T.needReadable = !0, T.flowing = !1, T.emittedReadable = !1, l("on readable", T.length, T.reading), T.length ? Z(this) : T.reading || _t.nextTick(ce, this)), De;
  }, I.prototype.addListener = I.prototype.on, I.prototype.removeListener = function(j, Q) {
    var De = n.prototype.removeListener.call(this, j, Q);
    return j === "readable" && _t.nextTick(N, this), De;
  }, I.prototype.removeAllListeners = function(j) {
    var Q = n.prototype.removeAllListeners.apply(this, arguments);
    return (j === "readable" || j === void 0) && _t.nextTick(N, this), Q;
  };
  function N(j) {
    var Q = j._readableState;
    Q.readableListening = j.listenerCount("readable") > 0, Q.resumeScheduled && !Q.paused ? Q.flowing = !0 : j.listenerCount("data") > 0 && j.resume();
  }
  function ce(j) {
    l("readable nexttick read 0"), j.read(0);
  }
  I.prototype.resume = function() {
    var j = this._readableState;
    return j.flowing || (l("resume"), j.flowing = !j.readableListening, me(this, j)), j.paused = !1, this;
  };
  function me(j, Q) {
    Q.resumeScheduled || (Q.resumeScheduled = !0, _t.nextTick(ve, j, Q));
  }
  function ve(j, Q) {
    l("resume", Q.reading), Q.reading || j.read(0), Q.resumeScheduled = !1, j.emit("resume"), he(j), Q.flowing && !Q.reading && j.read(0);
  }
  I.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function he(j) {
    var Q = j._readableState;
    for (l("flow", Q.flowing); Q.flowing && j.read() !== null; )
      ;
  }
  I.prototype.wrap = function(j) {
    var Q = this, De = this._readableState, T = !1;
    j.on("end", function() {
      if (l("wrapped end"), De.decoder && !De.ended) {
        var _ = De.decoder.end();
        _ && _.length && Q.push(_);
      }
      Q.push(null);
    }), j.on("data", function(_) {
      if (l("wrapped data"), De.decoder && (_ = De.decoder.write(_)), !(De.objectMode && _ == null) && !(!De.objectMode && (!_ || !_.length))) {
        var S = Q.push(_);
        S || (T = !0, j.pause());
      }
    });
    for (var pe in j)
      this[pe] === void 0 && typeof j[pe] == "function" && (this[pe] = /* @__PURE__ */ function(S) {
        return function() {
          return j[S].apply(j, arguments);
        };
      }(pe));
    for (var M = 0; M < U.length; M++)
      j.on(U[M], this.emit.bind(this, U[M]));
    return this._read = function(_) {
      l("wrapped _read", _), T && (T = !1, j.resume());
    }, this;
  }, typeof Symbol == "function" && (I.prototype[Symbol.asyncIterator] = function() {
    return x === void 0 && (x = zge()), x(this);
  }), Object.defineProperty(I.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(I.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(I.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Q) {
      this._readableState && (this._readableState.flowing = Q);
    }
  }), I._fromList = H, Object.defineProperty(I.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function H(j, Q) {
    if (Q.length === 0)
      return null;
    var De;
    return Q.objectMode ? De = Q.buffer.shift() : !j || j >= Q.length ? (Q.decoder ? De = Q.buffer.join("") : Q.buffer.length === 1 ? De = Q.buffer.first() : De = Q.buffer.concat(Q.length), Q.buffer.clear()) : De = Q.buffer.consume(j, Q.decoder), De;
  }
  function W(j) {
    var Q = j._readableState;
    l("endReadable", Q.endEmitted), Q.endEmitted || (Q.ended = !0, _t.nextTick(we, Q, j));
  }
  function we(j, Q) {
    if (l("endReadableNT", j.endEmitted, j.length), !j.endEmitted && j.length === 0 && (j.endEmitted = !0, Q.readable = !1, Q.emit("end"), j.autoDestroy)) {
      var De = Q._writableState;
      (!De || De.autoDestroy && De.finished) && Q.destroy();
    }
  }
  typeof Symbol == "function" && (I.from = function(j, Q) {
    return k === void 0 && (k = $ge()), k(I, j, Q);
  });
  function ye(j, Q) {
    for (var De = 0, T = j.length; De < T; De++)
      if (j[De] === Q)
        return De;
    return -1;
  }
  return P_;
}
var W_, DO;
function cP() {
  if (DO)
    return W_;
  DO = 1, W_ = s;
  var t = lh().codes, e = t.ERR_METHOD_NOT_IMPLEMENTED, n = t.ERR_MULTIPLE_CALLBACK, r = t.ERR_TRANSFORM_ALREADY_TRANSFORMING, i = t.ERR_TRANSFORM_WITH_LENGTH_0, o = Wf();
  _u(s, o);
  function a(u, d) {
    var f = this._transformState;
    f.transforming = !1;
    var p = f.writecb;
    if (p === null)
      return this.emit("error", new n());
    f.writechunk = null, f.writecb = null, d != null && this.push(d), p(u);
    var m = this._readableState;
    m.reading = !1, (m.needReadable || m.length < m.highWaterMark) && this._read(m.highWaterMark);
  }
  function s(u) {
    if (!(this instanceof s))
      return new s(u);
    o.call(this, u), this._transformState = {
      afterTransform: a.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, u && (typeof u.transform == "function" && (this._transform = u.transform), typeof u.flush == "function" && (this._flush = u.flush)), this.on("prefinish", l);
  }
  function l() {
    var u = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(d, f) {
      c(u, d, f);
    }) : c(this, null, null);
  }
  s.prototype.push = function(u, d) {
    return this._transformState.needTransform = !1, o.prototype.push.call(this, u, d);
  }, s.prototype._transform = function(u, d, f) {
    f(new e("_transform()"));
  }, s.prototype._write = function(u, d, f) {
    var p = this._transformState;
    if (p.writecb = f, p.writechunk = u, p.writeencoding = d, !p.transforming) {
      var m = this._readableState;
      (p.needTransform || m.needReadable || m.length < m.highWaterMark) && this._read(m.highWaterMark);
    }
  }, s.prototype._read = function(u) {
    var d = this._transformState;
    d.writechunk !== null && !d.transforming ? (d.transforming = !0, this._transform(d.writechunk, d.writeencoding, d.afterTransform)) : d.needTransform = !0;
  }, s.prototype._destroy = function(u, d) {
    o.prototype._destroy.call(this, u, function(f) {
      d(f);
    });
  };
  function c(u, d, f) {
    if (d)
      return u.emit("error", d);
    if (f != null && u.push(f), u._writableState.length)
      throw new i();
    if (u._transformState.transforming)
      throw new r();
    return u.push(null);
  }
  return W_;
}
var z_, EO;
function Hge() {
  if (EO)
    return z_;
  EO = 1, z_ = e;
  var t = cP();
  _u(e, t);
  function e(n) {
    if (!(this instanceof e))
      return new e(n);
    t.call(this, n);
  }
  return e.prototype._transform = function(n, r, i) {
    i(null, n);
  }, z_;
}
var $_, CO;
function jge() {
  if (CO)
    return $_;
  CO = 1;
  var t;
  function e(f) {
    var p = !1;
    return function() {
      p || (p = !0, f.apply(void 0, arguments));
    };
  }
  var n = lh().codes, r = n.ERR_MISSING_ARGS, i = n.ERR_STREAM_DESTROYED;
  function o(f) {
    if (f)
      throw f;
  }
  function a(f) {
    return f.setHeader && typeof f.abort == "function";
  }
  function s(f, p, m, g) {
    g = e(g);
    var b = !1;
    f.on("close", function() {
      b = !0;
    }), t === void 0 && (t = VC()), t(f, {
      readable: p,
      writable: m
    }, function(w) {
      if (w)
        return g(w);
      b = !0, g();
    });
    var y = !1;
    return function(w) {
      if (!b && !y) {
        if (y = !0, a(f))
          return f.abort();
        if (typeof f.destroy == "function")
          return f.destroy();
        g(w || new i("pipe"));
      }
    };
  }
  function l(f) {
    f();
  }
  function c(f, p) {
    return f.pipe(p);
  }
  function u(f) {
    return !f.length || typeof f[f.length - 1] != "function" ? o : f.pop();
  }
  function d() {
    for (var f = arguments.length, p = new Array(f), m = 0; m < f; m++)
      p[m] = arguments[m];
    var g = u(p);
    if (Array.isArray(p[0]) && (p = p[0]), p.length < 2)
      throw new r("streams");
    var b, y = p.map(function(w, x) {
      var k = x < p.length - 1, A = x > 0;
      return s(w, k, A, function(U) {
        b || (b = U), U && y.forEach(l), !k && (y.forEach(l), g(b));
      });
    });
    return p.reduce(c);
  }
  return $_ = d, $_;
}
var qC = ro, GC = zC.EventEmitter, Vge = _u;
Vge(ro, GC);
ro.Readable = lP();
ro.Writable = sP();
ro.Duplex = Wf();
ro.Transform = cP();
ro.PassThrough = Hge();
ro.finished = VC();
ro.pipeline = jge();
ro.Stream = ro;
function ro() {
  GC.call(this);
}
ro.prototype.pipe = function(t, e) {
  var n = this;
  function r(u) {
    t.writable && t.write(u) === !1 && n.pause && n.pause();
  }
  n.on("data", r);
  function i() {
    n.readable && n.resume && n.resume();
  }
  t.on("drain", i), !t._isStdio && (!e || e.end !== !1) && (n.on("end", a), n.on("close", s));
  var o = !1;
  function a() {
    o || (o = !0, t.end());
  }
  function s() {
    o || (o = !0, typeof t.destroy == "function" && t.destroy());
  }
  function l(u) {
    if (c(), GC.listenerCount(this, "error") === 0)
      throw u;
  }
  n.on("error", l), t.on("error", l);
  function c() {
    n.removeListener("data", r), t.removeListener("drain", i), n.removeListener("end", a), n.removeListener("close", s), n.removeListener("error", l), t.removeListener("error", l), n.removeListener("end", c), n.removeListener("close", c), t.removeListener("close", c);
  }
  return n.on("end", c), n.on("close", c), t.on("close", c), t.emit("pipe", n), t;
};
(function(t) {
  (function(e) {
    e.parser = function(H, W) {
      return new r(H, W);
    }, e.SAXParser = r, e.SAXStream = u, e.createStream = c, e.MAX_BUFFER_LENGTH = 64 * 1024;
    var n = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    e.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function r(H, W) {
      if (!(this instanceof r))
        return new r(H, W);
      var we = this;
      o(we), we.q = we.c = "", we.bufferCheckPosition = e.MAX_BUFFER_LENGTH, we.opt = W || {}, we.opt.lowercase = we.opt.lowercase || we.opt.lowercasetags, we.looseCase = we.opt.lowercase ? "toLowerCase" : "toUpperCase", we.tags = [], we.closed = we.closedRoot = we.sawRoot = !1, we.tag = we.error = null, we.strict = !!H, we.noscript = !!(H || we.opt.noscript), we.state = I.BEGIN, we.strictEntities = we.opt.strictEntities, we.ENTITIES = we.strictEntities ? Object.create(e.XML_ENTITIES) : Object.create(e.ENTITIES), we.attribList = [], we.opt.xmlns && (we.ns = Object.create(g)), we.trackPosition = we.opt.position !== !1, we.trackPosition && (we.position = we.line = we.column = 0), be(we, "onready");
    }
    Object.create || (Object.create = function(H) {
      function W() {
      }
      W.prototype = H;
      var we = new W();
      return we;
    }), Object.keys || (Object.keys = function(H) {
      var W = [];
      for (var we in H)
        H.hasOwnProperty(we) && W.push(we);
      return W;
    });
    function i(H) {
      for (var W = Math.max(e.MAX_BUFFER_LENGTH, 10), we = 0, ye = 0, j = n.length; ye < j; ye++) {
        var Q = H[n[ye]].length;
        if (Q > W)
          switch (n[ye]) {
            case "textNode":
              G(H);
              break;
            case "cdata":
              F(H, "oncdata", H.cdata), H.cdata = "";
              break;
            case "script":
              F(H, "onscript", H.script), H.script = "";
              break;
            default:
              ie(H, "Max buffer length exceeded: " + n[ye]);
          }
        we = Math.max(we, Q);
      }
      var De = e.MAX_BUFFER_LENGTH - we;
      H.bufferCheckPosition = De + H.position;
    }
    function o(H) {
      for (var W = 0, we = n.length; W < we; W++)
        H[n[W]] = "";
    }
    function a(H) {
      G(H), H.cdata !== "" && (F(H, "oncdata", H.cdata), H.cdata = ""), H.script !== "" && (F(H, "onscript", H.script), H.script = "");
    }
    r.prototype = {
      end: function() {
        ee(this);
      },
      write: he,
      resume: function() {
        return this.error = null, this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        a(this);
      }
    };
    var s;
    try {
      s = qC.Stream;
    } catch {
      s = function() {
      };
    }
    var l = e.EVENTS.filter(function(H) {
      return H !== "error" && H !== "end";
    });
    function c(H, W) {
      return new u(H, W);
    }
    function u(H, W) {
      if (!(this instanceof u))
        return new u(H, W);
      s.apply(this), this._parser = new r(H, W), this.writable = !0, this.readable = !0;
      var we = this;
      this._parser.onend = function() {
        we.emit("end");
      }, this._parser.onerror = function(ye) {
        we.emit("error", ye), we._parser.error = null;
      }, this._decoder = null, l.forEach(function(ye) {
        Object.defineProperty(we, "on" + ye, {
          get: function() {
            return we._parser["on" + ye];
          },
          set: function(j) {
            if (!j)
              return we.removeAllListeners(ye), we._parser["on" + ye] = j, j;
            we.on(ye, j);
          },
          enumerable: !0,
          configurable: !1
        });
      });
    }
    u.prototype = Object.create(s.prototype, {
      constructor: {
        value: u
      }
    }), u.prototype.write = function(H) {
      if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(H)) {
        if (!this._decoder) {
          var W = WT().StringDecoder;
          this._decoder = new W("utf8");
        }
        H = this._decoder.write(H);
      }
      return this._parser.write(H.toString()), this.emit("data", H), !0;
    }, u.prototype.end = function(H) {
      return H && H.length && this.write(H), this._parser.end(), !0;
    }, u.prototype.on = function(H, W) {
      var we = this;
      return !we._parser["on" + H] && l.indexOf(H) !== -1 && (we._parser["on" + H] = function() {
        var ye = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
        ye.splice(0, 0, H), we.emit.apply(we, ye);
      }), s.prototype.on.call(we, H, W);
    };
    var d = "[CDATA[", f = "DOCTYPE", p = "http://www.w3.org/XML/1998/namespace", m = "http://www.w3.org/2000/xmlns/", g = { xml: p, xmlns: m }, b = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, y = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, w = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, x = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function k(H) {
      return H === " " || H === `
` || H === "\r" || H === "	";
    }
    function A(H) {
      return H === '"' || H === "'";
    }
    function U(H) {
      return H === ">" || k(H);
    }
    function P(H, W) {
      return H.test(W);
    }
    function V(H, W) {
      return !P(H, W);
    }
    var I = 0;
    e.STATE = {
      BEGIN: I++,
      // leading byte order mark or whitespace
      BEGIN_WHITESPACE: I++,
      // leading whitespace
      TEXT: I++,
      // general stuff
      TEXT_ENTITY: I++,
      // &amp and such.
      OPEN_WAKA: I++,
      // <
      SGML_DECL: I++,
      // <!BLARG
      SGML_DECL_QUOTED: I++,
      // <!BLARG foo "bar
      DOCTYPE: I++,
      // <!DOCTYPE
      DOCTYPE_QUOTED: I++,
      // <!DOCTYPE "//blah
      DOCTYPE_DTD: I++,
      // <!DOCTYPE "//blah" [ ...
      DOCTYPE_DTD_QUOTED: I++,
      // <!DOCTYPE "//blah" [ "foo
      COMMENT_STARTING: I++,
      // <!-
      COMMENT: I++,
      // <!--
      COMMENT_ENDING: I++,
      // <!-- blah -
      COMMENT_ENDED: I++,
      // <!-- blah --
      CDATA: I++,
      // <![CDATA[ something
      CDATA_ENDING: I++,
      // ]
      CDATA_ENDING_2: I++,
      // ]]
      PROC_INST: I++,
      // <?hi
      PROC_INST_BODY: I++,
      // <?hi there
      PROC_INST_ENDING: I++,
      // <?hi "there" ?
      OPEN_TAG: I++,
      // <strong
      OPEN_TAG_SLASH: I++,
      // <strong /
      ATTRIB: I++,
      // <a
      ATTRIB_NAME: I++,
      // <a foo
      ATTRIB_NAME_SAW_WHITE: I++,
      // <a foo _
      ATTRIB_VALUE: I++,
      // <a foo=
      ATTRIB_VALUE_QUOTED: I++,
      // <a foo="bar
      ATTRIB_VALUE_CLOSED: I++,
      // <a foo="bar"
      ATTRIB_VALUE_UNQUOTED: I++,
      // <a foo=bar
      ATTRIB_VALUE_ENTITY_Q: I++,
      // <foo bar="&quot;"
      ATTRIB_VALUE_ENTITY_U: I++,
      // <foo bar=&quot
      CLOSE_TAG: I++,
      // </a
      CLOSE_TAG_SAW_WHITE: I++,
      // </a   >
      SCRIPT: I++,
      // <script> ...
      SCRIPT_ENDING: I++
      // <script> ... <
    }, e.XML_ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    }, e.ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    }, Object.keys(e.ENTITIES).forEach(function(H) {
      var W = e.ENTITIES[H], we = typeof W == "number" ? String.fromCharCode(W) : W;
      e.ENTITIES[H] = we;
    });
    for (var le in e.STATE)
      e.STATE[e.STATE[le]] = le;
    I = e.STATE;
    function be(H, W, we) {
      H[W] && H[W](we);
    }
    function F(H, W, we) {
      H.textNode && G(H), be(H, W, we);
    }
    function G(H) {
      H.textNode = C(H.opt, H.textNode), H.textNode && be(H, "ontext", H.textNode), H.textNode = "";
    }
    function C(H, W) {
      return H.trim && (W = W.trim()), H.normalize && (W = W.replace(/\s+/g, " ")), W;
    }
    function ie(H, W) {
      return G(H), H.trackPosition && (W += `
Line: ` + H.line + `
Column: ` + H.column + `
Char: ` + H.c), W = new Error(W), H.error = W, be(H, "onerror", W), H;
    }
    function ee(H) {
      return H.sawRoot && !H.closedRoot && Z(H, "Unclosed root tag"), H.state !== I.BEGIN && H.state !== I.BEGIN_WHITESPACE && H.state !== I.TEXT && ie(H, "Unexpected end"), G(H), H.c = "", H.closed = !0, be(H, "onend"), r.call(H, H.strict, H.opt), H;
    }
    function Z(H, W) {
      if (typeof H != "object" || !(H instanceof r))
        throw new Error("bad call to strictFail");
      H.strict && ie(H, W);
    }
    function oe(H) {
      H.strict || (H.tagName = H.tagName[H.looseCase]());
      var W = H.tags[H.tags.length - 1] || H, we = H.tag = { name: H.tagName, attributes: {} };
      H.opt.xmlns && (we.ns = W.ns), H.attribList.length = 0, F(H, "onopentagstart", we);
    }
    function te(H, W) {
      var we = H.indexOf(":"), ye = we < 0 ? ["", H] : H.split(":"), j = ye[0], Q = ye[1];
      return W && H === "xmlns" && (j = "xmlns", Q = ""), { prefix: j, local: Q };
    }
    function _e(H) {
      if (H.strict || (H.attribName = H.attribName[H.looseCase]()), H.attribList.indexOf(H.attribName) !== -1 || H.tag.attributes.hasOwnProperty(H.attribName)) {
        H.attribName = H.attribValue = "";
        return;
      }
      if (H.opt.xmlns) {
        var W = te(H.attribName, !0), we = W.prefix, ye = W.local;
        if (we === "xmlns")
          if (ye === "xml" && H.attribValue !== p)
            Z(
              H,
              "xml: prefix must be bound to " + p + `
Actual: ` + H.attribValue
            );
          else if (ye === "xmlns" && H.attribValue !== m)
            Z(
              H,
              "xmlns: prefix must be bound to " + m + `
Actual: ` + H.attribValue
            );
          else {
            var j = H.tag, Q = H.tags[H.tags.length - 1] || H;
            j.ns === Q.ns && (j.ns = Object.create(Q.ns)), j.ns[ye] = H.attribValue;
          }
        H.attribList.push([H.attribName, H.attribValue]);
      } else
        H.tag.attributes[H.attribName] = H.attribValue, F(H, "onattribute", {
          name: H.attribName,
          value: H.attribValue
        });
      H.attribName = H.attribValue = "";
    }
    function q(H, W) {
      if (H.opt.xmlns) {
        var we = H.tag, ye = te(H.tagName);
        we.prefix = ye.prefix, we.local = ye.local, we.uri = we.ns[ye.prefix] || "", we.prefix && !we.uri && (Z(H, "Unbound namespace prefix: " + JSON.stringify(H.tagName)), we.uri = ye.prefix);
        var j = H.tags[H.tags.length - 1] || H;
        we.ns && j.ns !== we.ns && Object.keys(we.ns).forEach(function(J) {
          F(H, "onopennamespace", {
            prefix: J,
            uri: we.ns[J]
          });
        });
        for (var Q = 0, De = H.attribList.length; Q < De; Q++) {
          var T = H.attribList[Q], pe = T[0], M = T[1], _ = te(pe, !0), S = _.prefix, O = _.local, ne = S === "" ? "" : we.ns[S] || "", fe = {
            name: pe,
            value: M,
            prefix: S,
            local: O,
            uri: ne
          };
          S && S !== "xmlns" && !ne && (Z(H, "Unbound namespace prefix: " + JSON.stringify(S)), fe.uri = S), H.tag.attributes[pe] = fe, F(H, "onattribute", fe);
        }
        H.attribList.length = 0;
      }
      H.tag.isSelfClosing = !!W, H.sawRoot = !0, H.tags.push(H.tag), F(H, "onopentag", H.tag), W || (!H.noscript && H.tagName.toLowerCase() === "script" ? H.state = I.SCRIPT : H.state = I.TEXT, H.tag = null, H.tagName = ""), H.attribName = H.attribValue = "", H.attribList.length = 0;
    }
    function N(H) {
      if (!H.tagName) {
        Z(H, "Weird empty close tag."), H.textNode += "</>", H.state = I.TEXT;
        return;
      }
      if (H.script) {
        if (H.tagName !== "script") {
          H.script += "</" + H.tagName + ">", H.tagName = "", H.state = I.SCRIPT;
          return;
        }
        F(H, "onscript", H.script), H.script = "";
      }
      var W = H.tags.length, we = H.tagName;
      H.strict || (we = we[H.looseCase]());
      for (var ye = we; W--; ) {
        var j = H.tags[W];
        if (j.name !== ye)
          Z(H, "Unexpected close tag");
        else
          break;
      }
      if (W < 0) {
        Z(H, "Unmatched closing tag: " + H.tagName), H.textNode += "</" + H.tagName + ">", H.state = I.TEXT;
        return;
      }
      H.tagName = we;
      for (var Q = H.tags.length; Q-- > W; ) {
        var De = H.tag = H.tags.pop();
        H.tagName = H.tag.name, F(H, "onclosetag", H.tagName);
        var T = {};
        for (var pe in De.ns)
          T[pe] = De.ns[pe];
        var M = H.tags[H.tags.length - 1] || H;
        H.opt.xmlns && De.ns !== M.ns && Object.keys(De.ns).forEach(function(_) {
          var S = De.ns[_];
          F(H, "onclosenamespace", { prefix: _, uri: S });
        });
      }
      W === 0 && (H.closedRoot = !0), H.tagName = H.attribValue = H.attribName = "", H.attribList.length = 0, H.state = I.TEXT;
    }
    function ce(H) {
      var W = H.entity, we = W.toLowerCase(), ye, j = "";
      return H.ENTITIES[W] ? H.ENTITIES[W] : H.ENTITIES[we] ? H.ENTITIES[we] : (W = we, W.charAt(0) === "#" && (W.charAt(1) === "x" ? (W = W.slice(2), ye = parseInt(W, 16), j = ye.toString(16)) : (W = W.slice(1), ye = parseInt(W, 10), j = ye.toString(10))), W = W.replace(/^0+/, ""), isNaN(ye) || j.toLowerCase() !== W ? (Z(H, "Invalid character entity"), "&" + H.entity + ";") : String.fromCodePoint(ye));
    }
    function me(H, W) {
      W === "<" ? (H.state = I.OPEN_WAKA, H.startTagPosition = H.position) : k(W) || (Z(H, "Non-whitespace before first tag."), H.textNode = W, H.state = I.TEXT);
    }
    function ve(H, W) {
      var we = "";
      return W < H.length && (we = H.charAt(W)), we;
    }
    function he(H) {
      var W = this;
      if (this.error)
        throw this.error;
      if (W.closed)
        return ie(
          W,
          "Cannot write after close. Assign an onready handler."
        );
      if (H === null)
        return ee(W);
      typeof H == "object" && (H = H.toString());
      for (var we = 0, ye = ""; ye = ve(H, we++), W.c = ye, !!ye; )
        switch (W.trackPosition && (W.position++, ye === `
` ? (W.line++, W.column = 0) : W.column++), W.state) {
          case I.BEGIN:
            if (W.state = I.BEGIN_WHITESPACE, ye === "\uFEFF")
              continue;
            me(W, ye);
            continue;
          case I.BEGIN_WHITESPACE:
            me(W, ye);
            continue;
          case I.TEXT:
            if (W.sawRoot && !W.closedRoot) {
              for (var j = we - 1; ye && ye !== "<" && ye !== "&"; )
                ye = ve(H, we++), ye && W.trackPosition && (W.position++, ye === `
` ? (W.line++, W.column = 0) : W.column++);
              W.textNode += H.substring(j, we - 1);
            }
            ye === "<" && !(W.sawRoot && W.closedRoot && !W.strict) ? (W.state = I.OPEN_WAKA, W.startTagPosition = W.position) : (!k(ye) && (!W.sawRoot || W.closedRoot) && Z(W, "Text data outside of root node."), ye === "&" ? W.state = I.TEXT_ENTITY : W.textNode += ye);
            continue;
          case I.SCRIPT:
            ye === "<" ? W.state = I.SCRIPT_ENDING : W.script += ye;
            continue;
          case I.SCRIPT_ENDING:
            ye === "/" ? W.state = I.CLOSE_TAG : (W.script += "<" + ye, W.state = I.SCRIPT);
            continue;
          case I.OPEN_WAKA:
            if (ye === "!")
              W.state = I.SGML_DECL, W.sgmlDecl = "";
            else if (!k(ye))
              if (P(b, ye))
                W.state = I.OPEN_TAG, W.tagName = ye;
              else if (ye === "/")
                W.state = I.CLOSE_TAG, W.tagName = "";
              else if (ye === "?")
                W.state = I.PROC_INST, W.procInstName = W.procInstBody = "";
              else {
                if (Z(W, "Unencoded <"), W.startTagPosition + 1 < W.position) {
                  var Q = W.position - W.startTagPosition;
                  ye = new Array(Q).join(" ") + ye;
                }
                W.textNode += "<" + ye, W.state = I.TEXT;
              }
            continue;
          case I.SGML_DECL:
            (W.sgmlDecl + ye).toUpperCase() === d ? (F(W, "onopencdata"), W.state = I.CDATA, W.sgmlDecl = "", W.cdata = "") : W.sgmlDecl + ye === "--" ? (W.state = I.COMMENT, W.comment = "", W.sgmlDecl = "") : (W.sgmlDecl + ye).toUpperCase() === f ? (W.state = I.DOCTYPE, (W.doctype || W.sawRoot) && Z(
              W,
              "Inappropriately located doctype declaration"
            ), W.doctype = "", W.sgmlDecl = "") : ye === ">" ? (F(W, "onsgmldeclaration", W.sgmlDecl), W.sgmlDecl = "", W.state = I.TEXT) : (A(ye) && (W.state = I.SGML_DECL_QUOTED), W.sgmlDecl += ye);
            continue;
          case I.SGML_DECL_QUOTED:
            ye === W.q && (W.state = I.SGML_DECL, W.q = ""), W.sgmlDecl += ye;
            continue;
          case I.DOCTYPE:
            ye === ">" ? (W.state = I.TEXT, F(W, "ondoctype", W.doctype), W.doctype = !0) : (W.doctype += ye, ye === "[" ? W.state = I.DOCTYPE_DTD : A(ye) && (W.state = I.DOCTYPE_QUOTED, W.q = ye));
            continue;
          case I.DOCTYPE_QUOTED:
            W.doctype += ye, ye === W.q && (W.q = "", W.state = I.DOCTYPE);
            continue;
          case I.DOCTYPE_DTD:
            W.doctype += ye, ye === "]" ? W.state = I.DOCTYPE : A(ye) && (W.state = I.DOCTYPE_DTD_QUOTED, W.q = ye);
            continue;
          case I.DOCTYPE_DTD_QUOTED:
            W.doctype += ye, ye === W.q && (W.state = I.DOCTYPE_DTD, W.q = "");
            continue;
          case I.COMMENT:
            ye === "-" ? W.state = I.COMMENT_ENDING : W.comment += ye;
            continue;
          case I.COMMENT_ENDING:
            ye === "-" ? (W.state = I.COMMENT_ENDED, W.comment = C(W.opt, W.comment), W.comment && F(W, "oncomment", W.comment), W.comment = "") : (W.comment += "-" + ye, W.state = I.COMMENT);
            continue;
          case I.COMMENT_ENDED:
            ye !== ">" ? (Z(W, "Malformed comment"), W.comment += "--" + ye, W.state = I.COMMENT) : W.state = I.TEXT;
            continue;
          case I.CDATA:
            ye === "]" ? W.state = I.CDATA_ENDING : W.cdata += ye;
            continue;
          case I.CDATA_ENDING:
            ye === "]" ? W.state = I.CDATA_ENDING_2 : (W.cdata += "]" + ye, W.state = I.CDATA);
            continue;
          case I.CDATA_ENDING_2:
            ye === ">" ? (W.cdata && F(W, "oncdata", W.cdata), F(W, "onclosecdata"), W.cdata = "", W.state = I.TEXT) : ye === "]" ? W.cdata += "]" : (W.cdata += "]]" + ye, W.state = I.CDATA);
            continue;
          case I.PROC_INST:
            ye === "?" ? W.state = I.PROC_INST_ENDING : k(ye) ? W.state = I.PROC_INST_BODY : W.procInstName += ye;
            continue;
          case I.PROC_INST_BODY:
            if (!W.procInstBody && k(ye))
              continue;
            ye === "?" ? W.state = I.PROC_INST_ENDING : W.procInstBody += ye;
            continue;
          case I.PROC_INST_ENDING:
            ye === ">" ? (F(W, "onprocessinginstruction", {
              name: W.procInstName,
              body: W.procInstBody
            }), W.procInstName = W.procInstBody = "", W.state = I.TEXT) : (W.procInstBody += "?" + ye, W.state = I.PROC_INST_BODY);
            continue;
          case I.OPEN_TAG:
            P(y, ye) ? W.tagName += ye : (oe(W), ye === ">" ? q(W) : ye === "/" ? W.state = I.OPEN_TAG_SLASH : (k(ye) || Z(W, "Invalid character in tag name"), W.state = I.ATTRIB));
            continue;
          case I.OPEN_TAG_SLASH:
            ye === ">" ? (q(W, !0), N(W)) : (Z(W, "Forward-slash in opening tag not followed by >"), W.state = I.ATTRIB);
            continue;
          case I.ATTRIB:
            if (k(ye))
              continue;
            ye === ">" ? q(W) : ye === "/" ? W.state = I.OPEN_TAG_SLASH : P(b, ye) ? (W.attribName = ye, W.attribValue = "", W.state = I.ATTRIB_NAME) : Z(W, "Invalid attribute name");
            continue;
          case I.ATTRIB_NAME:
            ye === "=" ? W.state = I.ATTRIB_VALUE : ye === ">" ? (Z(W, "Attribute without value"), W.attribValue = W.attribName, _e(W), q(W)) : k(ye) ? W.state = I.ATTRIB_NAME_SAW_WHITE : P(y, ye) ? W.attribName += ye : Z(W, "Invalid attribute name");
            continue;
          case I.ATTRIB_NAME_SAW_WHITE:
            if (ye === "=")
              W.state = I.ATTRIB_VALUE;
            else {
              if (k(ye))
                continue;
              Z(W, "Attribute without value"), W.tag.attributes[W.attribName] = "", W.attribValue = "", F(W, "onattribute", {
                name: W.attribName,
                value: ""
              }), W.attribName = "", ye === ">" ? q(W) : P(b, ye) ? (W.attribName = ye, W.state = I.ATTRIB_NAME) : (Z(W, "Invalid attribute name"), W.state = I.ATTRIB);
            }
            continue;
          case I.ATTRIB_VALUE:
            if (k(ye))
              continue;
            A(ye) ? (W.q = ye, W.state = I.ATTRIB_VALUE_QUOTED) : (Z(W, "Unquoted attribute value"), W.state = I.ATTRIB_VALUE_UNQUOTED, W.attribValue = ye);
            continue;
          case I.ATTRIB_VALUE_QUOTED:
            if (ye !== W.q) {
              ye === "&" ? W.state = I.ATTRIB_VALUE_ENTITY_Q : W.attribValue += ye;
              continue;
            }
            _e(W), W.q = "", W.state = I.ATTRIB_VALUE_CLOSED;
            continue;
          case I.ATTRIB_VALUE_CLOSED:
            k(ye) ? W.state = I.ATTRIB : ye === ">" ? q(W) : ye === "/" ? W.state = I.OPEN_TAG_SLASH : P(b, ye) ? (Z(W, "No whitespace between attributes"), W.attribName = ye, W.attribValue = "", W.state = I.ATTRIB_NAME) : Z(W, "Invalid attribute name");
            continue;
          case I.ATTRIB_VALUE_UNQUOTED:
            if (!U(ye)) {
              ye === "&" ? W.state = I.ATTRIB_VALUE_ENTITY_U : W.attribValue += ye;
              continue;
            }
            _e(W), ye === ">" ? q(W) : W.state = I.ATTRIB;
            continue;
          case I.CLOSE_TAG:
            if (W.tagName)
              ye === ">" ? N(W) : P(y, ye) ? W.tagName += ye : W.script ? (W.script += "</" + W.tagName, W.tagName = "", W.state = I.SCRIPT) : (k(ye) || Z(W, "Invalid tagname in closing tag"), W.state = I.CLOSE_TAG_SAW_WHITE);
            else {
              if (k(ye))
                continue;
              V(b, ye) ? W.script ? (W.script += "</" + ye, W.state = I.SCRIPT) : Z(W, "Invalid tagname in closing tag.") : W.tagName = ye;
            }
            continue;
          case I.CLOSE_TAG_SAW_WHITE:
            if (k(ye))
              continue;
            ye === ">" ? N(W) : Z(W, "Invalid characters in closing tag");
            continue;
          case I.TEXT_ENTITY:
          case I.ATTRIB_VALUE_ENTITY_Q:
          case I.ATTRIB_VALUE_ENTITY_U:
            var De, T;
            switch (W.state) {
              case I.TEXT_ENTITY:
                De = I.TEXT, T = "textNode";
                break;
              case I.ATTRIB_VALUE_ENTITY_Q:
                De = I.ATTRIB_VALUE_QUOTED, T = "attribValue";
                break;
              case I.ATTRIB_VALUE_ENTITY_U:
                De = I.ATTRIB_VALUE_UNQUOTED, T = "attribValue";
                break;
            }
            ye === ";" ? (W[T] += ce(W), W.entity = "", W.state = De) : P(W.entity.length ? x : w, ye) ? W.entity += ye : (Z(W, "Invalid character in entity name"), W[T] += "&" + W.entity + ye, W.entity = "", W.state = De);
            continue;
          default:
            throw new Error(W, "Unknown state: " + W.state);
        }
      return W.position >= W.bufferCheckPosition && i(W), W;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    String.fromCodePoint || function() {
      var H = String.fromCharCode, W = Math.floor, we = function() {
        var ye = 16384, j = [], Q, De, T = -1, pe = arguments.length;
        if (!pe)
          return "";
        for (var M = ""; ++T < pe; ) {
          var _ = Number(arguments[T]);
          if (!isFinite(_) || // `NaN`, `+Infinity`, or `-Infinity`
          _ < 0 || // not a valid Unicode code point
          _ > 1114111 || // not a valid Unicode code point
          W(_) !== _)
            throw RangeError("Invalid code point: " + _);
          _ <= 65535 ? j.push(_) : (_ -= 65536, Q = (_ >> 10) + 55296, De = _ % 1024 + 56320, j.push(Q, De)), (T + 1 === pe || j.length > ye) && (M += H.apply(null, j), j.length = 0);
        }
        return M;
      };
      Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
        value: we,
        configurable: !0,
        writable: !0
      }) : String.fromCodePoint = we;
    }();
  })(t);
})(P9);
var KC = {
  isArray: function(t) {
    return Array.isArray ? Array.isArray(t) : Object.prototype.toString.call(t) === "[object Array]";
  }
}, qge = KC.isArray, XC = {
  copyOptions: function(t) {
    var e, n = {};
    for (e in t)
      t.hasOwnProperty(e) && (n[e] = t[e]);
    return n;
  },
  ensureFlagExists: function(t, e) {
    (!(t in e) || typeof e[t] != "boolean") && (e[t] = !1);
  },
  ensureSpacesExists: function(t) {
    (!("spaces" in t) || typeof t.spaces != "number" && typeof t.spaces != "string") && (t.spaces = 0);
  },
  ensureAlwaysArrayExists: function(t) {
    (!("alwaysArray" in t) || typeof t.alwaysArray != "boolean" && !qge(t.alwaysArray)) && (t.alwaysArray = !1);
  },
  ensureKeyExists: function(t, e) {
    (!(t + "Key" in e) || typeof e[t + "Key"] != "string") && (e[t + "Key"] = e.compact ? "_" + t : t);
  },
  checkFnExists: function(t, e) {
    return t + "Fn" in e;
  }
}, Gge = P9, Vt = XC, pf = KC.isArray, Me, ft;
function Kge(t) {
  return Me = Vt.copyOptions(t), Vt.ensureFlagExists("ignoreDeclaration", Me), Vt.ensureFlagExists("ignoreInstruction", Me), Vt.ensureFlagExists("ignoreAttributes", Me), Vt.ensureFlagExists("ignoreText", Me), Vt.ensureFlagExists("ignoreComment", Me), Vt.ensureFlagExists("ignoreCdata", Me), Vt.ensureFlagExists("ignoreDoctype", Me), Vt.ensureFlagExists("compact", Me), Vt.ensureFlagExists("alwaysChildren", Me), Vt.ensureFlagExists("addParent", Me), Vt.ensureFlagExists("trim", Me), Vt.ensureFlagExists("nativeType", Me), Vt.ensureFlagExists("nativeTypeAttributes", Me), Vt.ensureFlagExists("sanitize", Me), Vt.ensureFlagExists("instructionHasAttributes", Me), Vt.ensureFlagExists("captureSpacesBetweenElements", Me), Vt.ensureAlwaysArrayExists(Me), Vt.ensureKeyExists("declaration", Me), Vt.ensureKeyExists("instruction", Me), Vt.ensureKeyExists("attributes", Me), Vt.ensureKeyExists("text", Me), Vt.ensureKeyExists("comment", Me), Vt.ensureKeyExists("cdata", Me), Vt.ensureKeyExists("doctype", Me), Vt.ensureKeyExists("type", Me), Vt.ensureKeyExists("name", Me), Vt.ensureKeyExists("elements", Me), Vt.ensureKeyExists("parent", Me), Me;
}
function uP(t) {
  var e = Number(t);
  if (!isNaN(e))
    return e;
  var n = t.toLowerCase();
  return n === "true" ? !0 : n === "false" ? !1 : t;
}
function eg(t, e) {
  var n;
  if (Me.compact) {
    if (!ft[Me[t + "Key"]] && (pf(Me.alwaysArray) ? Me.alwaysArray.indexOf(Me[t + "Key"]) !== -1 : Me.alwaysArray) && (ft[Me[t + "Key"]] = []), ft[Me[t + "Key"]] && !pf(ft[Me[t + "Key"]]) && (ft[Me[t + "Key"]] = [ft[Me[t + "Key"]]]), t + "Fn" in Me && typeof e == "string" && (e = Me[t + "Fn"](e, ft)), t === "instruction" && ("instructionFn" in Me || "instructionNameFn" in Me)) {
      for (n in e)
        if (e.hasOwnProperty(n))
          if ("instructionFn" in Me)
            e[n] = Me.instructionFn(e[n], n, ft);
          else {
            var r = e[n];
            delete e[n], e[Me.instructionNameFn(n, r, ft)] = r;
          }
    }
    pf(ft[Me[t + "Key"]]) ? ft[Me[t + "Key"]].push(e) : ft[Me[t + "Key"]] = e;
  } else {
    ft[Me.elementsKey] || (ft[Me.elementsKey] = []);
    var i = {};
    if (i[Me.typeKey] = t, t === "instruction") {
      for (n in e)
        if (e.hasOwnProperty(n))
          break;
      i[Me.nameKey] = "instructionNameFn" in Me ? Me.instructionNameFn(n, e, ft) : n, Me.instructionHasAttributes ? (i[Me.attributesKey] = e[n][Me.attributesKey], "instructionFn" in Me && (i[Me.attributesKey] = Me.instructionFn(i[Me.attributesKey], n, ft))) : ("instructionFn" in Me && (e[n] = Me.instructionFn(e[n], n, ft)), i[Me.instructionKey] = e[n]);
    } else
      t + "Fn" in Me && (e = Me[t + "Fn"](e, ft)), i[Me[t + "Key"]] = e;
    Me.addParent && (i[Me.parentKey] = ft), ft[Me.elementsKey].push(i);
  }
}
function dP(t) {
  if ("attributesFn" in Me && t && (t = Me.attributesFn(t, ft)), (Me.trim || "attributeValueFn" in Me || "attributeNameFn" in Me || Me.nativeTypeAttributes) && t) {
    var e;
    for (e in t)
      if (t.hasOwnProperty(e) && (Me.trim && (t[e] = t[e].trim()), Me.nativeTypeAttributes && (t[e] = uP(t[e])), "attributeValueFn" in Me && (t[e] = Me.attributeValueFn(t[e], e, ft)), "attributeNameFn" in Me)) {
        var n = t[e];
        delete t[e], t[Me.attributeNameFn(e, t[e], ft)] = n;
      }
  }
  return t;
}
function Xge(t) {
  var e = {};
  if (t.body && (t.name.toLowerCase() === "xml" || Me.instructionHasAttributes)) {
    for (var n = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g, r; (r = n.exec(t.body)) !== null; )
      e[r[1]] = r[2] || r[3] || r[4];
    e = dP(e);
  }
  if (t.name.toLowerCase() === "xml") {
    if (Me.ignoreDeclaration)
      return;
    ft[Me.declarationKey] = {}, Object.keys(e).length && (ft[Me.declarationKey][Me.attributesKey] = e), Me.addParent && (ft[Me.declarationKey][Me.parentKey] = ft);
  } else {
    if (Me.ignoreInstruction)
      return;
    Me.trim && (t.body = t.body.trim());
    var i = {};
    Me.instructionHasAttributes && Object.keys(e).length ? (i[t.name] = {}, i[t.name][Me.attributesKey] = e) : i[t.name] = t.body, eg("instruction", i);
  }
}
function Yge(t, e) {
  var n;
  if (typeof t == "object" && (e = t.attributes, t = t.name), e = dP(e), "elementNameFn" in Me && (t = Me.elementNameFn(t, ft)), Me.compact) {
    if (n = {}, !Me.ignoreAttributes && e && Object.keys(e).length) {
      n[Me.attributesKey] = {};
      var r;
      for (r in e)
        e.hasOwnProperty(r) && (n[Me.attributesKey][r] = e[r]);
    }
    !(t in ft) && (pf(Me.alwaysArray) ? Me.alwaysArray.indexOf(t) !== -1 : Me.alwaysArray) && (ft[t] = []), ft[t] && !pf(ft[t]) && (ft[t] = [ft[t]]), pf(ft[t]) ? ft[t].push(n) : ft[t] = n;
  } else
    ft[Me.elementsKey] || (ft[Me.elementsKey] = []), n = {}, n[Me.typeKey] = "element", n[Me.nameKey] = t, !Me.ignoreAttributes && e && Object.keys(e).length && (n[Me.attributesKey] = e), Me.alwaysChildren && (n[Me.elementsKey] = []), ft[Me.elementsKey].push(n);
  n[Me.parentKey] = ft, ft = n;
}
function Jge(t) {
  Me.ignoreText || !t.trim() && !Me.captureSpacesBetweenElements || (Me.trim && (t = t.trim()), Me.nativeType && (t = uP(t)), Me.sanitize && (t = t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")), eg("text", t));
}
function Zge(t) {
  Me.ignoreComment || (Me.trim && (t = t.trim()), eg("comment", t));
}
function Qge(t) {
  var e = ft[Me.parentKey];
  Me.addParent || delete ft[Me.parentKey], ft = e;
}
function eye(t) {
  Me.ignoreCdata || (Me.trim && (t = t.trim()), eg("cdata", t));
}
function tye(t) {
  Me.ignoreDoctype || (t = t.replace(/^ /, ""), Me.trim && (t = t.trim()), eg("doctype", t));
}
function nye(t) {
  t.note = t;
}
var fP = function(t, e) {
  var n = Gge.parser(!0, {}), r = {};
  if (ft = r, Me = Kge(e), n.opt = { strictEntities: !0 }, n.onopentag = Yge, n.ontext = Jge, n.oncomment = Zge, n.onclosetag = Qge, n.onerror = nye, n.oncdata = eye, n.ondoctype = tye, n.onprocessinginstruction = Xge, n.write(t).close(), r[Me.elementsKey]) {
    var i = r[Me.elementsKey];
    delete r[Me.elementsKey], r[Me.elementsKey] = i, delete r.text;
  }
  return r;
}, kO = XC, rye = fP;
function iye(t) {
  var e = kO.copyOptions(t);
  return kO.ensureSpacesExists(e), e;
}
var oye = function(t, e) {
  var n, r, i, o;
  return n = iye(e), r = rye(t, n), o = "compact" in n && n.compact ? "_parent" : "parent", "addParent" in n && n.addParent ? i = JSON.stringify(r, function(a, s) {
    return a === o ? "_" : s;
  }, n.spaces) : i = JSON.stringify(r, null, n.spaces), i.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
}, an = XC, aye = KC.isArray, wr, xr;
function sye(t) {
  var e = an.copyOptions(t);
  return an.ensureFlagExists("ignoreDeclaration", e), an.ensureFlagExists("ignoreInstruction", e), an.ensureFlagExists("ignoreAttributes", e), an.ensureFlagExists("ignoreText", e), an.ensureFlagExists("ignoreComment", e), an.ensureFlagExists("ignoreCdata", e), an.ensureFlagExists("ignoreDoctype", e), an.ensureFlagExists("compact", e), an.ensureFlagExists("indentText", e), an.ensureFlagExists("indentCdata", e), an.ensureFlagExists("indentAttributes", e), an.ensureFlagExists("indentInstruction", e), an.ensureFlagExists("fullTagEmptyElement", e), an.ensureFlagExists("noQuotesForNativeAttributes", e), an.ensureSpacesExists(e), typeof e.spaces == "number" && (e.spaces = Array(e.spaces + 1).join(" ")), an.ensureKeyExists("declaration", e), an.ensureKeyExists("instruction", e), an.ensureKeyExists("attributes", e), an.ensureKeyExists("text", e), an.ensureKeyExists("comment", e), an.ensureKeyExists("cdata", e), an.ensureKeyExists("doctype", e), an.ensureKeyExists("type", e), an.ensureKeyExists("name", e), an.ensureKeyExists("elements", e), e;
}
function na(t, e, n) {
  return (!n && t.spaces ? `
` : "") + Array(e + 1).join(t.spaces);
}
function E0(t, e, n) {
  if (e.ignoreAttributes)
    return "";
  "attributesFn" in e && (t = e.attributesFn(t, xr, wr));
  var r, i, o, a, s = [];
  for (r in t)
    t.hasOwnProperty(r) && t[r] !== null && t[r] !== void 0 && (a = e.noQuotesForNativeAttributes && typeof t[r] != "string" ? "" : '"', i = "" + t[r], i = i.replace(/"/g, "&quot;"), o = "attributeNameFn" in e ? e.attributeNameFn(r, i, xr, wr) : r, s.push(e.spaces && e.indentAttributes ? na(e, n + 1, !1) : " "), s.push(o + "=" + a + ("attributeValueFn" in e ? e.attributeValueFn(i, r, xr, wr) : i) + a));
  return t && Object.keys(t).length && e.spaces && e.indentAttributes && s.push(na(e, n, !1)), s.join("");
}
function hP(t, e, n) {
  return wr = t, xr = "xml", e.ignoreDeclaration ? "" : "<?xml" + E0(t[e.attributesKey], e, n) + "?>";
}
function pP(t, e, n) {
  if (e.ignoreInstruction)
    return "";
  var r;
  for (r in t)
    if (t.hasOwnProperty(r))
      break;
  var i = "instructionNameFn" in e ? e.instructionNameFn(r, t[r], xr, wr) : r;
  if (typeof t[r] == "object")
    return wr = t, xr = i, "<?" + i + E0(t[r][e.attributesKey], e, n) + "?>";
  var o = t[r] ? t[r] : "";
  return "instructionFn" in e && (o = e.instructionFn(o, r, xr, wr)), "<?" + i + (o ? " " + o : "") + "?>";
}
function mP(t, e) {
  return e.ignoreComment ? "" : "<!--" + ("commentFn" in e ? e.commentFn(t, xr, wr) : t) + "-->";
}
function gP(t, e) {
  return e.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in e ? e.cdataFn(t, xr, wr) : t.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
}
function yP(t, e) {
  return e.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in e ? e.doctypeFn(t, xr, wr) : t) + ">";
}
function YC(t, e) {
  return e.ignoreText ? "" : (t = "" + t, t = t.replace(/&amp;/g, "&"), t = t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), "textFn" in e ? e.textFn(t, xr, wr) : t);
}
function lye(t, e) {
  var n;
  if (t.elements && t.elements.length)
    for (n = 0; n < t.elements.length; ++n)
      switch (t.elements[n][e.typeKey]) {
        case "text":
          if (e.indentText)
            return !0;
          break;
        case "cdata":
          if (e.indentCdata)
            return !0;
          break;
        case "instruction":
          if (e.indentInstruction)
            return !0;
          break;
        case "doctype":
        case "comment":
        case "element":
          return !0;
        default:
          return !0;
      }
  return !1;
}
function cye(t, e, n) {
  wr = t, xr = t.name;
  var r = [], i = "elementNameFn" in e ? e.elementNameFn(t.name, t) : t.name;
  r.push("<" + i), t[e.attributesKey] && r.push(E0(t[e.attributesKey], e, n));
  var o = t[e.elementsKey] && t[e.elementsKey].length || t[e.attributesKey] && t[e.attributesKey]["xml:space"] === "preserve";
  return o || ("fullTagEmptyElementFn" in e ? o = e.fullTagEmptyElementFn(t.name, t) : o = e.fullTagEmptyElement), o ? (r.push(">"), t[e.elementsKey] && t[e.elementsKey].length && (r.push(bP(t[e.elementsKey], e, n + 1)), wr = t, xr = t.name), r.push(e.spaces && lye(t, e) ? `
` + Array(n + 1).join(e.spaces) : ""), r.push("</" + i + ">")) : r.push("/>"), r.join("");
}
function bP(t, e, n, r) {
  return t.reduce(function(i, o) {
    var a = na(e, n, r && !i);
    switch (o.type) {
      case "element":
        return i + a + cye(o, e, n);
      case "comment":
        return i + a + mP(o[e.commentKey], e);
      case "doctype":
        return i + a + yP(o[e.doctypeKey], e);
      case "cdata":
        return i + (e.indentCdata ? a : "") + gP(o[e.cdataKey], e);
      case "text":
        return i + (e.indentText ? a : "") + YC(o[e.textKey], e);
      case "instruction":
        var s = {};
        return s[o[e.nameKey]] = o[e.attributesKey] ? o : o[e.instructionKey], i + (e.indentInstruction ? a : "") + pP(s, e, n);
    }
  }, "");
}
function vP(t, e, n) {
  var r;
  for (r in t)
    if (t.hasOwnProperty(r))
      switch (r) {
        case e.parentKey:
        case e.attributesKey:
          break;
        case e.textKey:
          if (e.indentText || n)
            return !0;
          break;
        case e.cdataKey:
          if (e.indentCdata || n)
            return !0;
          break;
        case e.instructionKey:
          if (e.indentInstruction || n)
            return !0;
          break;
        case e.doctypeKey:
        case e.commentKey:
          return !0;
        default:
          return !0;
      }
  return !1;
}
function uye(t, e, n, r, i) {
  wr = t, xr = e;
  var o = "elementNameFn" in n ? n.elementNameFn(e, t) : e;
  if (typeof t > "u" || t === null || t === "")
    return "fullTagEmptyElementFn" in n && n.fullTagEmptyElementFn(e, t) || n.fullTagEmptyElement ? "<" + o + "></" + o + ">" : "<" + o + "/>";
  var a = [];
  if (e) {
    if (a.push("<" + o), typeof t != "object")
      return a.push(">" + YC(t, n) + "</" + o + ">"), a.join("");
    t[n.attributesKey] && a.push(E0(t[n.attributesKey], n, r));
    var s = vP(t, n, !0) || t[n.attributesKey] && t[n.attributesKey]["xml:space"] === "preserve";
    if (s || ("fullTagEmptyElementFn" in n ? s = n.fullTagEmptyElementFn(e, t) : s = n.fullTagEmptyElement), s)
      a.push(">");
    else
      return a.push("/>"), a.join("");
  }
  return a.push(wP(t, n, r + 1, !1)), wr = t, xr = e, e && a.push((i ? na(n, r, !1) : "") + "</" + o + ">"), a.join("");
}
function wP(t, e, n, r) {
  var i, o, a, s = [];
  for (o in t)
    if (t.hasOwnProperty(o))
      for (a = aye(t[o]) ? t[o] : [t[o]], i = 0; i < a.length; ++i) {
        switch (o) {
          case e.declarationKey:
            s.push(hP(a[i], e, n));
            break;
          case e.instructionKey:
            s.push((e.indentInstruction ? na(e, n, r) : "") + pP(a[i], e, n));
            break;
          case e.attributesKey:
          case e.parentKey:
            break;
          case e.textKey:
            s.push((e.indentText ? na(e, n, r) : "") + YC(a[i], e));
            break;
          case e.cdataKey:
            s.push((e.indentCdata ? na(e, n, r) : "") + gP(a[i], e));
            break;
          case e.doctypeKey:
            s.push(na(e, n, r) + yP(a[i], e));
            break;
          case e.commentKey:
            s.push(na(e, n, r) + mP(a[i], e));
            break;
          default:
            s.push(na(e, n, r) + uye(a[i], o, e, n, vP(a[i], e)));
        }
        r = r && !s.length;
      }
  return s.join("");
}
var xP = function(t, e) {
  e = sye(e);
  var n = [];
  return wr = t, xr = "_root_", e.compact ? n.push(wP(t, e, 0, !0)) : (t[e.declarationKey] && n.push(hP(t[e.declarationKey], e, 0)), t[e.elementsKey] && t[e.elementsKey].length && n.push(bP(t[e.elementsKey], e, 0, !n.length))), n.join("");
}, dye = xP, fye = function(t, e) {
  t instanceof Buffer && (t = t.toString());
  var n = null;
  if (typeof t == "string")
    try {
      n = JSON.parse(t);
    } catch {
      throw new Error("The JSON structure is invalid");
    }
  else
    n = t;
  return dye(n, e);
}, hye = fP, pye = oye, mye = xP, gye = fye, _P = {
  xml2js: hye,
  xml2json: pye,
  js2xml: mye,
  json2xml: gye
};
const JC = (t) => {
  switch (t.type) {
    case void 0:
    case "element":
      const e = new bye(t.name, t.attributes), n = t.elements || [];
      for (const r of n) {
        const i = JC(r);
        i !== void 0 && e.push(i);
      }
      return e;
    case "text":
      return t.text;
    default:
      return;
  }
};
class yye extends Ye {
  // noop
}
class bye extends Oe {
  /**
   * Converts the xml string to a XmlComponent tree.
   *
   * @param importedContent xml content of the imported component
   */
  static fromXmlString(e) {
    const n = _P.xml2js(e, { compact: !1 });
    return JC(n);
  }
  /**
   * Converts the xml string to a XmlComponent tree.
   *
   * @param importedContent xml content of the imported component
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(e, n) {
    super(e), n && this.root.push(new yye(n));
  }
  push(e) {
    this.root.push(e);
  }
}
class vye extends Oe {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(e) {
    super(""), this._attr = e;
  }
  prepForXml(e) {
    return {
      _attr: this._attr
    };
  }
}
class SP extends Oe {
  constructor(e, n) {
    super(e), n && (this.root = n.root);
  }
}
const Dr = (t) => {
  if (isNaN(t))
    throw new Error(`Invalid value '${t}' specified. Must be an integer.`);
  return Math.floor(t);
}, C0 = (t) => {
  const e = Dr(t);
  if (e < 0)
    throw new Error(`Invalid value '${t}' specified. Must be a positive integer.`);
  return e;
}, TP = (t, e) => {
  const n = e * 2;
  if (t.length !== n || isNaN(+`0x${t}`))
    throw new Error(`Invalid hex value '${t}'. Expected ${n} digit hex value`);
  return t;
}, AO = (t) => TP(t, 1), ZC = (t) => {
  const e = t.slice(-2), n = t.substring(0, t.length - 2);
  return `${Number(n)}${e}`;
}, DP = (t) => {
  const e = ZC(t);
  if (parseFloat(e) < 0)
    throw new Error(`Invalid value '${e}' specified. Expected a positive number.`);
  return e;
}, zf = (t) => {
  if (t === "auto")
    return t;
  const e = t.charAt(0) === "#" ? t.substring(1) : t;
  return TP(e, 3);
}, ts = (t) => typeof t == "string" ? ZC(t) : Dr(t), wye = (t) => typeof t == "string" ? DP(t) : C0(t), lr = (t) => typeof t == "string" ? DP(t) : C0(t), xye = (t) => {
  const e = t.substring(0, t.length - 1);
  return `${Number(e)}%`;
}, _ye = (t) => typeof t == "number" ? Dr(t) : t.slice(-1) === "%" ? xye(t) : ZC(t), Sye = C0, Tye = C0, Dye = (t) => t.toISOString();
class je extends Oe {
  constructor(e, n = !0) {
    super(e), n !== !0 && this.root.push(new En({ val: n }));
  }
}
class H_ extends Oe {
  constructor(e, n) {
    super(e), this.root.push(new En({ val: wye(n) }));
  }
}
class Gc extends Oe {
  constructor(e, n) {
    super(e), this.root.push(new En({ val: n }));
  }
}
const gp = (t, e) => new Fn({
  name: t,
  attributes: {
    value: { key: "w:val", value: e }
  }
});
class QC extends Oe {
  constructor(e, n) {
    super(e), this.root.push(new En({ val: n }));
  }
}
class Eye extends Oe {
  constructor(e, n) {
    super(e), this.root.push(new En({ val: n }));
  }
}
class Cc extends Oe {
  constructor(e, n) {
    super(e), this.root.push(n);
  }
}
class Fn extends Oe {
  constructor({
    name: e,
    attributes: n,
    children: r
  }) {
    super(e), n && this.root.push(new ws(n)), r && this.root.push(...r);
  }
}
const ri = {
  /** Align Start */
  START: "start",
  /** Align Center */
  CENTER: "center",
  /** End */
  END: "end",
  /** Justified */
  BOTH: "both",
  /** Medium Kashida Length */
  MEDIUM_KASHIDA: "mediumKashida",
  /** Distribute All Characters Equally */
  DISTRIBUTE: "distribute",
  /** Align to List Tab */
  NUM_TAB: "numTab",
  /** Widest Kashida Length */
  HIGH_KASHIDA: "highKashida",
  /** Low Kashida Length */
  LOW_KASHIDA: "lowKashida",
  /** Thai Language Justification */
  THAI_DISTRIBUTE: "thaiDistribute",
  /** Align Left */
  LEFT: "left",
  /** Align Right */
  RIGHT: "right",
  /** Justified */
  JUSTIFIED: "both"
};
class Cye extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { val: "w:val" });
  }
}
class EP extends Oe {
  constructor(e) {
    super("w:jc"), this.root.push(new Cye({ val: e }));
  }
}
class Xt extends Oe {
  constructor(e, { color: n, size: r, space: i, style: o }) {
    super(e), this.root.push(
      new kye({
        style: o,
        color: n === void 0 ? void 0 : zf(n),
        size: r === void 0 ? void 0 : Sye(r),
        space: i === void 0 ? void 0 : Tye(i)
      })
    );
  }
}
class kye extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      style: "w:val",
      color: "w:color",
      size: "w:sz",
      space: "w:space"
    });
  }
}
const ek = {
  SINGLE: "single",
  DASH_DOT_STROKED: "dashDotStroked",
  DASHED: "dashed",
  DASH_SMALL_GAP: "dashSmallGap",
  DOT_DASH: "dotDash",
  DOT_DOT_DASH: "dotDotDash",
  DOTTED: "dotted",
  DOUBLE: "double",
  DOUBLE_WAVE: "doubleWave",
  INSET: "inset",
  NIL: "nil",
  NONE: "none",
  OUTSET: "outset",
  THICK: "thick",
  THICK_THIN_LARGE_GAP: "thickThinLargeGap",
  THICK_THIN_MEDIUM_GAP: "thickThinMediumGap",
  THICK_THIN_SMALL_GAP: "thickThinSmallGap",
  THIN_THICK_LARGE_GAP: "thinThickLargeGap",
  THIN_THICK_MEDIUM_GAP: "thinThickMediumGap",
  THIN_THICK_SMALL_GAP: "thinThickSmallGap",
  THIN_THICK_THIN_LARGE_GAP: "thinThickThinLargeGap",
  THIN_THICK_THIN_MEDIUM_GAP: "thinThickThinMediumGap",
  THIN_THICK_THIN_SMALL_GAP: "thinThickThinSmallGap",
  THREE_D_EMBOSS: "threeDEmboss",
  THREE_D_ENGRAVE: "threeDEngrave",
  TRIPLE: "triple",
  WAVE: "wave"
};
class Aye extends vs {
  constructor(e) {
    super("w:pBdr"), e.top && this.root.push(new Xt("w:top", e.top)), e.bottom && this.root.push(new Xt("w:bottom", e.bottom)), e.left && this.root.push(new Xt("w:left", e.left)), e.right && this.root.push(new Xt("w:right", e.right));
  }
}
class Rye extends Oe {
  constructor() {
    super("w:pBdr");
    const e = new Xt("w:bottom", {
      color: "auto",
      space: 1,
      style: ek.SINGLE,
      size: 6
    });
    this.root.push(e);
  }
}
class Iye extends Oe {
  constructor({ start: e, end: n, left: r, right: i, hanging: o, firstLine: a }) {
    super("w:ind"), this.root.push(
      new ws({
        start: {
          key: "w:start",
          value: e === void 0 ? void 0 : ts(e)
        },
        end: {
          key: "w:end",
          value: n === void 0 ? void 0 : ts(n)
        },
        left: {
          key: "w:left",
          value: r === void 0 ? void 0 : ts(r)
        },
        right: {
          key: "w:right",
          value: i === void 0 ? void 0 : ts(i)
        },
        hanging: {
          key: "w:hanging",
          value: o === void 0 ? void 0 : lr(o)
        },
        firstLine: {
          key: "w:firstLine",
          value: a === void 0 ? void 0 : lr(a)
        }
      })
    );
  }
}
let Oye = class extends Oe {
  constructor() {
    super("w:br");
  }
};
const tk = {
  BEGIN: "begin",
  END: "end",
  SEPARATE: "separate"
};
class nk extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { type: "w:fldCharType", dirty: "w:dirty" });
  }
}
class Dp extends Oe {
  constructor(e) {
    super("w:fldChar"), this.root.push(new nk({ type: tk.BEGIN, dirty: e }));
  }
}
class Ep extends Oe {
  constructor(e) {
    super("w:fldChar"), this.root.push(new nk({ type: tk.SEPARATE, dirty: e }));
  }
}
class Cp extends Oe {
  constructor(e) {
    super("w:fldChar"), this.root.push(new nk({ type: tk.END, dirty: e }));
  }
}
const au = {
  DEFAULT: "default",
  PRESERVE: "preserve"
};
class su extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { space: "xml:space" });
  }
}
class Fye extends Oe {
  constructor() {
    super("w:instrText"), this.root.push(new su({ space: au.PRESERVE })), this.root.push("PAGE");
  }
}
class Uye extends Oe {
  constructor() {
    super("w:instrText"), this.root.push(new su({ space: au.PRESERVE })), this.root.push("NUMPAGES");
  }
}
class Nye extends Oe {
  constructor() {
    super("w:instrText"), this.root.push(new su({ space: au.PRESERVE })), this.root.push("SECTIONPAGES");
  }
}
class Mye extends Oe {
  constructor() {
    super("w:instrText"), this.root.push(new su({ space: au.PRESERVE })), this.root.push("SECTION");
  }
}
class Bye extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      fill: "w:fill",
      color: "w:color",
      type: "w:val"
    });
  }
}
class k0 extends Oe {
  constructor({ fill: e, color: n, type: r }) {
    super("w:shd"), this.root.push(
      new Bye({
        fill: e === void 0 ? void 0 : zf(e),
        color: n === void 0 ? void 0 : zf(n),
        type: r
      })
    );
  }
}
const Lye = {
  CLEAR: "clear",
  DIAGONAL_CROSS: "diagCross",
  DIAGONAL_STRIPE: "diagStripe",
  HORIZONTAL_CROSS: "horzCross",
  HORIZONTAL_STRIPE: "horzStripe",
  NIL: "nil",
  PERCENT_5: "pct5",
  PERCENT_10: "pct10",
  PERCENT_12: "pct12",
  PERCENT_15: "pct15",
  PERCENT_20: "pct20",
  PERCENT_25: "pct25",
  PERCENT_30: "pct30",
  PERCENT_35: "pct35",
  PERCENT_37: "pct37",
  PERCENT_40: "pct40",
  PERCENT_45: "pct45",
  PERCENT_50: "pct50",
  PERCENT_55: "pct55",
  PERCENT_60: "pct60",
  PERCENT_62: "pct62",
  PERCENT_65: "pct65",
  PERCENT_70: "pct70",
  PERCENT_75: "pct75",
  PERCENT_80: "pct80",
  PERCENT_85: "pct85",
  PERCENT_87: "pct87",
  PERCENT_90: "pct90",
  PERCENT_95: "pct95",
  REVERSE_DIAGONAL_STRIPE: "reverseDiagStripe",
  SOLID: "solid",
  THIN_DIAGONAL_CROSS: "thinDiagCross",
  THIN_DIAGONAL_STRIPE: "thinDiagStripe",
  THIN_HORIZONTAL_CROSS: "thinHorzCross",
  THIN_REVERSE_DIAGONAL_STRIPE: "thinReverseDiagStripe",
  THIN_VERTICAL_STRIPE: "thinVertStripe",
  VERTICAL_STRIPE: "vertStripe"
};
class Pye extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      id: "w:id",
      author: "w:author",
      date: "w:date"
    });
  }
}
const Wye = {
  DOT: "dot"
};
class zye extends Oe {
  constructor(e) {
    super("w:em"), this.root.push(
      new En({
        val: e
      })
    );
  }
}
class $ye extends zye {
  constructor(e = Wye.DOT) {
    super(e);
  }
}
class Hye extends Oe {
  constructor(e) {
    super("w:spacing"), this.root.push(
      new En({
        val: ts(e)
      })
    );
  }
}
class jye extends Oe {
  constructor(e) {
    super("w:color"), this.root.push(
      new En({
        val: zf(e)
      })
    );
  }
}
class Vye extends Oe {
  constructor(e) {
    super("w:highlight"), this.root.push(
      new En({
        val: e
      })
    );
  }
}
class qye extends Oe {
  constructor(e) {
    super("w:highlightCs"), this.root.push(
      new En({
        val: e
      })
    );
  }
}
const Gye = (t) => new Fn({
  name: "w:lang",
  attributes: {
    value: {
      key: "w:val",
      value: t.value
    },
    eastAsia: {
      key: "w:eastAsia",
      value: t.eastAsia
    },
    bidirectional: {
      key: "w:bidi",
      value: t.bidirectional
    }
  }
});
class RO extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      ascii: "w:ascii",
      cs: "w:cs",
      eastAsia: "w:eastAsia",
      hAnsi: "w:hAnsi",
      hint: "w:hint"
    });
  }
}
class j_ extends Oe {
  constructor(e, n) {
    if (super("w:rFonts"), typeof e == "string") {
      const r = e;
      this.root.push(
        new RO({
          ascii: r,
          cs: r,
          eastAsia: r,
          hAnsi: r,
          hint: n
        })
      );
    } else {
      const r = e;
      this.root.push(new RO(r));
    }
  }
}
let CP = class extends Oe {
  constructor(e) {
    super("w:vertAlign"), this.root.push(
      new En({
        val: e
      })
    );
  }
};
class Kye extends CP {
  constructor() {
    super("superscript");
  }
}
class Xye extends CP {
  constructor() {
    super("subscript");
  }
}
const kP = {
  SINGLE: "single",
  WORDS: "words",
  DOUBLE: "double",
  THICK: "thick",
  DOTTED: "dotted",
  DOTTEDHEAVY: "dottedHeavy",
  DASH: "dash",
  DASHEDHEAVY: "dashedHeavy",
  DASHLONG: "dashLong",
  DASHLONGHEAVY: "dashLongHeavy",
  DOTDASH: "dotDash",
  DASHDOTHEAVY: "dashDotHeavy",
  DOTDOTDASH: "dotDotDash",
  DASHDOTDOTHEAVY: "dashDotDotHeavy",
  WAVE: "wave",
  WAVYHEAVY: "wavyHeavy",
  WAVYDOUBLE: "wavyDouble",
  NONE: "none"
};
class Yye extends Oe {
  constructor(e = kP.SINGLE, n) {
    super("w:u"), this.root.push(
      new En({
        val: e,
        color: n === void 0 ? void 0 : zf(n)
      })
    );
  }
}
class Su extends vs {
  constructor(e) {
    var n, r;
    if (super("w:rPr"), !e)
      return;
    e.noProof !== void 0 && this.push(new je("w:noProof", e.noProof)), e.bold !== void 0 && this.push(new je("w:b", e.bold)), (e.boldComplexScript === void 0 && e.bold !== void 0 || e.boldComplexScript) && this.push(new je("w:bCs", (n = e.boldComplexScript) != null ? n : e.bold)), e.italics !== void 0 && this.push(new je("w:i", e.italics)), (e.italicsComplexScript === void 0 && e.italics !== void 0 || e.italicsComplexScript) && this.push(new je("w:iCs", (r = e.italicsComplexScript) != null ? r : e.italics)), e.underline && this.push(new Yye(e.underline.type, e.underline.color)), e.effect && this.push(new Gc("w:effect", e.effect)), e.emphasisMark && this.push(new $ye(e.emphasisMark.type)), e.color && this.push(new jye(e.color)), e.kern && this.push(new H_("w:kern", e.kern)), e.position && this.push(new Gc("w:position", e.position)), e.size !== void 0 && this.push(new H_("w:sz", e.size));
    const i = e.sizeComplexScript === void 0 || e.sizeComplexScript === !0 ? e.size : e.sizeComplexScript;
    i && this.push(new H_("w:szCs", i)), e.rightToLeft !== void 0 && this.push(new je("w:rtl", e.rightToLeft)), e.smallCaps !== void 0 ? this.push(new je("w:smallCaps", e.smallCaps)) : e.allCaps !== void 0 && this.push(new je("w:caps", e.allCaps)), e.strike !== void 0 && this.push(new je("w:strike", e.strike)), e.doubleStrike !== void 0 && this.push(new je("w:dstrike", e.doubleStrike)), e.subScript && this.push(new Xye()), e.superScript && this.push(new Kye()), e.style && this.push(new Gc("w:rStyle", e.style)), e.font && (typeof e.font == "string" ? this.push(new j_(e.font)) : "name" in e.font ? this.push(new j_(e.font.name, e.font.hint)) : this.push(new j_(e.font))), e.highlight && this.push(new Vye(e.highlight));
    const o = e.highlightComplexScript === void 0 || e.highlightComplexScript === !0 ? e.highlight : e.highlightComplexScript;
    o && this.push(new qye(o)), e.characterSpacing && this.push(new Hye(e.characterSpacing)), e.emboss !== void 0 && this.push(new je("w:emboss", e.emboss)), e.imprint !== void 0 && this.push(new je("w:imprint", e.imprint)), e.shading && this.push(new k0(e.shading)), e.revision && this.push(new Jye(e.revision)), e.border && this.push(new Xt("w:bdr", e.border)), e.snapToGrid !== void 0 && this.push(new je("w:snapToGrid", e.snapToGrid)), e.vanish && this.push(new je("w:vanish", e.vanish)), e.specVanish && this.push(new je("w:specVanish", e.vanish)), e.scale !== void 0 && this.push(new QC("w:w", e.scale)), e.language && this.push(Gye(e.language)), e.math && this.push(new je("w:oMath", e.math));
  }
  push(e) {
    this.root.push(e);
  }
}
class Jye extends Oe {
  constructor(e) {
    super("w:rPrChange"), this.root.push(
      new Pye({
        id: e.id,
        author: e.author,
        date: e.date
      })
    ), this.addChildElement(new Su(e));
  }
}
class zT extends Oe {
  constructor(e) {
    var n;
    super("w:t"), typeof e == "string" ? (this.root.push(new su({ space: au.PRESERVE })), this.root.push(e)) : (this.root.push(new su({ space: (n = e.space) != null ? n : au.DEFAULT })), this.root.push(e.text));
  }
}
const ky = {
  CURRENT: "CURRENT",
  TOTAL_PAGES: "TOTAL_PAGES",
  TOTAL_PAGES_IN_SECTION: "TOTAL_PAGES_IN_SECTION",
  CURRENT_SECTION: "SECTION"
};
class Tu extends Oe {
  constructor(e) {
    if (super("w:r"), Ue(this, "properties"), this.properties = new Su(e), this.root.push(this.properties), e.break)
      for (let n = 0; n < e.break; n++)
        this.root.push(new Oye());
    if (e.children)
      for (const n of e.children) {
        if (typeof n == "string") {
          switch (n) {
            case ky.CURRENT:
              this.root.push(new Dp()), this.root.push(new Fye()), this.root.push(new Ep()), this.root.push(new Cp());
              break;
            case ky.TOTAL_PAGES:
              this.root.push(new Dp()), this.root.push(new Uye()), this.root.push(new Ep()), this.root.push(new Cp());
              break;
            case ky.TOTAL_PAGES_IN_SECTION:
              this.root.push(new Dp()), this.root.push(new Nye()), this.root.push(new Ep()), this.root.push(new Cp());
              break;
            case ky.CURRENT_SECTION:
              this.root.push(new Dp()), this.root.push(new Mye()), this.root.push(new Ep()), this.root.push(new Cp());
              break;
            default:
              this.root.push(new zT(n));
              break;
          }
          continue;
        }
        this.root.push(n);
      }
    else e.text && this.root.push(new zT(e.text));
  }
}
class vo extends Tu {
  constructor(e) {
    if (typeof e == "string")
      return super({}), this.root.push(new zT(e)), this;
    super(e);
  }
}
let Zye = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Qye = (t, e = 21) => (n = e) => {
  let r = "", i = n;
  for (; i--; )
    r += t[Math.random() * t.length | 0];
  return r;
}, ebe = (t = 21) => {
  let e = "", n = t;
  for (; n--; )
    e += Zye[Math.random() * 64 | 0];
  return e;
};
const xi = (t) => Math.floor(t * 72 * 20), A0 = (t = 0) => {
  let e = t;
  return () => ++e;
}, tbe = () => A0(), nbe = () => A0(1), rbe = () => A0(), ibe = () => A0(), jv = () => ebe().toLowerCase(), yp = (t) => Qye("1234567890abcdef", t)(), obe = () => `${yp(8)}-${yp(4)}-${yp(4)}-${yp(4)}-${yp(12)}`, abe = {
  CHARACTER: "character",
  COLUMN: "column",
  INSIDE_MARGIN: "insideMargin",
  LEFT_MARGIN: "leftMargin",
  MARGIN: "margin",
  OUTSIDE_MARGIN: "outsideMargin",
  PAGE: "page",
  RIGHT_MARGIN: "rightMargin"
}, sbe = {
  BOTTOM_MARGIN: "bottomMargin",
  INSIDE_MARGIN: "insideMargin",
  LINE: "line",
  MARGIN: "margin",
  OUTSIDE_MARGIN: "outsideMargin",
  PAGE: "page",
  PARAGRAPH: "paragraph",
  TOP_MARGIN: "topMargin"
};
class lbe extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      x: "x",
      y: "y"
    });
  }
}
class cbe extends Oe {
  constructor() {
    super("wp:simplePos"), this.root.push(
      new lbe({
        x: 0,
        y: 0
      })
    );
  }
}
class AP extends Oe {
  constructor(e) {
    super("wp:align"), this.root.push(e);
  }
}
class RP extends Oe {
  constructor(e) {
    super("wp:posOffset"), this.root.push(e.toString());
  }
}
class ube extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      relativeFrom: "relativeFrom"
    });
  }
}
class dbe extends Oe {
  constructor(e) {
    if (super("wp:positionH"), this.root.push(
      new ube({
        relativeFrom: e.relative || abe.PAGE
      })
    ), e.align)
      this.root.push(new AP(e.align));
    else if (e.offset !== void 0)
      this.root.push(new RP(e.offset));
    else
      throw new Error("There is no configuration provided for floating position (Align or offset)");
  }
}
class fbe extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      relativeFrom: "relativeFrom"
    });
  }
}
class hbe extends Oe {
  constructor(e) {
    if (super("wp:positionV"), this.root.push(
      new fbe({
        relativeFrom: e.relative || sbe.PAGE
      })
    ), e.align)
      this.root.push(new AP(e.align));
    else if (e.offset !== void 0)
      this.root.push(new RP(e.offset));
    else
      throw new Error("There is no configuration provided for floating position (Align or offset)");
  }
}
class pbe extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      uri: "uri"
    });
  }
}
const mbe = (t) => new Fn({
  name: "asvg:svgBlip",
  attributes: {
    asvg: {
      key: "xmlns:asvg",
      value: "http://schemas.microsoft.com/office/drawing/2016/SVG/main"
    },
    embed: {
      key: "r:embed",
      value: `rId{${t.fileName}}`
    }
  }
}), gbe = (t) => new Fn({
  name: "a:ext",
  attributes: {
    uri: {
      key: "uri",
      value: "{96DAC541-7B7A-43D3-8B79-37D633B846F1}"
    }
  },
  children: [mbe(t)]
}), ybe = (t) => new Fn({
  name: "a:extLst",
  children: [gbe(t)]
}), bbe = (t) => new Fn({
  name: "a:blip",
  attributes: {
    embed: {
      key: "r:embed",
      value: `rId{${t.type === "svg" ? t.fallback.fileName : t.fileName}}`
    },
    cstate: {
      key: "cstate",
      value: "none"
    }
  },
  children: t.type === "svg" ? [ybe(t)] : []
});
class vbe extends Oe {
  constructor() {
    super("a:srcRect");
  }
}
class wbe extends Oe {
  constructor() {
    super("a:fillRect");
  }
}
class xbe extends Oe {
  constructor() {
    super("a:stretch"), this.root.push(new wbe());
  }
}
class _be extends Oe {
  constructor(e) {
    super("pic:blipFill"), this.root.push(bbe(e)), this.root.push(new vbe()), this.root.push(new xbe());
  }
}
class Sbe extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      noChangeAspect: "noChangeAspect",
      noChangeArrowheads: "noChangeArrowheads"
    });
  }
}
class Tbe extends Oe {
  constructor() {
    super("a:picLocks"), this.root.push(
      new Sbe({
        noChangeAspect: 1,
        noChangeArrowheads: 1
      })
    );
  }
}
class Dbe extends Oe {
  constructor() {
    super("pic:cNvPicPr"), this.root.push(new Tbe());
  }
}
const IP = (t, e) => new Fn({
  name: "a:hlinkClick",
  attributes: Il(Dt({}, e ? {
    xmlns: {
      key: "xmlns:a",
      value: "http://schemas.openxmlformats.org/drawingml/2006/main"
    }
  } : {}), {
    id: {
      key: "r:id",
      value: `rId${t}`
    }
  })
});
class Ebe extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      id: "id",
      name: "name",
      descr: "descr"
    });
  }
}
class Cbe extends Oe {
  constructor() {
    super("pic:cNvPr"), this.root.push(
      new Ebe({
        id: 0,
        name: "",
        descr: ""
      })
    );
  }
  prepForXml(e) {
    for (let n = e.stack.length - 1; n >= 0; n--) {
      const r = e.stack[n];
      if (r instanceof R0) {
        this.root.push(IP(r.linkId, !1));
        break;
      }
    }
    return super.prepForXml(e);
  }
}
class kbe extends Oe {
  constructor() {
    super("pic:nvPicPr"), this.root.push(new Cbe()), this.root.push(new Dbe());
  }
}
class Abe extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      xmlns: "xmlns:pic"
    });
  }
}
class Rbe extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      cx: "cx",
      cy: "cy"
    });
  }
}
class Ibe extends Oe {
  constructor(e, n) {
    super("a:ext"), Ue(this, "attributes"), this.attributes = new Rbe({
      cx: e,
      cy: n
    }), this.root.push(this.attributes);
  }
}
class Obe extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      x: "x",
      y: "y"
    });
  }
}
class Fbe extends Oe {
  constructor() {
    super("a:off"), this.root.push(
      new Obe({
        x: 0,
        y: 0
      })
    );
  }
}
class Ube extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      flipVertical: "flipV",
      flipHorizontal: "flipH",
      rotation: "rot"
    });
  }
}
class Nbe extends Oe {
  constructor(e) {
    var n, r;
    super("a:xfrm"), Ue(this, "extents"), this.root.push(
      new Ube({
        flipVertical: (n = e.flip) == null ? void 0 : n.vertical,
        flipHorizontal: (r = e.flip) == null ? void 0 : r.horizontal,
        rotation: e.rotation
      })
    ), this.extents = new Ibe(e.emus.x, e.emus.y), this.root.push(new Fbe()), this.root.push(this.extents);
  }
}
const OP = () => new Fn({ name: "a:noFill" }), Mbe = (t) => new Fn({
  name: "a:schemeClr",
  attributes: {
    value: {
      key: "val",
      value: t.value
    }
  }
}), Bbe = (t) => new Fn({
  name: "a:srgbClr",
  attributes: {
    value: {
      key: "val",
      value: t.value
    }
  }
}), IO = (t) => new Fn({
  name: "a:solidFill",
  children: [t.type === "rgb" ? Bbe(t) : Mbe(t)]
}), Lbe = (t) => new Fn({
  name: "a:ln",
  attributes: {
    width: {
      key: "w",
      value: t.width
    },
    cap: {
      key: "cap",
      value: t.cap
    },
    compoundLine: {
      key: "cmpd",
      value: t.compoundLine
    },
    align: {
      key: "algn",
      value: t.align
    }
  },
  children: [
    t.type === "noFill" ? OP() : t.solidFillType === "rgb" ? IO({
      type: "rgb",
      value: t.value
    }) : IO({
      type: "scheme",
      value: t.value
    })
  ]
});
class Pbe extends Oe {
  constructor() {
    super("a:avLst");
  }
}
class Wbe extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      prst: "prst"
    });
  }
}
class zbe extends Oe {
  constructor() {
    super("a:prstGeom"), this.root.push(
      new Wbe({
        prst: "rect"
      })
    ), this.root.push(new Pbe());
  }
}
class $be extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      bwMode: "bwMode"
    });
  }
}
class Hbe extends Oe {
  constructor({ outline: e, transform: n }) {
    super("pic:spPr"), Ue(this, "form"), this.root.push(
      new $be({
        bwMode: "auto"
      })
    ), this.form = new Nbe(n), this.root.push(this.form), this.root.push(new zbe()), e && (this.root.push(OP()), this.root.push(Lbe(e)));
  }
}
class jbe extends Oe {
  constructor({
    mediaData: e,
    transform: n,
    outline: r
  }) {
    super("pic:pic"), this.root.push(
      new Abe({
        xmlns: "http://schemas.openxmlformats.org/drawingml/2006/picture"
      })
    ), this.root.push(new kbe()), this.root.push(new _be(e)), this.root.push(new Hbe({ transform: n, outline: r }));
  }
}
class Vbe extends Oe {
  constructor({
    mediaData: e,
    transform: n,
    outline: r
  }) {
    super("a:graphicData"), Ue(this, "pic"), this.root.push(
      new pbe({
        uri: "http://schemas.openxmlformats.org/drawingml/2006/picture"
      })
    ), this.pic = new jbe({ mediaData: e, transform: n, outline: r }), this.root.push(this.pic);
  }
}
class qbe extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      a: "xmlns:a"
    });
  }
}
class FP extends Oe {
  constructor({
    mediaData: e,
    transform: n,
    outline: r
  }) {
    super("a:graphic"), Ue(this, "data"), this.root.push(
      new qbe({
        a: "http://schemas.openxmlformats.org/drawingml/2006/main"
      })
    ), this.data = new Vbe({ mediaData: e, transform: n, outline: r }), this.root.push(this.data);
  }
}
const Ay = {
  NONE: 0,
  SQUARE: 1,
  TIGHT: 2,
  TOP_AND_BOTTOM: 3
}, Gbe = {
  BOTH_SIDES: "bothSides",
  LEFT: "left",
  RIGHT: "right",
  LARGEST: "largest"
};
class OO extends Oe {
  constructor() {
    super("wp:wrapNone");
  }
}
class Kbe extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      distT: "distT",
      distB: "distB",
      distL: "distL",
      distR: "distR",
      wrapText: "wrapText"
    });
  }
}
class Xbe extends Oe {
  constructor(e, n = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  }) {
    super("wp:wrapSquare"), this.root.push(
      new Kbe({
        wrapText: e.side || Gbe.BOTH_SIDES,
        distT: n.top,
        distB: n.bottom,
        distL: n.left,
        distR: n.right
      })
    );
  }
}
class Ybe extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      distT: "distT",
      distB: "distB"
    });
  }
}
class Jbe extends Oe {
  constructor(e = {
    top: 0,
    bottom: 0
  }) {
    super("wp:wrapTight"), this.root.push(
      new Ybe({
        distT: e.top,
        distB: e.bottom
      })
    );
  }
}
class Zbe extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      distT: "distT",
      distB: "distB"
    });
  }
}
class Qbe extends Oe {
  constructor(e = {
    top: 0,
    bottom: 0
  }) {
    super("wp:wrapTopAndBottom"), this.root.push(
      new Zbe({
        distT: e.top,
        distB: e.bottom
      })
    );
  }
}
class UP extends Oe {
  constructor({ name: e, description: n, title: r } = { name: "", description: "", title: "" }) {
    super("wp:docPr"), Ue(this, "docPropertiesUniqueNumericId", rbe()), this.root.push(
      new ws({
        id: {
          key: "id",
          value: this.docPropertiesUniqueNumericId()
        },
        name: {
          key: "name",
          value: e
        },
        description: {
          key: "descr",
          value: n
        },
        title: {
          key: "title",
          value: r
        }
      })
    );
  }
  prepForXml(e) {
    for (let n = e.stack.length - 1; n >= 0; n--) {
      const r = e.stack[n];
      if (r instanceof R0) {
        this.root.push(IP(r.linkId, !0));
        break;
      }
    }
    return super.prepForXml(e);
  }
}
const NP = ({ top: t, right: e, bottom: n, left: r }) => new Fn({
  name: "wp:effectExtent",
  attributes: {
    top: {
      key: "t",
      value: t
    },
    right: {
      key: "r",
      value: e
    },
    bottom: {
      key: "b",
      value: n
    },
    left: {
      key: "l",
      value: r
    }
  }
});
class eve extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      cx: "cx",
      cy: "cy"
    });
  }
}
class MP extends Oe {
  constructor(e, n) {
    super("wp:extent"), Ue(this, "attributes"), this.attributes = new eve({
      cx: e,
      cy: n
    }), this.root.push(this.attributes);
  }
}
class tve extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      xmlns: "xmlns:a",
      noChangeAspect: "noChangeAspect"
    });
  }
}
class nve extends Oe {
  constructor() {
    super("a:graphicFrameLocks"), this.root.push(
      new tve({
        xmlns: "http://schemas.openxmlformats.org/drawingml/2006/main",
        noChangeAspect: 1
      })
    );
  }
}
class BP extends Oe {
  constructor() {
    super("wp:cNvGraphicFramePr"), this.root.push(new nve());
  }
}
class rve extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      distT: "distT",
      distB: "distB",
      distL: "distL",
      distR: "distR",
      allowOverlap: "allowOverlap",
      behindDoc: "behindDoc",
      layoutInCell: "layoutInCell",
      locked: "locked",
      relativeHeight: "relativeHeight",
      simplePos: "simplePos"
    });
  }
}
class ive extends Oe {
  constructor({
    mediaData: e,
    transform: n,
    drawingOptions: r
  }) {
    super("wp:anchor");
    const i = Dt({
      allowOverlap: !0,
      behindDocument: !1,
      lockAnchor: !1,
      layoutInCell: !0,
      verticalPosition: {},
      horizontalPosition: {}
    }, r.floating);
    if (this.root.push(
      new rve({
        distT: i.margins && i.margins.top || 0,
        distB: i.margins && i.margins.bottom || 0,
        distL: i.margins && i.margins.left || 0,
        distR: i.margins && i.margins.right || 0,
        simplePos: "0",
        // note: word doesn't fully support - so we use 0
        allowOverlap: i.allowOverlap === !0 ? "1" : "0",
        behindDoc: i.behindDocument === !0 ? "1" : "0",
        locked: i.lockAnchor === !0 ? "1" : "0",
        layoutInCell: i.layoutInCell === !0 ? "1" : "0",
        relativeHeight: i.zIndex ? i.zIndex : n.emus.y
      })
    ), this.root.push(new cbe()), this.root.push(new dbe(i.horizontalPosition)), this.root.push(new hbe(i.verticalPosition)), this.root.push(new MP(n.emus.x, n.emus.y)), this.root.push(NP({ top: 0, right: 0, bottom: 0, left: 0 })), r.floating !== void 0 && r.floating.wrap !== void 0)
      switch (r.floating.wrap.type) {
        case Ay.SQUARE:
          this.root.push(new Xbe(r.floating.wrap, r.floating.margins));
          break;
        case Ay.TIGHT:
          this.root.push(new Jbe(r.floating.margins));
          break;
        case Ay.TOP_AND_BOTTOM:
          this.root.push(new Qbe(r.floating.margins));
          break;
        case Ay.NONE:
        default:
          this.root.push(new OO());
      }
    else
      this.root.push(new OO());
    this.root.push(new UP(r.docProperties)), this.root.push(new BP()), this.root.push(new FP({ mediaData: e, transform: n, outline: r.outline }));
  }
}
const ove = ({ mediaData: t, transform: e, docProperties: n, outline: r }) => {
  var i, o, a, s;
  return new Fn({
    name: "wp:inline",
    attributes: {
      distanceTop: {
        key: "distT",
        value: 0
      },
      distanceBottom: {
        key: "distB",
        value: 0
      },
      distanceLeft: {
        key: "distL",
        value: 0
      },
      distanceRight: {
        key: "distR",
        value: 0
      }
    },
    children: [
      new MP(e.emus.x, e.emus.y),
      NP(
        r ? {
          top: ((i = r.width) != null ? i : 9525) * 2,
          right: ((o = r.width) != null ? o : 9525) * 2,
          bottom: ((a = r.width) != null ? a : 9525) * 2,
          left: ((s = r.width) != null ? s : 9525) * 2
        } : { top: 0, right: 0, bottom: 0, left: 0 }
      ),
      new UP(n),
      new BP(),
      new FP({ mediaData: t, transform: e, outline: r })
    ]
  });
};
class ave extends Oe {
  constructor(e, n = {}) {
    super("w:drawing"), n.floating ? this.root.push(new ive({ mediaData: e, transform: e.transformation, drawingOptions: n })) : this.root.push(
      ove({
        mediaData: e,
        transform: e.transformation,
        docProperties: n.docProperties,
        outline: n.outline
      })
    );
  }
}
const sve = (t) => {
  if (typeof atob == "function") {
    const e = ";base64,", n = t.indexOf(e), r = n === -1 ? 0 : n + e.length;
    return new Uint8Array(
      atob(t.substring(r)).split("").map((i) => i.charCodeAt(0))
    );
  } else {
    const e = require("buffer");
    return new e.Buffer(t, "base64");
  }
}, lve = (t) => typeof t == "string" ? sve(t) : t, V_ = (t, e) => ({
  data: lve(t.data),
  fileName: e,
  transformation: {
    pixels: {
      x: Math.round(t.transformation.width),
      y: Math.round(t.transformation.height)
    },
    emus: {
      x: Math.round(t.transformation.width * 9525),
      y: Math.round(t.transformation.height * 9525)
    },
    flip: t.transformation.flip,
    rotation: t.transformation.rotation ? t.transformation.rotation * 6e4 : void 0
  }
});
class cve extends Tu {
  constructor(e) {
    super({}), Ue(this, "key"), Ue(this, "fallbackKey", `${jv()}.png`), Ue(this, "imageData"), this.key = `${jv()}.${e.type}`, this.imageData = e.type === "svg" ? Il(Dt({
      type: e.type
    }, V_(e, this.key)), {
      fallback: Dt({
        type: e.fallback.type
      }, V_(
        Il(Dt({}, e.fallback), {
          transformation: e.transformation
        }),
        this.fallbackKey
      ))
    }) : Dt({
      type: e.type
    }, V_(e, this.key));
    const n = new ave(this.imageData, {
      floating: e.floating,
      docProperties: e.altText,
      outline: e.outline
    });
    this.root.push(n);
  }
  prepForXml(e) {
    return e.file.Media.addImage(this.key, this.imageData), this.imageData.type === "svg" && e.file.Media.addImage(this.fallbackKey, this.imageData.fallback), super.prepForXml(e);
  }
}
class uve extends Oe {
  constructor(e) {
    super("w:instrText"), this.root.push(new su({ space: au.PRESERVE })), this.root.push(`SEQ ${e}`);
  }
}
class dve extends Tu {
  constructor(e) {
    super({}), this.root.push(new Dp(!0)), this.root.push(new uve(e)), this.root.push(new Ep()), this.root.push(new Cp());
  }
}
class fve extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { instr: "w:instr" });
  }
}
class hve extends Oe {
  constructor(e, n) {
    super("w:fldSimple"), this.root.push(new fve({ instr: e })), n !== void 0 && this.root.push(new vo(n));
  }
}
class pve extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { id: "w:id", initials: "w:initials", author: "w:author", date: "w:date" });
  }
}
class mve extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      "xmlns:cx": "xmlns:cx",
      "xmlns:cx1": "xmlns:cx1",
      "xmlns:cx2": "xmlns:cx2",
      "xmlns:cx3": "xmlns:cx3",
      "xmlns:cx4": "xmlns:cx4",
      "xmlns:cx5": "xmlns:cx5",
      "xmlns:cx6": "xmlns:cx6",
      "xmlns:cx7": "xmlns:cx7",
      "xmlns:cx8": "xmlns:cx8",
      "xmlns:mc": "xmlns:mc",
      "xmlns:aink": "xmlns:aink",
      "xmlns:am3d": "xmlns:am3d",
      "xmlns:o": "xmlns:o",
      "xmlns:r": "xmlns:r",
      "xmlns:m": "xmlns:m",
      "xmlns:v": "xmlns:v",
      "xmlns:wp14": "xmlns:wp14",
      "xmlns:wp": "xmlns:wp",
      "xmlns:w10": "xmlns:w10",
      "xmlns:w": "xmlns:w",
      "xmlns:w14": "xmlns:w14",
      "xmlns:w15": "xmlns:w15",
      "xmlns:w16cex": "xmlns:w16cex",
      "xmlns:w16cid": "xmlns:w16cid",
      "xmlns:w16": "xmlns:w16",
      "xmlns:w16sdtdh": "xmlns:w16sdtdh",
      "xmlns:w16se": "xmlns:w16se",
      "xmlns:wpg": "xmlns:wpg",
      "xmlns:wpi": "xmlns:wpi",
      "xmlns:wne": "xmlns:wne",
      "xmlns:wps": "xmlns:wps"
    });
  }
}
class gve extends Oe {
  constructor({ id: e, initials: n, author: r, date: i = /* @__PURE__ */ new Date(), children: o }) {
    super("w:comment"), this.root.push(
      new pve({
        id: e,
        initials: n,
        author: r,
        date: i.toISOString()
      })
    );
    for (const a of o)
      this.root.push(a);
  }
}
class yve extends Oe {
  constructor({ children: e }) {
    super("w:comments"), this.root.push(
      new mve({
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
      })
    );
    for (const n of e)
      this.root.push(new gve(n));
  }
}
class bve extends Oe {
  constructor() {
    super("w:pageBreakBefore");
  }
}
const $T = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  AT_LEAST: "atLeast",
  EXACTLY: "exactly",
  EXACT: "exact",
  AUTO: "auto"
};
class vve extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      after: "w:after",
      before: "w:before",
      line: "w:line",
      lineRule: "w:lineRule"
    });
  }
}
class wve extends Oe {
  constructor(e) {
    super("w:spacing"), this.root.push(new vve(e));
  }
}
const Md = {
  HEADING_1: "Heading1",
  HEADING_2: "Heading2",
  HEADING_3: "Heading3",
  HEADING_4: "Heading4",
  HEADING_5: "Heading5",
  HEADING_6: "Heading6",
  TITLE: "Title"
};
let Ry = class extends Oe {
  constructor(e) {
    super("w:pStyle"), this.root.push(
      new En({
        val: e
      })
    );
  }
};
class xve extends Oe {
  constructor(e) {
    super("w:tabs");
    for (const n of e)
      this.root.push(new Sve(n));
  }
}
const Vv = {
  LEFT: "left",
  RIGHT: "right",
  CENTER: "center",
  BAR: "bar",
  CLEAR: "clear",
  DECIMAL: "decimal",
  END: "end",
  NUM: "num",
  START: "start"
}, FO = {
  MAX: 9026
};
class _ve extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { val: "w:val", pos: "w:pos", leader: "w:leader" });
  }
}
class Sve extends Oe {
  constructor({ type: e, position: n, leader: r }) {
    super("w:tab"), this.root.push(
      new _ve({
        val: e,
        pos: n,
        leader: r
      })
    );
  }
}
class q_ extends Oe {
  constructor(e, n) {
    super("w:numPr"), this.root.push(new Tve(n)), this.root.push(new Dve(e));
  }
}
class Tve extends Oe {
  constructor(e) {
    if (super("w:ilvl"), e > 9)
      throw new Error(
        "Level cannot be greater than 9. Read more here: https://answers.microsoft.com/en-us/msoffice/forum/all/does-word-support-more-than-9-list-levels/d130fdcd-1781-446d-8c84-c6c79124e4d7"
      );
    this.root.push(
      new En({
        val: e
      })
    );
  }
}
class Dve extends Oe {
  constructor(e) {
    super("w:numId"), this.root.push(
      new En({
        val: typeof e == "string" ? `{${e}}` : e
      })
    );
  }
}
class LP extends Oe {
  constructor() {
    super(...arguments), Ue(this, "fileChild", Symbol());
  }
}
class Eve extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      id: "Id",
      type: "Type",
      target: "Target",
      targetMode: "TargetMode"
    });
  }
}
const Cve = {
  EXTERNAL: "External"
};
class kve extends Oe {
  constructor(e, n, r, i) {
    super("Relationship"), this.root.push(
      new Eve({
        id: e,
        type: n,
        target: r,
        targetMode: i
      })
    );
  }
}
class Ave extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      id: "r:id",
      history: "w:history",
      anchor: "w:anchor"
    });
  }
}
class R0 extends Oe {
  constructor(e, n, r) {
    super("w:hyperlink"), Ue(this, "linkId"), this.linkId = n;
    const i = {
      history: 1,
      anchor: r || void 0,
      id: r ? void 0 : `rId${this.linkId}`
    }, o = new Ave(i);
    this.root.push(o), e.forEach((a) => {
      this.root.push(a);
    });
  }
}
class Rve extends R0 {
  constructor(e) {
    super(e.children, jv(), e.anchor);
  }
}
class PP extends Oe {
  constructor(e) {
    super("w:externalHyperlink"), this.options = e;
  }
}
class Ive extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      id: "w:id",
      name: "w:name"
    });
  }
}
class Ove extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      id: "w:id"
    });
  }
}
class WP {
  constructor(e) {
    Ue(this, "bookmarkUniqueNumericId", ibe()), Ue(this, "start"), Ue(this, "children"), Ue(this, "end");
    const n = this.bookmarkUniqueNumericId();
    this.start = new Fve(e.id, n), this.children = e.children, this.end = new Uve(n);
  }
}
class Fve extends Oe {
  constructor(e, n) {
    super("w:bookmarkStart");
    const r = new Ive({
      name: e,
      id: n
    });
    this.root.push(r);
  }
}
class Uve extends Oe {
  constructor(e) {
    super("w:bookmarkEnd");
    const n = new Ove({
      id: e
    });
    this.root.push(n);
  }
}
class Nve extends Oe {
  constructor(e) {
    super("w:outlineLvl"), this.level = e, this.root.push(
      new En({
        val: e
      })
    );
  }
}
class Mve extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      verticalAlign: "w:val"
    });
  }
}
class zP extends Oe {
  constructor(e) {
    super("w:vAlign"), this.root.push(new Mve({ verticalAlign: e }));
  }
}
const mf = {
  DEFAULT: "default",
  FIRST: "first",
  EVEN: "even"
};
class Bve extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      type: "w:type",
      id: "r:id"
    });
  }
}
const UO = {
  HEADER: "w:headerReference",
  FOOTER: "w:footerReference"
};
class G_ extends Oe {
  constructor(e, n) {
    super(e), this.root.push(
      new Bve({
        type: n.type || mf.DEFAULT,
        id: `rId${n.id}`
      })
    );
  }
}
class Lve extends Oe {
  constructor({ space: e, count: n, separate: r, equalWidth: i, children: o }) {
    super("w:cols"), this.root.push(
      new ws({
        space: { key: "w:space", value: e === void 0 ? void 0 : lr(e) },
        count: { key: "w:num", value: n === void 0 ? void 0 : Dr(n) },
        separate: { key: "w:sep", value: r },
        equalWidth: { key: "w:equalWidth", value: i }
      })
    ), !i && o && o.forEach((a) => this.addChildElement(a));
  }
}
class Pve extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      type: "w:type",
      linePitch: "w:linePitch",
      charSpace: "w:charSpace"
    });
  }
}
class Wve extends Oe {
  constructor(e, n, r) {
    super("w:docGrid"), this.root.push(
      new Pve({
        type: r,
        linePitch: Dr(e),
        charSpace: n ? Dr(n) : void 0
      })
    );
  }
}
const zve = ({ countBy: t, start: e, restart: n, distance: r }) => new Fn({
  name: "w:lnNumType",
  attributes: {
    countBy: { key: "w:countBy", value: t === void 0 ? void 0 : Dr(t) },
    start: { key: "w:start", value: e === void 0 ? void 0 : Dr(e) },
    restart: { key: "w:restart", value: n },
    distance: {
      key: "w:distance",
      value: r === void 0 ? void 0 : lr(r)
    }
  }
});
class NO extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      display: "w:display",
      offsetFrom: "w:offsetFrom",
      zOrder: "w:zOrder"
    });
  }
}
class $ve extends vs {
  constructor(e) {
    if (super("w:pgBorders"), !e)
      return this;
    e.pageBorders ? this.root.push(
      new NO({
        display: e.pageBorders.display,
        offsetFrom: e.pageBorders.offsetFrom,
        zOrder: e.pageBorders.zOrder
      })
    ) : this.root.push(new NO({})), e.pageBorderTop && this.root.push(new Xt("w:top", e.pageBorderTop)), e.pageBorderLeft && this.root.push(new Xt("w:left", e.pageBorderLeft)), e.pageBorderBottom && this.root.push(new Xt("w:bottom", e.pageBorderBottom)), e.pageBorderRight && this.root.push(new Xt("w:right", e.pageBorderRight));
  }
}
class Hve extends Oe {
  constructor(e, n, r, i, o, a, s) {
    super("w:pgMar"), this.root.push(
      new ws({
        top: { key: "w:top", value: ts(e) },
        right: { key: "w:right", value: lr(n) },
        bottom: { key: "w:bottom", value: ts(r) },
        left: { key: "w:left", value: lr(i) },
        header: { key: "w:header", value: lr(o) },
        footer: { key: "w:footer", value: lr(a) },
        gutter: { key: "w:gutter", value: lr(s) }
      })
    );
  }
}
class jve extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      start: "w:start",
      formatType: "w:fmt",
      separator: "w:chapSep"
    });
  }
}
class Vve extends Oe {
  constructor({ start: e, formatType: n, separator: r }) {
    super("w:pgNumType"), this.root.push(
      new jve({
        start: e === void 0 ? void 0 : Dr(e),
        formatType: n,
        separator: r
      })
    );
  }
}
const $P = {
  PORTRAIT: "portrait",
  LANDSCAPE: "landscape"
};
class qve extends Oe {
  constructor(e, n, r) {
    super("w:pgSz");
    const i = r === $P.LANDSCAPE, o = lr(e), a = lr(n);
    this.root.push(
      new ws({
        width: { key: "w:w", value: i ? a : o },
        height: { key: "w:h", value: i ? o : a },
        orientation: { key: "w:orient", value: r }
      })
    );
  }
}
class Gve extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { val: "w:val" });
  }
}
class Kve extends Oe {
  constructor(e) {
    super("w:textDirection"), this.root.push(
      new Gve({
        val: e
      })
    );
  }
}
const Xve = {
  NEXT_PAGE: "nextPage",
  NEXT_COLUMN: "nextColumn",
  CONTINUOUS: "continuous",
  EVEN_PAGE: "evenPage",
  ODD_PAGE: "oddPage"
};
class Yve extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      val: "w:val"
    });
  }
}
class Jve extends Oe {
  constructor(e) {
    super("w:type"), this.root.push(new Yve({ val: e }));
  }
}
const kc = {
  TOP: 1440,
  RIGHT: 1440,
  BOTTOM: 1440,
  LEFT: 1440,
  HEADER: 708,
  FOOTER: 708,
  GUTTER: 0
}, K_ = {
  WIDTH: 11906,
  HEIGHT: 16838,
  ORIENTATION: $P.PORTRAIT
};
class Zve extends Oe {
  constructor({
    page: {
      size: {
        width: e = K_.WIDTH,
        height: n = K_.HEIGHT,
        orientation: r = K_.ORIENTATION
      } = {},
      margin: {
        top: i = kc.TOP,
        right: o = kc.RIGHT,
        bottom: a = kc.BOTTOM,
        left: s = kc.LEFT,
        header: l = kc.HEADER,
        footer: c = kc.FOOTER,
        gutter: u = kc.GUTTER
      } = {},
      pageNumbers: d = {},
      borders: f,
      textDirection: p
    } = {},
    grid: { linePitch: m = 360, charSpace: g, type: b } = {},
    headerWrapperGroup: y = {},
    footerWrapperGroup: w = {},
    lineNumbers: x,
    titlePage: k,
    verticalAlign: A,
    column: U,
    type: P
  } = {}) {
    super("w:sectPr"), this.addHeaderFooterGroup(UO.HEADER, y), this.addHeaderFooterGroup(UO.FOOTER, w), P && this.root.push(new Jve(P)), this.root.push(new qve(e, n, r)), this.root.push(new Hve(i, o, a, s, l, c, u)), f && this.root.push(new $ve(f)), x && this.root.push(zve(x)), this.root.push(new Vve(d)), U && this.root.push(new Lve(U)), A && this.root.push(new zP(A)), k !== void 0 && this.root.push(new je("w:titlePg", k)), p && this.root.push(new Kve(p)), this.root.push(new Wve(m, g, b));
  }
  addHeaderFooterGroup(e, n) {
    n.default && this.root.push(
      new G_(e, {
        type: mf.DEFAULT,
        id: n.default.View.ReferenceId
      })
    ), n.first && this.root.push(
      new G_(e, {
        type: mf.FIRST,
        id: n.first.View.ReferenceId
      })
    ), n.even && this.root.push(
      new G_(e, {
        type: mf.EVEN,
        id: n.even.View.ReferenceId
      })
    );
  }
}
class Qve extends Oe {
  constructor() {
    super("w:body"), Ue(this, "sections", []);
  }
  /**
   * Adds new section properties.
   * Note: Previous section is created in paragraph after the current element, and then new section will be added.
   * The spec says:
   *  - section element should be in the last paragraph of the section
   *  - last section should be direct child of body
   *
   * @param options new section options
   */
  addSection(e) {
    const n = this.sections.pop();
    this.root.push(this.createSectionParagraph(n)), this.sections.push(new Zve(e));
  }
  prepForXml(e) {
    return this.sections.length === 1 && (this.root.splice(0, 1), this.root.push(this.sections.pop())), super.prepForXml(e);
  }
  push(e) {
    this.root.push(e);
  }
  createSectionParagraph(e) {
    const n = new Sl({}), r = new $f({});
    return r.push(e), n.addChildElement(r), n;
  }
}
class tg extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      Ignorable: "mc:Ignorable",
      cp: "xmlns:cp",
      dc: "xmlns:dc",
      dcterms: "xmlns:dcterms",
      dcmitype: "xmlns:dcmitype",
      xsi: "xmlns:xsi",
      type: "xsi:type",
      cx: "xmlns:cx",
      cx1: "xmlns:cx1",
      cx2: "xmlns:cx2",
      cx3: "xmlns:cx3",
      cx4: "xmlns:cx4",
      cx5: "xmlns:cx5",
      cx6: "xmlns:cx6",
      cx7: "xmlns:cx7",
      cx8: "xmlns:cx8",
      aink: "xmlns:aink",
      am3d: "xmlns:am3d",
      w16cex: "xmlns:w16cex",
      w16cid: "xmlns:w16cid",
      w16: "xmlns:w16",
      w16sdtdh: "xmlns:w16sdtdh",
      w16se: "xmlns:w16se"
    });
  }
}
class e1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      color: "w:color",
      themeColor: "w:themeColor",
      themeShade: "w:themeShade",
      themeTint: "w:themeTint"
    });
  }
}
class t1e extends Oe {
  constructor(e) {
    super("w:background"), this.root.push(
      new e1e({
        color: e.color === void 0 ? void 0 : zf(e.color),
        themeColor: e.themeColor,
        themeShade: e.themeShade === void 0 ? void 0 : AO(e.themeShade),
        themeTint: e.themeTint === void 0 ? void 0 : AO(e.themeTint)
      })
    );
  }
}
class n1e extends Oe {
  constructor(e) {
    super("w:document"), Ue(this, "body"), this.root.push(
      new tg({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        cx: "http://schemas.microsoft.com/office/drawing/2014/chartex",
        cx1: "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        cx2: "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        cx3: "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        cx4: "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        cx5: "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        cx6: "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        cx7: "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        cx8: "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        aink: "http://schemas.microsoft.com/office/drawing/2016/ink",
        am3d: "http://schemas.microsoft.com/office/drawing/2017/model3d",
        w16cex: "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        w16cid: "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        w16: "http://schemas.microsoft.com/office/word/2018/wordml",
        w16sdtdh: "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        w16se: "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        Ignorable: "w14 w15 wp14"
      })
    ), this.body = new Qve(), e.background && this.root.push(new t1e(e.background)), this.root.push(this.body);
  }
  add(e) {
    return this.body.push(e), this;
  }
  get Body() {
    return this.body;
  }
}
class r1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      xmlns: "xmlns"
    });
  }
}
class ch extends Oe {
  constructor() {
    super("Relationships"), this.root.push(
      new r1e({
        xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
      })
    );
  }
  createRelationship(e, n, r, i) {
    const o = new kve(`rId${e}`, n, r, i);
    return this.root.push(o), o;
  }
  get RelationshipCount() {
    return this.root.length - 1;
  }
}
class HP {
  constructor(e) {
    Ue(this, "document"), Ue(this, "relationships"), this.document = new n1e(e), this.relationships = new ch();
  }
  get View() {
    return this.document;
  }
  get Relationships() {
    return this.relationships;
  }
}
class i1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { val: "w:val" });
  }
}
class o1e extends Oe {
  constructor() {
    super("w:wordWrap"), this.root.push(new i1e({ val: 0 }));
  }
}
const a1e = (t) => {
  var e, n;
  return new Fn({
    name: "w:framePr",
    attributes: {
      anchorLock: {
        key: "w:anchorLock",
        value: t.anchorLock
      },
      dropCap: {
        key: "w:dropCap",
        value: t.dropCap
      },
      width: {
        key: "w:w",
        value: t.width
      },
      height: {
        key: "w:h",
        value: t.height
      },
      x: {
        key: "w:x",
        value: t.position ? t.position.x : void 0
      },
      y: {
        key: "w:y",
        value: t.position ? t.position.y : void 0
      },
      anchorHorizontal: {
        key: "w:hAnchor",
        value: t.anchor.horizontal
      },
      anchorVertical: {
        key: "w:vAnchor",
        value: t.anchor.vertical
      },
      spaceHorizontal: {
        key: "w:hSpace",
        value: (e = t.space) == null ? void 0 : e.horizontal
      },
      spaceVertical: {
        key: "w:vSpace",
        value: (n = t.space) == null ? void 0 : n.vertical
      },
      rule: {
        key: "w:hRule",
        value: t.rule
      },
      alignmentX: {
        key: "w:xAlign",
        value: t.alignment ? t.alignment.x : void 0
      },
      alignmentY: {
        key: "w:yAlign",
        value: t.alignment ? t.alignment.y : void 0
      },
      lines: {
        key: "w:lines",
        value: t.lines
      },
      wrap: {
        key: "w:wrap",
        value: t.wrap
      }
    }
  });
};
class $f extends vs {
  constructor(e) {
    var n, r;
    if (super("w:pPr"), Ue(this, "numberingReferences", []), !e)
      return this;
    e.heading && this.push(new Ry(e.heading)), e.bullet && this.push(new Ry("ListParagraph")), e.numbering && !e.style && !e.heading && (e.numbering.custom || this.push(new Ry("ListParagraph"))), e.style && this.push(new Ry(e.style)), e.keepNext !== void 0 && this.push(new je("w:keepNext", e.keepNext)), e.keepLines !== void 0 && this.push(new je("w:keepLines", e.keepLines)), e.pageBreakBefore && this.push(new bve()), e.frame && this.push(a1e(e.frame)), e.widowControl !== void 0 && this.push(new je("w:widowControl", e.widowControl)), e.bullet && this.push(new q_(1, e.bullet.level)), e.numbering ? (this.numberingReferences.push({
      reference: e.numbering.reference,
      instance: (n = e.numbering.instance) != null ? n : 0
    }), this.push(new q_(`${e.numbering.reference}-${(r = e.numbering.instance) != null ? r : 0}`, e.numbering.level))) : e.numbering === !1 && this.push(new q_(0, 0)), e.border && this.push(new Aye(e.border)), e.thematicBreak && this.push(new Rye()), e.shading && this.push(new k0(e.shading)), e.wordWrap && this.push(new o1e()), e.overflowPunctuation && this.push(new je("w:overflowPunct", e.overflowPunctuation));
    const i = [
      ...e.rightTabStop !== void 0 ? [{ type: Vv.RIGHT, position: e.rightTabStop }] : [],
      ...e.tabStops ? e.tabStops : [],
      ...e.leftTabStop !== void 0 ? [{ type: Vv.LEFT, position: e.leftTabStop }] : []
    ];
    i.length > 0 && this.push(new xve(i)), e.bidirectional !== void 0 && this.push(new je("w:bidi", e.bidirectional)), e.spacing && this.push(new wve(e.spacing)), e.indent && this.push(new Iye(e.indent)), e.contextualSpacing !== void 0 && this.push(new je("w:contextualSpacing", e.contextualSpacing)), e.alignment && this.push(new EP(e.alignment)), e.outlineLevel !== void 0 && this.push(new Nve(e.outlineLevel)), e.suppressLineNumbers !== void 0 && this.push(new je("w:suppressLineNumbers", e.suppressLineNumbers)), e.autoSpaceEastAsianText !== void 0 && this.push(new je("w:autoSpaceDN", e.autoSpaceEastAsianText)), e.run && this.push(new Su(e.run));
  }
  push(e) {
    this.root.push(e);
  }
  prepForXml(e) {
    if (e.viewWrapper instanceof HP)
      for (const n of this.numberingReferences)
        e.file.Numbering.createConcreteNumberingInstance(n.reference, n.instance);
    return super.prepForXml(e);
  }
}
class Sl extends LP {
  constructor(e) {
    if (super("w:p"), Ue(this, "properties"), typeof e == "string")
      return this.properties = new $f({}), this.root.push(this.properties), this.root.push(new vo(e)), this;
    if (this.properties = new $f(e), this.root.push(this.properties), e.text && this.root.push(new vo(e.text)), e.children)
      for (const n of e.children) {
        if (n instanceof WP) {
          this.root.push(n.start);
          for (const r of n.children)
            this.root.push(r);
          this.root.push(n.end);
          continue;
        }
        this.root.push(n);
      }
  }
  prepForXml(e) {
    for (const n of this.root)
      if (n instanceof PP) {
        const r = this.root.indexOf(n), i = new R0(n.options.children, jv());
        e.viewWrapper.Relationships.createRelationship(
          i.linkId,
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
          n.options.link,
          Cve.EXTERNAL
        ), this.root[r] = i;
      }
    return super.prepForXml(e);
  }
  addRunToFront(e) {
    return this.root.splice(1, 0, e), this;
  }
}
let MO = class extends Oe {
  constructor(e) {
    super("m:oMath");
    for (const n of e.children)
      this.root.push(n);
  }
};
class s1e extends Oe {
  constructor(e) {
    super("m:t"), this.root.push(e);
  }
}
class BO extends Oe {
  constructor(e) {
    super("m:r"), this.root.push(new s1e(e));
  }
}
class l1e extends Oe {
  constructor(e) {
    super("w:tblGrid");
    for (const n of e)
      this.root.push(new c1e(n));
  }
}
class c1e extends Oe {
  constructor(e) {
    super("w:gridCol"), e !== void 0 && this.root.push(
      new ws({
        width: { key: "w:w", value: lr(e) }
      })
    );
  }
}
const jP = {
  TABLE: "w:tblCellMar",
  // eslint-disable-next-line @typescript-eslint/naming-convention
  TABLE_CELL: "w:tcMar"
};
class VP extends vs {
  constructor(e, { marginUnitType: n = HT.DXA, top: r, left: i, bottom: o, right: a }) {
    super(e), r !== void 0 && this.root.push(new Lc("w:top", { type: n, size: r })), i !== void 0 && this.root.push(new Lc("w:left", { type: n, size: i })), o !== void 0 && this.root.push(new Lc("w:bottom", { type: n, size: o })), a !== void 0 && this.root.push(new Lc("w:right", { type: n, size: a }));
  }
}
const HT = {
  /** Auto. */
  AUTO: "auto",
  /** Value is in twentieths of a point */
  DXA: "dxa",
  /** No (empty) value. */
  NIL: "nil",
  /** Value is in percentage. */
  PERCENTAGE: "pct"
};
class Lc extends Oe {
  constructor(e, { type: n = HT.AUTO, size: r }) {
    super(e);
    let i = r;
    n === HT.PERCENTAGE && typeof r == "number" && (i = `${r}%`), this.root.push(
      new ws({
        type: { key: "w:type", value: n },
        size: { key: "w:w", value: _ye(i) }
      })
    );
  }
}
class u1e extends vs {
  constructor(e) {
    super("w:tcBorders"), e.top && this.root.push(new Xt("w:top", e.top)), e.start && this.root.push(new Xt("w:start", e.start)), e.left && this.root.push(new Xt("w:left", e.left)), e.bottom && this.root.push(new Xt("w:bottom", e.bottom)), e.end && this.root.push(new Xt("w:end", e.end)), e.right && this.root.push(new Xt("w:right", e.right));
  }
}
class d1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { val: "w:val" });
  }
}
class f1e extends Oe {
  constructor(e) {
    super("w:gridSpan"), this.root.push(
      new d1e({
        val: Dr(e)
      })
    );
  }
}
const qP = {
  /**
   * Cell that is merged with upper one.
   */
  CONTINUE: "continue",
  /**
   * Cell that is starting the vertical merge.
   */
  RESTART: "restart"
};
class h1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { val: "w:val" });
  }
}
class LO extends Oe {
  constructor(e) {
    super("w:vMerge"), this.root.push(
      new h1e({
        val: e
      })
    );
  }
}
class p1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { val: "w:val" });
  }
}
class m1e extends Oe {
  constructor(e) {
    super("w:textDirection"), this.root.push(
      new p1e({
        val: e
      })
    );
  }
}
class g1e extends vs {
  constructor(e) {
    super("w:tcPr"), e.width && this.root.push(new Lc("w:tcW", e.width)), e.columnSpan && this.root.push(new f1e(e.columnSpan)), e.verticalMerge ? this.root.push(new LO(e.verticalMerge)) : e.rowSpan && e.rowSpan > 1 && this.root.push(new LO(qP.RESTART)), e.borders && this.root.push(new u1e(e.borders)), e.shading && this.root.push(new k0(e.shading)), e.margins && this.root.push(new VP(jP.TABLE_CELL, e.margins)), e.textDirection && this.root.push(new m1e(e.textDirection)), e.verticalAlign && this.root.push(new zP(e.verticalAlign));
  }
}
class rk extends Oe {
  constructor(e) {
    super("w:tc"), this.options = e, this.root.push(new g1e(e));
    for (const n of e.children)
      this.root.push(n);
  }
  prepForXml(e) {
    return this.root[this.root.length - 1] instanceof Sl || this.root.push(new Sl({})), super.prepForXml(e);
  }
}
const Bd = {
  style: ek.NONE,
  size: 0,
  color: "auto"
}, Ld = {
  style: ek.SINGLE,
  size: 4,
  color: "auto"
};
class GP extends Oe {
  constructor(e) {
    super("w:tblBorders"), e.top ? this.root.push(new Xt("w:top", e.top)) : this.root.push(new Xt("w:top", Ld)), e.left ? this.root.push(new Xt("w:left", e.left)) : this.root.push(new Xt("w:left", Ld)), e.bottom ? this.root.push(new Xt("w:bottom", e.bottom)) : this.root.push(new Xt("w:bottom", Ld)), e.right ? this.root.push(new Xt("w:right", e.right)) : this.root.push(new Xt("w:right", Ld)), e.insideHorizontal ? this.root.push(new Xt("w:insideH", e.insideHorizontal)) : this.root.push(new Xt("w:insideH", Ld)), e.insideVertical ? this.root.push(new Xt("w:insideV", e.insideVertical)) : this.root.push(new Xt("w:insideV", Ld));
  }
}
Ue(GP, "NONE", {
  top: Bd,
  bottom: Bd,
  left: Bd,
  right: Bd,
  insideHorizontal: Bd,
  insideVertical: Bd
});
class y1e extends Oe {
  constructor({
    horizontalAnchor: e,
    verticalAnchor: n,
    absoluteHorizontalPosition: r,
    relativeHorizontalPosition: i,
    absoluteVerticalPosition: o,
    relativeVerticalPosition: a,
    bottomFromText: s,
    topFromText: l,
    leftFromText: c,
    rightFromText: u,
    overlap: d
  }) {
    super("w:tblpPr"), this.root.push(
      new ws({
        leftFromText: {
          key: "w:leftFromText",
          value: c === void 0 ? void 0 : lr(c)
        },
        rightFromText: {
          key: "w:rightFromText",
          value: u === void 0 ? void 0 : lr(u)
        },
        topFromText: {
          key: "w:topFromText",
          value: l === void 0 ? void 0 : lr(l)
        },
        bottomFromText: {
          key: "w:bottomFromText",
          value: s === void 0 ? void 0 : lr(s)
        },
        absoluteHorizontalPosition: {
          key: "w:tblpX",
          value: r === void 0 ? void 0 : ts(r)
        },
        absoluteVerticalPosition: {
          key: "w:tblpY",
          value: o === void 0 ? void 0 : ts(o)
        },
        horizontalAnchor: {
          key: "w:horzAnchor",
          value: e === void 0 ? void 0 : e
        },
        relativeHorizontalPosition: {
          key: "w:tblpXSpec",
          value: i
        },
        relativeVerticalPosition: {
          key: "w:tblpYSpec",
          value: a
        },
        verticalAnchor: {
          key: "w:vertAnchor",
          value: n
        }
      })
    ), d && this.root.push(new Eye("w:tblOverlap", d));
  }
}
class b1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { type: "w:type" });
  }
}
class v1e extends Oe {
  constructor(e) {
    super("w:tblLayout"), this.root.push(new b1e({ type: e }));
  }
}
class w1e extends vs {
  constructor(e) {
    super("w:tblPr"), e.style && this.root.push(new Gc("w:tblStyle", e.style)), e.float && this.root.push(new y1e(e.float)), e.visuallyRightToLeft !== void 0 && this.root.push(new je("w:bidiVisual", e.visuallyRightToLeft)), e.width && this.root.push(new Lc("w:tblW", e.width)), e.alignment && this.root.push(new EP(e.alignment)), e.indent && this.root.push(new Lc("w:tblInd", e.indent)), e.borders && this.root.push(new GP(e.borders)), e.shading && this.root.push(new k0(e.shading)), e.layout && this.root.push(new v1e(e.layout)), e.cellMargin && this.root.push(new VP(jP.TABLE, e.cellMargin));
  }
}
class x1e extends LP {
  constructor({
    rows: e,
    width: n,
    // eslint-disable-next-line functional/immutable-data
    columnWidths: r = Array(Math.max(...e.map((f) => f.CellCount))).fill(100),
    margins: i,
    indent: o,
    float: a,
    layout: s,
    style: l,
    borders: c,
    alignment: u,
    visuallyRightToLeft: d
  }) {
    super("w:tbl"), this.root.push(
      new w1e({
        borders: c ?? {},
        width: n ?? { size: 100 },
        indent: o,
        float: a,
        layout: s,
        style: l,
        alignment: u,
        cellMargin: i,
        visuallyRightToLeft: d
      })
    ), this.root.push(new l1e(r));
    for (const f of e)
      this.root.push(f);
    e.forEach((f, p) => {
      if (p === e.length - 1)
        return;
      let m = 0;
      f.cells.forEach((g) => {
        if (g.options.rowSpan && g.options.rowSpan > 1) {
          const b = new rk({
            // the inserted CONTINUE cell has rowSpan, and will be handled when process the next row
            rowSpan: g.options.rowSpan - 1,
            columnSpan: g.options.columnSpan,
            borders: g.options.borders,
            children: [],
            verticalMerge: qP.CONTINUE
          });
          e[p + 1].addCellToColumnIndex(b, m);
        }
        m += g.options.columnSpan || 1;
      });
    });
  }
}
class _1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { value: "w:val", rule: "w:hRule" });
  }
}
class S1e extends Oe {
  constructor(e, n) {
    super("w:trHeight"), this.root.push(
      new _1e({
        value: lr(e),
        rule: n
      })
    );
  }
}
class T1e extends vs {
  constructor(e) {
    super("w:trPr"), e.cantSplit !== void 0 && this.root.push(new je("w:cantSplit", e.cantSplit)), e.tableHeader !== void 0 && this.root.push(new je("w:tblHeader", e.tableHeader)), e.height && this.root.push(new S1e(e.height.value, e.height.rule));
  }
}
class D1e extends Oe {
  constructor(e) {
    super("w:tr"), this.options = e, this.root.push(new T1e(e));
    for (const n of e.children)
      this.root.push(n);
  }
  get CellCount() {
    return this.options.children.length;
  }
  get cells() {
    return this.root.filter((e) => e instanceof rk);
  }
  addCellToIndex(e, n) {
    this.root.splice(n + 1, 0, e);
  }
  addCellToColumnIndex(e, n) {
    const r = this.columnIndexToRootIndex(n, !0);
    this.addCellToIndex(e, r - 1);
  }
  rootIndexToColumnIndex(e) {
    if (e < 1 || e >= this.root.length)
      throw new Error(`cell 'rootIndex' should between 1 to ${this.root.length - 1}`);
    let n = 0;
    for (let r = 1; r < e; r++) {
      const i = this.root[r];
      n += i.options.columnSpan || 1;
    }
    return n;
  }
  columnIndexToRootIndex(e, n = !1) {
    if (e < 0)
      throw new Error("cell 'columnIndex' should not less than zero");
    let r = 0, i = 1;
    for (; r <= e; ) {
      if (i >= this.root.length) {
        if (n)
          return this.root.length;
        throw new Error(`cell 'columnIndex' should not great than ${r - 1}`);
      }
      const o = this.root[i];
      i += 1, r += o && o.options.columnSpan || 1;
    }
    return i - 1;
  }
}
class E1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      xmlns: "xmlns",
      vt: "xmlns:vt"
    });
  }
}
class C1e extends Oe {
  constructor() {
    super("Properties"), this.root.push(
      new E1e({
        xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
        vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
      })
    );
  }
}
class k1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      xmlns: "xmlns"
    });
  }
}
class A1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      contentType: "ContentType",
      extension: "Extension"
    });
  }
}
class Ga extends Oe {
  constructor(e, n) {
    super("Default"), this.root.push(
      new A1e({
        contentType: e,
        extension: n
      })
    );
  }
}
class R1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      contentType: "ContentType",
      partName: "PartName"
    });
  }
}
class Gi extends Oe {
  constructor(e, n) {
    super("Override"), this.root.push(
      new R1e({
        contentType: e,
        partName: n
      })
    );
  }
}
class I1e extends Oe {
  constructor() {
    super("Types"), this.root.push(
      new k1e({
        xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
      })
    ), this.root.push(new Ga("image/png", "png")), this.root.push(new Ga("image/jpeg", "jpeg")), this.root.push(new Ga("image/jpeg", "jpg")), this.root.push(new Ga("image/bmp", "bmp")), this.root.push(new Ga("image/gif", "gif")), this.root.push(new Ga("image/svg+xml", "svg")), this.root.push(new Ga("application/vnd.openxmlformats-package.relationships+xml", "rels")), this.root.push(new Ga("application/xml", "xml")), this.root.push(new Ga("application/vnd.openxmlformats-officedocument.obfuscatedFont", "odttf")), this.root.push(
      new Gi("application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml", "/word/document.xml")
    ), this.root.push(new Gi("application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml", "/word/styles.xml")), this.root.push(new Gi("application/vnd.openxmlformats-package.core-properties+xml", "/docProps/core.xml")), this.root.push(new Gi("application/vnd.openxmlformats-officedocument.custom-properties+xml", "/docProps/custom.xml")), this.root.push(new Gi("application/vnd.openxmlformats-officedocument.extended-properties+xml", "/docProps/app.xml")), this.root.push(new Gi("application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml", "/word/numbering.xml")), this.root.push(new Gi("application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml", "/word/footnotes.xml")), this.root.push(new Gi("application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml", "/word/settings.xml")), this.root.push(new Gi("application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml", "/word/comments.xml")), this.root.push(new Gi("application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml", "/word/fontTable.xml"));
  }
  addFooter(e) {
    this.root.push(
      new Gi("application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml", `/word/footer${e}.xml`)
    );
  }
  addHeader(e) {
    this.root.push(
      new Gi("application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml", `/word/header${e}.xml`)
    );
  }
}
class O1e extends Oe {
  constructor(e) {
    super("cp:coreProperties"), this.root.push(
      new tg({
        cp: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
        dc: "http://purl.org/dc/elements/1.1/",
        dcterms: "http://purl.org/dc/terms/",
        dcmitype: "http://purl.org/dc/dcmitype/",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
      })
    ), e.title && this.root.push(new Cc("dc:title", e.title)), e.subject && this.root.push(new Cc("dc:subject", e.subject)), e.creator && this.root.push(new Cc("dc:creator", e.creator)), e.keywords && this.root.push(new Cc("cp:keywords", e.keywords)), e.description && this.root.push(new Cc("dc:description", e.description)), e.lastModifiedBy && this.root.push(new Cc("cp:lastModifiedBy", e.lastModifiedBy)), e.revision && this.root.push(new Cc("cp:revision", String(e.revision))), this.root.push(new PO("dcterms:created")), this.root.push(new PO("dcterms:modified"));
  }
}
class PO extends Oe {
  constructor(e) {
    super(e), this.root.push(
      new tg({
        type: "dcterms:W3CDTF"
      })
    ), this.root.push(Dye(/* @__PURE__ */ new Date()));
  }
}
class F1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      xmlns: "xmlns",
      vt: "xmlns:vt"
    });
  }
}
class U1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      fmtid: "fmtid",
      pid: "pid",
      name: "name"
    });
  }
}
class N1e extends Oe {
  constructor(e, n) {
    super("property"), this.root.push(
      new U1e({
        fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
        pid: e.toString(),
        name: n.name
      })
    ), this.root.push(new M1e(n.value));
  }
}
class M1e extends Oe {
  constructor(e) {
    super("vt:lpwstr"), this.root.push(e);
  }
}
class B1e extends Oe {
  constructor(e) {
    super("Properties"), Ue(this, "nextId"), Ue(this, "properties", []), this.root.push(
      new F1e({
        xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
        vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
      })
    ), this.nextId = 2;
    for (const n of e)
      this.addCustomProperty(n);
  }
  prepForXml(e) {
    return this.properties.forEach((n) => this.root.push(n)), super.prepForXml(e);
  }
  addCustomProperty(e) {
    this.properties.push(new N1e(this.nextId++, e));
  }
}
class L1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      cp: "xmlns:cp",
      dc: "xmlns:dc",
      dcterms: "xmlns:dcterms",
      dcmitype: "xmlns:dcmitype",
      xsi: "xmlns:xsi",
      type: "xsi:type"
    });
  }
}
let P1e = class extends SP {
  constructor(e, n) {
    super("w:ftr", n), Ue(this, "refId"), this.refId = e, n || this.root.push(
      new L1e({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
      })
    );
  }
  get ReferenceId() {
    return this.refId;
  }
  add(e) {
    this.root.push(e);
  }
};
class W1e {
  constructor(e, n, r) {
    Ue(this, "footer"), Ue(this, "relationships"), this.media = e, this.footer = new P1e(n, r), this.relationships = new ch();
  }
  add(e) {
    this.footer.add(e);
  }
  addChildElement(e) {
    this.footer.addChildElement(e);
  }
  get View() {
    return this.footer;
  }
  get Relationships() {
    return this.relationships;
  }
  get Media() {
    return this.media;
  }
}
class z1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      type: "w:type",
      id: "w:id"
    });
  }
}
class $1e extends Oe {
  constructor() {
    super("w:footnoteRef");
  }
}
class H1e extends Tu {
  constructor() {
    super({
      style: "FootnoteReference"
    }), this.root.push(new $1e());
  }
}
const WO = {
  SEPERATOR: "separator",
  // eslint-disable-next-line @typescript-eslint/naming-convention
  CONTINUATION_SEPERATOR: "continuationSeparator"
};
class X_ extends Oe {
  constructor(e) {
    super("w:footnote"), this.root.push(
      new z1e({
        type: e.type,
        id: e.id
      })
    );
    for (let n = 0; n < e.children.length; n++) {
      const r = e.children[n];
      n === 0 && r.addRunToFront(new H1e()), this.root.push(r);
    }
  }
}
class j1e extends Oe {
  constructor() {
    super("w:continuationSeparator");
  }
}
class V1e extends Tu {
  constructor() {
    super({}), this.root.push(new j1e());
  }
}
class q1e extends Oe {
  constructor() {
    super("w:separator");
  }
}
class G1e extends Tu {
  constructor() {
    super({}), this.root.push(new q1e());
  }
}
class K1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      Ignorable: "mc:Ignorable"
    });
  }
}
class X1e extends Oe {
  constructor() {
    super("w:footnotes"), this.root.push(
      new K1e({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        Ignorable: "w14 w15 wp14"
      })
    );
    const e = new X_({
      id: -1,
      type: WO.SEPERATOR,
      children: [
        new Sl({
          spacing: {
            after: 0,
            line: 240,
            lineRule: $T.AUTO
          },
          children: [new G1e()]
        })
      ]
    });
    this.root.push(e);
    const n = new X_({
      id: 0,
      type: WO.CONTINUATION_SEPERATOR,
      children: [
        new Sl({
          spacing: {
            after: 0,
            line: 240,
            lineRule: $T.AUTO
          },
          children: [new V1e()]
        })
      ]
    });
    this.root.push(n);
  }
  createFootNote(e, n) {
    const r = new X_({
      id: e,
      children: n
    });
    this.root.push(r);
  }
}
class Y1e {
  constructor() {
    Ue(this, "footnotess"), Ue(this, "relationships"), this.footnotess = new X1e(), this.relationships = new ch();
  }
  get View() {
    return this.footnotess;
  }
  get Relationships() {
    return this.relationships;
  }
}
class J1e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      cp: "xmlns:cp",
      dc: "xmlns:dc",
      dcterms: "xmlns:dcterms",
      dcmitype: "xmlns:dcmitype",
      xsi: "xmlns:xsi",
      type: "xsi:type",
      cx: "xmlns:cx",
      cx1: "xmlns:cx1",
      cx2: "xmlns:cx2",
      cx3: "xmlns:cx3",
      cx4: "xmlns:cx4",
      cx5: "xmlns:cx5",
      cx6: "xmlns:cx6",
      cx7: "xmlns:cx7",
      cx8: "xmlns:cx8",
      w16cid: "xmlns:w16cid",
      w16se: "xmlns:w16se"
    });
  }
}
let Z1e = class extends SP {
  constructor(e, n) {
    super("w:hdr", n), Ue(this, "refId"), this.refId = e, n || this.root.push(
      new J1e({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        cx: "http://schemas.microsoft.com/office/drawing/2014/chartex",
        cx1: "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        cx2: "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        cx3: "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        cx4: "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        cx5: "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        cx6: "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        cx7: "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        cx8: "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        w16cid: "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        w16se: "http://schemas.microsoft.com/office/word/2015/wordml/symex"
      })
    );
  }
  get ReferenceId() {
    return this.refId;
  }
  add(e) {
    this.root.push(e);
  }
};
class Q1e {
  constructor(e, n, r) {
    Ue(this, "header"), Ue(this, "relationships"), this.media = e, this.header = new Z1e(n, r), this.relationships = new ch();
  }
  add(e) {
    return this.header.add(e), this;
  }
  addChildElement(e) {
    this.header.addChildElement(e);
  }
  get View() {
    return this.header;
  }
  get Relationships() {
    return this.relationships;
  }
  get Media() {
    return this.media;
  }
}
class e0e {
  constructor() {
    Ue(this, "map"), this.map = /* @__PURE__ */ new Map();
  }
  addImage(e, n) {
    this.map.set(e, n);
  }
  get Array() {
    return Array.from(this.map.values());
  }
}
const Si = {
  DECIMAL: "decimal",
  UPPER_ROMAN: "upperRoman",
  LOWER_ROMAN: "lowerRoman",
  UPPER_LETTER: "upperLetter",
  LOWER_LETTER: "lowerLetter",
  ORDINAL: "ordinal",
  CARDINAL_TEXT: "cardinalText",
  ORDINAL_TEXT: "ordinalText",
  HEX: "hex",
  CHICAGO: "chicago",
  IDEOGRAPH__DIGITAL: "ideographDigital",
  JAPANESE_COUNTING: "japaneseCounting",
  AIUEO: "aiueo",
  IROHA: "iroha",
  DECIMAL_FULL_WIDTH: "decimalFullWidth",
  DECIMAL_HALF_WIDTH: "decimalHalfWidth",
  JAPANESE_LEGAL: "japaneseLegal",
  JAPANESE_DIGITAL_TEN_THOUSAND: "japaneseDigitalTenThousand",
  DECIMAL_ENCLOSED_CIRCLE: "decimalEnclosedCircle",
  DECIMAL_FULL_WIDTH2: "decimalFullWidth2",
  AIUEO_FULL_WIDTH: "aiueoFullWidth",
  IROHA_FULL_WIDTH: "irohaFullWidth",
  DECIMAL_ZERO: "decimalZero",
  BULLET: "bullet",
  GANADA: "ganada",
  CHOSUNG: "chosung",
  DECIMAL_ENCLOSED_FULLSTOP: "decimalEnclosedFullstop",
  DECIMAL_ENCLOSED_PARENTHESES: "decimalEnclosedParen",
  DECIMAL_ENCLOSED_CIRCLE_CHINESE: "decimalEnclosedCircleChinese",
  IDEOGRAPH_ENCLOSED_CIRCLE: "ideographEnclosedCircle",
  IDEOGRAPH_TRADITIONAL: "ideographTraditional",
  IDEOGRAPH_ZODIAC: "ideographZodiac",
  IDEOGRAPH_ZODIAC_TRADITIONAL: "ideographZodiacTraditional",
  TAIWANESE_COUNTING: "taiwaneseCounting",
  IDEOGRAPH_LEGAL_TRADITIONAL: "ideographLegalTraditional",
  TAIWANESE_COUNTING_THOUSAND: "taiwaneseCountingThousand",
  TAIWANESE_DIGITAL: "taiwaneseDigital",
  CHINESE_COUNTING: "chineseCounting",
  CHINESE_LEGAL_SIMPLIFIED: "chineseLegalSimplified",
  CHINESE_COUNTING_THOUSAND: "chineseCountingThousand",
  KOREAN_DIGITAL: "koreanDigital",
  KOREAN_COUNTING: "koreanCounting",
  KOREAN_LEGAL: "koreanLegal",
  KOREAN_DIGITAL2: "koreanDigital2",
  VIETNAMESE_COUNTING: "vietnameseCounting",
  RUSSIAN_LOWER: "russianLower",
  RUSSIAN_UPPER: "russianUpper",
  NONE: "none",
  NUMBER_IN_DASH: "numberInDash",
  HEBREW1: "hebrew1",
  HEBREW2: "hebrew2",
  ARABIC_ALPHA: "arabicAlpha",
  ARABIC_ABJAD: "arabicAbjad",
  HINDI_VOWELS: "hindiVowels",
  HINDI_CONSONANTS: "hindiConsonants",
  HINDI_NUMBERS: "hindiNumbers",
  HINDI_COUNTING: "hindiCounting",
  THAI_LETTERS: "thaiLetters",
  THAI_NUMBERS: "thaiNumbers",
  THAI_COUNTING: "thaiCounting",
  BAHT_TEXT: "bahtText",
  DOLLAR_TEXT: "dollarText",
  CUSTOM: "custom"
};
class t0e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      ilvl: "w:ilvl",
      tentative: "w15:tentative"
    });
  }
}
class n0e extends Oe {
  constructor(e) {
    super("w:numFmt"), this.root.push(
      new En({
        val: e
      })
    );
  }
}
class r0e extends Oe {
  constructor(e) {
    super("w:lvlText"), this.root.push(
      new En({
        val: e
      })
    );
  }
}
class i0e extends Oe {
  constructor(e) {
    super("w:lvlJc"), this.root.push(
      new En({
        val: e
      })
    );
  }
}
class o0e extends Oe {
  constructor(e) {
    super("w:suff"), this.root.push(
      new En({
        val: e
      })
    );
  }
}
class a0e extends Oe {
  constructor() {
    super("w:isLgl");
  }
}
class s0e extends Oe {
  constructor({
    level: e,
    format: n,
    text: r,
    alignment: i = ri.START,
    start: o = 1,
    style: a,
    suffix: s,
    isLegalNumberingStyle: l
  }) {
    if (super("w:lvl"), Ue(this, "paragraphProperties"), Ue(this, "runProperties"), this.root.push(new QC("w:start", Dr(o))), n && this.root.push(new n0e(n)), s && this.root.push(new o0e(s)), l && this.root.push(new a0e()), r && this.root.push(new r0e(r)), this.root.push(new i0e(i)), this.paragraphProperties = new $f(a && a.paragraph), this.runProperties = new Su(a && a.run), this.root.push(this.paragraphProperties), this.root.push(this.runProperties), e > 9)
      throw new Error(
        "Level cannot be greater than 9. Read more here: https://answers.microsoft.com/en-us/msoffice/forum/all/does-word-support-more-than-9-list-levels/d130fdcd-1781-446d-8c84-c6c79124e4d7"
      );
    this.root.push(
      new t0e({
        ilvl: Dr(e),
        tentative: 1
      })
    );
  }
}
class l0e extends s0e {
  // This is the level that sits under abstractNum. We make a
  // handful of properties required
}
class c0e extends Oe {
  constructor(e) {
    super("w:multiLevelType"), this.root.push(
      new En({
        val: e
      })
    );
  }
}
class u0e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      abstractNumId: "w:abstractNumId",
      restartNumberingAfterBreak: "w15:restartNumberingAfterBreak"
    });
  }
}
class zO extends Oe {
  constructor(e, n) {
    super("w:abstractNum"), Ue(this, "id"), this.root.push(
      new u0e({
        abstractNumId: Dr(e),
        restartNumberingAfterBreak: 0
      })
    ), this.root.push(new c0e("hybridMultilevel")), this.id = e;
    for (const r of n)
      this.root.push(new l0e(r));
  }
}
class d0e extends Oe {
  constructor(e) {
    super("w:abstractNumId"), this.root.push(
      new En({
        val: e
      })
    );
  }
}
class f0e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { numId: "w:numId" });
  }
}
class $O extends Oe {
  constructor(e) {
    if (super("w:num"), Ue(this, "numId"), Ue(this, "reference"), Ue(this, "instance"), this.numId = e.numId, this.reference = e.reference, this.instance = e.instance, this.root.push(
      new f0e({
        numId: Dr(e.numId)
      })
    ), this.root.push(new d0e(Dr(e.abstractNumId))), e.overrideLevels && e.overrideLevels.length)
      for (const n of e.overrideLevels)
        this.root.push(new p0e(n.num, n.start));
  }
}
class h0e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { ilvl: "w:ilvl" });
  }
}
class p0e extends Oe {
  constructor(e, n) {
    super("w:lvlOverride"), this.root.push(new h0e({ ilvl: e })), n !== void 0 && this.root.push(new g0e(n));
  }
}
class m0e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { val: "w:val" });
  }
}
class g0e extends Oe {
  constructor(e) {
    super("w:startOverride"), this.root.push(new m0e({ val: e }));
  }
}
class y0e extends Oe {
  constructor(e) {
    super("w:numbering"), Ue(this, "abstractNumberingMap", /* @__PURE__ */ new Map()), Ue(this, "concreteNumberingMap", /* @__PURE__ */ new Map()), Ue(this, "referenceConfigMap", /* @__PURE__ */ new Map()), Ue(this, "abstractNumUniqueNumericId", tbe()), Ue(this, "concreteNumUniqueNumericId", nbe()), this.root.push(
      new tg({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        Ignorable: "w14 w15 wp14"
      })
    );
    const n = new zO(this.abstractNumUniqueNumericId(), [
      {
        level: 0,
        format: Si.BULLET,
        text: "●",
        alignment: ri.LEFT,
        style: {
          paragraph: {
            indent: { left: xi(0.5), hanging: xi(0.25) }
          }
        }
      },
      {
        level: 1,
        format: Si.BULLET,
        text: "○",
        alignment: ri.LEFT,
        style: {
          paragraph: {
            indent: { left: xi(1), hanging: xi(0.25) }
          }
        }
      },
      {
        level: 2,
        format: Si.BULLET,
        text: "■",
        alignment: ri.LEFT,
        style: {
          paragraph: {
            indent: { left: 2160, hanging: xi(0.25) }
          }
        }
      },
      {
        level: 3,
        format: Si.BULLET,
        text: "●",
        alignment: ri.LEFT,
        style: {
          paragraph: {
            indent: { left: 2880, hanging: xi(0.25) }
          }
        }
      },
      {
        level: 4,
        format: Si.BULLET,
        text: "○",
        alignment: ri.LEFT,
        style: {
          paragraph: {
            indent: { left: 3600, hanging: xi(0.25) }
          }
        }
      },
      {
        level: 5,
        format: Si.BULLET,
        text: "■",
        alignment: ri.LEFT,
        style: {
          paragraph: {
            indent: { left: 4320, hanging: xi(0.25) }
          }
        }
      },
      {
        level: 6,
        format: Si.BULLET,
        text: "●",
        alignment: ri.LEFT,
        style: {
          paragraph: {
            indent: { left: 5040, hanging: xi(0.25) }
          }
        }
      },
      {
        level: 7,
        format: Si.BULLET,
        text: "●",
        alignment: ri.LEFT,
        style: {
          paragraph: {
            indent: { left: 5760, hanging: xi(0.25) }
          }
        }
      },
      {
        level: 8,
        format: Si.BULLET,
        text: "●",
        alignment: ri.LEFT,
        style: {
          paragraph: {
            indent: { left: 6480, hanging: xi(0.25) }
          }
        }
      }
    ]);
    this.concreteNumberingMap.set(
      "default-bullet-numbering",
      new $O({
        numId: 1,
        abstractNumId: n.id,
        reference: "default-bullet-numbering",
        instance: 0,
        overrideLevels: [
          {
            num: 0,
            start: 1
          }
        ]
      })
    ), this.abstractNumberingMap.set("default-bullet-numbering", n);
    for (const r of e.config)
      this.abstractNumberingMap.set(r.reference, new zO(this.abstractNumUniqueNumericId(), r.levels)), this.referenceConfigMap.set(r.reference, r.levels);
  }
  prepForXml(e) {
    for (const n of this.abstractNumberingMap.values())
      this.root.push(n);
    for (const n of this.concreteNumberingMap.values())
      this.root.push(n);
    return super.prepForXml(e);
  }
  createConcreteNumberingInstance(e, n) {
    const r = this.abstractNumberingMap.get(e);
    if (!r)
      return;
    const i = `${e}-${n}`;
    if (this.concreteNumberingMap.has(i))
      return;
    const o = this.referenceConfigMap.get(e), a = o && o[0].start, s = {
      numId: this.concreteNumUniqueNumericId(),
      abstractNumId: r.id,
      reference: e,
      instance: n,
      overrideLevels: [
        a && Number.isInteger(a) ? {
          num: 0,
          start: a
        } : {
          num: 0,
          start: 1
        }
      ]
    };
    this.concreteNumberingMap.set(i, new $O(s));
  }
  get ConcreteNumbering() {
    return Array.from(this.concreteNumberingMap.values());
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get ReferenceConfig() {
    return Array.from(this.referenceConfigMap.values());
  }
}
class b0e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      version: "w:val",
      name: "w:name",
      uri: "w:uri"
    });
  }
}
class v0e extends Oe {
  constructor(e) {
    super("w:compatSetting"), this.root.push(
      new b0e({
        version: e,
        uri: "http://schemas.microsoft.com/office/word",
        name: "compatibilityMode"
      })
    );
  }
}
class w0e extends Oe {
  constructor(e) {
    super("w:compat"), e.version && this.root.push(new v0e(e.version)), e.useSingleBorderforContiguousCells && this.root.push(new je("w:useSingleBorderforContiguousCells", e.useSingleBorderforContiguousCells)), e.wordPerfectJustification && this.root.push(new je("w:wpJustification", e.wordPerfectJustification)), e.noTabStopForHangingIndent && this.root.push(new je("w:noTabHangInd", e.noTabStopForHangingIndent)), e.noLeading && this.root.push(new je("w:noLeading", e.noLeading)), e.spaceForUnderline && this.root.push(new je("w:spaceForUL", e.spaceForUnderline)), e.noColumnBalance && this.root.push(new je("w:noColumnBalance", e.noColumnBalance)), e.balanceSingleByteDoubleByteWidth && this.root.push(new je("w:balanceSingleByteDoubleByteWidth", e.balanceSingleByteDoubleByteWidth)), e.noExtraLineSpacing && this.root.push(new je("w:noExtraLineSpacing", e.noExtraLineSpacing)), e.doNotLeaveBackslashAlone && this.root.push(new je("w:doNotLeaveBackslashAlone", e.doNotLeaveBackslashAlone)), e.underlineTrailingSpaces && this.root.push(new je("w:ulTrailSpace", e.underlineTrailingSpaces)), e.doNotExpandShiftReturn && this.root.push(new je("w:doNotExpandShiftReturn", e.doNotExpandShiftReturn)), e.spacingInWholePoints && this.root.push(new je("w:spacingInWholePoints", e.spacingInWholePoints)), e.lineWrapLikeWord6 && this.root.push(new je("w:lineWrapLikeWord6", e.lineWrapLikeWord6)), e.printBodyTextBeforeHeader && this.root.push(new je("w:printBodyTextBeforeHeader", e.printBodyTextBeforeHeader)), e.printColorsBlack && this.root.push(new je("w:printColBlack", e.printColorsBlack)), e.spaceWidth && this.root.push(new je("w:wpSpaceWidth", e.spaceWidth)), e.showBreaksInFrames && this.root.push(new je("w:showBreaksInFrames", e.showBreaksInFrames)), e.subFontBySize && this.root.push(new je("w:subFontBySize", e.subFontBySize)), e.suppressBottomSpacing && this.root.push(new je("w:suppressBottomSpacing", e.suppressBottomSpacing)), e.suppressTopSpacing && this.root.push(new je("w:suppressTopSpacing", e.suppressTopSpacing)), e.suppressSpacingAtTopOfPage && this.root.push(new je("w:suppressSpacingAtTopOfPage", e.suppressSpacingAtTopOfPage)), e.suppressTopSpacingWP && this.root.push(new je("w:suppressTopSpacingWP", e.suppressTopSpacingWP)), e.suppressSpBfAfterPgBrk && this.root.push(new je("w:suppressSpBfAfterPgBrk", e.suppressSpBfAfterPgBrk)), e.swapBordersFacingPages && this.root.push(new je("w:swapBordersFacingPages", e.swapBordersFacingPages)), e.convertMailMergeEsc && this.root.push(new je("w:convMailMergeEsc", e.convertMailMergeEsc)), e.truncateFontHeightsLikeWP6 && this.root.push(new je("w:truncateFontHeightsLikeWP6", e.truncateFontHeightsLikeWP6)), e.macWordSmallCaps && this.root.push(new je("w:mwSmallCaps", e.macWordSmallCaps)), e.usePrinterMetrics && this.root.push(new je("w:usePrinterMetrics", e.usePrinterMetrics)), e.doNotSuppressParagraphBorders && this.root.push(new je("w:doNotSuppressParagraphBorders", e.doNotSuppressParagraphBorders)), e.wrapTrailSpaces && this.root.push(new je("w:wrapTrailSpaces", e.wrapTrailSpaces)), e.footnoteLayoutLikeWW8 && this.root.push(new je("w:footnoteLayoutLikeWW8", e.footnoteLayoutLikeWW8)), e.shapeLayoutLikeWW8 && this.root.push(new je("w:shapeLayoutLikeWW8", e.shapeLayoutLikeWW8)), e.alignTablesRowByRow && this.root.push(new je("w:alignTablesRowByRow", e.alignTablesRowByRow)), e.forgetLastTabAlignment && this.root.push(new je("w:forgetLastTabAlignment", e.forgetLastTabAlignment)), e.adjustLineHeightInTable && this.root.push(new je("w:adjustLineHeightInTable", e.adjustLineHeightInTable)), e.autoSpaceLikeWord95 && this.root.push(new je("w:autoSpaceLikeWord95", e.autoSpaceLikeWord95)), e.noSpaceRaiseLower && this.root.push(new je("w:noSpaceRaiseLower", e.noSpaceRaiseLower)), e.doNotUseHTMLParagraphAutoSpacing && this.root.push(new je("w:doNotUseHTMLParagraphAutoSpacing", e.doNotUseHTMLParagraphAutoSpacing)), e.layoutRawTableWidth && this.root.push(new je("w:layoutRawTableWidth", e.layoutRawTableWidth)), e.layoutTableRowsApart && this.root.push(new je("w:layoutTableRowsApart", e.layoutTableRowsApart)), e.useWord97LineBreakRules && this.root.push(new je("w:useWord97LineBreakRules", e.useWord97LineBreakRules)), e.doNotBreakWrappedTables && this.root.push(new je("w:doNotBreakWrappedTables", e.doNotBreakWrappedTables)), e.doNotSnapToGridInCell && this.root.push(new je("w:doNotSnapToGridInCell", e.doNotSnapToGridInCell)), e.selectFieldWithFirstOrLastCharacter && this.root.push(new je("w:selectFldWithFirstOrLastChar", e.selectFieldWithFirstOrLastCharacter)), e.applyBreakingRules && this.root.push(new je("w:applyBreakingRules", e.applyBreakingRules)), e.doNotWrapTextWithPunctuation && this.root.push(new je("w:doNotWrapTextWithPunct", e.doNotWrapTextWithPunctuation)), e.doNotUseEastAsianBreakRules && this.root.push(new je("w:doNotUseEastAsianBreakRules", e.doNotUseEastAsianBreakRules)), e.useWord2002TableStyleRules && this.root.push(new je("w:useWord2002TableStyleRules", e.useWord2002TableStyleRules)), e.growAutofit && this.root.push(new je("w:growAutofit", e.growAutofit)), e.useFELayout && this.root.push(new je("w:useFELayout", e.useFELayout)), e.useNormalStyleForList && this.root.push(new je("w:useNormalStyleForList", e.useNormalStyleForList)), e.doNotUseIndentAsNumberingTabStop && this.root.push(new je("w:doNotUseIndentAsNumberingTabStop", e.doNotUseIndentAsNumberingTabStop)), e.useAlternateEastAsianLineBreakRules && this.root.push(new je("w:useAltKinsokuLineBreakRules", e.useAlternateEastAsianLineBreakRules)), e.allowSpaceOfSameStyleInTable && this.root.push(new je("w:allowSpaceOfSameStyleInTable", e.allowSpaceOfSameStyleInTable)), e.doNotSuppressIndentation && this.root.push(new je("w:doNotSuppressIndentation", e.doNotSuppressIndentation)), e.doNotAutofitConstrainedTables && this.root.push(new je("w:doNotAutofitConstrainedTables", e.doNotAutofitConstrainedTables)), e.autofitToFirstFixedWidthCell && this.root.push(new je("w:autofitToFirstFixedWidthCell", e.autofitToFirstFixedWidthCell)), e.underlineTabInNumberingList && this.root.push(new je("w:underlineTabInNumList", e.underlineTabInNumberingList)), e.displayHangulFixedWidth && this.root.push(new je("w:displayHangulFixedWidth", e.displayHangulFixedWidth)), e.splitPgBreakAndParaMark && this.root.push(new je("w:splitPgBreakAndParaMark", e.splitPgBreakAndParaMark)), e.doNotVerticallyAlignCellWithSp && this.root.push(new je("w:doNotVertAlignCellWithSp", e.doNotVerticallyAlignCellWithSp)), e.doNotBreakConstrainedForcedTable && this.root.push(new je("w:doNotBreakConstrainedForcedTable", e.doNotBreakConstrainedForcedTable)), e.ignoreVerticalAlignmentInTextboxes && this.root.push(new je("w:doNotVertAlignInTxbx", e.ignoreVerticalAlignmentInTextboxes)), e.useAnsiKerningPairs && this.root.push(new je("w:useAnsiKerningPairs", e.useAnsiKerningPairs)), e.cachedColumnBalance && this.root.push(new je("w:cachedColBalance", e.cachedColumnBalance));
  }
}
class x0e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      wpc: "xmlns:wpc",
      mc: "xmlns:mc",
      o: "xmlns:o",
      r: "xmlns:r",
      m: "xmlns:m",
      v: "xmlns:v",
      wp14: "xmlns:wp14",
      wp: "xmlns:wp",
      w10: "xmlns:w10",
      w: "xmlns:w",
      w14: "xmlns:w14",
      w15: "xmlns:w15",
      wpg: "xmlns:wpg",
      wpi: "xmlns:wpi",
      wne: "xmlns:wne",
      wps: "xmlns:wps",
      Ignorable: "mc:Ignorable"
    });
  }
}
class _0e extends Oe {
  constructor(e) {
    var n, r, i, o;
    super("w:settings"), this.root.push(
      new x0e({
        wpc: "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        o: "urn:schemas-microsoft-com:office:office",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        m: "http://schemas.openxmlformats.org/officeDocument/2006/math",
        v: "urn:schemas-microsoft-com:vml",
        wp14: "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        wp: "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        w10: "urn:schemas-microsoft-com:office:word",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        wpg: "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        wpi: "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        wne: "http://schemas.microsoft.com/office/word/2006/wordml",
        wps: "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        Ignorable: "w14 w15 wp14"
      })
    ), this.root.push(new je("w:displayBackgroundShape", !0)), e.trackRevisions !== void 0 && this.root.push(new je("w:trackRevisions", e.trackRevisions)), e.evenAndOddHeaders !== void 0 && this.root.push(new je("w:evenAndOddHeaders", e.evenAndOddHeaders)), e.updateFields !== void 0 && this.root.push(new je("w:updateFields", e.updateFields)), e.defaultTabStop !== void 0 && this.root.push(new QC("w:defaultTabStop", e.defaultTabStop)), this.root.push(
      new w0e(Il(Dt({}, (n = e.compatibility) != null ? n : {}), {
        version: (o = (i = (r = e.compatibility) == null ? void 0 : r.version) != null ? i : e.compatibilityModeVersion) != null ? o : 15
      }))
    );
  }
}
class KP extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", { val: "w:val" });
  }
}
class S0e extends Oe {
  constructor(e) {
    super("w:name"), this.root.push(new KP({ val: e }));
  }
}
class T0e extends Oe {
  constructor(e) {
    super("w:uiPriority"), this.root.push(new KP({ val: Dr(e) }));
  }
}
class D0e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      type: "w:type",
      styleId: "w:styleId",
      default: "w:default",
      customStyle: "w:customStyle"
    });
  }
}
class XP extends Oe {
  constructor(e, n) {
    super("w:style"), this.root.push(new D0e(e)), n.name && this.root.push(new S0e(n.name)), n.basedOn && this.root.push(new Gc("w:basedOn", n.basedOn)), n.next && this.root.push(new Gc("w:next", n.next)), n.link && this.root.push(new Gc("w:link", n.link)), n.uiPriority !== void 0 && this.root.push(new T0e(n.uiPriority)), n.semiHidden !== void 0 && this.root.push(new je("w:semiHidden", n.semiHidden)), n.unhideWhenUsed !== void 0 && this.root.push(new je("w:unhideWhenUsed", n.unhideWhenUsed)), n.quickFormat !== void 0 && this.root.push(new je("w:qFormat", n.quickFormat));
  }
}
class I0 extends XP {
  constructor(e) {
    super({ type: "paragraph", styleId: e.id }, e), Ue(this, "paragraphProperties"), Ue(this, "runProperties"), this.paragraphProperties = new $f(e.paragraph), this.runProperties = new Su(e.run), this.root.push(this.paragraphProperties), this.root.push(this.runProperties);
  }
}
class O0 extends XP {
  constructor(e) {
    super(
      { type: "character", styleId: e.id },
      Dt({
        uiPriority: 99,
        unhideWhenUsed: !0
      }, e)
    ), Ue(this, "runProperties"), this.runProperties = new Su(e.run), this.root.push(this.runProperties);
  }
}
class jl extends I0 {
  constructor(e) {
    super(Dt({
      basedOn: "Normal",
      next: "Normal",
      quickFormat: !0
    }, e));
  }
}
class E0e extends jl {
  constructor(e) {
    super(Dt({
      id: "Title",
      name: "Title"
    }, e));
  }
}
class C0e extends jl {
  constructor(e) {
    super(Dt({
      id: "Heading1",
      name: "Heading 1"
    }, e));
  }
}
class k0e extends jl {
  constructor(e) {
    super(Dt({
      id: "Heading2",
      name: "Heading 2"
    }, e));
  }
}
class A0e extends jl {
  constructor(e) {
    super(Dt({
      id: "Heading3",
      name: "Heading 3"
    }, e));
  }
}
class R0e extends jl {
  constructor(e) {
    super(Dt({
      id: "Heading4",
      name: "Heading 4"
    }, e));
  }
}
class I0e extends jl {
  constructor(e) {
    super(Dt({
      id: "Heading5",
      name: "Heading 5"
    }, e));
  }
}
class O0e extends jl {
  constructor(e) {
    super(Dt({
      id: "Heading6",
      name: "Heading 6"
    }, e));
  }
}
class F0e extends jl {
  constructor(e) {
    super(Dt({
      id: "Strong",
      name: "Strong"
    }, e));
  }
}
class U0e extends I0 {
  constructor(e) {
    super(Dt({
      id: "ListParagraph",
      name: "List Paragraph",
      basedOn: "Normal",
      quickFormat: !0
    }, e));
  }
}
class N0e extends I0 {
  constructor(e) {
    super(Dt({
      id: "FootnoteText",
      name: "footnote text",
      link: "FootnoteTextChar",
      basedOn: "Normal",
      uiPriority: 99,
      semiHidden: !0,
      unhideWhenUsed: !0,
      paragraph: {
        spacing: {
          after: 0,
          line: 240,
          lineRule: $T.AUTO
        }
      },
      run: {
        size: 20
      }
    }, e));
  }
}
class M0e extends O0 {
  constructor(e) {
    super(Dt({
      id: "FootnoteReference",
      name: "footnote reference",
      basedOn: "DefaultParagraphFont",
      semiHidden: !0,
      run: {
        superScript: !0
      }
    }, e));
  }
}
class B0e extends O0 {
  constructor(e) {
    super(Dt({
      id: "FootnoteTextChar",
      name: "Footnote Text Char",
      basedOn: "DefaultParagraphFont",
      link: "FootnoteText",
      semiHidden: !0,
      run: {
        size: 20
      }
    }, e));
  }
}
class L0e extends O0 {
  constructor(e) {
    super(Dt({
      id: "Hyperlink",
      name: "Hyperlink",
      basedOn: "DefaultParagraphFont",
      run: {
        color: "0563C1",
        underline: {
          type: kP.SINGLE
        }
      }
    }, e));
  }
}
class jT extends Oe {
  constructor(e) {
    if (super("w:styles"), e.initialStyles && this.root.push(e.initialStyles), e.importedStyles)
      for (const n of e.importedStyles)
        this.root.push(n);
    if (e.paragraphStyles)
      for (const n of e.paragraphStyles)
        this.root.push(new I0(n));
    if (e.characterStyles)
      for (const n of e.characterStyles)
        this.root.push(new O0(n));
  }
}
class P0e extends Oe {
  constructor(e) {
    super("w:pPrDefault"), this.root.push(new $f(e));
  }
}
class W0e extends Oe {
  constructor(e) {
    super("w:rPrDefault"), this.root.push(new Su(e));
  }
}
class z0e extends Oe {
  constructor(e) {
    super("w:docDefaults"), Ue(this, "runPropertiesDefaults"), Ue(this, "paragraphPropertiesDefaults"), this.runPropertiesDefaults = new W0e(e.run), this.paragraphPropertiesDefaults = new P0e(e.paragraph), this.root.push(this.runPropertiesDefaults), this.root.push(this.paragraphPropertiesDefaults);
  }
}
class $0e {
  /**
   * Creates new Style based on the given styles.
   * Parses the styles and convert them to XmlComponent.
   * Example content from styles.xml:
   * <?xml version="1.0">
   * <w:styles xmlns:mc="some schema" ...>
   *
   *   <w:style w:type="paragraph" w:styleId="Heading1">
   *           <w:name w:val="heading 1"/>
   *           .....
   *   </w:style>
   *
   *   <w:style w:type="paragraph" w:styleId="Heading2">
   *           <w:name w:val="heading 2"/>
   *           .....
   *   </w:style>
   *
   *   <w:docDefaults>Or any other element will be parsed to</w:docDefaults>
   *
   * </w:styles>
   *
   * @param externalStyles context from styles.xml
   */
  newInstance(e) {
    const n = _P.xml2js(e, { compact: !1 });
    let r;
    for (const a of n.elements || [])
      a.name === "w:styles" && (r = a);
    if (r === void 0)
      throw new Error("can not find styles element");
    const i = r.elements || [];
    return new jT({
      initialStyles: new vye(r.attributes),
      importedStyles: i.map((a) => JC(a))
    });
  }
}
class HO {
  newInstance(e = {}) {
    var n;
    return {
      initialStyles: new tg({
        mc: "http://schemas.openxmlformats.org/markup-compatibility/2006",
        r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        w: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        w14: "http://schemas.microsoft.com/office/word/2010/wordml",
        w15: "http://schemas.microsoft.com/office/word/2012/wordml",
        Ignorable: "w14 w15"
      }),
      importedStyles: [
        new z0e((n = e.document) != null ? n : {}),
        new E0e(Dt({
          run: {
            size: 56
          }
        }, e.title)),
        new C0e(Dt({
          run: {
            color: "2E74B5",
            size: 32
          }
        }, e.heading1)),
        new k0e(Dt({
          run: {
            color: "2E74B5",
            size: 26
          }
        }, e.heading2)),
        new A0e(Dt({
          run: {
            color: "1F4D78",
            size: 24
          }
        }, e.heading3)),
        new R0e(Dt({
          run: {
            color: "2E74B5",
            italics: !0
          }
        }, e.heading4)),
        new I0e(Dt({
          run: {
            color: "2E74B5"
          }
        }, e.heading5)),
        new O0e(Dt({
          run: {
            color: "1F4D78"
          }
        }, e.heading6)),
        new F0e(Dt({
          run: {
            bold: !0
          }
        }, e.strong)),
        new U0e(e.listParagraph || {}),
        new L0e(e.hyperlink || {}),
        new M0e(e.footnoteReference || {}),
        new N0e(e.footnoteText || {}),
        new B0e(e.footnoteTextChar || {})
      ]
    };
  }
}
const Iy = ({ id: t, fontKey: e, subsetted: n }, r) => new Fn({
  name: r,
  attributes: Dt({
    id: { key: "r:id", value: t }
  }, e ? { fontKey: { key: "w:fontKey", value: `{${e}}` } } : {}),
  children: [...n ? [new je("w:subsetted", n)] : []]
}), H0e = ({
  name: t,
  altName: e,
  panose1: n,
  charset: r,
  family: i,
  notTrueType: o,
  pitch: a,
  sig: s,
  embedRegular: l,
  embedBold: c,
  embedItalic: u,
  embedBoldItalic: d
}) => (
  // http://www.datypic.com/sc/ooxml/e-w_font-1.html
  new Fn({
    name: "w:font",
    attributes: {
      name: { key: "w:name", value: t }
    },
    children: [
      // http://www.datypic.com/sc/ooxml/e-w_altName-1.html
      ...e ? [gp("w:altName", e)] : [],
      // http://www.datypic.com/sc/ooxml/e-w_panose1-1.html
      ...n ? [gp("w:panose1", n)] : [],
      // http://www.datypic.com/sc/ooxml/e-w_charset-1.html
      ...r ? [gp("w:charset", r)] : [],
      // http://www.datypic.com/sc/ooxml/e-w_family-1.html
      ...i ? [gp("w:family", i)] : [],
      // http://www.datypic.com/sc/ooxml/e-w_notTrueType-1.html
      ...o ? [new je("w:notTrueType", o)] : [],
      ...a ? [gp("w:pitch", a)] : [],
      // http://www.datypic.com/sc/ooxml/e-w_sig-1.html
      ...s ? [
        new Fn({
          name: "w:sig",
          attributes: {
            usb0: { key: "w:usb0", value: s.usb0 },
            usb1: { key: "w:usb1", value: s.usb1 },
            usb2: { key: "w:usb2", value: s.usb2 },
            usb3: { key: "w:usb3", value: s.usb3 },
            csb0: { key: "w:csb0", value: s.csb0 },
            csb1: { key: "w:csb1", value: s.csb1 }
          }
        })
      ] : [],
      // http://www.datypic.com/sc/ooxml/e-w_embedRegular-1.html
      ...l ? [Iy(l, "w:embedRegular")] : [],
      // http://www.datypic.com/sc/ooxml/e-w_embedBold-1.html
      ...c ? [Iy(c, "w:embedBold")] : [],
      // http://www.datypic.com/sc/ooxml/e-w_embedItalic-1.html
      ...u ? [Iy(u, "w:embedItalic")] : [],
      // http://www.datypic.com/sc/ooxml/e-w_embedBoldItalic-1.html
      ...d ? [Iy(d, "w:embedBoldItalic")] : []
    ]
  })
), j0e = ({
  name: t,
  index: e,
  fontKey: n,
  characterSet: r
}) => H0e({
  name: t,
  sig: {
    usb0: "E0002AFF",
    usb1: "C000247B",
    usb2: "00000009",
    usb3: "00000000",
    csb0: "000001FF",
    csb1: "00000000"
  },
  charset: r,
  family: "auto",
  pitch: "variable",
  embedRegular: {
    fontKey: n,
    id: `rId${e}`
  }
}), V0e = (t) => (
  // https://c-rex.net/projects/samples/ooxml/e1/Part4/OOXML_P4_DOCX_Font_topic_ID0ERNCU.html
  // http://www.datypic.com/sc/ooxml/e-w_fonts.html
  new Fn({
    name: "w:fonts",
    attributes: {
      mc: { key: "xmlns:mc", value: "http://schemas.openxmlformats.org/markup-compatibility/2006" },
      r: { key: "xmlns:r", value: "http://schemas.openxmlformats.org/officeDocument/2006/relationships" },
      w: { key: "xmlns:w", value: "http://schemas.openxmlformats.org/wordprocessingml/2006/main" },
      w14: { key: "xmlns:w14", value: "http://schemas.microsoft.com/office/word/2010/wordml" },
      w15: { key: "xmlns:w15", value: "http://schemas.microsoft.com/office/word/2012/wordml" },
      w16cex: { key: "xmlns:w16cex", value: "http://schemas.microsoft.com/office/word/2018/wordml/cex" },
      w16cid: { key: "xmlns:w16cid", value: "http://schemas.microsoft.com/office/word/2016/wordml/cid" },
      w16: { key: "xmlns:w16", value: "http://schemas.microsoft.com/office/word/2018/wordml" },
      w16sdtdh: { key: "xmlns:w16sdtdh", value: "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" },
      w16se: { key: "xmlns:w16se", value: "http://schemas.microsoft.com/office/word/2015/wordml/symex" },
      Ignorable: { key: "mc:Ignorable", value: "w14 w15 w16se w16cid w16 w16cex w16sdtdh" }
    },
    children: t.map(
      (e, n) => j0e({
        name: e.name,
        index: n + 1,
        fontKey: e.fontKey
      })
    )
  })
);
class q0e {
  constructor(e) {
    Ue(this, "fontTable"), Ue(this, "relationships"), Ue(this, "fontOptionsWithKey", []), this.options = e, this.fontOptionsWithKey = e.map((n) => Il(Dt({}, n), { fontKey: obe() })), this.fontTable = V0e(this.fontOptionsWithKey), this.relationships = new ch();
    for (let n = 0; n < e.length; n++)
      this.relationships.createRelationship(
        n + 1,
        "http://schemas.openxmlformats.org/officeDocument/2006/relationships/font",
        `fonts/${e[n].name}.odttf`
      );
  }
  get View() {
    return this.fontTable;
  }
  get Relationships() {
    return this.relationships;
  }
}
let G0e = class {
  constructor(e) {
    Ue(this, "currentRelationshipId", 1), Ue(this, "documentWrapper"), Ue(this, "headers", []), Ue(this, "footers", []), Ue(this, "coreProperties"), Ue(this, "numbering"), Ue(this, "media"), Ue(this, "fileRelationships"), Ue(this, "footnotesWrapper"), Ue(this, "settings"), Ue(this, "contentTypes"), Ue(this, "customProperties"), Ue(this, "appProperties"), Ue(this, "styles"), Ue(this, "comments"), Ue(this, "fontWrapper");
    var n, r, i, o, a, s, l, c;
    if (this.coreProperties = new O1e(Il(Dt({}, e), {
      creator: (n = e.creator) != null ? n : "Un-named",
      revision: (r = e.revision) != null ? r : 1,
      lastModifiedBy: (i = e.lastModifiedBy) != null ? i : "Un-named"
    })), this.numbering = new y0e(e.numbering ? e.numbering : { config: [] }), this.comments = new yve((o = e.comments) != null ? o : { children: [] }), this.fileRelationships = new ch(), this.customProperties = new B1e((a = e.customProperties) != null ? a : []), this.appProperties = new C1e(), this.footnotesWrapper = new Y1e(), this.contentTypes = new I1e(), this.documentWrapper = new HP({ background: e.background }), this.settings = new _0e({
      compatibilityModeVersion: e.compatabilityModeVersion,
      compatibility: e.compatibility,
      evenAndOddHeaders: !!e.evenAndOddHeaderAndFooters,
      trackRevisions: (s = e.features) == null ? void 0 : s.trackRevisions,
      updateFields: (l = e.features) == null ? void 0 : l.updateFields,
      defaultTabStop: e.defaultTabStop
    }), this.media = new e0e(), e.externalStyles !== void 0) {
      const u = new $0e();
      this.styles = u.newInstance(e.externalStyles);
    } else if (e.styles) {
      const d = new HO().newInstance(e.styles.default);
      this.styles = new jT(Dt(Dt({}, d), e.styles));
    } else {
      const u = new HO();
      this.styles = new jT(u.newInstance());
    }
    this.addDefaultRelationships();
    for (const u of e.sections)
      this.addSection(u);
    if (e.footnotes)
      for (const u in e.footnotes)
        this.footnotesWrapper.View.createFootNote(parseFloat(u), e.footnotes[u].children);
    this.fontWrapper = new q0e((c = e.fonts) != null ? c : []);
  }
  addSection({ headers: e = {}, footers: n = {}, children: r, properties: i }) {
    this.documentWrapper.View.Body.addSection(Il(Dt({}, i), {
      headerWrapperGroup: {
        default: e.default ? this.createHeader(e.default) : void 0,
        first: e.first ? this.createHeader(e.first) : void 0,
        even: e.even ? this.createHeader(e.even) : void 0
      },
      footerWrapperGroup: {
        default: n.default ? this.createFooter(n.default) : void 0,
        first: n.first ? this.createFooter(n.first) : void 0,
        even: n.even ? this.createFooter(n.even) : void 0
      }
    }));
    for (const o of r)
      this.documentWrapper.View.add(o);
  }
  createHeader(e) {
    const n = new Q1e(this.media, this.currentRelationshipId++);
    for (const r of e.options.children)
      n.add(r);
    return this.addHeaderToDocument(n), n;
  }
  createFooter(e) {
    const n = new W1e(this.media, this.currentRelationshipId++);
    for (const r of e.options.children)
      n.add(r);
    return this.addFooterToDocument(n), n;
  }
  addHeaderToDocument(e, n = mf.DEFAULT) {
    this.headers.push({ header: e, type: n }), this.documentWrapper.Relationships.createRelationship(
      e.View.ReferenceId,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header",
      `header${this.headers.length}.xml`
    ), this.contentTypes.addHeader(this.headers.length);
  }
  addFooterToDocument(e, n = mf.DEFAULT) {
    this.footers.push({ footer: e, type: n }), this.documentWrapper.Relationships.createRelationship(
      e.View.ReferenceId,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer",
      `footer${this.footers.length}.xml`
    ), this.contentTypes.addFooter(this.footers.length);
  }
  addDefaultRelationships() {
    this.fileRelationships.createRelationship(
      1,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
      "word/document.xml"
    ), this.fileRelationships.createRelationship(
      2,
      "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
      "docProps/core.xml"
    ), this.fileRelationships.createRelationship(
      3,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
      "docProps/app.xml"
    ), this.fileRelationships.createRelationship(
      4,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
      "docProps/custom.xml"
    ), this.documentWrapper.Relationships.createRelationship(
      // eslint-disable-next-line functional/immutable-data
      this.currentRelationshipId++,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
      "styles.xml"
    ), this.documentWrapper.Relationships.createRelationship(
      // eslint-disable-next-line functional/immutable-data
      this.currentRelationshipId++,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering",
      "numbering.xml"
    ), this.documentWrapper.Relationships.createRelationship(
      // eslint-disable-next-line functional/immutable-data
      this.currentRelationshipId++,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes",
      "footnotes.xml"
    ), this.documentWrapper.Relationships.createRelationship(
      // eslint-disable-next-line functional/immutable-data
      this.currentRelationshipId++,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings",
      "settings.xml"
    ), this.documentWrapper.Relationships.createRelationship(
      // eslint-disable-next-line functional/immutable-data
      this.currentRelationshipId++,
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
      "comments.xml"
    );
  }
  get Document() {
    return this.documentWrapper;
  }
  get Styles() {
    return this.styles;
  }
  get CoreProperties() {
    return this.coreProperties;
  }
  get Numbering() {
    return this.numbering;
  }
  get Media() {
    return this.media;
  }
  get FileRelationships() {
    return this.fileRelationships;
  }
  get Headers() {
    return this.headers.map((e) => e.header);
  }
  get Footers() {
    return this.footers.map((e) => e.footer);
  }
  get ContentTypes() {
    return this.contentTypes;
  }
  get CustomProperties() {
    return this.customProperties;
  }
  get AppProperties() {
    return this.appProperties;
  }
  get FootNotes() {
    return this.footnotesWrapper;
  }
  get Settings() {
    return this.settings;
  }
  get Comments() {
    return this.comments;
  }
  get FontTable() {
    return this.fontWrapper;
  }
};
class K0e extends Ye {
  constructor() {
    super(...arguments), Ue(this, "xmlKeys", {
      id: "w:id"
    });
  }
}
class X0e extends Oe {
  constructor(e) {
    super("w:footnoteReference"), this.root.push(
      new K0e({
        id: e
      })
    );
  }
}
class Y0e extends Tu {
  constructor(e) {
    super({ style: "FootnoteReference" }), this.root.push(new X0e(e));
  }
}
function Oy(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var YP = { exports: {} };
(function(t, e) {
  (function(n) {
    t.exports = n();
  })(function() {
    return function n(r, i, o) {
      function a(c, u) {
        if (!i[c]) {
          if (!r[c]) {
            var d = typeof Oy == "function" && Oy;
            if (!u && d)
              return d(c, !0);
            if (s)
              return s(c, !0);
            var f = new Error("Cannot find module '" + c + "'");
            throw f.code = "MODULE_NOT_FOUND", f;
          }
          var p = i[c] = { exports: {} };
          r[c][0].call(p.exports, function(m) {
            var g = r[c][1][m];
            return a(g || m);
          }, p, p.exports, n, r, i, o);
        }
        return i[c].exports;
      }
      for (var s = typeof Oy == "function" && Oy, l = 0; l < o.length; l++)
        a(o[l]);
      return a;
    }({ 1: [function(n, r, i) {
      var o = n("./utils"), a = n("./support"), s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      i.encode = function(l) {
        for (var c, u, d, f, p, m, g, b = [], y = 0, w = l.length, x = w, k = o.getTypeOf(l) !== "string"; y < l.length; )
          x = w - y, d = k ? (c = l[y++], u = y < w ? l[y++] : 0, y < w ? l[y++] : 0) : (c = l.charCodeAt(y++), u = y < w ? l.charCodeAt(y++) : 0, y < w ? l.charCodeAt(y++) : 0), f = c >> 2, p = (3 & c) << 4 | u >> 4, m = 1 < x ? (15 & u) << 2 | d >> 6 : 64, g = 2 < x ? 63 & d : 64, b.push(s.charAt(f) + s.charAt(p) + s.charAt(m) + s.charAt(g));
        return b.join("");
      }, i.decode = function(l) {
        var c, u, d, f, p, m, g = 0, b = 0, y = "data:";
        if (l.substr(0, y.length) === y)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var w, x = 3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (l.charAt(l.length - 1) === s.charAt(64) && x--, l.charAt(l.length - 2) === s.charAt(64) && x--, x % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (w = a.uint8array ? new Uint8Array(0 | x) : new Array(0 | x); g < l.length; )
          c = s.indexOf(l.charAt(g++)) << 2 | (f = s.indexOf(l.charAt(g++))) >> 4, u = (15 & f) << 4 | (p = s.indexOf(l.charAt(g++))) >> 2, d = (3 & p) << 6 | (m = s.indexOf(l.charAt(g++))), w[b++] = c, p !== 64 && (w[b++] = u), m !== 64 && (w[b++] = d);
        return w;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(n, r, i) {
      var o = n("./external"), a = n("./stream/DataWorker"), s = n("./stream/Crc32Probe"), l = n("./stream/DataLengthProbe");
      function c(u, d, f, p, m) {
        this.compressedSize = u, this.uncompressedSize = d, this.crc32 = f, this.compression = p, this.compressedContent = m;
      }
      c.prototype = { getContentWorker: function() {
        var u = new a(o.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), d = this;
        return u.on("end", function() {
          if (this.streamInfo.data_length !== d.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), u;
      }, getCompressedWorker: function() {
        return new a(o.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, c.createWorkerFrom = function(u, d, f) {
        return u.pipe(new s()).pipe(new l("uncompressedSize")).pipe(d.compressWorker(f)).pipe(new l("compressedSize")).withStreamInfo("compression", d);
      }, r.exports = c;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(n, r, i) {
      var o = n("./stream/GenericWorker");
      i.STORE = { magic: "\0\0", compressWorker: function() {
        return new o("STORE compression");
      }, uncompressWorker: function() {
        return new o("STORE decompression");
      } }, i.DEFLATE = n("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(n, r, i) {
      var o = n("./utils"), a = function() {
        for (var s, l = [], c = 0; c < 256; c++) {
          s = c;
          for (var u = 0; u < 8; u++)
            s = 1 & s ? 3988292384 ^ s >>> 1 : s >>> 1;
          l[c] = s;
        }
        return l;
      }();
      r.exports = function(s, l) {
        return s !== void 0 && s.length ? o.getTypeOf(s) !== "string" ? function(c, u, d, f) {
          var p = a, m = f + d;
          c ^= -1;
          for (var g = f; g < m; g++)
            c = c >>> 8 ^ p[255 & (c ^ u[g])];
          return -1 ^ c;
        }(0 | l, s, s.length, 0) : function(c, u, d, f) {
          var p = a, m = f + d;
          c ^= -1;
          for (var g = f; g < m; g++)
            c = c >>> 8 ^ p[255 & (c ^ u.charCodeAt(g))];
          return -1 ^ c;
        }(0 | l, s, s.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(n, r, i) {
      i.base64 = !1, i.binary = !1, i.dir = !1, i.createFolders = !0, i.date = null, i.compression = null, i.compressionOptions = null, i.comment = null, i.unixPermissions = null, i.dosPermissions = null;
    }, {}], 6: [function(n, r, i) {
      var o = null;
      o = typeof Promise < "u" ? Promise : n("lie"), r.exports = { Promise: o };
    }, { lie: 37 }], 7: [function(n, r, i) {
      var o = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", a = n("pako"), s = n("./utils"), l = n("./stream/GenericWorker"), c = o ? "uint8array" : "array";
      function u(d, f) {
        l.call(this, "FlateWorker/" + d), this._pako = null, this._pakoAction = d, this._pakoOptions = f, this.meta = {};
      }
      i.magic = "\b\0", s.inherits(u, l), u.prototype.processChunk = function(d) {
        this.meta = d.meta, this._pako === null && this._createPako(), this._pako.push(s.transformTo(c, d.data), !1);
      }, u.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, u.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, u.prototype._createPako = function() {
        this._pako = new a[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var d = this;
        this._pako.onData = function(f) {
          d.push({ data: f, meta: d.meta });
        };
      }, i.compressWorker = function(d) {
        return new u("Deflate", d);
      }, i.uncompressWorker = function() {
        return new u("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(n, r, i) {
      function o(p, m) {
        var g, b = "";
        for (g = 0; g < m; g++)
          b += String.fromCharCode(255 & p), p >>>= 8;
        return b;
      }
      function a(p, m, g, b, y, w) {
        var x, k, A = p.file, U = p.compression, P = w !== c.utf8encode, V = s.transformTo("string", w(A.name)), I = s.transformTo("string", c.utf8encode(A.name)), le = A.comment, be = s.transformTo("string", w(le)), F = s.transformTo("string", c.utf8encode(le)), G = I.length !== A.name.length, C = F.length !== le.length, ie = "", ee = "", Z = "", oe = A.dir, te = A.date, _e = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        m && !g || (_e.crc32 = p.crc32, _e.compressedSize = p.compressedSize, _e.uncompressedSize = p.uncompressedSize);
        var q = 0;
        m && (q |= 8), P || !G && !C || (q |= 2048);
        var N = 0, ce = 0;
        oe && (N |= 16), y === "UNIX" ? (ce = 798, N |= function(ve, he) {
          var H = ve;
          return ve || (H = he ? 16893 : 33204), (65535 & H) << 16;
        }(A.unixPermissions, oe)) : (ce = 20, N |= function(ve) {
          return 63 & (ve || 0);
        }(A.dosPermissions)), x = te.getUTCHours(), x <<= 6, x |= te.getUTCMinutes(), x <<= 5, x |= te.getUTCSeconds() / 2, k = te.getUTCFullYear() - 1980, k <<= 4, k |= te.getUTCMonth() + 1, k <<= 5, k |= te.getUTCDate(), G && (ee = o(1, 1) + o(u(V), 4) + I, ie += "up" + o(ee.length, 2) + ee), C && (Z = o(1, 1) + o(u(be), 4) + F, ie += "uc" + o(Z.length, 2) + Z);
        var me = "";
        return me += `
\0`, me += o(q, 2), me += U.magic, me += o(x, 2), me += o(k, 2), me += o(_e.crc32, 4), me += o(_e.compressedSize, 4), me += o(_e.uncompressedSize, 4), me += o(V.length, 2), me += o(ie.length, 2), { fileRecord: d.LOCAL_FILE_HEADER + me + V + ie, dirRecord: d.CENTRAL_FILE_HEADER + o(ce, 2) + me + o(be.length, 2) + "\0\0\0\0" + o(N, 4) + o(b, 4) + V + ie + be };
      }
      var s = n("../utils"), l = n("../stream/GenericWorker"), c = n("../utf8"), u = n("../crc32"), d = n("../signature");
      function f(p, m, g, b) {
        l.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = m, this.zipPlatform = g, this.encodeFileName = b, this.streamFiles = p, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      s.inherits(f, l), f.prototype.push = function(p) {
        var m = p.meta.percent || 0, g = this.entriesCount, b = this._sources.length;
        this.accumulate ? this.contentBuffer.push(p) : (this.bytesWritten += p.data.length, l.prototype.push.call(this, { data: p.data, meta: { currentFile: this.currentFile, percent: g ? (m + 100 * (g - b - 1)) / g : 100 } }));
      }, f.prototype.openedSource = function(p) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = p.file.name;
        var m = this.streamFiles && !p.file.dir;
        if (m) {
          var g = a(p, m, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: g.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = !0;
      }, f.prototype.closedSource = function(p) {
        this.accumulate = !1;
        var m = this.streamFiles && !p.file.dir, g = a(p, m, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(g.dirRecord), m)
          this.push({ data: function(b) {
            return d.DATA_DESCRIPTOR + o(b.crc32, 4) + o(b.compressedSize, 4) + o(b.uncompressedSize, 4);
          }(p), meta: { percent: 100 } });
        else
          for (this.push({ data: g.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, f.prototype.flush = function() {
        for (var p = this.bytesWritten, m = 0; m < this.dirRecords.length; m++)
          this.push({ data: this.dirRecords[m], meta: { percent: 100 } });
        var g = this.bytesWritten - p, b = function(y, w, x, k, A) {
          var U = s.transformTo("string", A(k));
          return d.CENTRAL_DIRECTORY_END + "\0\0\0\0" + o(y, 2) + o(y, 2) + o(w, 4) + o(x, 4) + o(U.length, 2) + U;
        }(this.dirRecords.length, g, p, this.zipComment, this.encodeFileName);
        this.push({ data: b, meta: { percent: 100 } });
      }, f.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, f.prototype.registerPrevious = function(p) {
        this._sources.push(p);
        var m = this;
        return p.on("data", function(g) {
          m.processChunk(g);
        }), p.on("end", function() {
          m.closedSource(m.previous.streamInfo), m._sources.length ? m.prepareNextSource() : m.end();
        }), p.on("error", function(g) {
          m.error(g);
        }), this;
      }, f.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, f.prototype.error = function(p) {
        var m = this._sources;
        if (!l.prototype.error.call(this, p))
          return !1;
        for (var g = 0; g < m.length; g++)
          try {
            m[g].error(p);
          } catch {
          }
        return !0;
      }, f.prototype.lock = function() {
        l.prototype.lock.call(this);
        for (var p = this._sources, m = 0; m < p.length; m++)
          p[m].lock();
      }, r.exports = f;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(n, r, i) {
      var o = n("../compressions"), a = n("./ZipFileWorker");
      i.generateWorker = function(s, l, c) {
        var u = new a(l.streamFiles, c, l.platform, l.encodeFileName), d = 0;
        try {
          s.forEach(function(f, p) {
            d++;
            var m = function(w, x) {
              var k = w || x, A = o[k];
              if (!A)
                throw new Error(k + " is not a valid compression method !");
              return A;
            }(p.options.compression, l.compression), g = p.options.compressionOptions || l.compressionOptions || {}, b = p.dir, y = p.date;
            p._compressWorker(m, g).withStreamInfo("file", { name: f, dir: b, date: y, comment: p.comment || "", unixPermissions: p.unixPermissions, dosPermissions: p.dosPermissions }).pipe(u);
          }), u.entriesCount = d;
        } catch (f) {
          u.error(f);
        }
        return u;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(n, r, i) {
      function o() {
        if (!(this instanceof o))
          return new o();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var a = new o();
          for (var s in this)
            typeof this[s] != "function" && (a[s] = this[s]);
          return a;
        };
      }
      (o.prototype = n("./object")).loadAsync = n("./load"), o.support = n("./support"), o.defaults = n("./defaults"), o.version = "3.10.1", o.loadAsync = function(a, s) {
        return new o().loadAsync(a, s);
      }, o.external = n("./external"), r.exports = o;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(n, r, i) {
      var o = n("./utils"), a = n("./external"), s = n("./utf8"), l = n("./zipEntries"), c = n("./stream/Crc32Probe"), u = n("./nodejsUtils");
      function d(f) {
        return new a.Promise(function(p, m) {
          var g = f.decompressed.getContentWorker().pipe(new c());
          g.on("error", function(b) {
            m(b);
          }).on("end", function() {
            g.streamInfo.crc32 !== f.decompressed.crc32 ? m(new Error("Corrupted zip : CRC32 mismatch")) : p();
          }).resume();
        });
      }
      r.exports = function(f, p) {
        var m = this;
        return p = o.extend(p || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: s.utf8decode }), u.isNode && u.isStream(f) ? a.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : o.prepareContent("the loaded zip file", f, !0, p.optimizedBinaryString, p.base64).then(function(g) {
          var b = new l(p);
          return b.load(g), b;
        }).then(function(g) {
          var b = [a.Promise.resolve(g)], y = g.files;
          if (p.checkCRC32)
            for (var w = 0; w < y.length; w++)
              b.push(d(y[w]));
          return a.Promise.all(b);
        }).then(function(g) {
          for (var b = g.shift(), y = b.files, w = 0; w < y.length; w++) {
            var x = y[w], k = x.fileNameStr, A = o.resolve(x.fileNameStr);
            m.file(A, x.decompressed, { binary: !0, optimizedBinaryString: !0, date: x.date, dir: x.dir, comment: x.fileCommentStr.length ? x.fileCommentStr : null, unixPermissions: x.unixPermissions, dosPermissions: x.dosPermissions, createFolders: p.createFolders }), x.dir || (m.file(A).unsafeOriginalName = k);
          }
          return b.zipComment.length && (m.comment = b.zipComment), m;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(n, r, i) {
      var o = n("../utils"), a = n("../stream/GenericWorker");
      function s(l, c) {
        a.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(c);
      }
      o.inherits(s, a), s.prototype._bindStream = function(l) {
        var c = this;
        (this._stream = l).pause(), l.on("data", function(u) {
          c.push({ data: u, meta: { percent: 0 } });
        }).on("error", function(u) {
          c.isPaused ? this.generatedError = u : c.error(u);
        }).on("end", function() {
          c.isPaused ? c._upstreamEnded = !0 : c.end();
        });
      }, s.prototype.pause = function() {
        return !!a.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, s.prototype.resume = function() {
        return !!a.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, r.exports = s;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(n, r, i) {
      var o = n("readable-stream").Readable;
      function a(s, l, c) {
        o.call(this, l), this._helper = s;
        var u = this;
        s.on("data", function(d, f) {
          u.push(d) || u._helper.pause(), c && c(f);
        }).on("error", function(d) {
          u.emit("error", d);
        }).on("end", function() {
          u.push(null);
        });
      }
      n("../utils").inherits(a, o), a.prototype._read = function() {
        this._helper.resume();
      }, r.exports = a;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(n, r, i) {
      r.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(o, a) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(o, a);
        if (typeof o == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(o, a);
      }, allocBuffer: function(o) {
        if (Buffer.alloc)
          return Buffer.alloc(o);
        var a = new Buffer(o);
        return a.fill(0), a;
      }, isBuffer: function(o) {
        return Buffer.isBuffer(o);
      }, isStream: function(o) {
        return o && typeof o.on == "function" && typeof o.pause == "function" && typeof o.resume == "function";
      } };
    }, {}], 15: [function(n, r, i) {
      function o(A, U, P) {
        var V, I = s.getTypeOf(U), le = s.extend(P || {}, u);
        le.date = le.date || /* @__PURE__ */ new Date(), le.compression !== null && (le.compression = le.compression.toUpperCase()), typeof le.unixPermissions == "string" && (le.unixPermissions = parseInt(le.unixPermissions, 8)), le.unixPermissions && 16384 & le.unixPermissions && (le.dir = !0), le.dosPermissions && 16 & le.dosPermissions && (le.dir = !0), le.dir && (A = y(A)), le.createFolders && (V = b(A)) && w.call(this, V, !0);
        var be = I === "string" && le.binary === !1 && le.base64 === !1;
        P && P.binary !== void 0 || (le.binary = !be), (U instanceof d && U.uncompressedSize === 0 || le.dir || !U || U.length === 0) && (le.base64 = !1, le.binary = !0, U = "", le.compression = "STORE", I = "string");
        var F = null;
        F = U instanceof d || U instanceof l ? U : m.isNode && m.isStream(U) ? new g(A, U) : s.prepareContent(A, U, le.binary, le.optimizedBinaryString, le.base64);
        var G = new f(A, F, le);
        this.files[A] = G;
      }
      var a = n("./utf8"), s = n("./utils"), l = n("./stream/GenericWorker"), c = n("./stream/StreamHelper"), u = n("./defaults"), d = n("./compressedObject"), f = n("./zipObject"), p = n("./generate"), m = n("./nodejsUtils"), g = n("./nodejs/NodejsStreamInputAdapter"), b = function(A) {
        A.slice(-1) === "/" && (A = A.substring(0, A.length - 1));
        var U = A.lastIndexOf("/");
        return 0 < U ? A.substring(0, U) : "";
      }, y = function(A) {
        return A.slice(-1) !== "/" && (A += "/"), A;
      }, w = function(A, U) {
        return U = U !== void 0 ? U : u.createFolders, A = y(A), this.files[A] || o.call(this, A, null, { dir: !0, createFolders: U }), this.files[A];
      };
      function x(A) {
        return Object.prototype.toString.call(A) === "[object RegExp]";
      }
      var k = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(A) {
        var U, P, V;
        for (U in this.files)
          V = this.files[U], (P = U.slice(this.root.length, U.length)) && U.slice(0, this.root.length) === this.root && A(P, V);
      }, filter: function(A) {
        var U = [];
        return this.forEach(function(P, V) {
          A(P, V) && U.push(V);
        }), U;
      }, file: function(A, U, P) {
        if (arguments.length !== 1)
          return A = this.root + A, o.call(this, A, U, P), this;
        if (x(A)) {
          var V = A;
          return this.filter(function(le, be) {
            return !be.dir && V.test(le);
          });
        }
        var I = this.files[this.root + A];
        return I && !I.dir ? I : null;
      }, folder: function(A) {
        if (!A)
          return this;
        if (x(A))
          return this.filter(function(I, le) {
            return le.dir && A.test(I);
          });
        var U = this.root + A, P = w.call(this, U), V = this.clone();
        return V.root = P.name, V;
      }, remove: function(A) {
        A = this.root + A;
        var U = this.files[A];
        if (U || (A.slice(-1) !== "/" && (A += "/"), U = this.files[A]), U && !U.dir)
          delete this.files[A];
        else
          for (var P = this.filter(function(I, le) {
            return le.name.slice(0, A.length) === A;
          }), V = 0; V < P.length; V++)
            delete this.files[P[V].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(A) {
        var U, P = {};
        try {
          if ((P = s.extend(A || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: a.utf8encode })).type = P.type.toLowerCase(), P.compression = P.compression.toUpperCase(), P.type === "binarystring" && (P.type = "string"), !P.type)
            throw new Error("No output type specified.");
          s.checkSupport(P.type), P.platform !== "darwin" && P.platform !== "freebsd" && P.platform !== "linux" && P.platform !== "sunos" || (P.platform = "UNIX"), P.platform === "win32" && (P.platform = "DOS");
          var V = P.comment || this.comment || "";
          U = p.generateWorker(this, P, V);
        } catch (I) {
          (U = new l("error")).error(I);
        }
        return new c(U, P.type || "string", P.mimeType);
      }, generateAsync: function(A, U) {
        return this.generateInternalStream(A).accumulate(U);
      }, generateNodeStream: function(A, U) {
        return (A = A || {}).type || (A.type = "nodebuffer"), this.generateInternalStream(A).toNodejsStream(U);
      } };
      r.exports = k;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(n, r, i) {
      r.exports = n("stream");
    }, { stream: void 0 }], 17: [function(n, r, i) {
      var o = n("./DataReader");
      function a(s) {
        o.call(this, s);
        for (var l = 0; l < this.data.length; l++)
          s[l] = 255 & s[l];
      }
      n("../utils").inherits(a, o), a.prototype.byteAt = function(s) {
        return this.data[this.zero + s];
      }, a.prototype.lastIndexOfSignature = function(s) {
        for (var l = s.charCodeAt(0), c = s.charCodeAt(1), u = s.charCodeAt(2), d = s.charCodeAt(3), f = this.length - 4; 0 <= f; --f)
          if (this.data[f] === l && this.data[f + 1] === c && this.data[f + 2] === u && this.data[f + 3] === d)
            return f - this.zero;
        return -1;
      }, a.prototype.readAndCheckSignature = function(s) {
        var l = s.charCodeAt(0), c = s.charCodeAt(1), u = s.charCodeAt(2), d = s.charCodeAt(3), f = this.readData(4);
        return l === f[0] && c === f[1] && u === f[2] && d === f[3];
      }, a.prototype.readData = function(s) {
        if (this.checkOffset(s), s === 0)
          return [];
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + s);
        return this.index += s, l;
      }, r.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(n, r, i) {
      var o = n("../utils");
      function a(s) {
        this.data = s, this.length = s.length, this.index = 0, this.zero = 0;
      }
      a.prototype = { checkOffset: function(s) {
        this.checkIndex(this.index + s);
      }, checkIndex: function(s) {
        if (this.length < this.zero + s || s < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + s + "). Corrupted zip ?");
      }, setIndex: function(s) {
        this.checkIndex(s), this.index = s;
      }, skip: function(s) {
        this.setIndex(this.index + s);
      }, byteAt: function() {
      }, readInt: function(s) {
        var l, c = 0;
        for (this.checkOffset(s), l = this.index + s - 1; l >= this.index; l--)
          c = (c << 8) + this.byteAt(l);
        return this.index += s, c;
      }, readString: function(s) {
        return o.transformTo("string", this.readData(s));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var s = this.readInt(4);
        return new Date(Date.UTC(1980 + (s >> 25 & 127), (s >> 21 & 15) - 1, s >> 16 & 31, s >> 11 & 31, s >> 5 & 63, (31 & s) << 1));
      } }, r.exports = a;
    }, { "../utils": 32 }], 19: [function(n, r, i) {
      var o = n("./Uint8ArrayReader");
      function a(s) {
        o.call(this, s);
      }
      n("../utils").inherits(a, o), a.prototype.readData = function(s) {
        this.checkOffset(s);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + s);
        return this.index += s, l;
      }, r.exports = a;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(n, r, i) {
      var o = n("./DataReader");
      function a(s) {
        o.call(this, s);
      }
      n("../utils").inherits(a, o), a.prototype.byteAt = function(s) {
        return this.data.charCodeAt(this.zero + s);
      }, a.prototype.lastIndexOfSignature = function(s) {
        return this.data.lastIndexOf(s) - this.zero;
      }, a.prototype.readAndCheckSignature = function(s) {
        return s === this.readData(4);
      }, a.prototype.readData = function(s) {
        this.checkOffset(s);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + s);
        return this.index += s, l;
      }, r.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(n, r, i) {
      var o = n("./ArrayReader");
      function a(s) {
        o.call(this, s);
      }
      n("../utils").inherits(a, o), a.prototype.readData = function(s) {
        if (this.checkOffset(s), s === 0)
          return new Uint8Array(0);
        var l = this.data.subarray(this.zero + this.index, this.zero + this.index + s);
        return this.index += s, l;
      }, r.exports = a;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(n, r, i) {
      var o = n("../utils"), a = n("../support"), s = n("./ArrayReader"), l = n("./StringReader"), c = n("./NodeBufferReader"), u = n("./Uint8ArrayReader");
      r.exports = function(d) {
        var f = o.getTypeOf(d);
        return o.checkSupport(f), f !== "string" || a.uint8array ? f === "nodebuffer" ? new c(d) : a.uint8array ? new u(o.transformTo("uint8array", d)) : new s(o.transformTo("array", d)) : new l(d);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(n, r, i) {
      i.LOCAL_FILE_HEADER = "PK", i.CENTRAL_FILE_HEADER = "PK", i.CENTRAL_DIRECTORY_END = "PK", i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", i.ZIP64_CENTRAL_DIRECTORY_END = "PK", i.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(n, r, i) {
      var o = n("./GenericWorker"), a = n("../utils");
      function s(l) {
        o.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      a.inherits(s, o), s.prototype.processChunk = function(l) {
        this.push({ data: a.transformTo(this.destType, l.data), meta: l.meta });
      }, r.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(n, r, i) {
      var o = n("./GenericWorker"), a = n("../crc32");
      function s() {
        o.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      n("../utils").inherits(s, o), s.prototype.processChunk = function(l) {
        this.streamInfo.crc32 = a(l.data, this.streamInfo.crc32 || 0), this.push(l);
      }, r.exports = s;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(n, r, i) {
      var o = n("../utils"), a = n("./GenericWorker");
      function s(l) {
        a.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      o.inherits(s, a), s.prototype.processChunk = function(l) {
        if (l) {
          var c = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = c + l.data.length;
        }
        a.prototype.processChunk.call(this, l);
      }, r.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(n, r, i) {
      var o = n("../utils"), a = n("./GenericWorker");
      function s(l) {
        a.call(this, "DataWorker");
        var c = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, l.then(function(u) {
          c.dataIsReady = !0, c.data = u, c.max = u && u.length || 0, c.type = o.getTypeOf(u), c.isPaused || c._tickAndRepeat();
        }, function(u) {
          c.error(u);
        });
      }
      o.inherits(s, a), s.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this.data = null;
      }, s.prototype.resume = function() {
        return !!a.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, o.delay(this._tickAndRepeat, [], this)), !0);
      }, s.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (o.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, s.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var l = null, c = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            l = this.data.substring(this.index, c);
            break;
          case "uint8array":
            l = this.data.subarray(this.index, c);
            break;
          case "array":
          case "nodebuffer":
            l = this.data.slice(this.index, c);
        }
        return this.index = c, this.push({ data: l, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, r.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(n, r, i) {
      function o(a) {
        this.name = a || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      o.prototype = { push: function(a) {
        this.emit("data", a);
      }, end: function() {
        if (this.isFinished)
          return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (a) {
          this.emit("error", a);
        }
        return !0;
      }, error: function(a) {
        return !this.isFinished && (this.isPaused ? this.generatedError = a : (this.isFinished = !0, this.emit("error", a), this.previous && this.previous.error(a), this.cleanUp()), !0);
      }, on: function(a, s) {
        return this._listeners[a].push(s), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(a, s) {
        if (this._listeners[a])
          for (var l = 0; l < this._listeners[a].length; l++)
            this._listeners[a][l].call(this, s);
      }, pipe: function(a) {
        return a.registerPrevious(this);
      }, registerPrevious: function(a) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = a.streamInfo, this.mergeStreamInfo(), this.previous = a;
        var s = this;
        return a.on("data", function(l) {
          s.processChunk(l);
        }), a.on("end", function() {
          s.end();
        }), a.on("error", function(l) {
          s.error(l);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return !1;
        var a = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), a = !0), this.previous && this.previous.resume(), !a;
      }, flush: function() {
      }, processChunk: function(a) {
        this.push(a);
      }, withStreamInfo: function(a, s) {
        return this.extraStreamInfo[a] = s, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var a in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, a) && (this.streamInfo[a] = this.extraStreamInfo[a]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var a = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + a : a;
      } }, r.exports = o;
    }, {}], 29: [function(n, r, i) {
      var o = n("../utils"), a = n("./ConvertWorker"), s = n("./GenericWorker"), l = n("../base64"), c = n("../support"), u = n("../external"), d = null;
      if (c.nodestream)
        try {
          d = n("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function f(m, g) {
        return new u.Promise(function(b, y) {
          var w = [], x = m._internalType, k = m._outputType, A = m._mimeType;
          m.on("data", function(U, P) {
            w.push(U), g && g(P);
          }).on("error", function(U) {
            w = [], y(U);
          }).on("end", function() {
            try {
              var U = function(P, V, I) {
                switch (P) {
                  case "blob":
                    return o.newBlob(o.transformTo("arraybuffer", V), I);
                  case "base64":
                    return l.encode(V);
                  default:
                    return o.transformTo(P, V);
                }
              }(k, function(P, V) {
                var I, le = 0, be = null, F = 0;
                for (I = 0; I < V.length; I++)
                  F += V[I].length;
                switch (P) {
                  case "string":
                    return V.join("");
                  case "array":
                    return Array.prototype.concat.apply([], V);
                  case "uint8array":
                    for (be = new Uint8Array(F), I = 0; I < V.length; I++)
                      be.set(V[I], le), le += V[I].length;
                    return be;
                  case "nodebuffer":
                    return Buffer.concat(V);
                  default:
                    throw new Error("concat : unsupported type '" + P + "'");
                }
              }(x, w), A);
              b(U);
            } catch (P) {
              y(P);
            }
            w = [];
          }).resume();
        });
      }
      function p(m, g, b) {
        var y = g;
        switch (g) {
          case "blob":
          case "arraybuffer":
            y = "uint8array";
            break;
          case "base64":
            y = "string";
        }
        try {
          this._internalType = y, this._outputType = g, this._mimeType = b, o.checkSupport(y), this._worker = m.pipe(new a(y)), m.lock();
        } catch (w) {
          this._worker = new s("error"), this._worker.error(w);
        }
      }
      p.prototype = { accumulate: function(m) {
        return f(this, m);
      }, on: function(m, g) {
        var b = this;
        return m === "data" ? this._worker.on(m, function(y) {
          g.call(b, y.data, y.meta);
        }) : this._worker.on(m, function() {
          o.delay(g, arguments, b);
        }), this;
      }, resume: function() {
        return o.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(m) {
        if (o.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new d(this, { objectMode: this._outputType !== "nodebuffer" }, m);
      } }, r.exports = p;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(n, r, i) {
      if (i.base64 = !0, i.array = !0, i.string = !0, i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", i.nodebuffer = typeof Buffer < "u", i.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        i.blob = !1;
      else {
        var o = new ArrayBuffer(0);
        try {
          i.blob = new Blob([o], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var a = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            a.append(o), i.blob = a.getBlob("application/zip").size === 0;
          } catch {
            i.blob = !1;
          }
        }
      }
      try {
        i.nodestream = !!n("readable-stream").Readable;
      } catch {
        i.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(n, r, i) {
      for (var o = n("./utils"), a = n("./support"), s = n("./nodejsUtils"), l = n("./stream/GenericWorker"), c = new Array(256), u = 0; u < 256; u++)
        c[u] = 252 <= u ? 6 : 248 <= u ? 5 : 240 <= u ? 4 : 224 <= u ? 3 : 192 <= u ? 2 : 1;
      c[254] = c[254] = 1;
      function d() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function f() {
        l.call(this, "utf-8 encode");
      }
      i.utf8encode = function(p) {
        return a.nodebuffer ? s.newBufferFrom(p, "utf-8") : function(m) {
          var g, b, y, w, x, k = m.length, A = 0;
          for (w = 0; w < k; w++)
            (64512 & (b = m.charCodeAt(w))) == 55296 && w + 1 < k && (64512 & (y = m.charCodeAt(w + 1))) == 56320 && (b = 65536 + (b - 55296 << 10) + (y - 56320), w++), A += b < 128 ? 1 : b < 2048 ? 2 : b < 65536 ? 3 : 4;
          for (g = a.uint8array ? new Uint8Array(A) : new Array(A), w = x = 0; x < A; w++)
            (64512 & (b = m.charCodeAt(w))) == 55296 && w + 1 < k && (64512 & (y = m.charCodeAt(w + 1))) == 56320 && (b = 65536 + (b - 55296 << 10) + (y - 56320), w++), b < 128 ? g[x++] = b : (b < 2048 ? g[x++] = 192 | b >>> 6 : (b < 65536 ? g[x++] = 224 | b >>> 12 : (g[x++] = 240 | b >>> 18, g[x++] = 128 | b >>> 12 & 63), g[x++] = 128 | b >>> 6 & 63), g[x++] = 128 | 63 & b);
          return g;
        }(p);
      }, i.utf8decode = function(p) {
        return a.nodebuffer ? o.transformTo("nodebuffer", p).toString("utf-8") : function(m) {
          var g, b, y, w, x = m.length, k = new Array(2 * x);
          for (g = b = 0; g < x; )
            if ((y = m[g++]) < 128)
              k[b++] = y;
            else if (4 < (w = c[y]))
              k[b++] = 65533, g += w - 1;
            else {
              for (y &= w === 2 ? 31 : w === 3 ? 15 : 7; 1 < w && g < x; )
                y = y << 6 | 63 & m[g++], w--;
              1 < w ? k[b++] = 65533 : y < 65536 ? k[b++] = y : (y -= 65536, k[b++] = 55296 | y >> 10 & 1023, k[b++] = 56320 | 1023 & y);
            }
          return k.length !== b && (k.subarray ? k = k.subarray(0, b) : k.length = b), o.applyFromCharCode(k);
        }(p = o.transformTo(a.uint8array ? "uint8array" : "array", p));
      }, o.inherits(d, l), d.prototype.processChunk = function(p) {
        var m = o.transformTo(a.uint8array ? "uint8array" : "array", p.data);
        if (this.leftOver && this.leftOver.length) {
          if (a.uint8array) {
            var g = m;
            (m = new Uint8Array(g.length + this.leftOver.length)).set(this.leftOver, 0), m.set(g, this.leftOver.length);
          } else
            m = this.leftOver.concat(m);
          this.leftOver = null;
        }
        var b = function(w, x) {
          var k;
          for ((x = x || w.length) > w.length && (x = w.length), k = x - 1; 0 <= k && (192 & w[k]) == 128; )
            k--;
          return k < 0 || k === 0 ? x : k + c[w[k]] > x ? k : x;
        }(m), y = m;
        b !== m.length && (a.uint8array ? (y = m.subarray(0, b), this.leftOver = m.subarray(b, m.length)) : (y = m.slice(0, b), this.leftOver = m.slice(b, m.length))), this.push({ data: i.utf8decode(y), meta: p.meta });
      }, d.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: i.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, i.Utf8DecodeWorker = d, o.inherits(f, l), f.prototype.processChunk = function(p) {
        this.push({ data: i.utf8encode(p.data), meta: p.meta });
      }, i.Utf8EncodeWorker = f;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(n, r, i) {
      var o = n("./support"), a = n("./base64"), s = n("./nodejsUtils"), l = n("./external");
      function c(g) {
        return g;
      }
      function u(g, b) {
        for (var y = 0; y < g.length; ++y)
          b[y] = 255 & g.charCodeAt(y);
        return b;
      }
      n("setimmediate"), i.newBlob = function(g, b) {
        i.checkSupport("blob");
        try {
          return new Blob([g], { type: b });
        } catch {
          try {
            var y = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return y.append(g), y.getBlob(b);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var d = { stringifyByChunk: function(g, b, y) {
        var w = [], x = 0, k = g.length;
        if (k <= y)
          return String.fromCharCode.apply(null, g);
        for (; x < k; )
          b === "array" || b === "nodebuffer" ? w.push(String.fromCharCode.apply(null, g.slice(x, Math.min(x + y, k)))) : w.push(String.fromCharCode.apply(null, g.subarray(x, Math.min(x + y, k)))), x += y;
        return w.join("");
      }, stringifyByChar: function(g) {
        for (var b = "", y = 0; y < g.length; y++)
          b += String.fromCharCode(g[y]);
        return b;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return o.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return o.nodebuffer && String.fromCharCode.apply(null, s.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function f(g) {
        var b = 65536, y = i.getTypeOf(g), w = !0;
        if (y === "uint8array" ? w = d.applyCanBeUsed.uint8array : y === "nodebuffer" && (w = d.applyCanBeUsed.nodebuffer), w)
          for (; 1 < b; )
            try {
              return d.stringifyByChunk(g, y, b);
            } catch {
              b = Math.floor(b / 2);
            }
        return d.stringifyByChar(g);
      }
      function p(g, b) {
        for (var y = 0; y < g.length; y++)
          b[y] = g[y];
        return b;
      }
      i.applyFromCharCode = f;
      var m = {};
      m.string = { string: c, array: function(g) {
        return u(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return m.string.uint8array(g).buffer;
      }, uint8array: function(g) {
        return u(g, new Uint8Array(g.length));
      }, nodebuffer: function(g) {
        return u(g, s.allocBuffer(g.length));
      } }, m.array = { string: f, array: c, arraybuffer: function(g) {
        return new Uint8Array(g).buffer;
      }, uint8array: function(g) {
        return new Uint8Array(g);
      }, nodebuffer: function(g) {
        return s.newBufferFrom(g);
      } }, m.arraybuffer = { string: function(g) {
        return f(new Uint8Array(g));
      }, array: function(g) {
        return p(new Uint8Array(g), new Array(g.byteLength));
      }, arraybuffer: c, uint8array: function(g) {
        return new Uint8Array(g);
      }, nodebuffer: function(g) {
        return s.newBufferFrom(new Uint8Array(g));
      } }, m.uint8array = { string: f, array: function(g) {
        return p(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return g.buffer;
      }, uint8array: c, nodebuffer: function(g) {
        return s.newBufferFrom(g);
      } }, m.nodebuffer = { string: f, array: function(g) {
        return p(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return m.nodebuffer.uint8array(g).buffer;
      }, uint8array: function(g) {
        return p(g, new Uint8Array(g.length));
      }, nodebuffer: c }, i.transformTo = function(g, b) {
        if (b = b || "", !g)
          return b;
        i.checkSupport(g);
        var y = i.getTypeOf(b);
        return m[y][g](b);
      }, i.resolve = function(g) {
        for (var b = g.split("/"), y = [], w = 0; w < b.length; w++) {
          var x = b[w];
          x === "." || x === "" && w !== 0 && w !== b.length - 1 || (x === ".." ? y.pop() : y.push(x));
        }
        return y.join("/");
      }, i.getTypeOf = function(g) {
        return typeof g == "string" ? "string" : Object.prototype.toString.call(g) === "[object Array]" ? "array" : o.nodebuffer && s.isBuffer(g) ? "nodebuffer" : o.uint8array && g instanceof Uint8Array ? "uint8array" : o.arraybuffer && g instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, i.checkSupport = function(g) {
        if (!o[g.toLowerCase()])
          throw new Error(g + " is not supported by this platform");
      }, i.MAX_VALUE_16BITS = 65535, i.MAX_VALUE_32BITS = -1, i.pretty = function(g) {
        var b, y, w = "";
        for (y = 0; y < (g || "").length; y++)
          w += "\\x" + ((b = g.charCodeAt(y)) < 16 ? "0" : "") + b.toString(16).toUpperCase();
        return w;
      }, i.delay = function(g, b, y) {
        setImmediate(function() {
          g.apply(y || null, b || []);
        });
      }, i.inherits = function(g, b) {
        function y() {
        }
        y.prototype = b.prototype, g.prototype = new y();
      }, i.extend = function() {
        var g, b, y = {};
        for (g = 0; g < arguments.length; g++)
          for (b in arguments[g])
            Object.prototype.hasOwnProperty.call(arguments[g], b) && y[b] === void 0 && (y[b] = arguments[g][b]);
        return y;
      }, i.prepareContent = function(g, b, y, w, x) {
        return l.Promise.resolve(b).then(function(k) {
          return o.blob && (k instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(k)) !== -1) && typeof FileReader < "u" ? new l.Promise(function(A, U) {
            var P = new FileReader();
            P.onload = function(V) {
              A(V.target.result);
            }, P.onerror = function(V) {
              U(V.target.error);
            }, P.readAsArrayBuffer(k);
          }) : k;
        }).then(function(k) {
          var A = i.getTypeOf(k);
          return A ? (A === "arraybuffer" ? k = i.transformTo("uint8array", k) : A === "string" && (x ? k = a.decode(k) : y && w !== !0 && (k = function(U) {
            return u(U, o.uint8array ? new Uint8Array(U.length) : new Array(U.length));
          }(k))), k) : l.Promise.reject(new Error("Can't read the data of '" + g + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(n, r, i) {
      var o = n("./reader/readerFor"), a = n("./utils"), s = n("./signature"), l = n("./zipEntry"), c = n("./support");
      function u(d) {
        this.files = [], this.loadOptions = d;
      }
      u.prototype = { checkSignature: function(d) {
        if (!this.reader.readAndCheckSignature(d)) {
          this.reader.index -= 4;
          var f = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + a.pretty(f) + ", expected " + a.pretty(d) + ")");
        }
      }, isSignature: function(d, f) {
        var p = this.reader.index;
        this.reader.setIndex(d);
        var m = this.reader.readString(4) === f;
        return this.reader.setIndex(p), m;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var d = this.reader.readData(this.zipCommentLength), f = c.uint8array ? "uint8array" : "array", p = a.transformTo(f, d);
        this.zipComment = this.loadOptions.decodeFileName(p);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var d, f, p, m = this.zip64EndOfCentralSize - 44; 0 < m; )
          d = this.reader.readInt(2), f = this.reader.readInt(4), p = this.reader.readData(f), this.zip64ExtensibleData[d] = { id: d, length: f, value: p };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var d, f;
        for (d = 0; d < this.files.length; d++)
          f = this.files[d], this.reader.setIndex(f.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), f.readLocalPart(this.reader), f.handleUTF8(), f.processAttributes();
      }, readCentralDir: function() {
        var d;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
          (d = new l({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(d);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var d = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
        if (d < 0)
          throw this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(d);
        var f = d;
        if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === a.MAX_VALUE_16BITS || this.diskWithCentralDirStart === a.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === a.MAX_VALUE_16BITS || this.centralDirRecords === a.MAX_VALUE_16BITS || this.centralDirSize === a.MAX_VALUE_32BITS || this.centralDirOffset === a.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (d = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(d), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var p = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (p += 20, p += 12 + this.zip64EndOfCentralSize);
        var m = f - p;
        if (0 < m)
          this.isSignature(f, s.CENTRAL_FILE_HEADER) || (this.reader.zero = m);
        else if (m < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(m) + " bytes.");
      }, prepareReader: function(d) {
        this.reader = o(d);
      }, load: function(d) {
        this.prepareReader(d), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, r.exports = u;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(n, r, i) {
      var o = n("./reader/readerFor"), a = n("./utils"), s = n("./compressedObject"), l = n("./crc32"), c = n("./utf8"), u = n("./compressions"), d = n("./support");
      function f(p, m) {
        this.options = p, this.loadOptions = m;
      }
      f.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(p) {
        var m, g;
        if (p.skip(22), this.fileNameLength = p.readInt(2), g = p.readInt(2), this.fileName = p.readData(this.fileNameLength), p.skip(g), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((m = function(b) {
          for (var y in u)
            if (Object.prototype.hasOwnProperty.call(u, y) && u[y].magic === b)
              return u[y];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + a.pretty(this.compressionMethod) + " unknown (inner file : " + a.transformTo("string", this.fileName) + ")");
        this.decompressed = new s(this.compressedSize, this.uncompressedSize, this.crc32, m, p.readData(this.compressedSize));
      }, readCentralPart: function(p) {
        this.versionMadeBy = p.readInt(2), p.skip(2), this.bitFlag = p.readInt(2), this.compressionMethod = p.readString(2), this.date = p.readDate(), this.crc32 = p.readInt(4), this.compressedSize = p.readInt(4), this.uncompressedSize = p.readInt(4);
        var m = p.readInt(2);
        if (this.extraFieldsLength = p.readInt(2), this.fileCommentLength = p.readInt(2), this.diskNumberStart = p.readInt(2), this.internalFileAttributes = p.readInt(2), this.externalFileAttributes = p.readInt(4), this.localHeaderOffset = p.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        p.skip(m), this.readExtraFields(p), this.parseZIP64ExtraField(p), this.fileComment = p.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var p = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), p == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), p == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var p = o(this.extraFields[1].value);
          this.uncompressedSize === a.MAX_VALUE_32BITS && (this.uncompressedSize = p.readInt(8)), this.compressedSize === a.MAX_VALUE_32BITS && (this.compressedSize = p.readInt(8)), this.localHeaderOffset === a.MAX_VALUE_32BITS && (this.localHeaderOffset = p.readInt(8)), this.diskNumberStart === a.MAX_VALUE_32BITS && (this.diskNumberStart = p.readInt(4));
        }
      }, readExtraFields: function(p) {
        var m, g, b, y = p.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); p.index + 4 < y; )
          m = p.readInt(2), g = p.readInt(2), b = p.readData(g), this.extraFields[m] = { id: m, length: g, value: b };
        p.setIndex(y);
      }, handleUTF8: function() {
        var p = d.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
        else {
          var m = this.findExtraFieldUnicodePath();
          if (m !== null)
            this.fileNameStr = m;
          else {
            var g = a.transformTo(p, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(g);
          }
          var b = this.findExtraFieldUnicodeComment();
          if (b !== null)
            this.fileCommentStr = b;
          else {
            var y = a.transformTo(p, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(y);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var p = this.extraFields[28789];
        if (p) {
          var m = o(p.value);
          return m.readInt(1) !== 1 || l(this.fileName) !== m.readInt(4) ? null : c.utf8decode(m.readData(p.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var p = this.extraFields[25461];
        if (p) {
          var m = o(p.value);
          return m.readInt(1) !== 1 || l(this.fileComment) !== m.readInt(4) ? null : c.utf8decode(m.readData(p.length - 5));
        }
        return null;
      } }, r.exports = f;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(n, r, i) {
      function o(m, g, b) {
        this.name = m, this.dir = b.dir, this.date = b.date, this.comment = b.comment, this.unixPermissions = b.unixPermissions, this.dosPermissions = b.dosPermissions, this._data = g, this._dataBinary = b.binary, this.options = { compression: b.compression, compressionOptions: b.compressionOptions };
      }
      var a = n("./stream/StreamHelper"), s = n("./stream/DataWorker"), l = n("./utf8"), c = n("./compressedObject"), u = n("./stream/GenericWorker");
      o.prototype = { internalStream: function(m) {
        var g = null, b = "string";
        try {
          if (!m)
            throw new Error("No output type specified.");
          var y = (b = m.toLowerCase()) === "string" || b === "text";
          b !== "binarystring" && b !== "text" || (b = "string"), g = this._decompressWorker();
          var w = !this._dataBinary;
          w && !y && (g = g.pipe(new l.Utf8EncodeWorker())), !w && y && (g = g.pipe(new l.Utf8DecodeWorker()));
        } catch (x) {
          (g = new u("error")).error(x);
        }
        return new a(g, b, "");
      }, async: function(m, g) {
        return this.internalStream(m).accumulate(g);
      }, nodeStream: function(m, g) {
        return this.internalStream(m || "nodebuffer").toNodejsStream(g);
      }, _compressWorker: function(m, g) {
        if (this._data instanceof c && this._data.compression.magic === m.magic)
          return this._data.getCompressedWorker();
        var b = this._decompressWorker();
        return this._dataBinary || (b = b.pipe(new l.Utf8EncodeWorker())), c.createWorkerFrom(b, m, g);
      }, _decompressWorker: function() {
        return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof u ? this._data : new s(this._data);
      } };
      for (var d = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], f = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, p = 0; p < d.length; p++)
        o.prototype[d[p]] = f;
      r.exports = o;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(n, r, i) {
      (function(o) {
        var a, s, l = o.MutationObserver || o.WebKitMutationObserver;
        if (l) {
          var c = 0, u = new l(m), d = o.document.createTextNode("");
          u.observe(d, { characterData: !0 }), a = function() {
            d.data = c = ++c % 2;
          };
        } else if (o.setImmediate || o.MessageChannel === void 0)
          a = "document" in o && "onreadystatechange" in o.document.createElement("script") ? function() {
            var g = o.document.createElement("script");
            g.onreadystatechange = function() {
              m(), g.onreadystatechange = null, g.parentNode.removeChild(g), g = null;
            }, o.document.documentElement.appendChild(g);
          } : function() {
            setTimeout(m, 0);
          };
        else {
          var f = new o.MessageChannel();
          f.port1.onmessage = m, a = function() {
            f.port2.postMessage(0);
          };
        }
        var p = [];
        function m() {
          var g, b;
          s = !0;
          for (var y = p.length; y; ) {
            for (b = p, p = [], g = -1; ++g < y; )
              b[g]();
            y = p.length;
          }
          s = !1;
        }
        r.exports = function(g) {
          p.push(g) !== 1 || s || a();
        };
      }).call(this, typeof oa < "u" ? oa : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(n, r, i) {
      var o = n("immediate");
      function a() {
      }
      var s = {}, l = ["REJECTED"], c = ["FULFILLED"], u = ["PENDING"];
      function d(y) {
        if (typeof y != "function")
          throw new TypeError("resolver must be a function");
        this.state = u, this.queue = [], this.outcome = void 0, y !== a && g(this, y);
      }
      function f(y, w, x) {
        this.promise = y, typeof w == "function" && (this.onFulfilled = w, this.callFulfilled = this.otherCallFulfilled), typeof x == "function" && (this.onRejected = x, this.callRejected = this.otherCallRejected);
      }
      function p(y, w, x) {
        o(function() {
          var k;
          try {
            k = w(x);
          } catch (A) {
            return s.reject(y, A);
          }
          k === y ? s.reject(y, new TypeError("Cannot resolve promise with itself")) : s.resolve(y, k);
        });
      }
      function m(y) {
        var w = y && y.then;
        if (y && (typeof y == "object" || typeof y == "function") && typeof w == "function")
          return function() {
            w.apply(y, arguments);
          };
      }
      function g(y, w) {
        var x = !1;
        function k(P) {
          x || (x = !0, s.reject(y, P));
        }
        function A(P) {
          x || (x = !0, s.resolve(y, P));
        }
        var U = b(function() {
          w(A, k);
        });
        U.status === "error" && k(U.value);
      }
      function b(y, w) {
        var x = {};
        try {
          x.value = y(w), x.status = "success";
        } catch (k) {
          x.status = "error", x.value = k;
        }
        return x;
      }
      (r.exports = d).prototype.finally = function(y) {
        if (typeof y != "function")
          return this;
        var w = this.constructor;
        return this.then(function(x) {
          return w.resolve(y()).then(function() {
            return x;
          });
        }, function(x) {
          return w.resolve(y()).then(function() {
            throw x;
          });
        });
      }, d.prototype.catch = function(y) {
        return this.then(null, y);
      }, d.prototype.then = function(y, w) {
        if (typeof y != "function" && this.state === c || typeof w != "function" && this.state === l)
          return this;
        var x = new this.constructor(a);
        return this.state !== u ? p(x, this.state === c ? y : w, this.outcome) : this.queue.push(new f(x, y, w)), x;
      }, f.prototype.callFulfilled = function(y) {
        s.resolve(this.promise, y);
      }, f.prototype.otherCallFulfilled = function(y) {
        p(this.promise, this.onFulfilled, y);
      }, f.prototype.callRejected = function(y) {
        s.reject(this.promise, y);
      }, f.prototype.otherCallRejected = function(y) {
        p(this.promise, this.onRejected, y);
      }, s.resolve = function(y, w) {
        var x = b(m, w);
        if (x.status === "error")
          return s.reject(y, x.value);
        var k = x.value;
        if (k)
          g(y, k);
        else {
          y.state = c, y.outcome = w;
          for (var A = -1, U = y.queue.length; ++A < U; )
            y.queue[A].callFulfilled(w);
        }
        return y;
      }, s.reject = function(y, w) {
        y.state = l, y.outcome = w;
        for (var x = -1, k = y.queue.length; ++x < k; )
          y.queue[x].callRejected(w);
        return y;
      }, d.resolve = function(y) {
        return y instanceof this ? y : s.resolve(new this(a), y);
      }, d.reject = function(y) {
        var w = new this(a);
        return s.reject(w, y);
      }, d.all = function(y) {
        var w = this;
        if (Object.prototype.toString.call(y) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var x = y.length, k = !1;
        if (!x)
          return this.resolve([]);
        for (var A = new Array(x), U = 0, P = -1, V = new this(a); ++P < x; )
          I(y[P], P);
        return V;
        function I(le, be) {
          w.resolve(le).then(function(F) {
            A[be] = F, ++U !== x || k || (k = !0, s.resolve(V, A));
          }, function(F) {
            k || (k = !0, s.reject(V, F));
          });
        }
      }, d.race = function(y) {
        var w = this;
        if (Object.prototype.toString.call(y) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var x = y.length, k = !1;
        if (!x)
          return this.resolve([]);
        for (var A = -1, U = new this(a); ++A < x; )
          P = y[A], w.resolve(P).then(function(V) {
            k || (k = !0, s.resolve(U, V));
          }, function(V) {
            k || (k = !0, s.reject(U, V));
          });
        var P;
        return U;
      };
    }, { immediate: 36 }], 38: [function(n, r, i) {
      var o = {};
      (0, n("./lib/utils/common").assign)(o, n("./lib/deflate"), n("./lib/inflate"), n("./lib/zlib/constants")), r.exports = o;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(n, r, i) {
      var o = n("./zlib/deflate"), a = n("./utils/common"), s = n("./utils/strings"), l = n("./zlib/messages"), c = n("./zlib/zstream"), u = Object.prototype.toString, d = 0, f = -1, p = 0, m = 8;
      function g(y) {
        if (!(this instanceof g))
          return new g(y);
        this.options = a.assign({ level: f, method: m, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: p, to: "" }, y || {});
        var w = this.options;
        w.raw && 0 < w.windowBits ? w.windowBits = -w.windowBits : w.gzip && 0 < w.windowBits && w.windowBits < 16 && (w.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var x = o.deflateInit2(this.strm, w.level, w.method, w.windowBits, w.memLevel, w.strategy);
        if (x !== d)
          throw new Error(l[x]);
        if (w.header && o.deflateSetHeader(this.strm, w.header), w.dictionary) {
          var k;
          if (k = typeof w.dictionary == "string" ? s.string2buf(w.dictionary) : u.call(w.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(w.dictionary) : w.dictionary, (x = o.deflateSetDictionary(this.strm, k)) !== d)
            throw new Error(l[x]);
          this._dict_set = !0;
        }
      }
      function b(y, w) {
        var x = new g(w);
        if (x.push(y, !0), x.err)
          throw x.msg || l[x.err];
        return x.result;
      }
      g.prototype.push = function(y, w) {
        var x, k, A = this.strm, U = this.options.chunkSize;
        if (this.ended)
          return !1;
        k = w === ~~w ? w : w === !0 ? 4 : 0, typeof y == "string" ? A.input = s.string2buf(y) : u.call(y) === "[object ArrayBuffer]" ? A.input = new Uint8Array(y) : A.input = y, A.next_in = 0, A.avail_in = A.input.length;
        do {
          if (A.avail_out === 0 && (A.output = new a.Buf8(U), A.next_out = 0, A.avail_out = U), (x = o.deflate(A, k)) !== 1 && x !== d)
            return this.onEnd(x), !(this.ended = !0);
          A.avail_out !== 0 && (A.avail_in !== 0 || k !== 4 && k !== 2) || (this.options.to === "string" ? this.onData(s.buf2binstring(a.shrinkBuf(A.output, A.next_out))) : this.onData(a.shrinkBuf(A.output, A.next_out)));
        } while ((0 < A.avail_in || A.avail_out === 0) && x !== 1);
        return k === 4 ? (x = o.deflateEnd(this.strm), this.onEnd(x), this.ended = !0, x === d) : k !== 2 || (this.onEnd(d), !(A.avail_out = 0));
      }, g.prototype.onData = function(y) {
        this.chunks.push(y);
      }, g.prototype.onEnd = function(y) {
        y === d && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = a.flattenChunks(this.chunks)), this.chunks = [], this.err = y, this.msg = this.strm.msg;
      }, i.Deflate = g, i.deflate = b, i.deflateRaw = function(y, w) {
        return (w = w || {}).raw = !0, b(y, w);
      }, i.gzip = function(y, w) {
        return (w = w || {}).gzip = !0, b(y, w);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(n, r, i) {
      var o = n("./zlib/inflate"), a = n("./utils/common"), s = n("./utils/strings"), l = n("./zlib/constants"), c = n("./zlib/messages"), u = n("./zlib/zstream"), d = n("./zlib/gzheader"), f = Object.prototype.toString;
      function p(g) {
        if (!(this instanceof p))
          return new p(g);
        this.options = a.assign({ chunkSize: 16384, windowBits: 0, to: "" }, g || {});
        var b = this.options;
        b.raw && 0 <= b.windowBits && b.windowBits < 16 && (b.windowBits = -b.windowBits, b.windowBits === 0 && (b.windowBits = -15)), !(0 <= b.windowBits && b.windowBits < 16) || g && g.windowBits || (b.windowBits += 32), 15 < b.windowBits && b.windowBits < 48 && !(15 & b.windowBits) && (b.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var y = o.inflateInit2(this.strm, b.windowBits);
        if (y !== l.Z_OK)
          throw new Error(c[y]);
        this.header = new d(), o.inflateGetHeader(this.strm, this.header);
      }
      function m(g, b) {
        var y = new p(b);
        if (y.push(g, !0), y.err)
          throw y.msg || c[y.err];
        return y.result;
      }
      p.prototype.push = function(g, b) {
        var y, w, x, k, A, U, P = this.strm, V = this.options.chunkSize, I = this.options.dictionary, le = !1;
        if (this.ended)
          return !1;
        w = b === ~~b ? b : b === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof g == "string" ? P.input = s.binstring2buf(g) : f.call(g) === "[object ArrayBuffer]" ? P.input = new Uint8Array(g) : P.input = g, P.next_in = 0, P.avail_in = P.input.length;
        do {
          if (P.avail_out === 0 && (P.output = new a.Buf8(V), P.next_out = 0, P.avail_out = V), (y = o.inflate(P, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && I && (U = typeof I == "string" ? s.string2buf(I) : f.call(I) === "[object ArrayBuffer]" ? new Uint8Array(I) : I, y = o.inflateSetDictionary(this.strm, U)), y === l.Z_BUF_ERROR && le === !0 && (y = l.Z_OK, le = !1), y !== l.Z_STREAM_END && y !== l.Z_OK)
            return this.onEnd(y), !(this.ended = !0);
          P.next_out && (P.avail_out !== 0 && y !== l.Z_STREAM_END && (P.avail_in !== 0 || w !== l.Z_FINISH && w !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (x = s.utf8border(P.output, P.next_out), k = P.next_out - x, A = s.buf2string(P.output, x), P.next_out = k, P.avail_out = V - k, k && a.arraySet(P.output, P.output, x, k, 0), this.onData(A)) : this.onData(a.shrinkBuf(P.output, P.next_out)))), P.avail_in === 0 && P.avail_out === 0 && (le = !0);
        } while ((0 < P.avail_in || P.avail_out === 0) && y !== l.Z_STREAM_END);
        return y === l.Z_STREAM_END && (w = l.Z_FINISH), w === l.Z_FINISH ? (y = o.inflateEnd(this.strm), this.onEnd(y), this.ended = !0, y === l.Z_OK) : w !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(P.avail_out = 0));
      }, p.prototype.onData = function(g) {
        this.chunks.push(g);
      }, p.prototype.onEnd = function(g) {
        g === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = a.flattenChunks(this.chunks)), this.chunks = [], this.err = g, this.msg = this.strm.msg;
      }, i.Inflate = p, i.inflate = m, i.inflateRaw = function(g, b) {
        return (b = b || {}).raw = !0, m(g, b);
      }, i.ungzip = m;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(n, r, i) {
      var o = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      i.assign = function(l) {
        for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
          var u = c.shift();
          if (u) {
            if (typeof u != "object")
              throw new TypeError(u + "must be non-object");
            for (var d in u)
              u.hasOwnProperty(d) && (l[d] = u[d]);
          }
        }
        return l;
      }, i.shrinkBuf = function(l, c) {
        return l.length === c ? l : l.subarray ? l.subarray(0, c) : (l.length = c, l);
      };
      var a = { arraySet: function(l, c, u, d, f) {
        if (c.subarray && l.subarray)
          l.set(c.subarray(u, u + d), f);
        else
          for (var p = 0; p < d; p++)
            l[f + p] = c[u + p];
      }, flattenChunks: function(l) {
        var c, u, d, f, p, m;
        for (c = d = 0, u = l.length; c < u; c++)
          d += l[c].length;
        for (m = new Uint8Array(d), c = f = 0, u = l.length; c < u; c++)
          p = l[c], m.set(p, f), f += p.length;
        return m;
      } }, s = { arraySet: function(l, c, u, d, f) {
        for (var p = 0; p < d; p++)
          l[f + p] = c[u + p];
      }, flattenChunks: function(l) {
        return [].concat.apply([], l);
      } };
      i.setTyped = function(l) {
        l ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, a)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, s));
      }, i.setTyped(o);
    }, {}], 42: [function(n, r, i) {
      var o = n("./common"), a = !0, s = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        a = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        s = !1;
      }
      for (var l = new o.Buf8(256), c = 0; c < 256; c++)
        l[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
      function u(d, f) {
        if (f < 65537 && (d.subarray && s || !d.subarray && a))
          return String.fromCharCode.apply(null, o.shrinkBuf(d, f));
        for (var p = "", m = 0; m < f; m++)
          p += String.fromCharCode(d[m]);
        return p;
      }
      l[254] = l[254] = 1, i.string2buf = function(d) {
        var f, p, m, g, b, y = d.length, w = 0;
        for (g = 0; g < y; g++)
          (64512 & (p = d.charCodeAt(g))) == 55296 && g + 1 < y && (64512 & (m = d.charCodeAt(g + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (m - 56320), g++), w += p < 128 ? 1 : p < 2048 ? 2 : p < 65536 ? 3 : 4;
        for (f = new o.Buf8(w), g = b = 0; b < w; g++)
          (64512 & (p = d.charCodeAt(g))) == 55296 && g + 1 < y && (64512 & (m = d.charCodeAt(g + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (m - 56320), g++), p < 128 ? f[b++] = p : (p < 2048 ? f[b++] = 192 | p >>> 6 : (p < 65536 ? f[b++] = 224 | p >>> 12 : (f[b++] = 240 | p >>> 18, f[b++] = 128 | p >>> 12 & 63), f[b++] = 128 | p >>> 6 & 63), f[b++] = 128 | 63 & p);
        return f;
      }, i.buf2binstring = function(d) {
        return u(d, d.length);
      }, i.binstring2buf = function(d) {
        for (var f = new o.Buf8(d.length), p = 0, m = f.length; p < m; p++)
          f[p] = d.charCodeAt(p);
        return f;
      }, i.buf2string = function(d, f) {
        var p, m, g, b, y = f || d.length, w = new Array(2 * y);
        for (p = m = 0; p < y; )
          if ((g = d[p++]) < 128)
            w[m++] = g;
          else if (4 < (b = l[g]))
            w[m++] = 65533, p += b - 1;
          else {
            for (g &= b === 2 ? 31 : b === 3 ? 15 : 7; 1 < b && p < y; )
              g = g << 6 | 63 & d[p++], b--;
            1 < b ? w[m++] = 65533 : g < 65536 ? w[m++] = g : (g -= 65536, w[m++] = 55296 | g >> 10 & 1023, w[m++] = 56320 | 1023 & g);
          }
        return u(w, m);
      }, i.utf8border = function(d, f) {
        var p;
        for ((f = f || d.length) > d.length && (f = d.length), p = f - 1; 0 <= p && (192 & d[p]) == 128; )
          p--;
        return p < 0 || p === 0 ? f : p + l[d[p]] > f ? p : f;
      };
    }, { "./common": 41 }], 43: [function(n, r, i) {
      r.exports = function(o, a, s, l) {
        for (var c = 65535 & o | 0, u = o >>> 16 & 65535 | 0, d = 0; s !== 0; ) {
          for (s -= d = 2e3 < s ? 2e3 : s; u = u + (c = c + a[l++] | 0) | 0, --d; )
            ;
          c %= 65521, u %= 65521;
        }
        return c | u << 16 | 0;
      };
    }, {}], 44: [function(n, r, i) {
      r.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(n, r, i) {
      var o = function() {
        for (var a, s = [], l = 0; l < 256; l++) {
          a = l;
          for (var c = 0; c < 8; c++)
            a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
          s[l] = a;
        }
        return s;
      }();
      r.exports = function(a, s, l, c) {
        var u = o, d = c + l;
        a ^= -1;
        for (var f = c; f < d; f++)
          a = a >>> 8 ^ u[255 & (a ^ s[f])];
        return -1 ^ a;
      };
    }, {}], 46: [function(n, r, i) {
      var o, a = n("../utils/common"), s = n("./trees"), l = n("./adler32"), c = n("./crc32"), u = n("./messages"), d = 0, f = 4, p = 0, m = -2, g = -1, b = 4, y = 2, w = 8, x = 9, k = 286, A = 30, U = 19, P = 2 * k + 1, V = 15, I = 3, le = 258, be = le + I + 1, F = 42, G = 113, C = 1, ie = 2, ee = 3, Z = 4;
      function oe(T, pe) {
        return T.msg = u[pe], pe;
      }
      function te(T) {
        return (T << 1) - (4 < T ? 9 : 0);
      }
      function _e(T) {
        for (var pe = T.length; 0 <= --pe; )
          T[pe] = 0;
      }
      function q(T) {
        var pe = T.state, M = pe.pending;
        M > T.avail_out && (M = T.avail_out), M !== 0 && (a.arraySet(T.output, pe.pending_buf, pe.pending_out, M, T.next_out), T.next_out += M, pe.pending_out += M, T.total_out += M, T.avail_out -= M, pe.pending -= M, pe.pending === 0 && (pe.pending_out = 0));
      }
      function N(T, pe) {
        s._tr_flush_block(T, 0 <= T.block_start ? T.block_start : -1, T.strstart - T.block_start, pe), T.block_start = T.strstart, q(T.strm);
      }
      function ce(T, pe) {
        T.pending_buf[T.pending++] = pe;
      }
      function me(T, pe) {
        T.pending_buf[T.pending++] = pe >>> 8 & 255, T.pending_buf[T.pending++] = 255 & pe;
      }
      function ve(T, pe) {
        var M, _, S = T.max_chain_length, O = T.strstart, ne = T.prev_length, fe = T.nice_match, J = T.strstart > T.w_size - be ? T.strstart - (T.w_size - be) : 0, re = T.window, de = T.w_mask, ge = T.prev, Ee = T.strstart + le, Ne = re[O + ne - 1], Le = re[O + ne];
        T.prev_length >= T.good_match && (S >>= 2), fe > T.lookahead && (fe = T.lookahead);
        do
          if (re[(M = pe) + ne] === Le && re[M + ne - 1] === Ne && re[M] === re[O] && re[++M] === re[O + 1]) {
            O += 2, M++;
            do
              ;
            while (re[++O] === re[++M] && re[++O] === re[++M] && re[++O] === re[++M] && re[++O] === re[++M] && re[++O] === re[++M] && re[++O] === re[++M] && re[++O] === re[++M] && re[++O] === re[++M] && O < Ee);
            if (_ = le - (Ee - O), O = Ee - le, ne < _) {
              if (T.match_start = pe, fe <= (ne = _))
                break;
              Ne = re[O + ne - 1], Le = re[O + ne];
            }
          }
        while ((pe = ge[pe & de]) > J && --S != 0);
        return ne <= T.lookahead ? ne : T.lookahead;
      }
      function he(T) {
        var pe, M, _, S, O, ne, fe, J, re, de, ge = T.w_size;
        do {
          if (S = T.window_size - T.lookahead - T.strstart, T.strstart >= ge + (ge - be)) {
            for (a.arraySet(T.window, T.window, ge, ge, 0), T.match_start -= ge, T.strstart -= ge, T.block_start -= ge, pe = M = T.hash_size; _ = T.head[--pe], T.head[pe] = ge <= _ ? _ - ge : 0, --M; )
              ;
            for (pe = M = ge; _ = T.prev[--pe], T.prev[pe] = ge <= _ ? _ - ge : 0, --M; )
              ;
            S += ge;
          }
          if (T.strm.avail_in === 0)
            break;
          if (ne = T.strm, fe = T.window, J = T.strstart + T.lookahead, re = S, de = void 0, de = ne.avail_in, re < de && (de = re), M = de === 0 ? 0 : (ne.avail_in -= de, a.arraySet(fe, ne.input, ne.next_in, de, J), ne.state.wrap === 1 ? ne.adler = l(ne.adler, fe, de, J) : ne.state.wrap === 2 && (ne.adler = c(ne.adler, fe, de, J)), ne.next_in += de, ne.total_in += de, de), T.lookahead += M, T.lookahead + T.insert >= I)
            for (O = T.strstart - T.insert, T.ins_h = T.window[O], T.ins_h = (T.ins_h << T.hash_shift ^ T.window[O + 1]) & T.hash_mask; T.insert && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[O + I - 1]) & T.hash_mask, T.prev[O & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = O, O++, T.insert--, !(T.lookahead + T.insert < I)); )
              ;
        } while (T.lookahead < be && T.strm.avail_in !== 0);
      }
      function H(T, pe) {
        for (var M, _; ; ) {
          if (T.lookahead < be) {
            if (he(T), T.lookahead < be && pe === d)
              return C;
            if (T.lookahead === 0)
              break;
          }
          if (M = 0, T.lookahead >= I && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + I - 1]) & T.hash_mask, M = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart), M !== 0 && T.strstart - M <= T.w_size - be && (T.match_length = ve(T, M)), T.match_length >= I)
            if (_ = s._tr_tally(T, T.strstart - T.match_start, T.match_length - I), T.lookahead -= T.match_length, T.match_length <= T.max_lazy_match && T.lookahead >= I) {
              for (T.match_length--; T.strstart++, T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + I - 1]) & T.hash_mask, M = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart, --T.match_length != 0; )
                ;
              T.strstart++;
            } else
              T.strstart += T.match_length, T.match_length = 0, T.ins_h = T.window[T.strstart], T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + 1]) & T.hash_mask;
          else
            _ = s._tr_tally(T, 0, T.window[T.strstart]), T.lookahead--, T.strstart++;
          if (_ && (N(T, !1), T.strm.avail_out === 0))
            return C;
        }
        return T.insert = T.strstart < I - 1 ? T.strstart : I - 1, pe === f ? (N(T, !0), T.strm.avail_out === 0 ? ee : Z) : T.last_lit && (N(T, !1), T.strm.avail_out === 0) ? C : ie;
      }
      function W(T, pe) {
        for (var M, _, S; ; ) {
          if (T.lookahead < be) {
            if (he(T), T.lookahead < be && pe === d)
              return C;
            if (T.lookahead === 0)
              break;
          }
          if (M = 0, T.lookahead >= I && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + I - 1]) & T.hash_mask, M = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart), T.prev_length = T.match_length, T.prev_match = T.match_start, T.match_length = I - 1, M !== 0 && T.prev_length < T.max_lazy_match && T.strstart - M <= T.w_size - be && (T.match_length = ve(T, M), T.match_length <= 5 && (T.strategy === 1 || T.match_length === I && 4096 < T.strstart - T.match_start) && (T.match_length = I - 1)), T.prev_length >= I && T.match_length <= T.prev_length) {
            for (S = T.strstart + T.lookahead - I, _ = s._tr_tally(T, T.strstart - 1 - T.prev_match, T.prev_length - I), T.lookahead -= T.prev_length - 1, T.prev_length -= 2; ++T.strstart <= S && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + I - 1]) & T.hash_mask, M = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart), --T.prev_length != 0; )
              ;
            if (T.match_available = 0, T.match_length = I - 1, T.strstart++, _ && (N(T, !1), T.strm.avail_out === 0))
              return C;
          } else if (T.match_available) {
            if ((_ = s._tr_tally(T, 0, T.window[T.strstart - 1])) && N(T, !1), T.strstart++, T.lookahead--, T.strm.avail_out === 0)
              return C;
          } else
            T.match_available = 1, T.strstart++, T.lookahead--;
        }
        return T.match_available && (_ = s._tr_tally(T, 0, T.window[T.strstart - 1]), T.match_available = 0), T.insert = T.strstart < I - 1 ? T.strstart : I - 1, pe === f ? (N(T, !0), T.strm.avail_out === 0 ? ee : Z) : T.last_lit && (N(T, !1), T.strm.avail_out === 0) ? C : ie;
      }
      function we(T, pe, M, _, S) {
        this.good_length = T, this.max_lazy = pe, this.nice_length = M, this.max_chain = _, this.func = S;
      }
      function ye() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = w, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new a.Buf16(2 * P), this.dyn_dtree = new a.Buf16(2 * (2 * A + 1)), this.bl_tree = new a.Buf16(2 * (2 * U + 1)), _e(this.dyn_ltree), _e(this.dyn_dtree), _e(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new a.Buf16(V + 1), this.heap = new a.Buf16(2 * k + 1), _e(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new a.Buf16(2 * k + 1), _e(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function j(T) {
        var pe;
        return T && T.state ? (T.total_in = T.total_out = 0, T.data_type = y, (pe = T.state).pending = 0, pe.pending_out = 0, pe.wrap < 0 && (pe.wrap = -pe.wrap), pe.status = pe.wrap ? F : G, T.adler = pe.wrap === 2 ? 0 : 1, pe.last_flush = d, s._tr_init(pe), p) : oe(T, m);
      }
      function Q(T) {
        var pe = j(T);
        return pe === p && function(M) {
          M.window_size = 2 * M.w_size, _e(M.head), M.max_lazy_match = o[M.level].max_lazy, M.good_match = o[M.level].good_length, M.nice_match = o[M.level].nice_length, M.max_chain_length = o[M.level].max_chain, M.strstart = 0, M.block_start = 0, M.lookahead = 0, M.insert = 0, M.match_length = M.prev_length = I - 1, M.match_available = 0, M.ins_h = 0;
        }(T.state), pe;
      }
      function De(T, pe, M, _, S, O) {
        if (!T)
          return m;
        var ne = 1;
        if (pe === g && (pe = 6), _ < 0 ? (ne = 0, _ = -_) : 15 < _ && (ne = 2, _ -= 16), S < 1 || x < S || M !== w || _ < 8 || 15 < _ || pe < 0 || 9 < pe || O < 0 || b < O)
          return oe(T, m);
        _ === 8 && (_ = 9);
        var fe = new ye();
        return (T.state = fe).strm = T, fe.wrap = ne, fe.gzhead = null, fe.w_bits = _, fe.w_size = 1 << fe.w_bits, fe.w_mask = fe.w_size - 1, fe.hash_bits = S + 7, fe.hash_size = 1 << fe.hash_bits, fe.hash_mask = fe.hash_size - 1, fe.hash_shift = ~~((fe.hash_bits + I - 1) / I), fe.window = new a.Buf8(2 * fe.w_size), fe.head = new a.Buf16(fe.hash_size), fe.prev = new a.Buf16(fe.w_size), fe.lit_bufsize = 1 << S + 6, fe.pending_buf_size = 4 * fe.lit_bufsize, fe.pending_buf = new a.Buf8(fe.pending_buf_size), fe.d_buf = 1 * fe.lit_bufsize, fe.l_buf = 3 * fe.lit_bufsize, fe.level = pe, fe.strategy = O, fe.method = M, Q(T);
      }
      o = [new we(0, 0, 0, 0, function(T, pe) {
        var M = 65535;
        for (M > T.pending_buf_size - 5 && (M = T.pending_buf_size - 5); ; ) {
          if (T.lookahead <= 1) {
            if (he(T), T.lookahead === 0 && pe === d)
              return C;
            if (T.lookahead === 0)
              break;
          }
          T.strstart += T.lookahead, T.lookahead = 0;
          var _ = T.block_start + M;
          if ((T.strstart === 0 || T.strstart >= _) && (T.lookahead = T.strstart - _, T.strstart = _, N(T, !1), T.strm.avail_out === 0) || T.strstart - T.block_start >= T.w_size - be && (N(T, !1), T.strm.avail_out === 0))
            return C;
        }
        return T.insert = 0, pe === f ? (N(T, !0), T.strm.avail_out === 0 ? ee : Z) : (T.strstart > T.block_start && (N(T, !1), T.strm.avail_out), C);
      }), new we(4, 4, 8, 4, H), new we(4, 5, 16, 8, H), new we(4, 6, 32, 32, H), new we(4, 4, 16, 16, W), new we(8, 16, 32, 32, W), new we(8, 16, 128, 128, W), new we(8, 32, 128, 256, W), new we(32, 128, 258, 1024, W), new we(32, 258, 258, 4096, W)], i.deflateInit = function(T, pe) {
        return De(T, pe, w, 15, 8, 0);
      }, i.deflateInit2 = De, i.deflateReset = Q, i.deflateResetKeep = j, i.deflateSetHeader = function(T, pe) {
        return T && T.state ? T.state.wrap !== 2 ? m : (T.state.gzhead = pe, p) : m;
      }, i.deflate = function(T, pe) {
        var M, _, S, O;
        if (!T || !T.state || 5 < pe || pe < 0)
          return T ? oe(T, m) : m;
        if (_ = T.state, !T.output || !T.input && T.avail_in !== 0 || _.status === 666 && pe !== f)
          return oe(T, T.avail_out === 0 ? -5 : m);
        if (_.strm = T, M = _.last_flush, _.last_flush = pe, _.status === F)
          if (_.wrap === 2)
            T.adler = 0, ce(_, 31), ce(_, 139), ce(_, 8), _.gzhead ? (ce(_, (_.gzhead.text ? 1 : 0) + (_.gzhead.hcrc ? 2 : 0) + (_.gzhead.extra ? 4 : 0) + (_.gzhead.name ? 8 : 0) + (_.gzhead.comment ? 16 : 0)), ce(_, 255 & _.gzhead.time), ce(_, _.gzhead.time >> 8 & 255), ce(_, _.gzhead.time >> 16 & 255), ce(_, _.gzhead.time >> 24 & 255), ce(_, _.level === 9 ? 2 : 2 <= _.strategy || _.level < 2 ? 4 : 0), ce(_, 255 & _.gzhead.os), _.gzhead.extra && _.gzhead.extra.length && (ce(_, 255 & _.gzhead.extra.length), ce(_, _.gzhead.extra.length >> 8 & 255)), _.gzhead.hcrc && (T.adler = c(T.adler, _.pending_buf, _.pending, 0)), _.gzindex = 0, _.status = 69) : (ce(_, 0), ce(_, 0), ce(_, 0), ce(_, 0), ce(_, 0), ce(_, _.level === 9 ? 2 : 2 <= _.strategy || _.level < 2 ? 4 : 0), ce(_, 3), _.status = G);
          else {
            var ne = w + (_.w_bits - 8 << 4) << 8;
            ne |= (2 <= _.strategy || _.level < 2 ? 0 : _.level < 6 ? 1 : _.level === 6 ? 2 : 3) << 6, _.strstart !== 0 && (ne |= 32), ne += 31 - ne % 31, _.status = G, me(_, ne), _.strstart !== 0 && (me(_, T.adler >>> 16), me(_, 65535 & T.adler)), T.adler = 1;
          }
        if (_.status === 69)
          if (_.gzhead.extra) {
            for (S = _.pending; _.gzindex < (65535 & _.gzhead.extra.length) && (_.pending !== _.pending_buf_size || (_.gzhead.hcrc && _.pending > S && (T.adler = c(T.adler, _.pending_buf, _.pending - S, S)), q(T), S = _.pending, _.pending !== _.pending_buf_size)); )
              ce(_, 255 & _.gzhead.extra[_.gzindex]), _.gzindex++;
            _.gzhead.hcrc && _.pending > S && (T.adler = c(T.adler, _.pending_buf, _.pending - S, S)), _.gzindex === _.gzhead.extra.length && (_.gzindex = 0, _.status = 73);
          } else
            _.status = 73;
        if (_.status === 73)
          if (_.gzhead.name) {
            S = _.pending;
            do {
              if (_.pending === _.pending_buf_size && (_.gzhead.hcrc && _.pending > S && (T.adler = c(T.adler, _.pending_buf, _.pending - S, S)), q(T), S = _.pending, _.pending === _.pending_buf_size)) {
                O = 1;
                break;
              }
              O = _.gzindex < _.gzhead.name.length ? 255 & _.gzhead.name.charCodeAt(_.gzindex++) : 0, ce(_, O);
            } while (O !== 0);
            _.gzhead.hcrc && _.pending > S && (T.adler = c(T.adler, _.pending_buf, _.pending - S, S)), O === 0 && (_.gzindex = 0, _.status = 91);
          } else
            _.status = 91;
        if (_.status === 91)
          if (_.gzhead.comment) {
            S = _.pending;
            do {
              if (_.pending === _.pending_buf_size && (_.gzhead.hcrc && _.pending > S && (T.adler = c(T.adler, _.pending_buf, _.pending - S, S)), q(T), S = _.pending, _.pending === _.pending_buf_size)) {
                O = 1;
                break;
              }
              O = _.gzindex < _.gzhead.comment.length ? 255 & _.gzhead.comment.charCodeAt(_.gzindex++) : 0, ce(_, O);
            } while (O !== 0);
            _.gzhead.hcrc && _.pending > S && (T.adler = c(T.adler, _.pending_buf, _.pending - S, S)), O === 0 && (_.status = 103);
          } else
            _.status = 103;
        if (_.status === 103 && (_.gzhead.hcrc ? (_.pending + 2 > _.pending_buf_size && q(T), _.pending + 2 <= _.pending_buf_size && (ce(_, 255 & T.adler), ce(_, T.adler >> 8 & 255), T.adler = 0, _.status = G)) : _.status = G), _.pending !== 0) {
          if (q(T), T.avail_out === 0)
            return _.last_flush = -1, p;
        } else if (T.avail_in === 0 && te(pe) <= te(M) && pe !== f)
          return oe(T, -5);
        if (_.status === 666 && T.avail_in !== 0)
          return oe(T, -5);
        if (T.avail_in !== 0 || _.lookahead !== 0 || pe !== d && _.status !== 666) {
          var fe = _.strategy === 2 ? function(J, re) {
            for (var de; ; ) {
              if (J.lookahead === 0 && (he(J), J.lookahead === 0)) {
                if (re === d)
                  return C;
                break;
              }
              if (J.match_length = 0, de = s._tr_tally(J, 0, J.window[J.strstart]), J.lookahead--, J.strstart++, de && (N(J, !1), J.strm.avail_out === 0))
                return C;
            }
            return J.insert = 0, re === f ? (N(J, !0), J.strm.avail_out === 0 ? ee : Z) : J.last_lit && (N(J, !1), J.strm.avail_out === 0) ? C : ie;
          }(_, pe) : _.strategy === 3 ? function(J, re) {
            for (var de, ge, Ee, Ne, Le = J.window; ; ) {
              if (J.lookahead <= le) {
                if (he(J), J.lookahead <= le && re === d)
                  return C;
                if (J.lookahead === 0)
                  break;
              }
              if (J.match_length = 0, J.lookahead >= I && 0 < J.strstart && (ge = Le[Ee = J.strstart - 1]) === Le[++Ee] && ge === Le[++Ee] && ge === Le[++Ee]) {
                Ne = J.strstart + le;
                do
                  ;
                while (ge === Le[++Ee] && ge === Le[++Ee] && ge === Le[++Ee] && ge === Le[++Ee] && ge === Le[++Ee] && ge === Le[++Ee] && ge === Le[++Ee] && ge === Le[++Ee] && Ee < Ne);
                J.match_length = le - (Ne - Ee), J.match_length > J.lookahead && (J.match_length = J.lookahead);
              }
              if (J.match_length >= I ? (de = s._tr_tally(J, 1, J.match_length - I), J.lookahead -= J.match_length, J.strstart += J.match_length, J.match_length = 0) : (de = s._tr_tally(J, 0, J.window[J.strstart]), J.lookahead--, J.strstart++), de && (N(J, !1), J.strm.avail_out === 0))
                return C;
            }
            return J.insert = 0, re === f ? (N(J, !0), J.strm.avail_out === 0 ? ee : Z) : J.last_lit && (N(J, !1), J.strm.avail_out === 0) ? C : ie;
          }(_, pe) : o[_.level].func(_, pe);
          if (fe !== ee && fe !== Z || (_.status = 666), fe === C || fe === ee)
            return T.avail_out === 0 && (_.last_flush = -1), p;
          if (fe === ie && (pe === 1 ? s._tr_align(_) : pe !== 5 && (s._tr_stored_block(_, 0, 0, !1), pe === 3 && (_e(_.head), _.lookahead === 0 && (_.strstart = 0, _.block_start = 0, _.insert = 0))), q(T), T.avail_out === 0))
            return _.last_flush = -1, p;
        }
        return pe !== f ? p : _.wrap <= 0 ? 1 : (_.wrap === 2 ? (ce(_, 255 & T.adler), ce(_, T.adler >> 8 & 255), ce(_, T.adler >> 16 & 255), ce(_, T.adler >> 24 & 255), ce(_, 255 & T.total_in), ce(_, T.total_in >> 8 & 255), ce(_, T.total_in >> 16 & 255), ce(_, T.total_in >> 24 & 255)) : (me(_, T.adler >>> 16), me(_, 65535 & T.adler)), q(T), 0 < _.wrap && (_.wrap = -_.wrap), _.pending !== 0 ? p : 1);
      }, i.deflateEnd = function(T) {
        var pe;
        return T && T.state ? (pe = T.state.status) !== F && pe !== 69 && pe !== 73 && pe !== 91 && pe !== 103 && pe !== G && pe !== 666 ? oe(T, m) : (T.state = null, pe === G ? oe(T, -3) : p) : m;
      }, i.deflateSetDictionary = function(T, pe) {
        var M, _, S, O, ne, fe, J, re, de = pe.length;
        if (!T || !T.state || (O = (M = T.state).wrap) === 2 || O === 1 && M.status !== F || M.lookahead)
          return m;
        for (O === 1 && (T.adler = l(T.adler, pe, de, 0)), M.wrap = 0, de >= M.w_size && (O === 0 && (_e(M.head), M.strstart = 0, M.block_start = 0, M.insert = 0), re = new a.Buf8(M.w_size), a.arraySet(re, pe, de - M.w_size, M.w_size, 0), pe = re, de = M.w_size), ne = T.avail_in, fe = T.next_in, J = T.input, T.avail_in = de, T.next_in = 0, T.input = pe, he(M); M.lookahead >= I; ) {
          for (_ = M.strstart, S = M.lookahead - (I - 1); M.ins_h = (M.ins_h << M.hash_shift ^ M.window[_ + I - 1]) & M.hash_mask, M.prev[_ & M.w_mask] = M.head[M.ins_h], M.head[M.ins_h] = _, _++, --S; )
            ;
          M.strstart = _, M.lookahead = I - 1, he(M);
        }
        return M.strstart += M.lookahead, M.block_start = M.strstart, M.insert = M.lookahead, M.lookahead = 0, M.match_length = M.prev_length = I - 1, M.match_available = 0, T.next_in = fe, T.input = J, T.avail_in = ne, M.wrap = O, p;
      }, i.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(n, r, i) {
      r.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(n, r, i) {
      r.exports = function(o, a) {
        var s, l, c, u, d, f, p, m, g, b, y, w, x, k, A, U, P, V, I, le, be, F, G, C, ie;
        s = o.state, l = o.next_in, C = o.input, c = l + (o.avail_in - 5), u = o.next_out, ie = o.output, d = u - (a - o.avail_out), f = u + (o.avail_out - 257), p = s.dmax, m = s.wsize, g = s.whave, b = s.wnext, y = s.window, w = s.hold, x = s.bits, k = s.lencode, A = s.distcode, U = (1 << s.lenbits) - 1, P = (1 << s.distbits) - 1;
        e:
          do {
            x < 15 && (w += C[l++] << x, x += 8, w += C[l++] << x, x += 8), V = k[w & U];
            t:
              for (; ; ) {
                if (w >>>= I = V >>> 24, x -= I, (I = V >>> 16 & 255) === 0)
                  ie[u++] = 65535 & V;
                else {
                  if (!(16 & I)) {
                    if (!(64 & I)) {
                      V = k[(65535 & V) + (w & (1 << I) - 1)];
                      continue t;
                    }
                    if (32 & I) {
                      s.mode = 12;
                      break e;
                    }
                    o.msg = "invalid literal/length code", s.mode = 30;
                    break e;
                  }
                  le = 65535 & V, (I &= 15) && (x < I && (w += C[l++] << x, x += 8), le += w & (1 << I) - 1, w >>>= I, x -= I), x < 15 && (w += C[l++] << x, x += 8, w += C[l++] << x, x += 8), V = A[w & P];
                  n:
                    for (; ; ) {
                      if (w >>>= I = V >>> 24, x -= I, !(16 & (I = V >>> 16 & 255))) {
                        if (!(64 & I)) {
                          V = A[(65535 & V) + (w & (1 << I) - 1)];
                          continue n;
                        }
                        o.msg = "invalid distance code", s.mode = 30;
                        break e;
                      }
                      if (be = 65535 & V, x < (I &= 15) && (w += C[l++] << x, (x += 8) < I && (w += C[l++] << x, x += 8)), p < (be += w & (1 << I) - 1)) {
                        o.msg = "invalid distance too far back", s.mode = 30;
                        break e;
                      }
                      if (w >>>= I, x -= I, (I = u - d) < be) {
                        if (g < (I = be - I) && s.sane) {
                          o.msg = "invalid distance too far back", s.mode = 30;
                          break e;
                        }
                        if (G = y, (F = 0) === b) {
                          if (F += m - I, I < le) {
                            for (le -= I; ie[u++] = y[F++], --I; )
                              ;
                            F = u - be, G = ie;
                          }
                        } else if (b < I) {
                          if (F += m + b - I, (I -= b) < le) {
                            for (le -= I; ie[u++] = y[F++], --I; )
                              ;
                            if (F = 0, b < le) {
                              for (le -= I = b; ie[u++] = y[F++], --I; )
                                ;
                              F = u - be, G = ie;
                            }
                          }
                        } else if (F += b - I, I < le) {
                          for (le -= I; ie[u++] = y[F++], --I; )
                            ;
                          F = u - be, G = ie;
                        }
                        for (; 2 < le; )
                          ie[u++] = G[F++], ie[u++] = G[F++], ie[u++] = G[F++], le -= 3;
                        le && (ie[u++] = G[F++], 1 < le && (ie[u++] = G[F++]));
                      } else {
                        for (F = u - be; ie[u++] = ie[F++], ie[u++] = ie[F++], ie[u++] = ie[F++], 2 < (le -= 3); )
                          ;
                        le && (ie[u++] = ie[F++], 1 < le && (ie[u++] = ie[F++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (l < c && u < f);
        l -= le = x >> 3, w &= (1 << (x -= le << 3)) - 1, o.next_in = l, o.next_out = u, o.avail_in = l < c ? c - l + 5 : 5 - (l - c), o.avail_out = u < f ? f - u + 257 : 257 - (u - f), s.hold = w, s.bits = x;
      };
    }, {}], 49: [function(n, r, i) {
      var o = n("../utils/common"), a = n("./adler32"), s = n("./crc32"), l = n("./inffast"), c = n("./inftrees"), u = 1, d = 2, f = 0, p = -2, m = 1, g = 852, b = 592;
      function y(F) {
        return (F >>> 24 & 255) + (F >>> 8 & 65280) + ((65280 & F) << 8) + ((255 & F) << 24);
      }
      function w() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new o.Buf16(320), this.work = new o.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function x(F) {
        var G;
        return F && F.state ? (G = F.state, F.total_in = F.total_out = G.total = 0, F.msg = "", G.wrap && (F.adler = 1 & G.wrap), G.mode = m, G.last = 0, G.havedict = 0, G.dmax = 32768, G.head = null, G.hold = 0, G.bits = 0, G.lencode = G.lendyn = new o.Buf32(g), G.distcode = G.distdyn = new o.Buf32(b), G.sane = 1, G.back = -1, f) : p;
      }
      function k(F) {
        var G;
        return F && F.state ? ((G = F.state).wsize = 0, G.whave = 0, G.wnext = 0, x(F)) : p;
      }
      function A(F, G) {
        var C, ie;
        return F && F.state ? (ie = F.state, G < 0 ? (C = 0, G = -G) : (C = 1 + (G >> 4), G < 48 && (G &= 15)), G && (G < 8 || 15 < G) ? p : (ie.window !== null && ie.wbits !== G && (ie.window = null), ie.wrap = C, ie.wbits = G, k(F))) : p;
      }
      function U(F, G) {
        var C, ie;
        return F ? (ie = new w(), (F.state = ie).window = null, (C = A(F, G)) !== f && (F.state = null), C) : p;
      }
      var P, V, I = !0;
      function le(F) {
        if (I) {
          var G;
          for (P = new o.Buf32(512), V = new o.Buf32(32), G = 0; G < 144; )
            F.lens[G++] = 8;
          for (; G < 256; )
            F.lens[G++] = 9;
          for (; G < 280; )
            F.lens[G++] = 7;
          for (; G < 288; )
            F.lens[G++] = 8;
          for (c(u, F.lens, 0, 288, P, 0, F.work, { bits: 9 }), G = 0; G < 32; )
            F.lens[G++] = 5;
          c(d, F.lens, 0, 32, V, 0, F.work, { bits: 5 }), I = !1;
        }
        F.lencode = P, F.lenbits = 9, F.distcode = V, F.distbits = 5;
      }
      function be(F, G, C, ie) {
        var ee, Z = F.state;
        return Z.window === null && (Z.wsize = 1 << Z.wbits, Z.wnext = 0, Z.whave = 0, Z.window = new o.Buf8(Z.wsize)), ie >= Z.wsize ? (o.arraySet(Z.window, G, C - Z.wsize, Z.wsize, 0), Z.wnext = 0, Z.whave = Z.wsize) : (ie < (ee = Z.wsize - Z.wnext) && (ee = ie), o.arraySet(Z.window, G, C - ie, ee, Z.wnext), (ie -= ee) ? (o.arraySet(Z.window, G, C - ie, ie, 0), Z.wnext = ie, Z.whave = Z.wsize) : (Z.wnext += ee, Z.wnext === Z.wsize && (Z.wnext = 0), Z.whave < Z.wsize && (Z.whave += ee))), 0;
      }
      i.inflateReset = k, i.inflateReset2 = A, i.inflateResetKeep = x, i.inflateInit = function(F) {
        return U(F, 15);
      }, i.inflateInit2 = U, i.inflate = function(F, G) {
        var C, ie, ee, Z, oe, te, _e, q, N, ce, me, ve, he, H, W, we, ye, j, Q, De, T, pe, M, _, S = 0, O = new o.Buf8(4), ne = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!F || !F.state || !F.output || !F.input && F.avail_in !== 0)
          return p;
        (C = F.state).mode === 12 && (C.mode = 13), oe = F.next_out, ee = F.output, _e = F.avail_out, Z = F.next_in, ie = F.input, te = F.avail_in, q = C.hold, N = C.bits, ce = te, me = _e, pe = f;
        e:
          for (; ; )
            switch (C.mode) {
              case m:
                if (C.wrap === 0) {
                  C.mode = 13;
                  break;
                }
                for (; N < 16; ) {
                  if (te === 0)
                    break e;
                  te--, q += ie[Z++] << N, N += 8;
                }
                if (2 & C.wrap && q === 35615) {
                  O[C.check = 0] = 255 & q, O[1] = q >>> 8 & 255, C.check = s(C.check, O, 2, 0), N = q = 0, C.mode = 2;
                  break;
                }
                if (C.flags = 0, C.head && (C.head.done = !1), !(1 & C.wrap) || (((255 & q) << 8) + (q >> 8)) % 31) {
                  F.msg = "incorrect header check", C.mode = 30;
                  break;
                }
                if ((15 & q) != 8) {
                  F.msg = "unknown compression method", C.mode = 30;
                  break;
                }
                if (N -= 4, T = 8 + (15 & (q >>>= 4)), C.wbits === 0)
                  C.wbits = T;
                else if (T > C.wbits) {
                  F.msg = "invalid window size", C.mode = 30;
                  break;
                }
                C.dmax = 1 << T, F.adler = C.check = 1, C.mode = 512 & q ? 10 : 12, N = q = 0;
                break;
              case 2:
                for (; N < 16; ) {
                  if (te === 0)
                    break e;
                  te--, q += ie[Z++] << N, N += 8;
                }
                if (C.flags = q, (255 & C.flags) != 8) {
                  F.msg = "unknown compression method", C.mode = 30;
                  break;
                }
                if (57344 & C.flags) {
                  F.msg = "unknown header flags set", C.mode = 30;
                  break;
                }
                C.head && (C.head.text = q >> 8 & 1), 512 & C.flags && (O[0] = 255 & q, O[1] = q >>> 8 & 255, C.check = s(C.check, O, 2, 0)), N = q = 0, C.mode = 3;
              case 3:
                for (; N < 32; ) {
                  if (te === 0)
                    break e;
                  te--, q += ie[Z++] << N, N += 8;
                }
                C.head && (C.head.time = q), 512 & C.flags && (O[0] = 255 & q, O[1] = q >>> 8 & 255, O[2] = q >>> 16 & 255, O[3] = q >>> 24 & 255, C.check = s(C.check, O, 4, 0)), N = q = 0, C.mode = 4;
              case 4:
                for (; N < 16; ) {
                  if (te === 0)
                    break e;
                  te--, q += ie[Z++] << N, N += 8;
                }
                C.head && (C.head.xflags = 255 & q, C.head.os = q >> 8), 512 & C.flags && (O[0] = 255 & q, O[1] = q >>> 8 & 255, C.check = s(C.check, O, 2, 0)), N = q = 0, C.mode = 5;
              case 5:
                if (1024 & C.flags) {
                  for (; N < 16; ) {
                    if (te === 0)
                      break e;
                    te--, q += ie[Z++] << N, N += 8;
                  }
                  C.length = q, C.head && (C.head.extra_len = q), 512 & C.flags && (O[0] = 255 & q, O[1] = q >>> 8 & 255, C.check = s(C.check, O, 2, 0)), N = q = 0;
                } else
                  C.head && (C.head.extra = null);
                C.mode = 6;
              case 6:
                if (1024 & C.flags && (te < (ve = C.length) && (ve = te), ve && (C.head && (T = C.head.extra_len - C.length, C.head.extra || (C.head.extra = new Array(C.head.extra_len)), o.arraySet(C.head.extra, ie, Z, ve, T)), 512 & C.flags && (C.check = s(C.check, ie, ve, Z)), te -= ve, Z += ve, C.length -= ve), C.length))
                  break e;
                C.length = 0, C.mode = 7;
              case 7:
                if (2048 & C.flags) {
                  if (te === 0)
                    break e;
                  for (ve = 0; T = ie[Z + ve++], C.head && T && C.length < 65536 && (C.head.name += String.fromCharCode(T)), T && ve < te; )
                    ;
                  if (512 & C.flags && (C.check = s(C.check, ie, ve, Z)), te -= ve, Z += ve, T)
                    break e;
                } else
                  C.head && (C.head.name = null);
                C.length = 0, C.mode = 8;
              case 8:
                if (4096 & C.flags) {
                  if (te === 0)
                    break e;
                  for (ve = 0; T = ie[Z + ve++], C.head && T && C.length < 65536 && (C.head.comment += String.fromCharCode(T)), T && ve < te; )
                    ;
                  if (512 & C.flags && (C.check = s(C.check, ie, ve, Z)), te -= ve, Z += ve, T)
                    break e;
                } else
                  C.head && (C.head.comment = null);
                C.mode = 9;
              case 9:
                if (512 & C.flags) {
                  for (; N < 16; ) {
                    if (te === 0)
                      break e;
                    te--, q += ie[Z++] << N, N += 8;
                  }
                  if (q !== (65535 & C.check)) {
                    F.msg = "header crc mismatch", C.mode = 30;
                    break;
                  }
                  N = q = 0;
                }
                C.head && (C.head.hcrc = C.flags >> 9 & 1, C.head.done = !0), F.adler = C.check = 0, C.mode = 12;
                break;
              case 10:
                for (; N < 32; ) {
                  if (te === 0)
                    break e;
                  te--, q += ie[Z++] << N, N += 8;
                }
                F.adler = C.check = y(q), N = q = 0, C.mode = 11;
              case 11:
                if (C.havedict === 0)
                  return F.next_out = oe, F.avail_out = _e, F.next_in = Z, F.avail_in = te, C.hold = q, C.bits = N, 2;
                F.adler = C.check = 1, C.mode = 12;
              case 12:
                if (G === 5 || G === 6)
                  break e;
              case 13:
                if (C.last) {
                  q >>>= 7 & N, N -= 7 & N, C.mode = 27;
                  break;
                }
                for (; N < 3; ) {
                  if (te === 0)
                    break e;
                  te--, q += ie[Z++] << N, N += 8;
                }
                switch (C.last = 1 & q, N -= 1, 3 & (q >>>= 1)) {
                  case 0:
                    C.mode = 14;
                    break;
                  case 1:
                    if (le(C), C.mode = 20, G !== 6)
                      break;
                    q >>>= 2, N -= 2;
                    break e;
                  case 2:
                    C.mode = 17;
                    break;
                  case 3:
                    F.msg = "invalid block type", C.mode = 30;
                }
                q >>>= 2, N -= 2;
                break;
              case 14:
                for (q >>>= 7 & N, N -= 7 & N; N < 32; ) {
                  if (te === 0)
                    break e;
                  te--, q += ie[Z++] << N, N += 8;
                }
                if ((65535 & q) != (q >>> 16 ^ 65535)) {
                  F.msg = "invalid stored block lengths", C.mode = 30;
                  break;
                }
                if (C.length = 65535 & q, N = q = 0, C.mode = 15, G === 6)
                  break e;
              case 15:
                C.mode = 16;
              case 16:
                if (ve = C.length) {
                  if (te < ve && (ve = te), _e < ve && (ve = _e), ve === 0)
                    break e;
                  o.arraySet(ee, ie, Z, ve, oe), te -= ve, Z += ve, _e -= ve, oe += ve, C.length -= ve;
                  break;
                }
                C.mode = 12;
                break;
              case 17:
                for (; N < 14; ) {
                  if (te === 0)
                    break e;
                  te--, q += ie[Z++] << N, N += 8;
                }
                if (C.nlen = 257 + (31 & q), q >>>= 5, N -= 5, C.ndist = 1 + (31 & q), q >>>= 5, N -= 5, C.ncode = 4 + (15 & q), q >>>= 4, N -= 4, 286 < C.nlen || 30 < C.ndist) {
                  F.msg = "too many length or distance symbols", C.mode = 30;
                  break;
                }
                C.have = 0, C.mode = 18;
              case 18:
                for (; C.have < C.ncode; ) {
                  for (; N < 3; ) {
                    if (te === 0)
                      break e;
                    te--, q += ie[Z++] << N, N += 8;
                  }
                  C.lens[ne[C.have++]] = 7 & q, q >>>= 3, N -= 3;
                }
                for (; C.have < 19; )
                  C.lens[ne[C.have++]] = 0;
                if (C.lencode = C.lendyn, C.lenbits = 7, M = { bits: C.lenbits }, pe = c(0, C.lens, 0, 19, C.lencode, 0, C.work, M), C.lenbits = M.bits, pe) {
                  F.msg = "invalid code lengths set", C.mode = 30;
                  break;
                }
                C.have = 0, C.mode = 19;
              case 19:
                for (; C.have < C.nlen + C.ndist; ) {
                  for (; we = (S = C.lencode[q & (1 << C.lenbits) - 1]) >>> 16 & 255, ye = 65535 & S, !((W = S >>> 24) <= N); ) {
                    if (te === 0)
                      break e;
                    te--, q += ie[Z++] << N, N += 8;
                  }
                  if (ye < 16)
                    q >>>= W, N -= W, C.lens[C.have++] = ye;
                  else {
                    if (ye === 16) {
                      for (_ = W + 2; N < _; ) {
                        if (te === 0)
                          break e;
                        te--, q += ie[Z++] << N, N += 8;
                      }
                      if (q >>>= W, N -= W, C.have === 0) {
                        F.msg = "invalid bit length repeat", C.mode = 30;
                        break;
                      }
                      T = C.lens[C.have - 1], ve = 3 + (3 & q), q >>>= 2, N -= 2;
                    } else if (ye === 17) {
                      for (_ = W + 3; N < _; ) {
                        if (te === 0)
                          break e;
                        te--, q += ie[Z++] << N, N += 8;
                      }
                      N -= W, T = 0, ve = 3 + (7 & (q >>>= W)), q >>>= 3, N -= 3;
                    } else {
                      for (_ = W + 7; N < _; ) {
                        if (te === 0)
                          break e;
                        te--, q += ie[Z++] << N, N += 8;
                      }
                      N -= W, T = 0, ve = 11 + (127 & (q >>>= W)), q >>>= 7, N -= 7;
                    }
                    if (C.have + ve > C.nlen + C.ndist) {
                      F.msg = "invalid bit length repeat", C.mode = 30;
                      break;
                    }
                    for (; ve--; )
                      C.lens[C.have++] = T;
                  }
                }
                if (C.mode === 30)
                  break;
                if (C.lens[256] === 0) {
                  F.msg = "invalid code -- missing end-of-block", C.mode = 30;
                  break;
                }
                if (C.lenbits = 9, M = { bits: C.lenbits }, pe = c(u, C.lens, 0, C.nlen, C.lencode, 0, C.work, M), C.lenbits = M.bits, pe) {
                  F.msg = "invalid literal/lengths set", C.mode = 30;
                  break;
                }
                if (C.distbits = 6, C.distcode = C.distdyn, M = { bits: C.distbits }, pe = c(d, C.lens, C.nlen, C.ndist, C.distcode, 0, C.work, M), C.distbits = M.bits, pe) {
                  F.msg = "invalid distances set", C.mode = 30;
                  break;
                }
                if (C.mode = 20, G === 6)
                  break e;
              case 20:
                C.mode = 21;
              case 21:
                if (6 <= te && 258 <= _e) {
                  F.next_out = oe, F.avail_out = _e, F.next_in = Z, F.avail_in = te, C.hold = q, C.bits = N, l(F, me), oe = F.next_out, ee = F.output, _e = F.avail_out, Z = F.next_in, ie = F.input, te = F.avail_in, q = C.hold, N = C.bits, C.mode === 12 && (C.back = -1);
                  break;
                }
                for (C.back = 0; we = (S = C.lencode[q & (1 << C.lenbits) - 1]) >>> 16 & 255, ye = 65535 & S, !((W = S >>> 24) <= N); ) {
                  if (te === 0)
                    break e;
                  te--, q += ie[Z++] << N, N += 8;
                }
                if (we && !(240 & we)) {
                  for (j = W, Q = we, De = ye; we = (S = C.lencode[De + ((q & (1 << j + Q) - 1) >> j)]) >>> 16 & 255, ye = 65535 & S, !(j + (W = S >>> 24) <= N); ) {
                    if (te === 0)
                      break e;
                    te--, q += ie[Z++] << N, N += 8;
                  }
                  q >>>= j, N -= j, C.back += j;
                }
                if (q >>>= W, N -= W, C.back += W, C.length = ye, we === 0) {
                  C.mode = 26;
                  break;
                }
                if (32 & we) {
                  C.back = -1, C.mode = 12;
                  break;
                }
                if (64 & we) {
                  F.msg = "invalid literal/length code", C.mode = 30;
                  break;
                }
                C.extra = 15 & we, C.mode = 22;
              case 22:
                if (C.extra) {
                  for (_ = C.extra; N < _; ) {
                    if (te === 0)
                      break e;
                    te--, q += ie[Z++] << N, N += 8;
                  }
                  C.length += q & (1 << C.extra) - 1, q >>>= C.extra, N -= C.extra, C.back += C.extra;
                }
                C.was = C.length, C.mode = 23;
              case 23:
                for (; we = (S = C.distcode[q & (1 << C.distbits) - 1]) >>> 16 & 255, ye = 65535 & S, !((W = S >>> 24) <= N); ) {
                  if (te === 0)
                    break e;
                  te--, q += ie[Z++] << N, N += 8;
                }
                if (!(240 & we)) {
                  for (j = W, Q = we, De = ye; we = (S = C.distcode[De + ((q & (1 << j + Q) - 1) >> j)]) >>> 16 & 255, ye = 65535 & S, !(j + (W = S >>> 24) <= N); ) {
                    if (te === 0)
                      break e;
                    te--, q += ie[Z++] << N, N += 8;
                  }
                  q >>>= j, N -= j, C.back += j;
                }
                if (q >>>= W, N -= W, C.back += W, 64 & we) {
                  F.msg = "invalid distance code", C.mode = 30;
                  break;
                }
                C.offset = ye, C.extra = 15 & we, C.mode = 24;
              case 24:
                if (C.extra) {
                  for (_ = C.extra; N < _; ) {
                    if (te === 0)
                      break e;
                    te--, q += ie[Z++] << N, N += 8;
                  }
                  C.offset += q & (1 << C.extra) - 1, q >>>= C.extra, N -= C.extra, C.back += C.extra;
                }
                if (C.offset > C.dmax) {
                  F.msg = "invalid distance too far back", C.mode = 30;
                  break;
                }
                C.mode = 25;
              case 25:
                if (_e === 0)
                  break e;
                if (ve = me - _e, C.offset > ve) {
                  if ((ve = C.offset - ve) > C.whave && C.sane) {
                    F.msg = "invalid distance too far back", C.mode = 30;
                    break;
                  }
                  he = ve > C.wnext ? (ve -= C.wnext, C.wsize - ve) : C.wnext - ve, ve > C.length && (ve = C.length), H = C.window;
                } else
                  H = ee, he = oe - C.offset, ve = C.length;
                for (_e < ve && (ve = _e), _e -= ve, C.length -= ve; ee[oe++] = H[he++], --ve; )
                  ;
                C.length === 0 && (C.mode = 21);
                break;
              case 26:
                if (_e === 0)
                  break e;
                ee[oe++] = C.length, _e--, C.mode = 21;
                break;
              case 27:
                if (C.wrap) {
                  for (; N < 32; ) {
                    if (te === 0)
                      break e;
                    te--, q |= ie[Z++] << N, N += 8;
                  }
                  if (me -= _e, F.total_out += me, C.total += me, me && (F.adler = C.check = C.flags ? s(C.check, ee, me, oe - me) : a(C.check, ee, me, oe - me)), me = _e, (C.flags ? q : y(q)) !== C.check) {
                    F.msg = "incorrect data check", C.mode = 30;
                    break;
                  }
                  N = q = 0;
                }
                C.mode = 28;
              case 28:
                if (C.wrap && C.flags) {
                  for (; N < 32; ) {
                    if (te === 0)
                      break e;
                    te--, q += ie[Z++] << N, N += 8;
                  }
                  if (q !== (4294967295 & C.total)) {
                    F.msg = "incorrect length check", C.mode = 30;
                    break;
                  }
                  N = q = 0;
                }
                C.mode = 29;
              case 29:
                pe = 1;
                break e;
              case 30:
                pe = -3;
                break e;
              case 31:
                return -4;
              case 32:
              default:
                return p;
            }
        return F.next_out = oe, F.avail_out = _e, F.next_in = Z, F.avail_in = te, C.hold = q, C.bits = N, (C.wsize || me !== F.avail_out && C.mode < 30 && (C.mode < 27 || G !== 4)) && be(F, F.output, F.next_out, me - F.avail_out) ? (C.mode = 31, -4) : (ce -= F.avail_in, me -= F.avail_out, F.total_in += ce, F.total_out += me, C.total += me, C.wrap && me && (F.adler = C.check = C.flags ? s(C.check, ee, me, F.next_out - me) : a(C.check, ee, me, F.next_out - me)), F.data_type = C.bits + (C.last ? 64 : 0) + (C.mode === 12 ? 128 : 0) + (C.mode === 20 || C.mode === 15 ? 256 : 0), (ce == 0 && me === 0 || G === 4) && pe === f && (pe = -5), pe);
      }, i.inflateEnd = function(F) {
        if (!F || !F.state)
          return p;
        var G = F.state;
        return G.window && (G.window = null), F.state = null, f;
      }, i.inflateGetHeader = function(F, G) {
        var C;
        return F && F.state && 2 & (C = F.state).wrap ? ((C.head = G).done = !1, f) : p;
      }, i.inflateSetDictionary = function(F, G) {
        var C, ie = G.length;
        return F && F.state ? (C = F.state).wrap !== 0 && C.mode !== 11 ? p : C.mode === 11 && a(1, G, ie, 0) !== C.check ? -3 : be(F, G, ie, ie) ? (C.mode = 31, -4) : (C.havedict = 1, f) : p;
      }, i.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(n, r, i) {
      var o = n("../utils/common"), a = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], s = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      r.exports = function(u, d, f, p, m, g, b, y) {
        var w, x, k, A, U, P, V, I, le, be = y.bits, F = 0, G = 0, C = 0, ie = 0, ee = 0, Z = 0, oe = 0, te = 0, _e = 0, q = 0, N = null, ce = 0, me = new o.Buf16(16), ve = new o.Buf16(16), he = null, H = 0;
        for (F = 0; F <= 15; F++)
          me[F] = 0;
        for (G = 0; G < p; G++)
          me[d[f + G]]++;
        for (ee = be, ie = 15; 1 <= ie && me[ie] === 0; ie--)
          ;
        if (ie < ee && (ee = ie), ie === 0)
          return m[g++] = 20971520, m[g++] = 20971520, y.bits = 1, 0;
        for (C = 1; C < ie && me[C] === 0; C++)
          ;
        for (ee < C && (ee = C), F = te = 1; F <= 15; F++)
          if (te <<= 1, (te -= me[F]) < 0)
            return -1;
        if (0 < te && (u === 0 || ie !== 1))
          return -1;
        for (ve[1] = 0, F = 1; F < 15; F++)
          ve[F + 1] = ve[F] + me[F];
        for (G = 0; G < p; G++)
          d[f + G] !== 0 && (b[ve[d[f + G]]++] = G);
        if (P = u === 0 ? (N = he = b, 19) : u === 1 ? (N = a, ce -= 257, he = s, H -= 257, 256) : (N = l, he = c, -1), F = C, U = g, oe = G = q = 0, k = -1, A = (_e = 1 << (Z = ee)) - 1, u === 1 && 852 < _e || u === 2 && 592 < _e)
          return 1;
        for (; ; ) {
          for (V = F - oe, le = b[G] < P ? (I = 0, b[G]) : b[G] > P ? (I = he[H + b[G]], N[ce + b[G]]) : (I = 96, 0), w = 1 << F - oe, C = x = 1 << Z; m[U + (q >> oe) + (x -= w)] = V << 24 | I << 16 | le | 0, x !== 0; )
            ;
          for (w = 1 << F - 1; q & w; )
            w >>= 1;
          if (w !== 0 ? (q &= w - 1, q += w) : q = 0, G++, --me[F] == 0) {
            if (F === ie)
              break;
            F = d[f + b[G]];
          }
          if (ee < F && (q & A) !== k) {
            for (oe === 0 && (oe = ee), U += C, te = 1 << (Z = F - oe); Z + oe < ie && !((te -= me[Z + oe]) <= 0); )
              Z++, te <<= 1;
            if (_e += 1 << Z, u === 1 && 852 < _e || u === 2 && 592 < _e)
              return 1;
            m[k = q & A] = ee << 24 | Z << 16 | U - g | 0;
          }
        }
        return q !== 0 && (m[U + q] = F - oe << 24 | 64 << 16 | 0), y.bits = ee, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(n, r, i) {
      r.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(n, r, i) {
      var o = n("../utils/common"), a = 0, s = 1;
      function l(S) {
        for (var O = S.length; 0 <= --O; )
          S[O] = 0;
      }
      var c = 0, u = 29, d = 256, f = d + 1 + u, p = 30, m = 19, g = 2 * f + 1, b = 15, y = 16, w = 7, x = 256, k = 16, A = 17, U = 18, P = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], V = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], I = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], le = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], be = new Array(2 * (f + 2));
      l(be);
      var F = new Array(2 * p);
      l(F);
      var G = new Array(512);
      l(G);
      var C = new Array(256);
      l(C);
      var ie = new Array(u);
      l(ie);
      var ee, Z, oe, te = new Array(p);
      function _e(S, O, ne, fe, J) {
        this.static_tree = S, this.extra_bits = O, this.extra_base = ne, this.elems = fe, this.max_length = J, this.has_stree = S && S.length;
      }
      function q(S, O) {
        this.dyn_tree = S, this.max_code = 0, this.stat_desc = O;
      }
      function N(S) {
        return S < 256 ? G[S] : G[256 + (S >>> 7)];
      }
      function ce(S, O) {
        S.pending_buf[S.pending++] = 255 & O, S.pending_buf[S.pending++] = O >>> 8 & 255;
      }
      function me(S, O, ne) {
        S.bi_valid > y - ne ? (S.bi_buf |= O << S.bi_valid & 65535, ce(S, S.bi_buf), S.bi_buf = O >> y - S.bi_valid, S.bi_valid += ne - y) : (S.bi_buf |= O << S.bi_valid & 65535, S.bi_valid += ne);
      }
      function ve(S, O, ne) {
        me(S, ne[2 * O], ne[2 * O + 1]);
      }
      function he(S, O) {
        for (var ne = 0; ne |= 1 & S, S >>>= 1, ne <<= 1, 0 < --O; )
          ;
        return ne >>> 1;
      }
      function H(S, O, ne) {
        var fe, J, re = new Array(b + 1), de = 0;
        for (fe = 1; fe <= b; fe++)
          re[fe] = de = de + ne[fe - 1] << 1;
        for (J = 0; J <= O; J++) {
          var ge = S[2 * J + 1];
          ge !== 0 && (S[2 * J] = he(re[ge]++, ge));
        }
      }
      function W(S) {
        var O;
        for (O = 0; O < f; O++)
          S.dyn_ltree[2 * O] = 0;
        for (O = 0; O < p; O++)
          S.dyn_dtree[2 * O] = 0;
        for (O = 0; O < m; O++)
          S.bl_tree[2 * O] = 0;
        S.dyn_ltree[2 * x] = 1, S.opt_len = S.static_len = 0, S.last_lit = S.matches = 0;
      }
      function we(S) {
        8 < S.bi_valid ? ce(S, S.bi_buf) : 0 < S.bi_valid && (S.pending_buf[S.pending++] = S.bi_buf), S.bi_buf = 0, S.bi_valid = 0;
      }
      function ye(S, O, ne, fe) {
        var J = 2 * O, re = 2 * ne;
        return S[J] < S[re] || S[J] === S[re] && fe[O] <= fe[ne];
      }
      function j(S, O, ne) {
        for (var fe = S.heap[ne], J = ne << 1; J <= S.heap_len && (J < S.heap_len && ye(O, S.heap[J + 1], S.heap[J], S.depth) && J++, !ye(O, fe, S.heap[J], S.depth)); )
          S.heap[ne] = S.heap[J], ne = J, J <<= 1;
        S.heap[ne] = fe;
      }
      function Q(S, O, ne) {
        var fe, J, re, de, ge = 0;
        if (S.last_lit !== 0)
          for (; fe = S.pending_buf[S.d_buf + 2 * ge] << 8 | S.pending_buf[S.d_buf + 2 * ge + 1], J = S.pending_buf[S.l_buf + ge], ge++, fe === 0 ? ve(S, J, O) : (ve(S, (re = C[J]) + d + 1, O), (de = P[re]) !== 0 && me(S, J -= ie[re], de), ve(S, re = N(--fe), ne), (de = V[re]) !== 0 && me(S, fe -= te[re], de)), ge < S.last_lit; )
            ;
        ve(S, x, O);
      }
      function De(S, O) {
        var ne, fe, J, re = O.dyn_tree, de = O.stat_desc.static_tree, ge = O.stat_desc.has_stree, Ee = O.stat_desc.elems, Ne = -1;
        for (S.heap_len = 0, S.heap_max = g, ne = 0; ne < Ee; ne++)
          re[2 * ne] !== 0 ? (S.heap[++S.heap_len] = Ne = ne, S.depth[ne] = 0) : re[2 * ne + 1] = 0;
        for (; S.heap_len < 2; )
          re[2 * (J = S.heap[++S.heap_len] = Ne < 2 ? ++Ne : 0)] = 1, S.depth[J] = 0, S.opt_len--, ge && (S.static_len -= de[2 * J + 1]);
        for (O.max_code = Ne, ne = S.heap_len >> 1; 1 <= ne; ne--)
          j(S, re, ne);
        for (J = Ee; ne = S.heap[1], S.heap[1] = S.heap[S.heap_len--], j(S, re, 1), fe = S.heap[1], S.heap[--S.heap_max] = ne, S.heap[--S.heap_max] = fe, re[2 * J] = re[2 * ne] + re[2 * fe], S.depth[J] = (S.depth[ne] >= S.depth[fe] ? S.depth[ne] : S.depth[fe]) + 1, re[2 * ne + 1] = re[2 * fe + 1] = J, S.heap[1] = J++, j(S, re, 1), 2 <= S.heap_len; )
          ;
        S.heap[--S.heap_max] = S.heap[1], function(Le, Qe) {
          var Ze, at, gt, et, Zt, Un, Ft = Qe.dyn_tree, Ar = Qe.max_code, Ii = Qe.stat_desc.static_tree, xn = Qe.stat_desc.has_stree, Bn = Qe.stat_desc.extra_bits, Ln = Qe.stat_desc.extra_base, ht = Qe.stat_desc.max_length, _n = 0;
          for (et = 0; et <= b; et++)
            Le.bl_count[et] = 0;
          for (Ft[2 * Le.heap[Le.heap_max] + 1] = 0, Ze = Le.heap_max + 1; Ze < g; Ze++)
            ht < (et = Ft[2 * Ft[2 * (at = Le.heap[Ze]) + 1] + 1] + 1) && (et = ht, _n++), Ft[2 * at + 1] = et, Ar < at || (Le.bl_count[et]++, Zt = 0, Ln <= at && (Zt = Bn[at - Ln]), Un = Ft[2 * at], Le.opt_len += Un * (et + Zt), xn && (Le.static_len += Un * (Ii[2 * at + 1] + Zt)));
          if (_n !== 0) {
            do {
              for (et = ht - 1; Le.bl_count[et] === 0; )
                et--;
              Le.bl_count[et]--, Le.bl_count[et + 1] += 2, Le.bl_count[ht]--, _n -= 2;
            } while (0 < _n);
            for (et = ht; et !== 0; et--)
              for (at = Le.bl_count[et]; at !== 0; )
                Ar < (gt = Le.heap[--Ze]) || (Ft[2 * gt + 1] !== et && (Le.opt_len += (et - Ft[2 * gt + 1]) * Ft[2 * gt], Ft[2 * gt + 1] = et), at--);
          }
        }(S, O), H(re, Ne, S.bl_count);
      }
      function T(S, O, ne) {
        var fe, J, re = -1, de = O[1], ge = 0, Ee = 7, Ne = 4;
        for (de === 0 && (Ee = 138, Ne = 3), O[2 * (ne + 1) + 1] = 65535, fe = 0; fe <= ne; fe++)
          J = de, de = O[2 * (fe + 1) + 1], ++ge < Ee && J === de || (ge < Ne ? S.bl_tree[2 * J] += ge : J !== 0 ? (J !== re && S.bl_tree[2 * J]++, S.bl_tree[2 * k]++) : ge <= 10 ? S.bl_tree[2 * A]++ : S.bl_tree[2 * U]++, re = J, Ne = (ge = 0) === de ? (Ee = 138, 3) : J === de ? (Ee = 6, 3) : (Ee = 7, 4));
      }
      function pe(S, O, ne) {
        var fe, J, re = -1, de = O[1], ge = 0, Ee = 7, Ne = 4;
        for (de === 0 && (Ee = 138, Ne = 3), fe = 0; fe <= ne; fe++)
          if (J = de, de = O[2 * (fe + 1) + 1], !(++ge < Ee && J === de)) {
            if (ge < Ne)
              for (; ve(S, J, S.bl_tree), --ge != 0; )
                ;
            else
              J !== 0 ? (J !== re && (ve(S, J, S.bl_tree), ge--), ve(S, k, S.bl_tree), me(S, ge - 3, 2)) : ge <= 10 ? (ve(S, A, S.bl_tree), me(S, ge - 3, 3)) : (ve(S, U, S.bl_tree), me(S, ge - 11, 7));
            re = J, Ne = (ge = 0) === de ? (Ee = 138, 3) : J === de ? (Ee = 6, 3) : (Ee = 7, 4);
          }
      }
      l(te);
      var M = !1;
      function _(S, O, ne, fe) {
        me(S, (c << 1) + (fe ? 1 : 0), 3), function(J, re, de, ge) {
          we(J), ce(J, de), ce(J, ~de), o.arraySet(J.pending_buf, J.window, re, de, J.pending), J.pending += de;
        }(S, O, ne);
      }
      i._tr_init = function(S) {
        M || (function() {
          var O, ne, fe, J, re, de = new Array(b + 1);
          for (J = fe = 0; J < u - 1; J++)
            for (ie[J] = fe, O = 0; O < 1 << P[J]; O++)
              C[fe++] = J;
          for (C[fe - 1] = J, J = re = 0; J < 16; J++)
            for (te[J] = re, O = 0; O < 1 << V[J]; O++)
              G[re++] = J;
          for (re >>= 7; J < p; J++)
            for (te[J] = re << 7, O = 0; O < 1 << V[J] - 7; O++)
              G[256 + re++] = J;
          for (ne = 0; ne <= b; ne++)
            de[ne] = 0;
          for (O = 0; O <= 143; )
            be[2 * O + 1] = 8, O++, de[8]++;
          for (; O <= 255; )
            be[2 * O + 1] = 9, O++, de[9]++;
          for (; O <= 279; )
            be[2 * O + 1] = 7, O++, de[7]++;
          for (; O <= 287; )
            be[2 * O + 1] = 8, O++, de[8]++;
          for (H(be, f + 1, de), O = 0; O < p; O++)
            F[2 * O + 1] = 5, F[2 * O] = he(O, 5);
          ee = new _e(be, P, d + 1, f, b), Z = new _e(F, V, 0, p, b), oe = new _e(new Array(0), I, 0, m, w);
        }(), M = !0), S.l_desc = new q(S.dyn_ltree, ee), S.d_desc = new q(S.dyn_dtree, Z), S.bl_desc = new q(S.bl_tree, oe), S.bi_buf = 0, S.bi_valid = 0, W(S);
      }, i._tr_stored_block = _, i._tr_flush_block = function(S, O, ne, fe) {
        var J, re, de = 0;
        0 < S.level ? (S.strm.data_type === 2 && (S.strm.data_type = function(ge) {
          var Ee, Ne = 4093624447;
          for (Ee = 0; Ee <= 31; Ee++, Ne >>>= 1)
            if (1 & Ne && ge.dyn_ltree[2 * Ee] !== 0)
              return a;
          if (ge.dyn_ltree[18] !== 0 || ge.dyn_ltree[20] !== 0 || ge.dyn_ltree[26] !== 0)
            return s;
          for (Ee = 32; Ee < d; Ee++)
            if (ge.dyn_ltree[2 * Ee] !== 0)
              return s;
          return a;
        }(S)), De(S, S.l_desc), De(S, S.d_desc), de = function(ge) {
          var Ee;
          for (T(ge, ge.dyn_ltree, ge.l_desc.max_code), T(ge, ge.dyn_dtree, ge.d_desc.max_code), De(ge, ge.bl_desc), Ee = m - 1; 3 <= Ee && ge.bl_tree[2 * le[Ee] + 1] === 0; Ee--)
            ;
          return ge.opt_len += 3 * (Ee + 1) + 5 + 5 + 4, Ee;
        }(S), J = S.opt_len + 3 + 7 >>> 3, (re = S.static_len + 3 + 7 >>> 3) <= J && (J = re)) : J = re = ne + 5, ne + 4 <= J && O !== -1 ? _(S, O, ne, fe) : S.strategy === 4 || re === J ? (me(S, 2 + (fe ? 1 : 0), 3), Q(S, be, F)) : (me(S, 4 + (fe ? 1 : 0), 3), function(ge, Ee, Ne, Le) {
          var Qe;
          for (me(ge, Ee - 257, 5), me(ge, Ne - 1, 5), me(ge, Le - 4, 4), Qe = 0; Qe < Le; Qe++)
            me(ge, ge.bl_tree[2 * le[Qe] + 1], 3);
          pe(ge, ge.dyn_ltree, Ee - 1), pe(ge, ge.dyn_dtree, Ne - 1);
        }(S, S.l_desc.max_code + 1, S.d_desc.max_code + 1, de + 1), Q(S, S.dyn_ltree, S.dyn_dtree)), W(S), fe && we(S);
      }, i._tr_tally = function(S, O, ne) {
        return S.pending_buf[S.d_buf + 2 * S.last_lit] = O >>> 8 & 255, S.pending_buf[S.d_buf + 2 * S.last_lit + 1] = 255 & O, S.pending_buf[S.l_buf + S.last_lit] = 255 & ne, S.last_lit++, O === 0 ? S.dyn_ltree[2 * ne]++ : (S.matches++, O--, S.dyn_ltree[2 * (C[ne] + d + 1)]++, S.dyn_dtree[2 * N(O)]++), S.last_lit === S.lit_bufsize - 1;
      }, i._tr_align = function(S) {
        me(S, 2, 3), ve(S, x, be), function(O) {
          O.bi_valid === 16 ? (ce(O, O.bi_buf), O.bi_buf = 0, O.bi_valid = 0) : 8 <= O.bi_valid && (O.pending_buf[O.pending++] = 255 & O.bi_buf, O.bi_buf >>= 8, O.bi_valid -= 8);
        }(S);
      };
    }, { "../utils/common": 41 }], 53: [function(n, r, i) {
      r.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(n, r, i) {
      (function(o) {
        (function(a, s) {
          if (!a.setImmediate) {
            var l, c, u, d, f = 1, p = {}, m = !1, g = a.document, b = Object.getPrototypeOf && Object.getPrototypeOf(a);
            b = b && b.setTimeout ? b : a, l = {}.toString.call(a.process) === "[object process]" ? function(k) {
              _t.nextTick(function() {
                w(k);
              });
            } : function() {
              if (a.postMessage && !a.importScripts) {
                var k = !0, A = a.onmessage;
                return a.onmessage = function() {
                  k = !1;
                }, a.postMessage("", "*"), a.onmessage = A, k;
              }
            }() ? (d = "setImmediate$" + Math.random() + "$", a.addEventListener ? a.addEventListener("message", x, !1) : a.attachEvent("onmessage", x), function(k) {
              a.postMessage(d + k, "*");
            }) : a.MessageChannel ? ((u = new MessageChannel()).port1.onmessage = function(k) {
              w(k.data);
            }, function(k) {
              u.port2.postMessage(k);
            }) : g && "onreadystatechange" in g.createElement("script") ? (c = g.documentElement, function(k) {
              var A = g.createElement("script");
              A.onreadystatechange = function() {
                w(k), A.onreadystatechange = null, c.removeChild(A), A = null;
              }, c.appendChild(A);
            }) : function(k) {
              setTimeout(w, 0, k);
            }, b.setImmediate = function(k) {
              typeof k != "function" && (k = new Function("" + k));
              for (var A = new Array(arguments.length - 1), U = 0; U < A.length; U++)
                A[U] = arguments[U + 1];
              var P = { callback: k, args: A };
              return p[f] = P, l(f), f++;
            }, b.clearImmediate = y;
          }
          function y(k) {
            delete p[k];
          }
          function w(k) {
            if (m)
              setTimeout(w, 0, k);
            else {
              var A = p[k];
              if (A) {
                m = !0;
                try {
                  (function(U) {
                    var P = U.callback, V = U.args;
                    switch (V.length) {
                      case 0:
                        P();
                        break;
                      case 1:
                        P(V[0]);
                        break;
                      case 2:
                        P(V[0], V[1]);
                        break;
                      case 3:
                        P(V[0], V[1], V[2]);
                        break;
                      default:
                        P.apply(s, V);
                    }
                  })(A);
                } finally {
                  y(k), m = !1;
                }
              }
            }
          }
          function x(k) {
            k.source === a && typeof k.data == "string" && k.data.indexOf(d) === 0 && w(+k.data.slice(d.length));
          }
        })(typeof self > "u" ? o === void 0 ? this : o : self);
      }).call(this, typeof oa < "u" ? oa : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(YP);
var J0e = YP.exports;
const Z0e = /* @__PURE__ */ L9(J0e);
var qv = { exports: {} }, Q0e = {
  "&": "&amp;",
  '"': "&quot;",
  "'": "&apos;",
  "<": "&lt;",
  ">": "&gt;"
};
function ewe(t) {
  return t && t.replace ? t.replace(/([&"<>'])/g, function(e, n) {
    return Q0e[n];
  }) : t;
}
var twe = ewe, VT = twe, jO = qC.Stream, nwe = "    ";
function rwe(t, e) {
  typeof e != "object" && (e = {
    indent: e
  });
  var n = e.stream ? new jO() : null, r = "", i = !1, o = e.indent ? e.indent === !0 ? nwe : e.indent : "", a = !0;
  function s(f) {
    a ? _t.nextTick(f) : f();
  }
  function l(f, p) {
    if (p !== void 0 && (r += p), f && !i && (n = n || new jO(), i = !0), f && i) {
      var m = r;
      s(function() {
        n.emit("data", m);
      }), r = "";
    }
  }
  function c(f, p) {
    ik(l, Gv(f, o, o ? 1 : 0), p);
  }
  function u() {
    if (n) {
      var f = r;
      s(function() {
        n.emit("data", f), n.emit("end"), n.readable = !1, n.emit("close");
      });
    }
  }
  function d(f) {
    var p = f.encoding || "UTF-8", m = { version: "1.0", encoding: p };
    f.standalone && (m.standalone = f.standalone), c({ "?xml": { _attr: m } }), r = r.replace("/>", "?>");
  }
  return s(function() {
    a = !1;
  }), e.declaration && d(e.declaration), t && t.forEach ? t.forEach(function(f, p) {
    var m;
    p + 1 === t.length && (m = u), c(f, m);
  }) : c(t, u), n ? (n.readable = !0, n) : r;
}
function iwe() {
  var t = Array.prototype.slice.call(arguments), e = {
    _elem: Gv(t)
  };
  return e.push = function(n) {
    if (!this.append)
      throw new Error("not assigned to a parent!");
    var r = this, i = this._elem.indent;
    ik(
      this.append,
      Gv(
        n,
        i,
        this._elem.icount + (i ? 1 : 0)
      ),
      function() {
        r.append(!0);
      }
    );
  }, e.close = function(n) {
    n !== void 0 && this.push(n), this.end && this.end();
  }, e;
}
function owe(t, e) {
  return new Array(e || 0).join(t || "");
}
function Gv(t, e, n) {
  n = n || 0;
  var r = owe(e, n), i, o = t, a = !1;
  if (typeof t == "object") {
    var s = Object.keys(t);
    if (i = s[0], o = t[i], o && o._elem)
      return o._elem.name = i, o._elem.icount = n, o._elem.indent = e, o._elem.indents = r, o._elem.interrupt = o, o._elem;
  }
  var l = [], c = [], u;
  function d(f) {
    var p = Object.keys(f);
    p.forEach(function(m) {
      l.push(awe(m, f[m]));
    });
  }
  switch (typeof o) {
    case "object":
      if (o === null)
        break;
      o._attr && d(o._attr), o._cdata && c.push(
        ("<![CDATA[" + o._cdata).replace(/\]\]>/g, "]]]]><![CDATA[>") + "]]>"
      ), o.forEach && (u = !1, c.push(""), o.forEach(function(f) {
        if (typeof f == "object") {
          var p = Object.keys(f)[0];
          p == "_attr" ? d(f._attr) : c.push(Gv(
            f,
            e,
            n + 1
          ));
        } else
          c.pop(), u = !0, c.push(VT(f));
      }), u || c.push(""));
      break;
    default:
      c.push(VT(o));
  }
  return {
    name: i,
    interrupt: a,
    attributes: l,
    content: c,
    icount: n,
    indents: r,
    indent: e
  };
}
function ik(t, e, n) {
  if (typeof e != "object")
    return t(!1, e);
  var r = e.interrupt ? 1 : e.content.length;
  function i() {
    for (; e.content.length; ) {
      var a = e.content.shift();
      if (a !== void 0) {
        if (o(a))
          return;
        ik(t, a);
      }
    }
    t(!1, (r > 1 ? e.indents : "") + (e.name ? "</" + e.name + ">" : "") + (e.indent && !n ? `
` : "")), n && n();
  }
  function o(a) {
    return a.interrupt ? (a.interrupt.append = t, a.interrupt.end = i, a.interrupt = !1, t(!0), !0) : !1;
  }
  if (t(!1, e.indents + (e.name ? "<" + e.name : "") + (e.attributes.length ? " " + e.attributes.join(" ") : "") + (r ? e.name ? ">" : "" : e.name ? "/>" : "") + (e.indent && r > 1 ? `
` : "")), !r)
    return t(!1, e.indent ? `
` : "");
  o(e) || i();
}
function awe(t, e) {
  return t + '="' + VT(e) + '"';
}
qv.exports = rwe;
qv.exports.element = qv.exports.Element = iwe;
var swe = qv.exports;
const kn = /* @__PURE__ */ L9(swe), VO = 0, qO = 32, lwe = 32, cwe = (t, e) => {
  const n = e.replace(/-/g, "");
  if (n.length !== lwe)
    throw new Error(`Error: Cannot extract GUID from font filename: ${e}`);
  const i = n.replace(/(..)/g, "$1 ").trim().split(" ").map((l) => parseInt(l, 16));
  i.reverse();
  const a = t.slice(VO, qO).map((l, c) => l ^ i[c % i.length]);
  return Buffer.concat([t.slice(0, VO), a, t.slice(qO)]);
};
class uwe {
  // tslint:disable-next-line: no-object-literal-type-assertion
  format(e, n = { stack: [] }) {
    const r = e.prepForXml(n);
    if (r)
      return r;
    throw Error("XMLComponent did not format correctly");
  }
}
class dwe {
  replace(e, n, r) {
    let i = e;
    return n.forEach((o, a) => {
      i = i.replace(new RegExp(`{${o.fileName}}`, "g"), (r + a).toString());
    }), i;
  }
  getMediaData(e, n) {
    return n.Array.filter((r) => e.search(`{${r.fileName}}`) > 0);
  }
}
class fwe {
  replace(e, n) {
    let r = e;
    for (const i of n)
      r = r.replace(
        new RegExp(`{${i.reference}-${i.instance}}`, "g"),
        i.numId.toString()
      );
    return r;
  }
}
class hwe {
  constructor() {
    Ue(this, "formatter"), Ue(this, "imageReplacer"), Ue(this, "numberingReplacer"), this.formatter = new uwe(), this.imageReplacer = new dwe(), this.numberingReplacer = new fwe();
  }
  compile(e, n) {
    const r = new Z0e(), i = this.xmlifyFile(e, n), o = new Map(Object.entries(i));
    for (const [, a] of o)
      if (Array.isArray(a))
        for (const s of a)
          r.file(s.path, s.data);
      else
        r.file(a.path, a.data);
    for (const a of e.Media.Array)
      a.type !== "svg" ? r.file(`word/media/${a.fileName}`, a.data) : (r.file(`word/media/${a.fileName}`, a.data), r.file(`word/media/${a.fallback.fileName}`, a.fallback.data));
    for (const { data: a, name: s, fontKey: l } of e.FontTable.fontOptionsWithKey) {
      const [c] = s.split(".");
      r.file(`word/fonts/${c}.odttf`, cwe(a, l));
    }
    return r;
  }
  xmlifyFile(e, n) {
    const r = e.Document.Relationships.RelationshipCount + 1, i = kn(
      this.formatter.format(e.Document.View, {
        viewWrapper: e.Document,
        file: e,
        stack: []
      }),
      {
        indent: n,
        declaration: {
          standalone: "yes",
          encoding: "UTF-8"
        }
      }
    ), o = this.imageReplacer.getMediaData(i, e.Media);
    return {
      Relationships: {
        data: (o.forEach((a, s) => {
          e.Document.Relationships.createRelationship(
            r + s,
            "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
            `media/${a.fileName}`
          );
        }), kn(
          this.formatter.format(e.Document.Relationships, {
            viewWrapper: e.Document,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              encoding: "UTF-8"
            }
          }
        )),
        path: "word/_rels/document.xml.rels"
      },
      Document: {
        data: (() => {
          const a = this.imageReplacer.replace(i, o, r);
          return this.numberingReplacer.replace(a, e.Numbering.ConcreteNumbering);
        })(),
        path: "word/document.xml"
      },
      Styles: {
        data: (() => {
          const a = kn(
            this.formatter.format(e.Styles, {
              viewWrapper: e.Document,
              file: e,
              stack: []
            }),
            {
              indent: n,
              declaration: {
                standalone: "yes",
                encoding: "UTF-8"
              }
            }
          );
          return this.numberingReplacer.replace(a, e.Numbering.ConcreteNumbering);
        })(),
        path: "word/styles.xml"
      },
      Properties: {
        data: kn(
          this.formatter.format(e.CoreProperties, {
            viewWrapper: e.Document,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "docProps/core.xml"
      },
      Numbering: {
        data: kn(
          this.formatter.format(e.Numbering, {
            viewWrapper: e.Document,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/numbering.xml"
      },
      FileRelationships: {
        data: kn(
          this.formatter.format(e.FileRelationships, {
            viewWrapper: e.Document,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ),
        path: "_rels/.rels"
      },
      HeaderRelationships: e.Headers.map((a, s) => {
        const l = kn(
          this.formatter.format(a.View, {
            viewWrapper: a,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              encoding: "UTF-8"
            }
          }
        );
        return this.imageReplacer.getMediaData(l, e.Media).forEach((u, d) => {
          a.Relationships.createRelationship(
            d,
            "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
            `media/${u.fileName}`
          );
        }), {
          data: kn(
            this.formatter.format(a.Relationships, {
              viewWrapper: a,
              file: e,
              stack: []
            }),
            {
              indent: n,
              declaration: {
                encoding: "UTF-8"
              }
            }
          ),
          path: `word/_rels/header${s + 1}.xml.rels`
        };
      }),
      FooterRelationships: e.Footers.map((a, s) => {
        const l = kn(
          this.formatter.format(a.View, {
            viewWrapper: a,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              encoding: "UTF-8"
            }
          }
        );
        return this.imageReplacer.getMediaData(l, e.Media).forEach((u, d) => {
          a.Relationships.createRelationship(
            d,
            "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
            `media/${u.fileName}`
          );
        }), {
          data: kn(
            this.formatter.format(a.Relationships, {
              viewWrapper: a,
              file: e,
              stack: []
            }),
            {
              indent: n,
              declaration: {
                encoding: "UTF-8"
              }
            }
          ),
          path: `word/_rels/footer${s + 1}.xml.rels`
        };
      }),
      Headers: e.Headers.map((a, s) => {
        const l = kn(
          this.formatter.format(a.View, {
            viewWrapper: a,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ), c = this.imageReplacer.getMediaData(l, e.Media), u = this.imageReplacer.replace(l, c, 0);
        return {
          data: this.numberingReplacer.replace(u, e.Numbering.ConcreteNumbering),
          path: `word/header${s + 1}.xml`
        };
      }),
      Footers: e.Footers.map((a, s) => {
        const l = kn(
          this.formatter.format(a.View, {
            viewWrapper: a,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ), c = this.imageReplacer.getMediaData(l, e.Media), u = this.imageReplacer.replace(l, c, 0);
        return {
          data: this.numberingReplacer.replace(u, e.Numbering.ConcreteNumbering),
          path: `word/footer${s + 1}.xml`
        };
      }),
      ContentTypes: {
        data: kn(
          this.formatter.format(e.ContentTypes, {
            viewWrapper: e.Document,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ),
        path: "[Content_Types].xml"
      },
      CustomProperties: {
        data: kn(
          this.formatter.format(e.CustomProperties, {
            viewWrapper: e.Document,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "docProps/custom.xml"
      },
      AppProperties: {
        data: kn(
          this.formatter.format(e.AppProperties, {
            viewWrapper: e.Document,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "docProps/app.xml"
      },
      FootNotes: {
        data: kn(
          this.formatter.format(e.FootNotes.View, {
            viewWrapper: e.FootNotes,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/footnotes.xml"
      },
      FootNotesRelationships: {
        data: kn(
          this.formatter.format(e.FootNotes.Relationships, {
            viewWrapper: e.FootNotes,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/_rels/footnotes.xml.rels"
      },
      Settings: {
        data: kn(
          this.formatter.format(e.Settings, {
            viewWrapper: e.Document,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/settings.xml"
      },
      Comments: {
        data: kn(
          this.formatter.format(e.Comments, {
            viewWrapper: e.Document,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/comments.xml"
      },
      FontTable: {
        data: kn(
          this.formatter.format(e.FontTable.View, {
            viewWrapper: e.Document,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              standalone: "yes",
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/fontTable.xml"
      },
      FontTableRelationships: {
        data: kn(
          this.formatter.format(e.FontTable.Relationships, {
            viewWrapper: e.Document,
            file: e,
            stack: []
          }),
          {
            indent: n,
            declaration: {
              encoding: "UTF-8"
            }
          }
        ),
        path: "word/_rels/fontTable.xml.rels"
      }
    };
  }
}
const pwe = {
  NONE: "",
  WITH_2_BLANKS: "  ",
  WITH_4_BLANKS: "    ",
  // eslint-disable-next-line @typescript-eslint/naming-convention
  WITH_TAB: "	"
}, bp = (t) => t === !0 ? pwe.WITH_2_BLANKS : t === !1 ? void 0 : t;
class JP {
  static toString(e, n) {
    return Dy(this, null, function* () {
      return yield this.compiler.compile(e, bp(n)).generateAsync({
        type: "string",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
    });
  }
  static toBuffer(e, n) {
    return Dy(this, null, function* () {
      return yield this.compiler.compile(e, bp(n)).generateAsync({
        type: "nodebuffer",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
    });
  }
  static toBase64String(e, n) {
    return Dy(this, null, function* () {
      return yield this.compiler.compile(e, bp(n)).generateAsync({
        type: "base64",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
    });
  }
  static toBlob(e, n) {
    return Dy(this, null, function* () {
      return yield this.compiler.compile(e, bp(n)).generateAsync({
        type: "blob",
        mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        compression: "DEFLATE"
      });
    });
  }
  static toStream(e, n) {
    const r = new qC.Stream();
    return this.compiler.compile(e, bp(n)).generateAsync({
      type: "nodebuffer",
      mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      compression: "DEFLATE"
    }).then((o) => {
      r.emit("data", o), r.emit("end");
    }), r;
  }
}
Ue(JP, "compiler", new hwe());
var ok = { exports: {} };
function mwe(t) {
  return t.toString("ascii", 0, 2) === "BM";
}
function gwe(t) {
  return {
    width: t.readUInt32LE(18),
    height: Math.abs(t.readInt32LE(22))
  };
}
var ywe = {
  detect: mwe,
  calculate: gwe
}, bwe = 1, vwe = 6, wwe = 16;
function xwe(t) {
  var e;
  return t.readUInt16LE(0) !== 0 ? !1 : (e = t.readUInt16LE(2), e === bwe);
}
function GO(t, e) {
  var n = t.readUInt8(e);
  return n === 0 ? 256 : n;
}
function KO(t, e) {
  var n = vwe + e * wwe;
  return {
    width: GO(t, n),
    height: GO(t, n + 1)
  };
}
function _we(t) {
  var e = t.readUInt16LE(4), n = KO(t, 0), r;
  if (e === 1)
    return n;
  for (n.images = [{
    width: n.width,
    height: n.height
  }], r = 1; r < e; r += 1)
    n.images.push(KO(t, r));
  return n;
}
var ZP = {
  detect: xwe,
  calculate: _we
}, Swe = 2;
function Twe(t) {
  var e;
  return t.readUInt16LE(0) !== 0 ? !1 : (e = t.readUInt16LE(2), e === Swe);
}
var Dwe = {
  detect: Twe,
  calculate: ZP.calculate
};
function Ewe(t) {
  return t.readUInt32LE(0) === 542327876;
}
function Cwe(t) {
  return {
    height: t.readUInt32LE(12),
    width: t.readUInt32LE(16)
  };
}
var kwe = {
  detect: Ewe,
  calculate: Cwe
}, Awe = /^GIF8[79]a/;
function Rwe(t) {
  var e = t.toString("ascii", 0, 6);
  return Awe.test(e);
}
function Iwe(t) {
  return {
    width: t.readUInt16LE(6),
    height: t.readUInt16LE(8)
  };
}
var Owe = {
  detect: Rwe,
  calculate: Iwe
};
function Fwe(t) {
  var e = t.toString("hex", 0, 2);
  return e === "ffd8";
}
function Uwe(t, e) {
  return {
    height: t.readUInt16BE(e),
    width: t.readUInt16BE(e + 2)
  };
}
function Nwe(t, e) {
  if (e > t.length)
    throw new TypeError("Corrupt JPG, exceeded buffer limits");
  if (t[e] !== 255)
    throw new TypeError("Invalid JPG, marker table corrupted");
}
function Mwe(t) {
  t = t.slice(4);
  for (var e, n; t.length; ) {
    if (e = t.readUInt16BE(0), Nwe(t, e), n = t[e + 1], n === 192 || n === 193 || n === 194)
      return Uwe(t, e + 5);
    t = t.slice(e + 2);
  }
  throw new TypeError("Invalid JPG, no size found");
}
var Bwe = {
  detect: Fwe,
  calculate: Mwe
}, Lwe = `PNG\r

`, Pwe = "IHDR", QP = "CgBI";
function Wwe(t) {
  if (Lwe === t.toString("ascii", 1, 8)) {
    var e = t.toString("ascii", 12, 16);
    if (e === QP && (e = t.toString("ascii", 28, 32)), e !== Pwe)
      throw new TypeError("invalid png");
    return !0;
  }
}
function zwe(t) {
  return t.toString("ascii", 12, 16) === QP ? {
    width: t.readUInt32BE(32),
    height: t.readUInt32BE(36)
  } : {
    width: t.readUInt32BE(16),
    height: t.readUInt32BE(20)
  };
}
var $we = {
  detect: Wwe,
  calculate: zwe
};
function Hwe(t) {
  return t.toString("ascii", 0, 4) === "8BPS";
}
function jwe(t) {
  return {
    width: t.readUInt32BE(18),
    height: t.readUInt32BE(14)
  };
}
var Vwe = {
  detect: Hwe,
  calculate: jwe
}, qwe = /<svg[^>]+[^>]*>/;
function Gwe(t) {
  return qwe.test(t);
}
var fb = {
  root: /<svg\s[^>]+>/,
  width: /\bwidth=(['"])([^%]+?)\1/,
  height: /\bheight=(['"])([^%]+?)\1/,
  viewbox: /\bviewBox=(['"])(.+?)\1/
};
function Kwe(t) {
  var e = t.split(" ");
  return {
    width: parseInt(e[2], 10),
    height: parseInt(e[3], 10)
  };
}
function Xwe(t) {
  var e = t.match(fb.width), n = t.match(fb.height), r = t.match(fb.viewbox);
  return {
    width: e && parseInt(e[2], 10),
    height: n && parseInt(n[2], 10),
    viewbox: r && Kwe(r[2])
  };
}
function Ywe(t) {
  return {
    width: t.width,
    height: t.height
  };
}
function Jwe(t) {
  var e = t.viewbox.width / t.viewbox.height;
  return t.width ? {
    width: t.width,
    height: Math.floor(t.width / e)
  } : t.height ? {
    width: Math.floor(t.height * e),
    height: t.height
  } : {
    width: t.viewbox.width,
    height: t.viewbox.height
  };
}
function Zwe(t) {
  var e = t.toString("utf8").match(fb.root);
  if (e) {
    var n = Xwe(e[0]);
    if (n.width && n.height)
      return Ywe(n);
    if (n.viewbox)
      return Jwe(n);
  }
  throw new TypeError("invalid svg");
}
var Qwe = {
  detect: Gwe,
  calculate: Zwe
};
function exe(t) {
  var e = t.toString("ascii", 0, 4) === "RIFF", n = t.toString("ascii", 8, 12) === "WEBP", r = t.toString("ascii", 12, 15) === "VP8";
  return e && n && r;
}
function txe(t) {
  var e = t.toString("ascii", 12, 16);
  if (t = t.slice(20, 30), e === "VP8X") {
    var n = t[0], r = (n & 192) === 0, i = (n & 1) === 0;
    return r && i ? nxe(t) : !1;
  }
  if (e === "VP8 " && t[0] !== 47)
    return ixe(t);
  var o = t.toString("hex", 3, 6);
  return e === "VP8L" && o !== "9d012a" ? rxe(t) : !1;
}
function nxe(t) {
  return {
    width: 1 + t.readUIntLE(4, 3),
    height: 1 + t.readUIntLE(7, 3)
  };
}
function rxe(t) {
  return {
    width: 1 + ((t[2] & 63) << 8 | t[1]),
    height: 1 + ((t[4] & 15) << 10 | t[3] << 2 | (t[2] & 192) >> 6)
  };
}
function ixe(t) {
  return {
    width: t.readInt16LE(6) & 16383,
    height: t.readInt16LE(8) & 16383
  };
}
var oxe = {
  detect: exe,
  calculate: txe
}, axe = {
  bmp: ywe,
  cur: Dwe,
  dds: kwe,
  gif: Owe,
  ico: ZP,
  jpg: Bwe,
  png: $we,
  psd: Vwe,
  svg: Qwe,
  webp: oxe
}, e7 = axe, XO = e7, sxe = function(t) {
  var e, n;
  for (e in XO)
    if (n = XO[e].detect(t), n)
      return e;
}, qT = e7, lxe = sxe;
function cxe(t) {
  var e = lxe(t);
  if (e in qT) {
    var n = qT[e].calculate(t);
    if (n !== !1)
      return n.type = e, n;
  }
  throw new TypeError("unsupported file type: " + e);
}
ok.exports = function(t) {
  if (Buffer.isBuffer(t))
    return cxe(t);
  throw new TypeError("expecting only a buffer as input");
};
ok.exports.types = Object.keys(qT);
var uxe = ok.exports;
const dxe = /* @__PURE__ */ n6(uxe);
function t7(t) {
  return {
    alignment: ri.START,
    style: {
      paragraph: {
        indent: { left: xi(t), hanging: xi(0.18) }
      }
    }
  };
}
const fxe = Array(3).fill([Si.DECIMAL, Si.LOWER_LETTER, Si.LOWER_ROMAN]).flat().map((t, e) => Object.assign({
  level: e,
  format: t,
  text: `%${e + 1}.`
}, t7((e + 1) / 2))), hxe = Array(3).fill(["●", "○", "■"]).flat().map((t, e) => Object.assign({ level: e, format: Si.BULLET, text: t }, t7((e + 1) / 2))), pxe = {
  numbered: fxe,
  bullets: hxe
};
function mxe(t, e) {
  return {
    reference: t,
    levels: pxe[e]
  };
}
function YO() {
  return Math.random().toString(36).substr(2, 9);
}
function gxe(t) {
  return new G0e({
    footnotes: t.footnotes,
    numbering: {
      config: t.numbering
    },
    sections: [
      {
        properties: {
          type: Xve.CONTINUOUS
        },
        children: t.children
      }
    ]
  });
}
function JO(t) {
  let e = "";
  return t.forEach((n) => {
    n.isText && (e += n.text);
  }), e;
}
const Y_ = 600;
function ZO(t, e, n, r) {
  const i = n ? [new vo(n)] : [], o = [];
  return new WP({
    id: t,
    children: [...i, new dve(e), ...o]
  });
}
class yxe {
  constructor(e, n, r) {
    this.footnotes = {}, this.current = [], this.maxImageWidth = Y_, this.$footnoteCounter = 0, this.nodes = e, this.marks = n, this.options = r ?? {}, this.children = [], this.numbering = [];
  }
  renderContent(e, n) {
    e.forEach((r, i, o) => {
      n && this.addParagraphOptions(n), this.render(r, e, o);
    });
  }
  render(e, n, r) {
    if (typeof n == "number")
      throw new Error("!");
    if (!this.nodes[e.type.name])
      throw new Error(`Token type \`${e.type.name}\` not supported by Word renderer`);
    this.nodes[e.type.name](this, e, n, r);
  }
  renderMarks(e, n) {
    return n.map((r) => {
      var i, o;
      return (o = (i = this.marks)[r.type.name]) === null || o === void 0 ? void 0 : o.call(i, this, e, r);
    }).reduce((r, i) => Object.assign(Object.assign({}, r), i), {});
  }
  renderInline(e) {
    let n;
    const r = () => {
      if (!n)
        return;
      const a = new PP({
        link: n.link,
        // child: this.current[0],
        children: this.current
      });
      this.current = [...n.stack, a], n = void 0;
    }, i = (a) => {
      const s = a === (n == null ? void 0 : n.link);
      this.addRunOptions({ style: "Hyperlink" });
      {
        if (n && s)
          return;
        n && !s && r();
      }
      n = {
        link: a,
        stack: this.current
      }, this.current = [];
    }, o = (a, s, l) => {
      const c = a.marks.filter((d) => d.type.name === "link"), u = c.length > 0;
      u ? i(c[0].attrs.href) : !u && n && r(), a.isText ? this.text(a.text, this.renderMarks(a, [...a.marks])) : this.render(a, e, l);
    };
    e.forEach(o), r();
  }
  renderList(e, n) {
    if (this.currentNumbering) {
      const { reference: r, level: i } = this.currentNumbering;
      this.currentNumbering = { reference: r, level: i + 1 };
    } else {
      const r = YO();
      this.numbering.push(mxe(r, n)), this.currentNumbering = { reference: r, level: 0 };
    }
    if (this.renderContent(e), this.currentNumbering.level === 0)
      delete this.currentNumbering;
    else {
      const { reference: r, level: i } = this.currentNumbering;
      this.currentNumbering = { reference: r, level: i - 1 };
    }
  }
  // This is a pass through to the paragraphs, etc. underneath they will close the block
  renderListItem(e) {
    if (!this.currentNumbering)
      throw new Error("Trying to create a list item without a list?");
    this.addParagraphOptions({ numbering: this.currentNumbering }), this.renderContent(e);
  }
  addParagraphOptions(e) {
    this.nextParentParagraphOpts = Object.assign(Object.assign({}, this.nextParentParagraphOpts), e);
  }
  addRunOptions(e) {
    this.nextRunOpts = Object.assign(Object.assign({}, this.nextRunOpts), e);
  }
  text(e, n) {
    e && (this.current.push(new vo(Object.assign(Object.assign({ text: e }, this.nextRunOpts), n))), delete this.nextRunOpts);
  }
  math(e, n = { inline: !0 }) {
    var r;
    if (n.inline || !n.numbered) {
      this.current.push(new MO({ children: [new BO(e)] }));
      return;
    }
    const i = (r = n.id) !== null && r !== void 0 ? r : YO();
    this.current = [
      new vo("	"),
      new MO({
        children: [new BO(e)]
      }),
      new vo("	("),
      ZO(i, "Equation"),
      new vo(")")
    ], this.addParagraphOptions({
      tabStops: [
        {
          type: Vv.CENTER,
          position: FO.MAX / 2
        },
        {
          type: Vv.RIGHT,
          position: FO.MAX
        }
      ]
    });
  }
  image(e, n = 70, r = "center", i) {
    const o = this.options.getImageBuffer(e), a = dxe(o), s = a.height / a.width, l = this.maxImageWidth * (n / 100);
    this.current.push(new cve(Object.assign(Object.assign({}, i), { data: o, transformation: Object.assign(Object.assign({}, (i == null ? void 0 : i.transformation) || {}), { width: l, height: l * s }) })));
    let c;
    switch (r) {
      case "right":
        c = ri.RIGHT;
        break;
      case "left":
        c = ri.LEFT;
        break;
      default:
        c = ri.CENTER;
    }
    this.addParagraphOptions({
      // TODO: fix
      alignment: c
    });
  }
  table(e, n = {}) {
    const { getCellOptions: r, getRowOptions: i, tableOptions: o } = n, a = this.children, s = [];
    e.content.forEach((c) => {
      const u = [];
      let d = !0;
      c.content.forEach((f) => {
        f.type.name !== "table_header" && (d = !1);
      }), this.maxImageWidth = Y_ / c.content.childCount, c.content.forEach((f) => {
        var p, m;
        this.children = [], this.renderContent(f);
        const g = { children: this.children }, b = (p = f.attrs.colspan) !== null && p !== void 0 ? p : 1, y = (m = f.attrs.rowspan) !== null && m !== void 0 ? m : 1;
        b > 1 && (g.columnSpan = b), y > 1 && (g.rowSpan = y), u.push(new rk(Object.assign(Object.assign({}, g), (r == null ? void 0 : r(f)) || {})));
      }), s.push(new D1e(Object.assign(Object.assign({}, (i == null ? void 0 : i(c)) || {}), { children: u, tableHeader: d })));
    }), this.maxImageWidth = Y_;
    const l = new x1e(Object.assign(Object.assign({}, o), { rows: s }));
    a.push(l), a.push(new Sl("")), this.children = a;
  }
  captionLabel(e, n, { suffix: r } = { suffix: ": " }) {
    this.current.push(ZO(e, n, `${n} `), new vo(r));
  }
  footnote(e) {
    const { current: n, nextRunOpts: r } = this;
    this.current = [], delete this.nextRunOpts, this.$footnoteCounter += 1, this.renderInline(e), this.footnotes[this.$footnoteCounter] = {
      children: [new Sl({ children: this.current })]
    }, this.current = n, this.nextRunOpts = r, this.current.push(new Y0e(this.$footnoteCounter));
  }
  closeBlock(e, n) {
    const r = new Sl(Object.assign(Object.assign({ children: this.current }, this.nextParentParagraphOpts), n));
    this.current = [], delete this.nextParentParagraphOpts, this.children.push(r);
  }
  createReference(e, n, r) {
    const i = [];
    n && i.push(new vo(n)), i.push(new hve(`REF ${e} \\h`)), r && i.push(new vo(r));
    const o = new Rve({ anchor: e, children: i });
    this.current.push(o);
  }
}
class bxe {
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  serialize(e, n) {
    const r = new yxe(this.nodes, this.marks, n);
    return r.renderContent(e), gxe(r);
  }
}
const Pd = {
  text(t, e) {
    var n;
    t.text((n = e.text) !== null && n !== void 0 ? n : "");
  },
  paragraph(t, e) {
    t.renderInline(e), t.closeBlock(e);
  },
  heading(t, e) {
    t.renderInline(e);
    const n = [
      Md.HEADING_1,
      Md.HEADING_2,
      Md.HEADING_3,
      Md.HEADING_4,
      Md.HEADING_5,
      Md.HEADING_6
    ][e.attrs.level - 1];
    t.closeBlock(e, { heading: n });
  },
  blockquote(t, e) {
    t.renderContent(e, { style: "IntenseQuote" });
  },
  code_block(t, e) {
    t.renderContent(e), t.closeBlock(e);
  },
  horizontal_rule(t, e) {
    t.closeBlock(e, { thematicBreak: !0 }), t.closeBlock(e);
  },
  hard_break(t) {
    t.addRunOptions({ break: 1 });
  },
  ordered_list(t, e) {
    t.renderList(e, "numbered");
  },
  bullet_list(t, e) {
    t.renderList(e, "bullets");
  },
  list_item(t, e) {
    t.renderListItem(e);
  },
  // Presentational
  image(t, e) {
    const { src: n } = e.attrs;
    t.image(n), t.closeBlock(e);
  },
  // Technical
  math(t, e) {
    t.math(JO(e), { inline: !0 });
  },
  equation(t, e) {
    const { id: n, numbered: r } = e.attrs;
    t.math(JO(e), { inline: !1, numbered: r, id: n }), t.closeBlock(e);
  },
  table(t, e) {
    t.table(e);
  }
}, vxe = {
  em() {
    return { italics: !0 };
  },
  strong() {
    return { bold: !0 };
  },
  italic() {
    return { italics: !0 };
  },
  bold() {
    return { bold: !0 };
  },
  link() {
    return {};
  },
  code() {
    return {
      font: {
        name: "Monospace"
      },
      color: "000000",
      shading: {
        type: Lye.SOLID,
        color: "D2D3D2",
        fill: "D2D3D2"
      }
    };
  },
  abbr() {
    return {};
  },
  subscript() {
    return { subScript: !0 };
  },
  superscript() {
    return { superScript: !0 };
  },
  strikethrough() {
    return { strike: !0 };
  },
  underline() {
    return {
      underline: {}
    };
  },
  smallcaps() {
    return { smallCaps: !0 };
  },
  allcaps() {
    return { allCaps: !0 };
  }
}, wxe = typeof window < "u";
function xxe(t, e) {
  if (wxe) {
    const n = window.URL.createObjectURL(t), r = document.createElement("a");
    return r.href = n, r.download = e, r.click(), window.URL.revokeObjectURL(n), Promise.resolve();
  }
  return console.error("Download is not supported in Node.js"), Promise.resolve();
}
const _xe = {
  ...Pd,
  hardBreak: Pd.hard_break,
  orderedList: Pd.ordered_list,
  listItem: Pd.list_item,
  bulletList: Pd.bullet_list,
  horizontalRule: Pd.horizontal_rule,
  // Requirement Buffer on browser
  image(t, e) {
    t.renderInline(e), t.closeBlock(e);
  }
}, Sxe = new bxe(_xe, vxe), a_e = St.create({
  name: "exportWord",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      button: ({ editor: e, t: n }) => ({
        component: Je,
        componentProps: {
          icon: "ExportWord",
          action: () => {
            e == null || e.commands.exportToWord();
          },
          tooltip: n("editor.exportWord.tooltip"),
          isActive: () => !1,
          disabled: !1
        }
      })
    };
  },
  // @ts-expect-error
  addCommands() {
    return {
      exportToWord: () => async ({ editor: t }) => {
        const e = {
          getImageBuffer: async (r) => {
            const o = await (await fetch(r)).arrayBuffer();
            return new Uint8Array(o);
          }
        }, n = Sxe.serialize(t.state.doc, e);
        return JP.toBlob(n).then((r) => xxe(new Blob([r]), "export-document.docx")), !0;
      }
    };
  }
}), Txe = "_toc_aag8a_1", Dxe = "_visible_aag8a_7", Exe = "_list_aag8a_11", Cxe = "_item_aag8a_16", Fy = {
  toc: Txe,
  visible: Dxe,
  list: Exe,
  item: Cxe,
  "item--3": "_item--3_aag8a_19",
  "item--4": "_item--4_aag8a_22",
  "item--5": "_item--5_aag8a_25",
  "item--6": "_item--6_aag8a_28"
};
function kxe(t) {
  const e = [], n = [e];
  return t.forEach((r) => {
    let i = -1, o = n[r.level + i];
    for (; !o; )
      i -= 1, o = n[r.level + i];
    o.push({ ...r, children: n[r.level] = [] });
  }), e;
}
function Axe({ editor: t }) {
  const e = WD(), [n, r] = nt([]), { t: i } = Wt(), o = Et(() => {
    const a = [], s = t.state.tr;
    t.state.doc.descendants((l, c) => {
      if (l.type.name === "heading") {
        const u = `heading-${a.length + 1}`;
        l.attrs.id !== u && s.setNodeMarkup(c, void 0, {
          ...l.attrs,
          id: u
        }), a.push({
          level: l.attrs.level,
          text: l.textContent,
          id: u
        });
      }
    }), s.setMeta("addToHistory", !1), s.setMeta("preventUpdate", !0), t.view.dispatch(s), r(a), t.eventEmitter && t.eventEmitter.emit("TableOfContents", kxe(a));
  }, [t]);
  return Tt(() => {
    if (t) {
      if (!t.options.editable) {
        o();
        return;
      }
      return t.on("update", o), () => {
        t.off("update", o);
      };
    }
  }, [t, o]), Tt(() => {
    o();
  }, []), /* @__PURE__ */ z(xl, { className: xo("tableOfContent", Fy.toc, e && Fy.visible), children: e ? /* @__PURE__ */ Fe("div", { style: { position: "relative" }, children: [
    /* @__PURE__ */ z("p", { className: "richtext-mb-[8px] text-[20px] richtext-font-semibold", children: i("editor.table_of_content") }),
    /* @__PURE__ */ z("ul", { className: Fy.list, children: n.map((a, s) => /* @__PURE__ */ z("li", { className: Fy.item, style: { paddingLeft: `${a.level - 1}rem` }, children: /* @__PURE__ */ z("a", { href: `#${a.id}`, children: a.text }) }, `table-of-content-${s}`)) })
  ] }) : null });
}
function Rxe(t) {
  return t && t.type.name === "title";
}
function Ixe(t, e) {
  const r = [t.getJSON()], i = [];
  for (; r.length; ) {
    const o = r.shift();
    o.type === e && i.push(o), o.content && o.content.length && r.push(...o.content);
  }
  return i;
}
function Oxe(t, ...e) {
  const [n, r] = nt(!1);
  return Tt(() => {
    const i = () => {
      r(t.isActive.apply(t, e));
    };
    return t.on("selectionUpdate", i), t.on("transaction", i), () => {
      t.off("selectionUpdate", i), t.off("transaction", i);
    };
  }, [t, e, r]), n;
}
function Fxe({ editor: t, icon: e, tooltip: n }) {
  const r = Oxe(t, Uxe.name), i = Et(() => {
    if (r) {
      t.chain().focus().removeTableOfContents().run();
      return;
    }
    t.chain().focus().setTableOfContents().run();
  }, [t, r]);
  return /* @__PURE__ */ z(
    Je,
    {
      action: i,
      isActive: () => r || !1,
      icon: e,
      tooltip: n
    }
  );
}
const Uxe = rn.create({
  name: "tableOfContents",
  group: "block",
  atom: !0,
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      onHasOneBeforeInsert: () => {
      },
      resizable: !0,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1,
      button: ({ editor: e, t: n }) => ({
        component: Fxe,
        componentProps: {
          disabled: !1,
          icon: "BookMarked",
          tooltip: n("editor.table.tooltip"),
          editor: e
        }
      })
    };
  },
  parseHTML() {
    return [
      {
        tag: "toc"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["toc", bt(t)];
  },
  addNodeView() {
    return Vf(Axe);
  },
  // @ts-expect-error
  addCommands() {
    return {
      setTableOfContents: () => ({ commands: t, editor: e, view: n }) => {
        if (Ixe(e, this.name).length) {
          this.options.onHasOneBeforeInsert();
          return;
        }
        const i = n.props.state.doc.content.firstChild;
        if (Rxe(i)) {
          const o = (i.firstChild && i.firstChild.nodeSize || 0) + 1;
          return t.insertContentAt(o, { type: this.name });
        }
        return t.insertContent({
          type: this.name
        });
      },
      removeTableOfContents: () => ({ state: t, dispatch: e }) => {
        const { tr: n } = t, r = t.schema.nodes.tableOfContents;
        return t.doc.descendants((i, o) => {
          if (i.type === r) {
            const a = o, s = o + i.nodeSize;
            n.delete(a, s);
          }
        }), n.docChanged ? (e(n), !0) : !1;
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: ["heading"],
        attributes: {
          id: {
            default: null
          }
        }
      }
    ];
  }
});
function Nxe(t) {
  var n;
  const e = Yt(() => {
    var o;
    const r = (o = t == null ? void 0 : t.items) == null ? void 0 : o.find((a) => a.isActive());
    return r && !r.default ? {
      ...r,
      icon: r.icon ? r.icon : t.icon
    } : {
      title: t == null ? void 0 : t.tooltip,
      icon: t.icon,
      isActive: () => !1
    };
  }, [t]);
  return /* @__PURE__ */ Fe(Eo, { modal: !0, children: [
    /* @__PURE__ */ z(Co, { disabled: t == null ? void 0 : t.disabled, asChild: !0, children: /* @__PURE__ */ z(
      Je,
      {
        customClass: "!richtext-w-12 richtext-h-12",
        icon: t == null ? void 0 : t.icon,
        tooltip: t == null ? void 0 : t.tooltip,
        disabled: t == null ? void 0 : t.disabled,
        children: /* @__PURE__ */ z($t, { className: "richtext-w-3 richtext-h-3 richtext-ml-1 richtext-text-zinc-500", name: "MenuDown" })
      }
    ) }),
    /* @__PURE__ */ z(
      oo,
      {
        className: "richtext-min-w-4 richtext-w-full !richtext-p-[4px] richtext-flex richtext-flex-row richtext-gap-1",
        align: "start",
        side: "bottom",
        children: (n = t == null ? void 0 : t.items) == null ? void 0 : n.map((r, i) => {
          var o, a;
          return /* @__PURE__ */ Fe(Kf, { children: [
            /* @__PURE__ */ z(Xf, { asChild: !0, children: /* @__PURE__ */ z(
              zm,
              {
                size: "sm",
                onClick: r == null ? void 0 : r.action,
                className: "richtext-p-1 richtext-w-7 richtext-h-7",
                pressed: e.title === r.title,
                "data-state": e.title === r.title ? "on" : "off",
                children: (r == null ? void 0 : r.icon) && /* @__PURE__ */ z($t, { name: r.icon })
              }
            ) }),
            /* @__PURE__ */ Fe(gu, { className: "richtext-flex richtext-flex-col richtext-items-center", children: [
              /* @__PURE__ */ z("span", { children: r.title }),
              !!((o = r.shortcutKeys) != null && o.length) && /* @__PURE__ */ z("span", { children: (a = r.shortcutKeys) == null ? void 0 : a.map((s) => h1(s)).join(" ") })
            ] })
          ] }, `text-align-${i}`);
        })
      }
    )
  ] });
}
const s_e = St.create({
  name: "text-direction",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      types: ["heading", "paragraph"],
      directions: ["auto", "ltr", "rtl"],
      defaultDirection: "auto",
      button({
        editor: e,
        extension: n,
        t: r
      }) {
        var l;
        const i = ((l = n.options) == null ? void 0 : l.directions) || [], o = {
          auto: "TextDirection",
          ltr: "LeftToRight",
          rtl: "RightToLeft"
        }, a = i.map((c) => ({
          title: r(`editor.textDirection.${c}.tooltip`),
          icon: o[c],
          isActive: () => !1,
          action: () => {
            var u, d, f, p;
            if (c === "auto") {
              (d = (u = e.commands) == null ? void 0 : u.unsetTextDirection) == null || d.call(u);
              return;
            }
            (p = (f = e.commands) == null ? void 0 : f.setTextDirection) == null || p.call(f, c);
          },
          disabled: !1
        })), s = a.filter((c) => c.disabled).length === a.length;
        return {
          component: Nxe,
          componentProps: {
            icon: "TextDirection",
            tooltip: r("editor.textDirection.tooltip"),
            disabled: s,
            items: a
          }
        };
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          dir: {
            default: this.options.defaultDirection,
            parseHTML: (t) => t.attributes.dir && this.options.directions.includes(t.attributes.dir) ? t.attributes.dir.value : this.options.defaultDirection,
            renderHTML: (t) => ({ dir: t.dir })
          }
        }
      }
    ];
  },
  // @ts-expect-error
  addCommands() {
    return {
      setTextDirection: (t) => ({ commands: e }) => this.options.directions.includes(t) ? this.options.types.every((n) => e.updateAttributes(n, { dir: t })) : !1,
      unsetTextDirection: () => ({ commands: t }) => this.options.types.every((e) => t.resetAttributes(e, "dir"))
    };
  }
}), Mxe = new Nt("mention"), Bxe = rn.create({
  name: "mention",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {},
      renderText({ options: t, node: e }) {
        var n;
        return `${t.suggestion.char}${(n = e.attrs.label) !== null && n !== void 0 ? n : e.attrs.id}`;
      },
      deleteTriggerWithBackspace: !1,
      renderHTML({ options: t, node: e }) {
        var n;
        return [
          "span",
          bt(this.HTMLAttributes, t.HTMLAttributes),
          `${t.suggestion.char}${(n = e.attrs.label) !== null && n !== void 0 ? n : e.attrs.id}`
        ];
      },
      suggestion: {
        char: "@",
        pluginKey: Mxe,
        command: ({ editor: t, range: e, props: n }) => {
          var r, i, o;
          const a = t.view.state.selection.$to.nodeAfter;
          ((r = a == null ? void 0 : a.text) === null || r === void 0 ? void 0 : r.startsWith(" ")) && (e.to += 1), t.chain().focus().insertContentAt(e, [
            {
              type: this.name,
              attrs: n
            },
            {
              type: "text",
              text: " "
            }
          ]).run(), (o = (i = t.view.dom.ownerDocument.defaultView) === null || i === void 0 ? void 0 : i.getSelection()) === null || o === void 0 || o.collapseToEnd();
        },
        allow: ({ state: t, range: e }) => {
          const n = t.doc.resolve(e.from), r = t.schema.nodes[this.name];
          return !!n.parent.type.contentMatch.matchType(r);
        }
      }
    };
  },
  group: "inline",
  inline: !0,
  selectable: !1,
  atom: !0,
  addAttributes() {
    return {
      id: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-id"),
        renderHTML: (t) => t.id ? {
          "data-id": t.id
        } : {}
      },
      label: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-label"),
        renderHTML: (t) => t.label ? {
          "data-label": t.label
        } : {}
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `span[data-type="${this.name}"]`
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    if (this.options.renderLabel !== void 0)
      return console.warn("renderLabel is deprecated use renderText and renderHTML instead"), [
        "span",
        bt({ "data-type": this.name }, this.options.HTMLAttributes, e),
        this.options.renderLabel({
          options: this.options,
          node: t
        })
      ];
    const n = { ...this.options };
    n.HTMLAttributes = bt({ "data-type": this.name }, this.options.HTMLAttributes, e);
    const r = this.options.renderHTML({
      options: n,
      node: t
    });
    return typeof r == "string" ? [
      "span",
      bt({ "data-type": this.name }, this.options.HTMLAttributes, e),
      r
    ] : r;
  },
  renderText({ node: t }) {
    return this.options.renderLabel !== void 0 ? (console.warn("renderLabel is deprecated use renderText and renderHTML instead"), this.options.renderLabel({
      options: this.options,
      node: t
    })) : this.options.renderText({
      options: this.options,
      node: t
    });
  },
  addKeyboardShortcuts() {
    return {
      Backspace: () => this.editor.commands.command(({ tr: t, state: e }) => {
        let n = !1;
        const { selection: r } = e, { empty: i, anchor: o } = r;
        return i ? (e.doc.nodesBetween(o - 1, o, (a, s) => {
          if (a.type.name === this.name)
            return n = !0, t.insertText(this.options.deleteTriggerWithBackspace ? "" : this.options.suggestion.char || "", s, s + a.nodeSize), !1;
        }), n) : !1;
      })
    };
  },
  addProseMirrorPlugins() {
    return [
      wE({
        editor: this.editor,
        ...this.options.suggestion
      })
    ];
  }
}), Lxe = "_listUsers_en3pm_1", Pxe = "_itemUser_en3pm_10", Wxe = "_selectedUser_en3pm_31", Uy = {
  listUsers: Lxe,
  itemUser: Pxe,
  selectedUser: Wxe
}, zxe = Om((t, e) => {
  const n = Wr(), [r, i] = nt(0), o = (c) => {
    const u = t.items[c];
    u && t.command({ id: u, label: u });
  }, a = () => {
    i((r + t.items.length - 1) % t.items.length);
  }, s = () => {
    i((r + 1) % t.items.length);
  }, l = () => {
    o(r);
  };
  return Tt(() => i(0), [t.items]), Tt(() => {
    if (Number.isNaN(r + 1))
      return;
    const c = n.current.querySelector(`span:nth-of-type(${r + 1})`);
    c && XT(c, { behavior: "smooth", scrollMode: "if-needed" });
  }, [r]), Kv(e, () => ({
    onKeyDown: ({ event: c }) => c.key === "ArrowUp" ? (a(), !0) : c.key === "ArrowDown" ? (s(), !0) : c.key === "Enter" ? (l(), !0) : !1
  })), /* @__PURE__ */ z("div", { className: xo("listUsers", Uy.listUsers), children: /* @__PURE__ */ z("div", { ref: n, children: t.items.length ? t.items.map((c, u) => /* @__PURE__ */ z(
    "span",
    {
      className: xo("itemUser", Uy.itemUser, u === r ? Uy.selectedUser : ""),
      onClick: () => o(u),
      children: c
    },
    u
  )) : /* @__PURE__ */ z("div", { className: xo("itemUserEmpty", Uy.itemUser), children: "Empty" }) }) });
}), $xe = [
  {
    id: "1",
    name: "John Doe"
  },
  {
    id: "2",
    name: "Jane Doe"
  },
  {
    id: "3",
    name: "Alice"
  },
  {
    id: "4",
    name: "Bob"
  }
], Hxe = {
  items: async ({ query: t }) => $xe.map((n) => n.name).filter((n) => n.toLowerCase().startsWith(t.toLowerCase())),
  render: () => {
    let t, e;
    return {
      onStart: (n) => {
        t = new g1(zxe, {
          props: n,
          editor: n.editor
        }), e = Fm("body", {
          getReferenceClientRect: n.clientRect,
          appendTo: () => document.body,
          content: t.element,
          showOnCreate: !0,
          interactive: !0,
          trigger: "manual",
          placement: "bottom-start"
        });
      },
      onUpdate(n) {
        t.updateProps(n), e[0].setProps({
          getReferenceClientRect: n.clientRect
        });
      },
      onKeyDown(n) {
        var r;
        return n.event.key === "Escape" ? (e[0].hide(), !0) : (r = t.ref) == null ? void 0 : r.onKeyDown(n);
      },
      onExit() {
        e[0].destroy(), t.destroy();
      }
    };
  }
}, l_e = Bxe.extend({
  addAttributes() {
    return {
      id: {
        default: "",
        parseHTML: Yi("id")
      },
      label: {
        default: "",
        parseHTML: Yi("label")
      }
    };
  }
}).configure({
  HTMLAttributes: {
    class: "mention"
  },
  suggestion: Hxe
});
var Du = {}, Ac = {};
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QO;
function jxe() {
  if (QO) return Ac;
  QO = 1;
  var t = Lt;
  function e(B) {
    for (var X = "https://reactjs.org/docs/error-decoder.html?invariant=" + B, ue = 1; ue < arguments.length; ue++) X += "&args[]=" + encodeURIComponent(arguments[ue]);
    return "Minified React error #" + B + "; visit " + X + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = Object.prototype.hasOwnProperty, r = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, i = {}, o = {};
  function a(B) {
    return n.call(o, B) ? !0 : n.call(i, B) ? !1 : r.test(B) ? o[B] = !0 : (i[B] = !0, !1);
  }
  function s(B, X, ue, Se, Re, Ce, Be) {
    this.acceptsBooleans = X === 2 || X === 3 || X === 4, this.attributeName = Se, this.attributeNamespace = Re, this.mustUseProperty = ue, this.propertyName = B, this.type = X, this.sanitizeURL = Ce, this.removeEmptyString = Be;
  }
  var l = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(B) {
    l[B] = new s(B, 0, !1, B, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(B) {
    var X = B[0];
    l[X] = new s(X, 1, !1, B[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(B) {
    l[B] = new s(B, 2, !1, B.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(B) {
    l[B] = new s(B, 2, !1, B, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(B) {
    l[B] = new s(B, 3, !1, B.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(B) {
    l[B] = new s(B, 3, !0, B, null, !1, !1);
  }), ["capture", "download"].forEach(function(B) {
    l[B] = new s(B, 4, !1, B, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(B) {
    l[B] = new s(B, 6, !1, B, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(B) {
    l[B] = new s(B, 5, !1, B.toLowerCase(), null, !1, !1);
  });
  var c = /[\-:]([a-z])/g;
  function u(B) {
    return B[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(B) {
    var X = B.replace(
      c,
      u
    );
    l[X] = new s(X, 1, !1, B, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(B) {
    var X = B.replace(c, u);
    l[X] = new s(X, 1, !1, B, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(B) {
    var X = B.replace(c, u);
    l[X] = new s(X, 1, !1, B, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(B) {
    l[B] = new s(B, 1, !1, B.toLowerCase(), null, !1, !1);
  }), l.xlinkHref = new s("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(B) {
    l[B] = new s(B, 1, !1, B.toLowerCase(), null, !0, !0);
  });
  var d = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, f = ["Webkit", "ms", "Moz", "O"];
  Object.keys(d).forEach(function(B) {
    f.forEach(function(X) {
      X = X + B.charAt(0).toUpperCase() + B.substring(1), d[X] = d[B];
    });
  });
  var p = /["'&<>]/;
  function m(B) {
    if (typeof B == "boolean" || typeof B == "number") return "" + B;
    B = "" + B;
    var X = p.exec(B);
    if (X) {
      var ue = "", Se, Re = 0;
      for (Se = X.index; Se < B.length; Se++) {
        switch (B.charCodeAt(Se)) {
          case 34:
            X = "&quot;";
            break;
          case 38:
            X = "&amp;";
            break;
          case 39:
            X = "&#x27;";
            break;
          case 60:
            X = "&lt;";
            break;
          case 62:
            X = "&gt;";
            break;
          default:
            continue;
        }
        Re !== Se && (ue += B.substring(Re, Se)), Re = Se + 1, ue += X;
      }
      B = Re !== Se ? ue + B.substring(Re, Se) : ue;
    }
    return B;
  }
  var g = /([A-Z])/g, b = /^ms-/, y = Array.isArray;
  function w(B, X) {
    return { insertionMode: B, selectedValue: X };
  }
  function x(B, X, ue) {
    switch (X) {
      case "select":
        return w(1, ue.value != null ? ue.value : ue.defaultValue);
      case "svg":
        return w(2, null);
      case "math":
        return w(3, null);
      case "foreignObject":
        return w(1, null);
      case "table":
        return w(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return w(5, null);
      case "colgroup":
        return w(7, null);
      case "tr":
        return w(6, null);
    }
    return 4 <= B.insertionMode || B.insertionMode === 0 ? w(1, null) : B;
  }
  var k = /* @__PURE__ */ new Map();
  function A(B, X, ue) {
    if (typeof ue != "object") throw Error(e(62));
    X = !0;
    for (var Se in ue) if (n.call(ue, Se)) {
      var Re = ue[Se];
      if (Re != null && typeof Re != "boolean" && Re !== "") {
        if (Se.indexOf("--") === 0) {
          var Ce = m(Se);
          Re = m(("" + Re).trim());
        } else {
          Ce = Se;
          var Be = k.get(Ce);
          Be !== void 0 || (Be = m(Ce.replace(g, "-$1").toLowerCase().replace(b, "-ms-")), k.set(Ce, Be)), Ce = Be, Re = typeof Re == "number" ? Re === 0 || n.call(d, Se) ? "" + Re : Re + "px" : m(("" + Re).trim());
        }
        X ? (X = !1, B.push(' style="', Ce, ":", Re)) : B.push(";", Ce, ":", Re);
      }
    }
    X || B.push('"');
  }
  function U(B, X, ue, Se) {
    switch (ue) {
      case "style":
        A(B, X, Se);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < ue.length) || ue[0] !== "o" && ue[0] !== "O" || ue[1] !== "n" && ue[1] !== "N") {
      if (X = l.hasOwnProperty(ue) ? l[ue] : null, X !== null) {
        switch (typeof Se) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!X.acceptsBooleans) return;
        }
        switch (ue = X.attributeName, X.type) {
          case 3:
            Se && B.push(" ", ue, '=""');
            break;
          case 4:
            Se === !0 ? B.push(" ", ue, '=""') : Se !== !1 && B.push(" ", ue, '="', m(Se), '"');
            break;
          case 5:
            isNaN(Se) || B.push(" ", ue, '="', m(Se), '"');
            break;
          case 6:
            !isNaN(Se) && 1 <= Se && B.push(" ", ue, '="', m(Se), '"');
            break;
          default:
            X.sanitizeURL && (Se = "" + Se), B.push(" ", ue, '="', m(Se), '"');
        }
      } else if (a(ue)) {
        switch (typeof Se) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (X = ue.toLowerCase().slice(0, 5), X !== "data-" && X !== "aria-") return;
        }
        B.push(" ", ue, '="', m(Se), '"');
      }
    }
  }
  function P(B, X, ue) {
    if (X != null) {
      if (ue != null) throw Error(e(60));
      if (typeof X != "object" || !("__html" in X)) throw Error(e(61));
      X = X.__html, X != null && B.push("" + X);
    }
  }
  function V(B) {
    var X = "";
    return t.Children.forEach(B, function(ue) {
      ue != null && (X += ue);
    }), X;
  }
  function I(B, X, ue, Se) {
    B.push(F(ue));
    var Re = ue = null, Ce;
    for (Ce in X) if (n.call(X, Ce)) {
      var Be = X[Ce];
      if (Be != null) switch (Ce) {
        case "children":
          ue = Be;
          break;
        case "dangerouslySetInnerHTML":
          Re = Be;
          break;
        default:
          U(B, Se, Ce, Be);
      }
    }
    return B.push(">"), P(B, Re, ue), typeof ue == "string" ? (B.push(m(ue)), null) : ue;
  }
  var le = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, be = /* @__PURE__ */ new Map();
  function F(B) {
    var X = be.get(B);
    if (X === void 0) {
      if (!le.test(B)) throw Error(e(65, B));
      X = "<" + B, be.set(B, X);
    }
    return X;
  }
  function G(B, X, ue, Se, Re) {
    switch (X) {
      case "select":
        B.push(F("select"));
        var Ce = null, Be = null;
        for (it in ue) if (n.call(ue, it)) {
          var Ve = ue[it];
          if (Ve != null) switch (it) {
            case "children":
              Ce = Ve;
              break;
            case "dangerouslySetInnerHTML":
              Be = Ve;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              U(B, Se, it, Ve);
          }
        }
        return B.push(">"), P(B, Be, Ce), Ce;
      case "option":
        Be = Re.selectedValue, B.push(F("option"));
        var rt = Ve = null, lt = null, it = null;
        for (Ce in ue) if (n.call(ue, Ce)) {
          var Rt = ue[Ce];
          if (Rt != null) switch (Ce) {
            case "children":
              Ve = Rt;
              break;
            case "selected":
              lt = Rt;
              break;
            case "dangerouslySetInnerHTML":
              it = Rt;
              break;
            case "value":
              rt = Rt;
            default:
              U(B, Se, Ce, Rt);
          }
        }
        if (Be != null) if (ue = rt !== null ? "" + rt : V(Ve), y(Be)) {
          for (Se = 0; Se < Be.length; Se++)
            if ("" + Be[Se] === ue) {
              B.push(' selected=""');
              break;
            }
        } else "" + Be === ue && B.push(' selected=""');
        else lt && B.push(' selected=""');
        return B.push(">"), P(B, it, Ve), Ve;
      case "textarea":
        B.push(F("textarea")), it = Be = Ce = null;
        for (Ve in ue) if (n.call(ue, Ve) && (rt = ue[Ve], rt != null)) switch (Ve) {
          case "children":
            it = rt;
            break;
          case "value":
            Ce = rt;
            break;
          case "defaultValue":
            Be = rt;
            break;
          case "dangerouslySetInnerHTML":
            throw Error(e(91));
          default:
            U(
              B,
              Se,
              Ve,
              rt
            );
        }
        if (Ce === null && Be !== null && (Ce = Be), B.push(">"), it != null) {
          if (Ce != null) throw Error(e(92));
          if (y(it) && 1 < it.length) throw Error(e(93));
          Ce = "" + it;
        }
        return typeof Ce == "string" && Ce[0] === `
` && B.push(`
`), Ce !== null && B.push(m("" + Ce)), null;
      case "input":
        B.push(F("input")), rt = it = Ve = Ce = null;
        for (Be in ue) if (n.call(ue, Be) && (lt = ue[Be], lt != null)) switch (Be) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(e(399, "input"));
          case "defaultChecked":
            rt = lt;
            break;
          case "defaultValue":
            Ve = lt;
            break;
          case "checked":
            it = lt;
            break;
          case "value":
            Ce = lt;
            break;
          default:
            U(B, Se, Be, lt);
        }
        return it !== null ? U(B, Se, "checked", it) : rt !== null && U(B, Se, "checked", rt), Ce !== null ? U(B, Se, "value", Ce) : Ve !== null && U(B, Se, "value", Ve), B.push("/>"), null;
      case "menuitem":
        B.push(F("menuitem"));
        for (var zn in ue) if (n.call(ue, zn) && (Ce = ue[zn], Ce != null)) switch (zn) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(e(400));
          default:
            U(B, Se, zn, Ce);
        }
        return B.push(">"), null;
      case "title":
        B.push(F("title")), Ce = null;
        for (Rt in ue) if (n.call(ue, Rt) && (Be = ue[Rt], Be != null)) switch (Rt) {
          case "children":
            Ce = Be;
            break;
          case "dangerouslySetInnerHTML":
            throw Error(e(434));
          default:
            U(B, Se, Rt, Be);
        }
        return B.push(">"), Ce;
      case "listing":
      case "pre":
        B.push(F(X)), Be = Ce = null;
        for (rt in ue) if (n.call(ue, rt) && (Ve = ue[rt], Ve != null)) switch (rt) {
          case "children":
            Ce = Ve;
            break;
          case "dangerouslySetInnerHTML":
            Be = Ve;
            break;
          default:
            U(B, Se, rt, Ve);
        }
        if (B.push(">"), Be != null) {
          if (Ce != null) throw Error(e(60));
          if (typeof Be != "object" || !("__html" in Be)) throw Error(e(61));
          ue = Be.__html, ue != null && (typeof ue == "string" && 0 < ue.length && ue[0] === `
` ? B.push(`
`, ue) : B.push("" + ue));
        }
        return typeof Ce == "string" && Ce[0] === `
` && B.push(`
`), Ce;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        B.push(F(X));
        for (var $n in ue) if (n.call(ue, $n) && (Ce = ue[$n], Ce != null)) switch ($n) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(e(399, X));
          default:
            U(B, Se, $n, Ce);
        }
        return B.push("/>"), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return I(
          B,
          ue,
          X,
          Se
        );
      case "html":
        return Re.insertionMode === 0 && B.push("<!DOCTYPE html>"), I(B, ue, X, Se);
      default:
        if (X.indexOf("-") === -1 && typeof ue.is != "string") return I(B, ue, X, Se);
        B.push(F(X)), Be = Ce = null;
        for (lt in ue) if (n.call(ue, lt) && (Ve = ue[lt], Ve != null)) switch (lt) {
          case "children":
            Ce = Ve;
            break;
          case "dangerouslySetInnerHTML":
            Be = Ve;
            break;
          case "style":
            A(B, Se, Ve);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            break;
          default:
            a(lt) && typeof Ve != "function" && typeof Ve != "symbol" && B.push(" ", lt, '="', m(Ve), '"');
        }
        return B.push(">"), P(B, Be, Ce), Ce;
    }
  }
  function C(B, X, ue) {
    if (B.push('<!--$?--><template id="'), ue === null) throw Error(e(395));
    return B.push(ue), B.push('"></template>');
  }
  function ie(B, X, ue, Se) {
    switch (ue.insertionMode) {
      case 0:
      case 1:
        return B.push('<div hidden id="'), B.push(X.segmentPrefix), X = Se.toString(16), B.push(X), B.push('">');
      case 2:
        return B.push('<svg aria-hidden="true" style="display:none" id="'), B.push(X.segmentPrefix), X = Se.toString(16), B.push(X), B.push('">');
      case 3:
        return B.push('<math aria-hidden="true" style="display:none" id="'), B.push(X.segmentPrefix), X = Se.toString(16), B.push(X), B.push('">');
      case 4:
        return B.push('<table hidden id="'), B.push(X.segmentPrefix), X = Se.toString(16), B.push(X), B.push('">');
      case 5:
        return B.push('<table hidden><tbody id="'), B.push(X.segmentPrefix), X = Se.toString(16), B.push(X), B.push('">');
      case 6:
        return B.push('<table hidden><tr id="'), B.push(X.segmentPrefix), X = Se.toString(16), B.push(X), B.push('">');
      case 7:
        return B.push('<table hidden><colgroup id="'), B.push(X.segmentPrefix), X = Se.toString(16), B.push(X), B.push('">');
      default:
        throw Error(e(397));
    }
  }
  function ee(B, X) {
    switch (X.insertionMode) {
      case 0:
      case 1:
        return B.push("</div>");
      case 2:
        return B.push("</svg>");
      case 3:
        return B.push("</math>");
      case 4:
        return B.push("</table>");
      case 5:
        return B.push("</tbody></table>");
      case 6:
        return B.push("</tr></table>");
      case 7:
        return B.push("</colgroup></table>");
      default:
        throw Error(e(397));
    }
  }
  var Z = /[<\u2028\u2029]/g;
  function oe(B) {
    return JSON.stringify(B).replace(Z, function(X) {
      switch (X) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  function te(B, X) {
    return X = X === void 0 ? "" : X, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: X + "P:", segmentPrefix: X + "S:", boundaryPrefix: X + "B:", idPrefix: X, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: B };
  }
  function _e(B, X, ue, Se) {
    return ue.generateStaticMarkup ? (B.push(m(X)), !1) : (X === "" ? B = Se : (Se && B.push("<!-- -->"), B.push(m(X)), B = !0), B);
  }
  var q = Object.assign, N = Symbol.for("react.element"), ce = Symbol.for("react.portal"), me = Symbol.for("react.fragment"), ve = Symbol.for("react.strict_mode"), he = Symbol.for("react.profiler"), H = Symbol.for("react.provider"), W = Symbol.for("react.context"), we = Symbol.for("react.forward_ref"), ye = Symbol.for("react.suspense"), j = Symbol.for("react.suspense_list"), Q = Symbol.for("react.memo"), De = Symbol.for("react.lazy"), T = Symbol.for("react.scope"), pe = Symbol.for("react.debug_trace_mode"), M = Symbol.for("react.legacy_hidden"), _ = Symbol.for("react.default_value"), S = Symbol.iterator;
  function O(B) {
    if (B == null) return null;
    if (typeof B == "function") return B.displayName || B.name || null;
    if (typeof B == "string") return B;
    switch (B) {
      case me:
        return "Fragment";
      case ce:
        return "Portal";
      case he:
        return "Profiler";
      case ve:
        return "StrictMode";
      case ye:
        return "Suspense";
      case j:
        return "SuspenseList";
    }
    if (typeof B == "object") switch (B.$$typeof) {
      case W:
        return (B.displayName || "Context") + ".Consumer";
      case H:
        return (B._context.displayName || "Context") + ".Provider";
      case we:
        var X = B.render;
        return B = B.displayName, B || (B = X.displayName || X.name || "", B = B !== "" ? "ForwardRef(" + B + ")" : "ForwardRef"), B;
      case Q:
        return X = B.displayName || null, X !== null ? X : O(B.type) || "Memo";
      case De:
        X = B._payload, B = B._init;
        try {
          return O(B(X));
        } catch {
        }
    }
    return null;
  }
  var ne = {};
  function fe(B, X) {
    if (B = B.contextTypes, !B) return ne;
    var ue = {}, Se;
    for (Se in B) ue[Se] = X[Se];
    return ue;
  }
  var J = null;
  function re(B, X) {
    if (B !== X) {
      B.context._currentValue2 = B.parentValue, B = B.parent;
      var ue = X.parent;
      if (B === null) {
        if (ue !== null) throw Error(e(401));
      } else {
        if (ue === null) throw Error(e(401));
        re(B, ue);
      }
      X.context._currentValue2 = X.value;
    }
  }
  function de(B) {
    B.context._currentValue2 = B.parentValue, B = B.parent, B !== null && de(B);
  }
  function ge(B) {
    var X = B.parent;
    X !== null && ge(X), B.context._currentValue2 = B.value;
  }
  function Ee(B, X) {
    if (B.context._currentValue2 = B.parentValue, B = B.parent, B === null) throw Error(e(402));
    B.depth === X.depth ? re(B, X) : Ee(B, X);
  }
  function Ne(B, X) {
    var ue = X.parent;
    if (ue === null) throw Error(e(402));
    B.depth === ue.depth ? re(B, ue) : Ne(B, ue), X.context._currentValue2 = X.value;
  }
  function Le(B) {
    var X = J;
    X !== B && (X === null ? ge(B) : B === null ? de(X) : X.depth === B.depth ? re(X, B) : X.depth > B.depth ? Ee(X, B) : Ne(X, B), J = B);
  }
  var Qe = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(B, X) {
    B = B._reactInternals, B.queue !== null && B.queue.push(X);
  }, enqueueReplaceState: function(B, X) {
    B = B._reactInternals, B.replace = !0, B.queue = [X];
  }, enqueueForceUpdate: function() {
  } };
  function Ze(B, X, ue, Se) {
    var Re = B.state !== void 0 ? B.state : null;
    B.updater = Qe, B.props = ue, B.state = Re;
    var Ce = { queue: [], replace: !1 };
    B._reactInternals = Ce;
    var Be = X.contextType;
    if (B.context = typeof Be == "object" && Be !== null ? Be._currentValue2 : Se, Be = X.getDerivedStateFromProps, typeof Be == "function" && (Be = Be(ue, Re), Re = Be == null ? Re : q({}, Re, Be), B.state = Re), typeof X.getDerivedStateFromProps != "function" && typeof B.getSnapshotBeforeUpdate != "function" && (typeof B.UNSAFE_componentWillMount == "function" || typeof B.componentWillMount == "function")) if (X = B.state, typeof B.componentWillMount == "function" && B.componentWillMount(), typeof B.UNSAFE_componentWillMount == "function" && B.UNSAFE_componentWillMount(), X !== B.state && Qe.enqueueReplaceState(B, B.state, null), Ce.queue !== null && 0 < Ce.queue.length) if (X = Ce.queue, Be = Ce.replace, Ce.queue = null, Ce.replace = !1, Be && X.length === 1) B.state = X[0];
    else {
      for (Ce = Be ? X[0] : B.state, Re = !0, Be = Be ? 1 : 0; Be < X.length; Be++) {
        var Ve = X[Be];
        Ve = typeof Ve == "function" ? Ve.call(B, Ce, ue, Se) : Ve, Ve != null && (Re ? (Re = !1, Ce = q({}, Ce, Ve)) : q(Ce, Ve));
      }
      B.state = Ce;
    }
    else Ce.queue = null;
  }
  var at = { id: 1, overflow: "" };
  function gt(B, X, ue) {
    var Se = B.id;
    B = B.overflow;
    var Re = 32 - et(Se) - 1;
    Se &= ~(1 << Re), ue += 1;
    var Ce = 32 - et(X) + Re;
    if (30 < Ce) {
      var Be = Re - Re % 5;
      return Ce = (Se & (1 << Be) - 1).toString(32), Se >>= Be, Re -= Be, { id: 1 << 32 - et(X) + Re | ue << Re | Se, overflow: Ce + B };
    }
    return { id: 1 << Ce | ue << Re | Se, overflow: B };
  }
  var et = Math.clz32 ? Math.clz32 : Ft, Zt = Math.log, Un = Math.LN2;
  function Ft(B) {
    return B >>>= 0, B === 0 ? 32 : 31 - (Zt(B) / Un | 0) | 0;
  }
  function Ar(B, X) {
    return B === X && (B !== 0 || 1 / B === 1 / X) || B !== B && X !== X;
  }
  var Ii = typeof Object.is == "function" ? Object.is : Ar, xn = null, Bn = null, Ln = null, ht = null, _n = !1, Oo = !1, ao = 0, Vr = null, Fo = 0;
  function mi() {
    if (xn === null) throw Error(e(321));
    return xn;
  }
  function Sn() {
    if (0 < Fo) throw Error(e(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function xa() {
    return ht === null ? Ln === null ? (_n = !1, Ln = ht = Sn()) : (_n = !0, ht = Ln) : ht.next === null ? (_n = !1, ht = ht.next = Sn()) : (_n = !0, ht = ht.next), ht;
  }
  function _a() {
    Bn = xn = null, Oo = !1, Ln = null, Fo = 0, ht = Vr = null;
  }
  function _s(B, X) {
    return typeof X == "function" ? X(B) : X;
  }
  function mn(B, X, ue) {
    if (xn = mi(), ht = xa(), _n) {
      var Se = ht.queue;
      if (X = Se.dispatch, Vr !== null && (ue = Vr.get(Se), ue !== void 0)) {
        Vr.delete(Se), Se = ht.memoizedState;
        do
          Se = B(Se, ue.action), ue = ue.next;
        while (ue !== null);
        return ht.memoizedState = Se, [Se, X];
      }
      return [ht.memoizedState, X];
    }
    return B = B === _s ? typeof X == "function" ? X() : X : ue !== void 0 ? ue(X) : X, ht.memoizedState = B, B = ht.queue = { last: null, dispatch: null }, B = B.dispatch = Vl.bind(null, xn, B), [ht.memoizedState, B];
  }
  function Sa(B, X) {
    if (xn = mi(), ht = xa(), X = X === void 0 ? null : X, ht !== null) {
      var ue = ht.memoizedState;
      if (ue !== null && X !== null) {
        var Se = ue[1];
        e: if (Se === null) Se = !1;
        else {
          for (var Re = 0; Re < Se.length && Re < X.length; Re++) if (!Ii(X[Re], Se[Re])) {
            Se = !1;
            break e;
          }
          Se = !0;
        }
        if (Se) return ue[0];
      }
    }
    return B = B(), ht.memoizedState = [B, X], B;
  }
  function Vl(B, X, ue) {
    if (25 <= Fo) throw Error(e(301));
    if (B === xn) if (Oo = !0, B = { action: ue, next: null }, Vr === null && (Vr = /* @__PURE__ */ new Map()), ue = Vr.get(X), ue === void 0) Vr.set(X, B);
    else {
      for (X = ue; X.next !== null; ) X = X.next;
      X.next = B;
    }
  }
  function ql() {
    throw Error(e(394));
  }
  function qr() {
  }
  var Ta = { readContext: function(B) {
    return B._currentValue2;
  }, useContext: function(B) {
    return mi(), B._currentValue2;
  }, useMemo: Sa, useReducer: mn, useRef: function(B) {
    xn = mi(), ht = xa();
    var X = ht.memoizedState;
    return X === null ? (B = { current: B }, ht.memoizedState = B) : X;
  }, useState: function(B) {
    return mn(_s, B);
  }, useInsertionEffect: qr, useLayoutEffect: function() {
  }, useCallback: function(B, X) {
    return Sa(function() {
      return B;
    }, X);
  }, useImperativeHandle: qr, useEffect: qr, useDebugValue: qr, useDeferredValue: function(B) {
    return mi(), B;
  }, useTransition: function() {
    return mi(), [
      !1,
      ql
    ];
  }, useId: function() {
    var B = Bn.treeContext, X = B.overflow;
    B = B.id, B = (B & ~(1 << 32 - et(B) - 1)).toString(32) + X;
    var ue = Uo;
    if (ue === null) throw Error(e(404));
    return X = ao++, B = ":" + ue.idPrefix + "R" + B, 0 < X && (B += "H" + X.toString(32)), B + ":";
  }, useMutableSource: function(B, X) {
    return mi(), X(B._source);
  }, useSyncExternalStore: function(B, X, ue) {
    if (ue === void 0) throw Error(e(407));
    return ue();
  } }, Uo = null, Oi = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function Qn(B) {
    return console.error(B), null;
  }
  function Gr() {
  }
  function No(B, X, ue, Se, Re, Ce, Be, Ve, rt) {
    var lt = [], it = /* @__PURE__ */ new Set();
    return X = { destination: null, responseState: X, progressiveChunkSize: Se === void 0 ? 12800 : Se, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: it, pingedTasks: lt, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: Re === void 0 ? Qn : Re, onAllReady: Gr, onShellReady: Be === void 0 ? Gr : Be, onShellError: Gr, onFatalError: Gr }, ue = Ui(X, 0, null, ue, !1, !1), ue.parentFlushed = !0, B = Fi(X, B, null, ue, it, ne, null, at), lt.push(B), X;
  }
  function Fi(B, X, ue, Se, Re, Ce, Be, Ve) {
    B.allPendingTasks++, ue === null ? B.pendingRootTasks++ : ue.pendingTasks++;
    var rt = { node: X, ping: function() {
      var lt = B.pingedTasks;
      lt.push(rt), lt.length === 1 && Pn(B);
    }, blockedBoundary: ue, blockedSegment: Se, abortSet: Re, legacyContext: Ce, context: Be, treeContext: Ve };
    return Re.add(rt), rt;
  }
  function Ui(B, X, ue, Se, Re, Ce) {
    return { status: 0, id: -1, index: X, parentFlushed: !1, chunks: [], children: [], formatContext: Se, boundary: ue, lastPushedText: Re, textEmbedded: Ce };
  }
  function Kr(B, X) {
    if (B = B.onError(X), B != null && typeof B != "string") throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof B + '" instead');
    return B;
  }
  function Ni(B, X) {
    var ue = B.onShellError;
    ue(X), ue = B.onFatalError, ue(X), B.destination !== null ? (B.status = 2, B.destination.destroy(X)) : (B.status = 1, B.fatalError = X);
  }
  function er(B, X, ue, Se, Re) {
    for (xn = {}, Bn = X, ao = 0, B = ue(Se, Re); Oo; ) Oo = !1, ao = 0, Fo += 1, ht = null, B = ue(Se, Re);
    return _a(), B;
  }
  function Ss(B, X, ue, Se) {
    var Re = ue.render(), Ce = Se.childContextTypes;
    if (Ce != null) {
      var Be = X.legacyContext;
      if (typeof ue.getChildContext != "function") Se = Be;
      else {
        ue = ue.getChildContext();
        for (var Ve in ue) if (!(Ve in Ce)) throw Error(e(108, O(Se) || "Unknown", Ve));
        Se = q({}, Be, ue);
      }
      X.legacyContext = Se, gn(B, X, Re), X.legacyContext = Be;
    } else gn(B, X, Re);
  }
  function Ts(B, X) {
    if (B && B.defaultProps) {
      X = q({}, X), B = B.defaultProps;
      for (var ue in B) X[ue] === void 0 && (X[ue] = B[ue]);
      return X;
    }
    return X;
  }
  function gi(B, X, ue, Se, Re) {
    if (typeof ue == "function") if (ue.prototype && ue.prototype.isReactComponent) {
      Re = fe(ue, X.legacyContext);
      var Ce = ue.contextType;
      Ce = new ue(Se, typeof Ce == "object" && Ce !== null ? Ce._currentValue2 : Re), Ze(Ce, ue, Se, Re), Ss(B, X, Ce, ue);
    } else {
      Ce = fe(ue, X.legacyContext), Re = er(B, X, ue, Se, Ce);
      var Be = ao !== 0;
      if (typeof Re == "object" && Re !== null && typeof Re.render == "function" && Re.$$typeof === void 0) Ze(Re, ue, Se, Ce), Ss(B, X, Re, ue);
      else if (Be) {
        Se = X.treeContext, X.treeContext = gt(Se, 1, 0);
        try {
          gn(B, X, Re);
        } finally {
          X.treeContext = Se;
        }
      } else gn(B, X, Re);
    }
    else if (typeof ue == "string") {
      switch (Re = X.blockedSegment, Ce = G(Re.chunks, ue, Se, B.responseState, Re.formatContext), Re.lastPushedText = !1, Be = Re.formatContext, Re.formatContext = x(Be, ue, Se), Yr(B, X, Ce), Re.formatContext = Be, ue) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          Re.chunks.push("</", ue, ">");
      }
      Re.lastPushedText = !1;
    } else {
      switch (ue) {
        case M:
        case pe:
        case ve:
        case he:
        case me:
          gn(B, X, Se.children);
          return;
        case j:
          gn(B, X, Se.children);
          return;
        case T:
          throw Error(e(343));
        case ye:
          e: {
            ue = X.blockedBoundary, Re = X.blockedSegment, Ce = Se.fallback, Se = Se.children, Be = /* @__PURE__ */ new Set();
            var Ve = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: Be, errorDigest: null }, rt = Ui(B, Re.chunks.length, Ve, Re.formatContext, !1, !1);
            Re.children.push(rt), Re.lastPushedText = !1;
            var lt = Ui(B, 0, null, Re.formatContext, !1, !1);
            lt.parentFlushed = !0, X.blockedBoundary = Ve, X.blockedSegment = lt;
            try {
              if (Yr(
                B,
                X,
                Se
              ), B.responseState.generateStaticMarkup || lt.lastPushedText && lt.textEmbedded && lt.chunks.push("<!-- -->"), lt.status = 1, Rr(Ve, lt), Ve.pendingTasks === 0) break e;
            } catch (it) {
              lt.status = 4, Ve.forceClientRender = !0, Ve.errorDigest = Kr(B, it);
            } finally {
              X.blockedBoundary = ue, X.blockedSegment = Re;
            }
            X = Fi(B, Ce, ue, rt, Be, X.legacyContext, X.context, X.treeContext), B.pingedTasks.push(X);
          }
          return;
      }
      if (typeof ue == "object" && ue !== null) switch (ue.$$typeof) {
        case we:
          if (Se = er(B, X, ue.render, Se, Re), ao !== 0) {
            ue = X.treeContext, X.treeContext = gt(ue, 1, 0);
            try {
              gn(B, X, Se);
            } finally {
              X.treeContext = ue;
            }
          } else gn(B, X, Se);
          return;
        case Q:
          ue = ue.type, Se = Ts(ue, Se), gi(B, X, ue, Se, Re);
          return;
        case H:
          if (Re = Se.children, ue = ue._context, Se = Se.value, Ce = ue._currentValue2, ue._currentValue2 = Se, Be = J, J = Se = { parent: Be, depth: Be === null ? 0 : Be.depth + 1, context: ue, parentValue: Ce, value: Se }, X.context = Se, gn(B, X, Re), B = J, B === null) throw Error(e(403));
          Se = B.parentValue, B.context._currentValue2 = Se === _ ? B.context._defaultValue : Se, B = J = B.parent, X.context = B;
          return;
        case W:
          Se = Se.children, Se = Se(ue._currentValue2), gn(B, X, Se);
          return;
        case De:
          Re = ue._init, ue = Re(ue._payload), Se = Ts(ue, Se), gi(
            B,
            X,
            ue,
            Se,
            void 0
          );
          return;
      }
      throw Error(e(130, ue == null ? ue : typeof ue, ""));
    }
  }
  function gn(B, X, ue) {
    if (X.node = ue, typeof ue == "object" && ue !== null) {
      switch (ue.$$typeof) {
        case N:
          gi(B, X, ue.type, ue.props, ue.ref);
          return;
        case ce:
          throw Error(e(257));
        case De:
          var Se = ue._init;
          ue = Se(ue._payload), gn(B, X, ue);
          return;
      }
      if (y(ue)) {
        Xr(B, X, ue);
        return;
      }
      if (ue === null || typeof ue != "object" ? Se = null : (Se = S && ue[S] || ue["@@iterator"], Se = typeof Se == "function" ? Se : null), Se && (Se = Se.call(ue))) {
        if (ue = Se.next(), !ue.done) {
          var Re = [];
          do
            Re.push(ue.value), ue = Se.next();
          while (!ue.done);
          Xr(B, X, Re);
        }
        return;
      }
      throw B = Object.prototype.toString.call(ue), Error(e(31, B === "[object Object]" ? "object with keys {" + Object.keys(ue).join(", ") + "}" : B));
    }
    typeof ue == "string" ? (Se = X.blockedSegment, Se.lastPushedText = _e(X.blockedSegment.chunks, ue, B.responseState, Se.lastPushedText)) : typeof ue == "number" && (Se = X.blockedSegment, Se.lastPushedText = _e(X.blockedSegment.chunks, "" + ue, B.responseState, Se.lastPushedText));
  }
  function Xr(B, X, ue) {
    for (var Se = ue.length, Re = 0; Re < Se; Re++) {
      var Ce = X.treeContext;
      X.treeContext = gt(Ce, Se, Re);
      try {
        Yr(B, X, ue[Re]);
      } finally {
        X.treeContext = Ce;
      }
    }
  }
  function Yr(B, X, ue) {
    var Se = X.blockedSegment.formatContext, Re = X.legacyContext, Ce = X.context;
    try {
      return gn(B, X, ue);
    } catch (rt) {
      if (_a(), typeof rt == "object" && rt !== null && typeof rt.then == "function") {
        ue = rt;
        var Be = X.blockedSegment, Ve = Ui(B, Be.chunks.length, null, Be.formatContext, Be.lastPushedText, !0);
        Be.children.push(Ve), Be.lastPushedText = !1, B = Fi(B, X.node, X.blockedBoundary, Ve, X.abortSet, X.legacyContext, X.context, X.treeContext).ping, ue.then(B, B), X.blockedSegment.formatContext = Se, X.legacyContext = Re, X.context = Ce, Le(Ce);
      } else throw X.blockedSegment.formatContext = Se, X.legacyContext = Re, X.context = Ce, Le(Ce), rt;
    }
  }
  function Mi(B) {
    var X = B.blockedBoundary;
    B = B.blockedSegment, B.status = 3, Jr(this, X, B);
  }
  function Mo(B, X, ue) {
    var Se = B.blockedBoundary;
    B.blockedSegment.status = 3, Se === null ? (X.allPendingTasks--, X.status !== 2 && (X.status = 2, X.destination !== null && X.destination.push(null))) : (Se.pendingTasks--, Se.forceClientRender || (Se.forceClientRender = !0, B = ue === void 0 ? Error(e(432)) : ue, Se.errorDigest = X.onError(B), Se.parentFlushed && X.clientRenderedBoundaries.push(Se)), Se.fallbackAbortableTasks.forEach(function(Re) {
      return Mo(Re, X, ue);
    }), Se.fallbackAbortableTasks.clear(), X.allPendingTasks--, X.allPendingTasks === 0 && (Se = X.onAllReady, Se()));
  }
  function Rr(B, X) {
    if (X.chunks.length === 0 && X.children.length === 1 && X.children[0].boundary === null) {
      var ue = X.children[0];
      ue.id = X.id, ue.parentFlushed = !0, ue.status === 1 && Rr(B, ue);
    } else B.completedSegments.push(X);
  }
  function Jr(B, X, ue) {
    if (X === null) {
      if (ue.parentFlushed) {
        if (B.completedRootSegment !== null) throw Error(e(389));
        B.completedRootSegment = ue;
      }
      B.pendingRootTasks--, B.pendingRootTasks === 0 && (B.onShellError = Gr, X = B.onShellReady, X());
    } else X.pendingTasks--, X.forceClientRender || (X.pendingTasks === 0 ? (ue.parentFlushed && ue.status === 1 && Rr(X, ue), X.parentFlushed && B.completedBoundaries.push(X), X.fallbackAbortableTasks.forEach(Mi, B), X.fallbackAbortableTasks.clear()) : ue.parentFlushed && ue.status === 1 && (Rr(X, ue), X.completedSegments.length === 1 && X.parentFlushed && B.partialBoundaries.push(X)));
    B.allPendingTasks--, B.allPendingTasks === 0 && (B = B.onAllReady, B());
  }
  function Pn(B) {
    if (B.status !== 2) {
      var X = J, ue = Oi.current;
      Oi.current = Ta;
      var Se = Uo;
      Uo = B.responseState;
      try {
        var Re = B.pingedTasks, Ce;
        for (Ce = 0; Ce < Re.length; Ce++) {
          var Be = Re[Ce], Ve = B, rt = Be.blockedSegment;
          if (rt.status === 0) {
            Le(Be.context);
            try {
              gn(Ve, Be, Be.node), Ve.responseState.generateStaticMarkup || rt.lastPushedText && rt.textEmbedded && rt.chunks.push("<!-- -->"), Be.abortSet.delete(Be), rt.status = 1, Jr(Ve, Be.blockedBoundary, rt);
            } catch (Hn) {
              if (_a(), typeof Hn == "object" && Hn !== null && typeof Hn.then == "function") {
                var lt = Be.ping;
                Hn.then(lt, lt);
              } else {
                Be.abortSet.delete(Be), rt.status = 4;
                var it = Be.blockedBoundary, Rt = Hn, zn = Kr(Ve, Rt);
                if (it === null ? Ni(Ve, Rt) : (it.pendingTasks--, it.forceClientRender || (it.forceClientRender = !0, it.errorDigest = zn, it.parentFlushed && Ve.clientRenderedBoundaries.push(it))), Ve.allPendingTasks--, Ve.allPendingTasks === 0) {
                  var $n = Ve.onAllReady;
                  $n();
                }
              }
            } finally {
            }
          }
        }
        Re.splice(0, Ce), B.destination !== null && Wn(B, B.destination);
      } catch (Hn) {
        Kr(B, Hn), Ni(B, Hn);
      } finally {
        Uo = Se, Oi.current = ue, ue === Ta && Le(X);
      }
    }
  }
  function Bi(B, X, ue) {
    switch (ue.parentFlushed = !0, ue.status) {
      case 0:
        var Se = ue.id = B.nextSegmentId++;
        return ue.lastPushedText = !1, ue.textEmbedded = !1, B = B.responseState, X.push('<template id="'), X.push(B.placeholderPrefix), B = Se.toString(16), X.push(B), X.push('"></template>');
      case 1:
        ue.status = 2;
        var Re = !0;
        Se = ue.chunks;
        var Ce = 0;
        ue = ue.children;
        for (var Be = 0; Be < ue.length; Be++) {
          for (Re = ue[Be]; Ce < Re.index; Ce++) X.push(Se[Ce]);
          Re = so(B, X, Re);
        }
        for (; Ce < Se.length - 1; Ce++) X.push(Se[Ce]);
        return Ce < Se.length && (Re = X.push(Se[Ce])), Re;
      default:
        throw Error(e(390));
    }
  }
  function so(B, X, ue) {
    var Se = ue.boundary;
    if (Se === null) return Bi(B, X, ue);
    if (Se.parentFlushed = !0, Se.forceClientRender) return B.responseState.generateStaticMarkup || (Se = Se.errorDigest, X.push("<!--$!-->"), X.push("<template"), Se && (X.push(' data-dgst="'), Se = m(Se), X.push(Se), X.push('"')), X.push("></template>")), Bi(B, X, ue), B = B.responseState.generateStaticMarkup ? !0 : X.push("<!--/$-->"), B;
    if (0 < Se.pendingTasks) {
      Se.rootSegmentID = B.nextSegmentId++, 0 < Se.completedSegments.length && B.partialBoundaries.push(Se);
      var Re = B.responseState, Ce = Re.nextSuspenseID++;
      return Re = Re.boundaryPrefix + Ce.toString(16), Se = Se.id = Re, C(X, B.responseState, Se), Bi(B, X, ue), X.push("<!--/$-->");
    }
    if (Se.byteSize > B.progressiveChunkSize) return Se.rootSegmentID = B.nextSegmentId++, B.completedBoundaries.push(Se), C(X, B.responseState, Se.id), Bi(B, X, ue), X.push("<!--/$-->");
    if (B.responseState.generateStaticMarkup || X.push("<!--$-->"), ue = Se.completedSegments, ue.length !== 1) throw Error(e(391));
    return so(B, X, ue[0]), B = B.responseState.generateStaticMarkup ? !0 : X.push("<!--/$-->"), B;
  }
  function Bo(B, X, ue) {
    return ie(X, B.responseState, ue.formatContext, ue.id), so(B, X, ue), ee(X, ue.formatContext);
  }
  function hr(B, X, ue) {
    for (var Se = ue.completedSegments, Re = 0; Re < Se.length; Re++) Zr(B, X, ue, Se[Re]);
    if (Se.length = 0, B = B.responseState, Se = ue.id, ue = ue.rootSegmentID, X.push(B.startInlineScript), B.sentCompleteBoundaryFunction ? X.push('$RC("') : (B.sentCompleteBoundaryFunction = !0, X.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), Se === null) throw Error(e(395));
    return ue = ue.toString(16), X.push(Se), X.push('","'), X.push(B.segmentPrefix), X.push(ue), X.push('")<\/script>');
  }
  function Zr(B, X, ue, Se) {
    if (Se.status === 2) return !0;
    var Re = Se.id;
    if (Re === -1) {
      if ((Se.id = ue.rootSegmentID) === -1) throw Error(e(392));
      return Bo(B, X, Se);
    }
    return Bo(B, X, Se), B = B.responseState, X.push(B.startInlineScript), B.sentCompleteSegmentFunction ? X.push('$RS("') : (B.sentCompleteSegmentFunction = !0, X.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), X.push(B.segmentPrefix), Re = Re.toString(16), X.push(Re), X.push('","'), X.push(B.placeholderPrefix), X.push(Re), X.push('")<\/script>');
  }
  function Wn(B, X) {
    try {
      var ue = B.completedRootSegment;
      if (ue !== null && B.pendingRootTasks === 0) {
        so(B, X, ue), B.completedRootSegment = null;
        var Se = B.responseState.bootstrapChunks;
        for (ue = 0; ue < Se.length - 1; ue++) X.push(Se[ue]);
        ue < Se.length && X.push(Se[ue]);
      }
      var Re = B.clientRenderedBoundaries, Ce;
      for (Ce = 0; Ce < Re.length; Ce++) {
        var Be = Re[Ce];
        Se = X;
        var Ve = B.responseState, rt = Be.id, lt = Be.errorDigest, it = Be.errorMessage, Rt = Be.errorComponentStack;
        if (Se.push(Ve.startInlineScript), Ve.sentClientRenderFunction ? Se.push('$RX("') : (Ve.sentClientRenderFunction = !0, Se.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), rt === null) throw Error(e(395));
        if (Se.push(rt), Se.push('"'), lt || it || Rt) {
          Se.push(",");
          var zn = oe(lt || "");
          Se.push(zn);
        }
        if (it || Rt) {
          Se.push(",");
          var $n = oe(it || "");
          Se.push($n);
        }
        if (Rt) {
          Se.push(",");
          var Hn = oe(Rt);
          Se.push(Hn);
        }
        if (!Se.push(")<\/script>")) {
          B.destination = null, Ce++, Re.splice(0, Ce);
          return;
        }
      }
      Re.splice(0, Ce);
      var Li = B.completedBoundaries;
      for (Ce = 0; Ce < Li.length; Ce++) if (!hr(B, X, Li[Ce])) {
        B.destination = null, Ce++, Li.splice(0, Ce);
        return;
      }
      Li.splice(0, Ce);
      var Qr = B.partialBoundaries;
      for (Ce = 0; Ce < Qr.length; Ce++) {
        var Po = Qr[Ce];
        e: {
          Re = B, Be = X;
          var Pi = Po.completedSegments;
          for (Ve = 0; Ve < Pi.length; Ve++) if (!Zr(Re, Be, Po, Pi[Ve])) {
            Ve++, Pi.splice(0, Ve);
            var lo = !1;
            break e;
          }
          Pi.splice(0, Ve), lo = !0;
        }
        if (!lo) {
          B.destination = null, Ce++, Qr.splice(0, Ce);
          return;
        }
      }
      Qr.splice(0, Ce);
      var yi = B.completedBoundaries;
      for (Ce = 0; Ce < yi.length; Ce++) if (!hr(B, X, yi[Ce])) {
        B.destination = null, Ce++, yi.splice(0, Ce);
        return;
      }
      yi.splice(0, Ce);
    } finally {
      B.allPendingTasks === 0 && B.pingedTasks.length === 0 && B.clientRenderedBoundaries.length === 0 && B.completedBoundaries.length === 0 && X.push(null);
    }
  }
  function Lo(B, X) {
    try {
      var ue = B.abortableTasks;
      ue.forEach(function(Se) {
        return Mo(Se, B, X);
      }), ue.clear(), B.destination !== null && Wn(B, B.destination);
    } catch (Se) {
      Kr(B, Se), Ni(B, Se);
    }
  }
  function Cn() {
  }
  function tr(B, X, ue, Se) {
    var Re = !1, Ce = null, Be = "", Ve = { push: function(lt) {
      return lt !== null && (Be += lt), !0;
    }, destroy: function(lt) {
      Re = !0, Ce = lt;
    } }, rt = !1;
    if (B = No(B, te(ue, X ? X.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, 1 / 0, Cn, void 0, function() {
      rt = !0;
    }), Pn(B), Lo(B, Se), B.status === 1) B.status = 2, Ve.destroy(B.fatalError);
    else if (B.status !== 2 && B.destination === null) {
      B.destination = Ve;
      try {
        Wn(B, Ve);
      } catch (lt) {
        Kr(B, lt), Ni(B, lt);
      }
    }
    if (Re) throw Ce;
    if (!rt) throw Error(e(426));
    return Be;
  }
  return Ac.renderToNodeStream = function() {
    throw Error(e(207));
  }, Ac.renderToStaticMarkup = function(B, X) {
    return tr(B, X, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Ac.renderToStaticNodeStream = function() {
    throw Error(e(208));
  }, Ac.renderToString = function(B, X) {
    return tr(B, X, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Ac.version = "18.3.1", Ac;
}
var Ny = {};
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var eF;
function Vxe() {
  if (eF) return Ny;
  eF = 1;
  var t = Lt;
  function e(L) {
    for (var K = "https://reactjs.org/docs/error-decoder.html?invariant=" + L, ae = 1; ae < arguments.length; ae++) K += "&args[]=" + encodeURIComponent(arguments[ae]);
    return "Minified React error #" + L + "; visit " + K + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = null, r = 0;
  function i(L, K) {
    if (K.length !== 0) if (512 < K.length) 0 < r && (L.enqueue(new Uint8Array(n.buffer, 0, r)), n = new Uint8Array(512), r = 0), L.enqueue(K);
    else {
      var ae = n.length - r;
      ae < K.length && (ae === 0 ? L.enqueue(n) : (n.set(K.subarray(0, ae), r), L.enqueue(n), K = K.subarray(ae)), n = new Uint8Array(512), r = 0), n.set(K, r), r += K.length;
    }
  }
  function o(L, K) {
    return i(L, K), !0;
  }
  function a(L) {
    n && 0 < r && (L.enqueue(new Uint8Array(n.buffer, 0, r)), n = null, r = 0);
  }
  var s = new TextEncoder();
  function l(L) {
    return s.encode(L);
  }
  function c(L) {
    return s.encode(L);
  }
  function u(L, K) {
    typeof L.error == "function" ? L.error(K) : L.close();
  }
  var d = Object.prototype.hasOwnProperty, f = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, p = {}, m = {};
  function g(L) {
    return d.call(m, L) ? !0 : d.call(p, L) ? !1 : f.test(L) ? m[L] = !0 : (p[L] = !0, !1);
  }
  function b(L, K, ae, xe, Ie, Ae, Pe) {
    this.acceptsBooleans = K === 2 || K === 3 || K === 4, this.attributeName = xe, this.attributeNamespace = Ie, this.mustUseProperty = ae, this.propertyName = L, this.type = K, this.sanitizeURL = Ae, this.removeEmptyString = Pe;
  }
  var y = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(L) {
    y[L] = new b(L, 0, !1, L, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(L) {
    var K = L[0];
    y[K] = new b(K, 1, !1, L[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(L) {
    y[L] = new b(L, 2, !1, L.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(L) {
    y[L] = new b(L, 2, !1, L, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(L) {
    y[L] = new b(L, 3, !1, L.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(L) {
    y[L] = new b(L, 3, !0, L, null, !1, !1);
  }), ["capture", "download"].forEach(function(L) {
    y[L] = new b(L, 4, !1, L, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(L) {
    y[L] = new b(L, 6, !1, L, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(L) {
    y[L] = new b(L, 5, !1, L.toLowerCase(), null, !1, !1);
  });
  var w = /[\-:]([a-z])/g;
  function x(L) {
    return L[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(L) {
    var K = L.replace(
      w,
      x
    );
    y[K] = new b(K, 1, !1, L, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(L) {
    var K = L.replace(w, x);
    y[K] = new b(K, 1, !1, L, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(L) {
    var K = L.replace(w, x);
    y[K] = new b(K, 1, !1, L, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(L) {
    y[L] = new b(L, 1, !1, L.toLowerCase(), null, !1, !1);
  }), y.xlinkHref = new b("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(L) {
    y[L] = new b(L, 1, !1, L.toLowerCase(), null, !0, !0);
  });
  var k = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, A = ["Webkit", "ms", "Moz", "O"];
  Object.keys(k).forEach(function(L) {
    A.forEach(function(K) {
      K = K + L.charAt(0).toUpperCase() + L.substring(1), k[K] = k[L];
    });
  });
  var U = /["'&<>]/;
  function P(L) {
    if (typeof L == "boolean" || typeof L == "number") return "" + L;
    L = "" + L;
    var K = U.exec(L);
    if (K) {
      var ae = "", xe, Ie = 0;
      for (xe = K.index; xe < L.length; xe++) {
        switch (L.charCodeAt(xe)) {
          case 34:
            K = "&quot;";
            break;
          case 38:
            K = "&amp;";
            break;
          case 39:
            K = "&#x27;";
            break;
          case 60:
            K = "&lt;";
            break;
          case 62:
            K = "&gt;";
            break;
          default:
            continue;
        }
        Ie !== xe && (ae += L.substring(Ie, xe)), Ie = xe + 1, ae += K;
      }
      L = Ie !== xe ? ae + L.substring(Ie, xe) : ae;
    }
    return L;
  }
  var V = /([A-Z])/g, I = /^ms-/, le = Array.isArray, be = c("<script>"), F = c("<\/script>"), G = c('<script src="'), C = c('<script type="module" src="'), ie = c('" async=""><\/script>'), ee = /(<\/|<)(s)(cript)/gi;
  function Z(L, K, ae, xe) {
    return "" + K + (ae === "s" ? "\\u0073" : "\\u0053") + xe;
  }
  function oe(L, K, ae, xe, Ie) {
    L = L === void 0 ? "" : L, K = K === void 0 ? be : c('<script nonce="' + P(K) + '">');
    var Ae = [];
    if (ae !== void 0 && Ae.push(K, l(("" + ae).replace(ee, Z)), F), xe !== void 0) for (ae = 0; ae < xe.length; ae++) Ae.push(G, l(P(xe[ae])), ie);
    if (Ie !== void 0) for (xe = 0; xe < Ie.length; xe++) Ae.push(C, l(P(Ie[xe])), ie);
    return { bootstrapChunks: Ae, startInlineScript: K, placeholderPrefix: c(L + "P:"), segmentPrefix: c(L + "S:"), boundaryPrefix: L + "B:", idPrefix: L, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
  }
  function te(L, K) {
    return { insertionMode: L, selectedValue: K };
  }
  function _e(L) {
    return te(L === "http://www.w3.org/2000/svg" ? 2 : L === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null);
  }
  function q(L, K, ae) {
    switch (K) {
      case "select":
        return te(1, ae.value != null ? ae.value : ae.defaultValue);
      case "svg":
        return te(2, null);
      case "math":
        return te(3, null);
      case "foreignObject":
        return te(1, null);
      case "table":
        return te(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return te(5, null);
      case "colgroup":
        return te(7, null);
      case "tr":
        return te(6, null);
    }
    return 4 <= L.insertionMode || L.insertionMode === 0 ? te(1, null) : L;
  }
  var N = c("<!-- -->");
  function ce(L, K, ae, xe) {
    return K === "" ? xe : (xe && L.push(N), L.push(l(P(K))), !0);
  }
  var me = /* @__PURE__ */ new Map(), ve = c(' style="'), he = c(":"), H = c(";");
  function W(L, K, ae) {
    if (typeof ae != "object") throw Error(e(62));
    K = !0;
    for (var xe in ae) if (d.call(ae, xe)) {
      var Ie = ae[xe];
      if (Ie != null && typeof Ie != "boolean" && Ie !== "") {
        if (xe.indexOf("--") === 0) {
          var Ae = l(P(xe));
          Ie = l(P(("" + Ie).trim()));
        } else {
          Ae = xe;
          var Pe = me.get(Ae);
          Pe !== void 0 || (Pe = c(P(Ae.replace(V, "-$1").toLowerCase().replace(I, "-ms-"))), me.set(Ae, Pe)), Ae = Pe, Ie = typeof Ie == "number" ? Ie === 0 || d.call(k, xe) ? l("" + Ie) : l(Ie + "px") : l(P(("" + Ie).trim()));
        }
        K ? (K = !1, L.push(ve, Ae, he, Ie)) : L.push(H, Ae, he, Ie);
      }
    }
    K || L.push(j);
  }
  var we = c(" "), ye = c('="'), j = c('"'), Q = c('=""');
  function De(L, K, ae, xe) {
    switch (ae) {
      case "style":
        W(L, K, xe);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < ae.length) || ae[0] !== "o" && ae[0] !== "O" || ae[1] !== "n" && ae[1] !== "N") {
      if (K = y.hasOwnProperty(ae) ? y[ae] : null, K !== null) {
        switch (typeof xe) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!K.acceptsBooleans) return;
        }
        switch (ae = l(K.attributeName), K.type) {
          case 3:
            xe && L.push(we, ae, Q);
            break;
          case 4:
            xe === !0 ? L.push(we, ae, Q) : xe !== !1 && L.push(we, ae, ye, l(P(xe)), j);
            break;
          case 5:
            isNaN(xe) || L.push(we, ae, ye, l(P(xe)), j);
            break;
          case 6:
            !isNaN(xe) && 1 <= xe && L.push(we, ae, ye, l(P(xe)), j);
            break;
          default:
            K.sanitizeURL && (xe = "" + xe), L.push(we, ae, ye, l(P(xe)), j);
        }
      } else if (g(ae)) {
        switch (typeof xe) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (K = ae.toLowerCase().slice(0, 5), K !== "data-" && K !== "aria-") return;
        }
        L.push(we, l(ae), ye, l(P(xe)), j);
      }
    }
  }
  var T = c(">"), pe = c("/>");
  function M(L, K, ae) {
    if (K != null) {
      if (ae != null) throw Error(e(60));
      if (typeof K != "object" || !("__html" in K)) throw Error(e(61));
      K = K.__html, K != null && L.push(l("" + K));
    }
  }
  function _(L) {
    var K = "";
    return t.Children.forEach(L, function(ae) {
      ae != null && (K += ae);
    }), K;
  }
  var S = c(' selected=""');
  function O(L, K, ae, xe) {
    L.push(re(ae));
    var Ie = ae = null, Ae;
    for (Ae in K) if (d.call(K, Ae)) {
      var Pe = K[Ae];
      if (Pe != null) switch (Ae) {
        case "children":
          ae = Pe;
          break;
        case "dangerouslySetInnerHTML":
          Ie = Pe;
          break;
        default:
          De(L, xe, Ae, Pe);
      }
    }
    return L.push(T), M(L, Ie, ae), typeof ae == "string" ? (L.push(l(P(ae))), null) : ae;
  }
  var ne = c(`
`), fe = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, J = /* @__PURE__ */ new Map();
  function re(L) {
    var K = J.get(L);
    if (K === void 0) {
      if (!fe.test(L)) throw Error(e(65, L));
      K = c("<" + L), J.set(L, K);
    }
    return K;
  }
  var de = c("<!DOCTYPE html>");
  function ge(L, K, ae, xe, Ie) {
    switch (K) {
      case "select":
        L.push(re("select"));
        var Ae = null, Pe = null;
        for (pt in ae) if (d.call(ae, pt)) {
          var qe = ae[pt];
          if (qe != null) switch (pt) {
            case "children":
              Ae = qe;
              break;
            case "dangerouslySetInnerHTML":
              Pe = qe;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              De(L, xe, pt, qe);
          }
        }
        return L.push(T), M(L, Pe, Ae), Ae;
      case "option":
        Pe = Ie.selectedValue, L.push(re("option"));
        var ct = qe = null, mt = null, pt = null;
        for (Ae in ae) if (d.call(ae, Ae)) {
          var jt = ae[Ae];
          if (jt != null) switch (Ae) {
            case "children":
              qe = jt;
              break;
            case "selected":
              mt = jt;
              break;
            case "dangerouslySetInnerHTML":
              pt = jt;
              break;
            case "value":
              ct = jt;
            default:
              De(L, xe, Ae, jt);
          }
        }
        if (Pe != null) if (ae = ct !== null ? "" + ct : _(qe), le(Pe)) {
          for (xe = 0; xe < Pe.length; xe++)
            if ("" + Pe[xe] === ae) {
              L.push(S);
              break;
            }
        } else "" + Pe === ae && L.push(S);
        else mt && L.push(S);
        return L.push(T), M(L, pt, qe), qe;
      case "textarea":
        L.push(re("textarea")), pt = Pe = Ae = null;
        for (qe in ae) if (d.call(ae, qe) && (ct = ae[qe], ct != null)) switch (qe) {
          case "children":
            pt = ct;
            break;
          case "value":
            Ae = ct;
            break;
          case "defaultValue":
            Pe = ct;
            break;
          case "dangerouslySetInnerHTML":
            throw Error(e(91));
          default:
            De(L, xe, qe, ct);
        }
        if (Ae === null && Pe !== null && (Ae = Pe), L.push(T), pt != null) {
          if (Ae != null) throw Error(e(92));
          if (le(pt) && 1 < pt.length) throw Error(e(93));
          Ae = "" + pt;
        }
        return typeof Ae == "string" && Ae[0] === `
` && L.push(ne), Ae !== null && L.push(l(P("" + Ae))), null;
      case "input":
        L.push(re("input")), ct = pt = qe = Ae = null;
        for (Pe in ae) if (d.call(ae, Pe) && (mt = ae[Pe], mt != null)) switch (Pe) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(e(399, "input"));
          case "defaultChecked":
            ct = mt;
            break;
          case "defaultValue":
            qe = mt;
            break;
          case "checked":
            pt = mt;
            break;
          case "value":
            Ae = mt;
            break;
          default:
            De(L, xe, Pe, mt);
        }
        return pt !== null ? De(
          L,
          xe,
          "checked",
          pt
        ) : ct !== null && De(L, xe, "checked", ct), Ae !== null ? De(L, xe, "value", Ae) : qe !== null && De(L, xe, "value", qe), L.push(pe), null;
      case "menuitem":
        L.push(re("menuitem"));
        for (var rr in ae) if (d.call(ae, rr) && (Ae = ae[rr], Ae != null)) switch (rr) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(e(400));
          default:
            De(L, xe, rr, Ae);
        }
        return L.push(T), null;
      case "title":
        L.push(re("title")), Ae = null;
        for (jt in ae) if (d.call(ae, jt) && (Pe = ae[jt], Pe != null)) switch (jt) {
          case "children":
            Ae = Pe;
            break;
          case "dangerouslySetInnerHTML":
            throw Error(e(434));
          default:
            De(L, xe, jt, Pe);
        }
        return L.push(T), Ae;
      case "listing":
      case "pre":
        L.push(re(K)), Pe = Ae = null;
        for (ct in ae) if (d.call(ae, ct) && (qe = ae[ct], qe != null)) switch (ct) {
          case "children":
            Ae = qe;
            break;
          case "dangerouslySetInnerHTML":
            Pe = qe;
            break;
          default:
            De(L, xe, ct, qe);
        }
        if (L.push(T), Pe != null) {
          if (Ae != null) throw Error(e(60));
          if (typeof Pe != "object" || !("__html" in Pe)) throw Error(e(61));
          ae = Pe.__html, ae != null && (typeof ae == "string" && 0 < ae.length && ae[0] === `
` ? L.push(ne, l(ae)) : L.push(l("" + ae)));
        }
        return typeof Ae == "string" && Ae[0] === `
` && L.push(ne), Ae;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        L.push(re(K));
        for (var Or in ae) if (d.call(ae, Or) && (Ae = ae[Or], Ae != null)) switch (Or) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(e(399, K));
          default:
            De(L, xe, Or, Ae);
        }
        return L.push(pe), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return O(L, ae, K, xe);
      case "html":
        return Ie.insertionMode === 0 && L.push(de), O(L, ae, K, xe);
      default:
        if (K.indexOf("-") === -1 && typeof ae.is != "string") return O(L, ae, K, xe);
        L.push(re(K)), Pe = Ae = null;
        for (mt in ae) if (d.call(ae, mt) && (qe = ae[mt], qe != null)) switch (mt) {
          case "children":
            Ae = qe;
            break;
          case "dangerouslySetInnerHTML":
            Pe = qe;
            break;
          case "style":
            W(L, xe, qe);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            break;
          default:
            g(mt) && typeof qe != "function" && typeof qe != "symbol" && L.push(we, l(mt), ye, l(P(qe)), j);
        }
        return L.push(T), M(L, Pe, Ae), Ae;
    }
  }
  var Ee = c("</"), Ne = c(">"), Le = c('<template id="'), Qe = c('"></template>'), Ze = c("<!--$-->"), at = c('<!--$?--><template id="'), gt = c('"></template>'), et = c("<!--$!-->"), Zt = c("<!--/$-->"), Un = c("<template"), Ft = c('"'), Ar = c(' data-dgst="');
  c(' data-msg="'), c(' data-stck="');
  var Ii = c("></template>");
  function xn(L, K, ae) {
    if (i(L, at), ae === null) throw Error(e(395));
    return i(L, ae), o(L, gt);
  }
  var Bn = c('<div hidden id="'), Ln = c('">'), ht = c("</div>"), _n = c('<svg aria-hidden="true" style="display:none" id="'), Oo = c('">'), ao = c("</svg>"), Vr = c('<math aria-hidden="true" style="display:none" id="'), Fo = c('">'), mi = c("</math>"), Sn = c('<table hidden id="'), xa = c('">'), _a = c("</table>"), _s = c('<table hidden><tbody id="'), mn = c('">'), Sa = c("</tbody></table>"), Vl = c('<table hidden><tr id="'), ql = c('">'), qr = c("</tr></table>"), Ta = c('<table hidden><colgroup id="'), Uo = c('">'), Oi = c("</colgroup></table>");
  function Qn(L, K, ae, xe) {
    switch (ae.insertionMode) {
      case 0:
      case 1:
        return i(L, Bn), i(L, K.segmentPrefix), i(L, l(xe.toString(16))), o(L, Ln);
      case 2:
        return i(L, _n), i(L, K.segmentPrefix), i(L, l(xe.toString(16))), o(L, Oo);
      case 3:
        return i(L, Vr), i(L, K.segmentPrefix), i(L, l(xe.toString(16))), o(L, Fo);
      case 4:
        return i(L, Sn), i(L, K.segmentPrefix), i(L, l(xe.toString(16))), o(L, xa);
      case 5:
        return i(L, _s), i(L, K.segmentPrefix), i(L, l(xe.toString(16))), o(L, mn);
      case 6:
        return i(L, Vl), i(L, K.segmentPrefix), i(L, l(xe.toString(16))), o(L, ql);
      case 7:
        return i(
          L,
          Ta
        ), i(L, K.segmentPrefix), i(L, l(xe.toString(16))), o(L, Uo);
      default:
        throw Error(e(397));
    }
  }
  function Gr(L, K) {
    switch (K.insertionMode) {
      case 0:
      case 1:
        return o(L, ht);
      case 2:
        return o(L, ao);
      case 3:
        return o(L, mi);
      case 4:
        return o(L, _a);
      case 5:
        return o(L, Sa);
      case 6:
        return o(L, qr);
      case 7:
        return o(L, Oi);
      default:
        throw Error(e(397));
    }
  }
  var No = c('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), Fi = c('$RS("'), Ui = c('","'), Kr = c('")<\/script>'), Ni = c('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), er = c('$RC("'), Ss = c('","'), Ts = c('")<\/script>'), gi = c('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), gn = c('$RX("'), Xr = c('"'), Yr = c(")<\/script>"), Mi = c(","), Mo = /[<\u2028\u2029]/g;
  function Rr(L) {
    return JSON.stringify(L).replace(Mo, function(K) {
      switch (K) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  var Jr = Object.assign, Pn = Symbol.for("react.element"), Bi = Symbol.for("react.portal"), so = Symbol.for("react.fragment"), Bo = Symbol.for("react.strict_mode"), hr = Symbol.for("react.profiler"), Zr = Symbol.for("react.provider"), Wn = Symbol.for("react.context"), Lo = Symbol.for("react.forward_ref"), Cn = Symbol.for("react.suspense"), tr = Symbol.for("react.suspense_list"), B = Symbol.for("react.memo"), X = Symbol.for("react.lazy"), ue = Symbol.for("react.scope"), Se = Symbol.for("react.debug_trace_mode"), Re = Symbol.for("react.legacy_hidden"), Ce = Symbol.for("react.default_value"), Be = Symbol.iterator;
  function Ve(L) {
    if (L == null) return null;
    if (typeof L == "function") return L.displayName || L.name || null;
    if (typeof L == "string") return L;
    switch (L) {
      case so:
        return "Fragment";
      case Bi:
        return "Portal";
      case hr:
        return "Profiler";
      case Bo:
        return "StrictMode";
      case Cn:
        return "Suspense";
      case tr:
        return "SuspenseList";
    }
    if (typeof L == "object") switch (L.$$typeof) {
      case Wn:
        return (L.displayName || "Context") + ".Consumer";
      case Zr:
        return (L._context.displayName || "Context") + ".Provider";
      case Lo:
        var K = L.render;
        return L = L.displayName, L || (L = K.displayName || K.name || "", L = L !== "" ? "ForwardRef(" + L + ")" : "ForwardRef"), L;
      case B:
        return K = L.displayName || null, K !== null ? K : Ve(L.type) || "Memo";
      case X:
        K = L._payload, L = L._init;
        try {
          return Ve(L(K));
        } catch {
        }
    }
    return null;
  }
  var rt = {};
  function lt(L, K) {
    if (L = L.contextTypes, !L) return rt;
    var ae = {}, xe;
    for (xe in L) ae[xe] = K[xe];
    return ae;
  }
  var it = null;
  function Rt(L, K) {
    if (L !== K) {
      L.context._currentValue = L.parentValue, L = L.parent;
      var ae = K.parent;
      if (L === null) {
        if (ae !== null) throw Error(e(401));
      } else {
        if (ae === null) throw Error(e(401));
        Rt(L, ae);
      }
      K.context._currentValue = K.value;
    }
  }
  function zn(L) {
    L.context._currentValue = L.parentValue, L = L.parent, L !== null && zn(L);
  }
  function $n(L) {
    var K = L.parent;
    K !== null && $n(K), L.context._currentValue = L.value;
  }
  function Hn(L, K) {
    if (L.context._currentValue = L.parentValue, L = L.parent, L === null) throw Error(e(402));
    L.depth === K.depth ? Rt(L, K) : Hn(L, K);
  }
  function Li(L, K) {
    var ae = K.parent;
    if (ae === null) throw Error(e(402));
    L.depth === ae.depth ? Rt(L, ae) : Li(L, ae), K.context._currentValue = K.value;
  }
  function Qr(L) {
    var K = it;
    K !== L && (K === null ? $n(L) : L === null ? zn(K) : K.depth === L.depth ? Rt(K, L) : K.depth > L.depth ? Hn(K, L) : Li(K, L), it = L);
  }
  var Po = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(L, K) {
    L = L._reactInternals, L.queue !== null && L.queue.push(K);
  }, enqueueReplaceState: function(L, K) {
    L = L._reactInternals, L.replace = !0, L.queue = [K];
  }, enqueueForceUpdate: function() {
  } };
  function Pi(L, K, ae, xe) {
    var Ie = L.state !== void 0 ? L.state : null;
    L.updater = Po, L.props = ae, L.state = Ie;
    var Ae = { queue: [], replace: !1 };
    L._reactInternals = Ae;
    var Pe = K.contextType;
    if (L.context = typeof Pe == "object" && Pe !== null ? Pe._currentValue : xe, Pe = K.getDerivedStateFromProps, typeof Pe == "function" && (Pe = Pe(ae, Ie), Ie = Pe == null ? Ie : Jr({}, Ie, Pe), L.state = Ie), typeof K.getDerivedStateFromProps != "function" && typeof L.getSnapshotBeforeUpdate != "function" && (typeof L.UNSAFE_componentWillMount == "function" || typeof L.componentWillMount == "function")) if (K = L.state, typeof L.componentWillMount == "function" && L.componentWillMount(), typeof L.UNSAFE_componentWillMount == "function" && L.UNSAFE_componentWillMount(), K !== L.state && Po.enqueueReplaceState(L, L.state, null), Ae.queue !== null && 0 < Ae.queue.length) if (K = Ae.queue, Pe = Ae.replace, Ae.queue = null, Ae.replace = !1, Pe && K.length === 1) L.state = K[0];
    else {
      for (Ae = Pe ? K[0] : L.state, Ie = !0, Pe = Pe ? 1 : 0; Pe < K.length; Pe++) {
        var qe = K[Pe];
        qe = typeof qe == "function" ? qe.call(L, Ae, ae, xe) : qe, qe != null && (Ie ? (Ie = !1, Ae = Jr({}, Ae, qe)) : Jr(Ae, qe));
      }
      L.state = Ae;
    }
    else Ae.queue = null;
  }
  var lo = { id: 1, overflow: "" };
  function yi(L, K, ae) {
    var xe = L.id;
    L = L.overflow;
    var Ie = 32 - co(xe) - 1;
    xe &= ~(1 << Ie), ae += 1;
    var Ae = 32 - co(K) + Ie;
    if (30 < Ae) {
      var Pe = Ie - Ie % 5;
      return Ae = (xe & (1 << Pe) - 1).toString(32), xe >>= Pe, Ie -= Pe, { id: 1 << 32 - co(K) + Ie | ae << Ie | xe, overflow: Ae + L };
    }
    return { id: 1 << Ae | ae << Ie | xe, overflow: L };
  }
  var co = Math.clz32 ? Math.clz32 : Ds, uh = Math.log, dh = Math.LN2;
  function Ds(L) {
    return L >>>= 0, L === 0 ? 32 : 31 - (uh(L) / dh | 0) | 0;
  }
  function ei(L, K) {
    return L === K && (L !== 0 || 1 / L === 1 / K) || L !== L && K !== K;
  }
  var fh = typeof Object.is == "function" ? Object.is : ei, bi = null, Gl = null, Es = null, zt = null, uo = !1, Cs = !1, fo = 0, Wi = null, ks = 0;
  function zi() {
    if (bi === null) throw Error(e(321));
    return bi;
  }
  function Ir() {
    if (0 < ks) throw Error(e(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function Kl() {
    return zt === null ? Es === null ? (uo = !1, Es = zt = Ir()) : (uo = !0, zt = Es) : zt.next === null ? (uo = !1, zt = zt.next = Ir()) : (uo = !0, zt = zt.next), zt;
  }
  function Da() {
    Gl = bi = null, Cs = !1, Es = null, ks = 0, zt = Wi = null;
  }
  function Eu(L, K) {
    return typeof K == "function" ? K(L) : K;
  }
  function As(L, K, ae) {
    if (bi = zi(), zt = Kl(), uo) {
      var xe = zt.queue;
      if (K = xe.dispatch, Wi !== null && (ae = Wi.get(xe), ae !== void 0)) {
        Wi.delete(xe), xe = zt.memoizedState;
        do
          xe = L(xe, ae.action), ae = ae.next;
        while (ae !== null);
        return zt.memoizedState = xe, [xe, K];
      }
      return [zt.memoizedState, K];
    }
    return L = L === Eu ? typeof K == "function" ? K() : K : ae !== void 0 ? ae(K) : K, zt.memoizedState = L, L = zt.queue = { last: null, dispatch: null }, L = L.dispatch = hh.bind(null, bi, L), [zt.memoizedState, L];
  }
  function Cu(L, K) {
    if (bi = zi(), zt = Kl(), K = K === void 0 ? null : K, zt !== null) {
      var ae = zt.memoizedState;
      if (ae !== null && K !== null) {
        var xe = ae[1];
        e: if (xe === null) xe = !1;
        else {
          for (var Ie = 0; Ie < xe.length && Ie < K.length; Ie++) if (!fh(K[Ie], xe[Ie])) {
            xe = !1;
            break e;
          }
          xe = !0;
        }
        if (xe) return ae[0];
      }
    }
    return L = L(), zt.memoizedState = [L, K], L;
  }
  function hh(L, K, ae) {
    if (25 <= ks) throw Error(e(301));
    if (L === bi) if (Cs = !0, L = { action: ae, next: null }, Wi === null && (Wi = /* @__PURE__ */ new Map()), ae = Wi.get(K), ae === void 0) Wi.set(K, L);
    else {
      for (K = ae; K.next !== null; ) K = K.next;
      K.next = L;
    }
  }
  function ph() {
    throw Error(e(394));
  }
  function Rs() {
  }
  var ku = { readContext: function(L) {
    return L._currentValue;
  }, useContext: function(L) {
    return zi(), L._currentValue;
  }, useMemo: Cu, useReducer: As, useRef: function(L) {
    bi = zi(), zt = Kl();
    var K = zt.memoizedState;
    return K === null ? (L = { current: L }, zt.memoizedState = L) : K;
  }, useState: function(L) {
    return As(Eu, L);
  }, useInsertionEffect: Rs, useLayoutEffect: function() {
  }, useCallback: function(L, K) {
    return Cu(function() {
      return L;
    }, K);
  }, useImperativeHandle: Rs, useEffect: Rs, useDebugValue: Rs, useDeferredValue: function(L) {
    return zi(), L;
  }, useTransition: function() {
    return zi(), [!1, ph];
  }, useId: function() {
    var L = Gl.treeContext, K = L.overflow;
    L = L.id, L = (L & ~(1 << 32 - co(L) - 1)).toString(32) + K;
    var ae = Ea;
    if (ae === null) throw Error(e(404));
    return K = fo++, L = ":" + ae.idPrefix + "R" + L, 0 < K && (L += "H" + K.toString(32)), L + ":";
  }, useMutableSource: function(L, K) {
    return zi(), K(L._source);
  }, useSyncExternalStore: function(L, K, ae) {
    if (ae === void 0) throw Error(e(407));
    return ae();
  } }, Ea = null, Xl = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function mh(L) {
    return console.error(L), null;
  }
  function Wo() {
  }
  function Yl(L, K, ae, xe, Ie, Ae, Pe, qe, ct) {
    var mt = [], pt = /* @__PURE__ */ new Set();
    return K = { destination: null, responseState: K, progressiveChunkSize: xe === void 0 ? 12800 : xe, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: pt, pingedTasks: mt, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: Ie === void 0 ? mh : Ie, onAllReady: Ae === void 0 ? Wo : Ae, onShellReady: Pe === void 0 ? Wo : Pe, onShellError: qe === void 0 ? Wo : qe, onFatalError: ct === void 0 ? Wo : ct }, ae = zo(K, 0, null, ae, !1, !1), ae.parentFlushed = !0, L = Jl(K, L, null, ae, pt, rt, null, lo), mt.push(L), K;
  }
  function Jl(L, K, ae, xe, Ie, Ae, Pe, qe) {
    L.allPendingTasks++, ae === null ? L.pendingRootTasks++ : ae.pendingTasks++;
    var ct = { node: K, ping: function() {
      var mt = L.pingedTasks;
      mt.push(ct), mt.length === 1 && Nu(L);
    }, blockedBoundary: ae, blockedSegment: xe, abortSet: Ie, legacyContext: Ae, context: Pe, treeContext: qe };
    return Ie.add(ct), ct;
  }
  function zo(L, K, ae, xe, Ie, Ae) {
    return { status: 0, id: -1, index: K, parentFlushed: !1, chunks: [], children: [], formatContext: xe, boundary: ae, lastPushedText: Ie, textEmbedded: Ae };
  }
  function Ca(L, K) {
    if (L = L.onError(K), L != null && typeof L != "string") throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof L + '" instead');
    return L;
  }
  function Is(L, K) {
    var ae = L.onShellError;
    ae(K), ae = L.onFatalError, ae(K), L.destination !== null ? (L.status = 2, u(L.destination, K)) : (L.status = 1, L.fatalError = K);
  }
  function Au(L, K, ae, xe, Ie) {
    for (bi = {}, Gl = K, fo = 0, L = ae(xe, Ie); Cs; ) Cs = !1, fo = 0, ks += 1, zt = null, L = ae(xe, Ie);
    return Da(), L;
  }
  function Ru(L, K, ae, xe) {
    var Ie = ae.render(), Ae = xe.childContextTypes;
    if (Ae != null) {
      var Pe = K.legacyContext;
      if (typeof ae.getChildContext != "function") xe = Pe;
      else {
        ae = ae.getChildContext();
        for (var qe in ae) if (!(qe in Ae)) throw Error(e(108, Ve(xe) || "Unknown", qe));
        xe = Jr({}, Pe, ae);
      }
      K.legacyContext = xe, nr(L, K, Ie), K.legacyContext = Pe;
    } else nr(L, K, Ie);
  }
  function Iu(L, K) {
    if (L && L.defaultProps) {
      K = Jr({}, K), L = L.defaultProps;
      for (var ae in L) K[ae] === void 0 && (K[ae] = L[ae]);
      return K;
    }
    return K;
  }
  function Os(L, K, ae, xe, Ie) {
    if (typeof ae == "function") if (ae.prototype && ae.prototype.isReactComponent) {
      Ie = lt(ae, K.legacyContext);
      var Ae = ae.contextType;
      Ae = new ae(xe, typeof Ae == "object" && Ae !== null ? Ae._currentValue : Ie), Pi(Ae, ae, xe, Ie), Ru(L, K, Ae, ae);
    } else {
      Ae = lt(ae, K.legacyContext), Ie = Au(L, K, ae, xe, Ae);
      var Pe = fo !== 0;
      if (typeof Ie == "object" && Ie !== null && typeof Ie.render == "function" && Ie.$$typeof === void 0) Pi(Ie, ae, xe, Ae), Ru(L, K, Ie, ae);
      else if (Pe) {
        xe = K.treeContext, K.treeContext = yi(xe, 1, 0);
        try {
          nr(L, K, Ie);
        } finally {
          K.treeContext = xe;
        }
      } else nr(L, K, Ie);
    }
    else if (typeof ae == "string") {
      switch (Ie = K.blockedSegment, Ae = ge(Ie.chunks, ae, xe, L.responseState, Ie.formatContext), Ie.lastPushedText = !1, Pe = Ie.formatContext, Ie.formatContext = q(Pe, ae, xe), Fs(L, K, Ae), Ie.formatContext = Pe, ae) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          Ie.chunks.push(Ee, l(ae), Ne);
      }
      Ie.lastPushedText = !1;
    } else {
      switch (ae) {
        case Re:
        case Se:
        case Bo:
        case hr:
        case so:
          nr(L, K, xe.children);
          return;
        case tr:
          nr(L, K, xe.children);
          return;
        case ue:
          throw Error(e(343));
        case Cn:
          e: {
            ae = K.blockedBoundary, Ie = K.blockedSegment, Ae = xe.fallback, xe = xe.children, Pe = /* @__PURE__ */ new Set();
            var qe = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: Pe, errorDigest: null }, ct = zo(L, Ie.chunks.length, qe, Ie.formatContext, !1, !1);
            Ie.children.push(ct), Ie.lastPushedText = !1;
            var mt = zo(L, 0, null, Ie.formatContext, !1, !1);
            mt.parentFlushed = !0, K.blockedBoundary = qe, K.blockedSegment = mt;
            try {
              if (Fs(
                L,
                K,
                xe
              ), mt.lastPushedText && mt.textEmbedded && mt.chunks.push(N), mt.status = 1, Us(qe, mt), qe.pendingTasks === 0) break e;
            } catch (pt) {
              mt.status = 4, qe.forceClientRender = !0, qe.errorDigest = Ca(L, pt);
            } finally {
              K.blockedBoundary = ae, K.blockedSegment = Ie;
            }
            K = Jl(L, Ae, ae, ct, Pe, K.legacyContext, K.context, K.treeContext), L.pingedTasks.push(K);
          }
          return;
      }
      if (typeof ae == "object" && ae !== null) switch (ae.$$typeof) {
        case Lo:
          if (xe = Au(L, K, ae.render, xe, Ie), fo !== 0) {
            ae = K.treeContext, K.treeContext = yi(ae, 1, 0);
            try {
              nr(L, K, xe);
            } finally {
              K.treeContext = ae;
            }
          } else nr(L, K, xe);
          return;
        case B:
          ae = ae.type, xe = Iu(ae, xe), Os(L, K, ae, xe, Ie);
          return;
        case Zr:
          if (Ie = xe.children, ae = ae._context, xe = xe.value, Ae = ae._currentValue, ae._currentValue = xe, Pe = it, it = xe = { parent: Pe, depth: Pe === null ? 0 : Pe.depth + 1, context: ae, parentValue: Ae, value: xe }, K.context = xe, nr(L, K, Ie), L = it, L === null) throw Error(e(403));
          xe = L.parentValue, L.context._currentValue = xe === Ce ? L.context._defaultValue : xe, L = it = L.parent, K.context = L;
          return;
        case Wn:
          xe = xe.children, xe = xe(ae._currentValue), nr(L, K, xe);
          return;
        case X:
          Ie = ae._init, ae = Ie(ae._payload), xe = Iu(ae, xe), Os(L, K, ae, xe, void 0);
          return;
      }
      throw Error(e(
        130,
        ae == null ? ae : typeof ae,
        ""
      ));
    }
  }
  function nr(L, K, ae) {
    if (K.node = ae, typeof ae == "object" && ae !== null) {
      switch (ae.$$typeof) {
        case Pn:
          Os(L, K, ae.type, ae.props, ae.ref);
          return;
        case Bi:
          throw Error(e(257));
        case X:
          var xe = ae._init;
          ae = xe(ae._payload), nr(L, K, ae);
          return;
      }
      if (le(ae)) {
        Ou(L, K, ae);
        return;
      }
      if (ae === null || typeof ae != "object" ? xe = null : (xe = Be && ae[Be] || ae["@@iterator"], xe = typeof xe == "function" ? xe : null), xe && (xe = xe.call(ae))) {
        if (ae = xe.next(), !ae.done) {
          var Ie = [];
          do
            Ie.push(ae.value), ae = xe.next();
          while (!ae.done);
          Ou(L, K, Ie);
        }
        return;
      }
      throw L = Object.prototype.toString.call(ae), Error(e(31, L === "[object Object]" ? "object with keys {" + Object.keys(ae).join(", ") + "}" : L));
    }
    typeof ae == "string" ? (xe = K.blockedSegment, xe.lastPushedText = ce(K.blockedSegment.chunks, ae, L.responseState, xe.lastPushedText)) : typeof ae == "number" && (xe = K.blockedSegment, xe.lastPushedText = ce(K.blockedSegment.chunks, "" + ae, L.responseState, xe.lastPushedText));
  }
  function Ou(L, K, ae) {
    for (var xe = ae.length, Ie = 0; Ie < xe; Ie++) {
      var Ae = K.treeContext;
      K.treeContext = yi(Ae, xe, Ie);
      try {
        Fs(L, K, ae[Ie]);
      } finally {
        K.treeContext = Ae;
      }
    }
  }
  function Fs(L, K, ae) {
    var xe = K.blockedSegment.formatContext, Ie = K.legacyContext, Ae = K.context;
    try {
      return nr(L, K, ae);
    } catch (ct) {
      if (Da(), typeof ct == "object" && ct !== null && typeof ct.then == "function") {
        ae = ct;
        var Pe = K.blockedSegment, qe = zo(L, Pe.chunks.length, null, Pe.formatContext, Pe.lastPushedText, !0);
        Pe.children.push(qe), Pe.lastPushedText = !1, L = Jl(L, K.node, K.blockedBoundary, qe, K.abortSet, K.legacyContext, K.context, K.treeContext).ping, ae.then(L, L), K.blockedSegment.formatContext = xe, K.legacyContext = Ie, K.context = Ae, Qr(Ae);
      } else throw K.blockedSegment.formatContext = xe, K.legacyContext = Ie, K.context = Ae, Qr(Ae), ct;
    }
  }
  function gh(L) {
    var K = L.blockedBoundary;
    L = L.blockedSegment, L.status = 3, Uu(this, K, L);
  }
  function Fu(L, K, ae) {
    var xe = L.blockedBoundary;
    L.blockedSegment.status = 3, xe === null ? (K.allPendingTasks--, K.status !== 2 && (K.status = 2, K.destination !== null && K.destination.close())) : (xe.pendingTasks--, xe.forceClientRender || (xe.forceClientRender = !0, L = ae === void 0 ? Error(e(432)) : ae, xe.errorDigest = K.onError(L), xe.parentFlushed && K.clientRenderedBoundaries.push(xe)), xe.fallbackAbortableTasks.forEach(function(Ie) {
      return Fu(Ie, K, ae);
    }), xe.fallbackAbortableTasks.clear(), K.allPendingTasks--, K.allPendingTasks === 0 && (xe = K.onAllReady, xe()));
  }
  function Us(L, K) {
    if (K.chunks.length === 0 && K.children.length === 1 && K.children[0].boundary === null) {
      var ae = K.children[0];
      ae.id = K.id, ae.parentFlushed = !0, ae.status === 1 && Us(L, ae);
    } else L.completedSegments.push(K);
  }
  function Uu(L, K, ae) {
    if (K === null) {
      if (ae.parentFlushed) {
        if (L.completedRootSegment !== null) throw Error(e(389));
        L.completedRootSegment = ae;
      }
      L.pendingRootTasks--, L.pendingRootTasks === 0 && (L.onShellError = Wo, K = L.onShellReady, K());
    } else K.pendingTasks--, K.forceClientRender || (K.pendingTasks === 0 ? (ae.parentFlushed && ae.status === 1 && Us(K, ae), K.parentFlushed && L.completedBoundaries.push(K), K.fallbackAbortableTasks.forEach(gh, L), K.fallbackAbortableTasks.clear()) : ae.parentFlushed && ae.status === 1 && (Us(K, ae), K.completedSegments.length === 1 && K.parentFlushed && L.partialBoundaries.push(K)));
    L.allPendingTasks--, L.allPendingTasks === 0 && (L = L.onAllReady, L());
  }
  function Nu(L) {
    if (L.status !== 2) {
      var K = it, ae = Xl.current;
      Xl.current = ku;
      var xe = Ea;
      Ea = L.responseState;
      try {
        var Ie = L.pingedTasks, Ae;
        for (Ae = 0; Ae < Ie.length; Ae++) {
          var Pe = Ie[Ae], qe = L, ct = Pe.blockedSegment;
          if (ct.status === 0) {
            Qr(Pe.context);
            try {
              nr(qe, Pe, Pe.node), ct.lastPushedText && ct.textEmbedded && ct.chunks.push(N), Pe.abortSet.delete(Pe), ct.status = 1, Uu(qe, Pe.blockedBoundary, ct);
            } catch (Fr) {
              if (Da(), typeof Fr == "object" && Fr !== null && typeof Fr.then == "function") {
                var mt = Pe.ping;
                Fr.then(mt, mt);
              } else {
                Pe.abortSet.delete(Pe), ct.status = 4;
                var pt = Pe.blockedBoundary, jt = Fr, rr = Ca(qe, jt);
                if (pt === null ? Is(qe, jt) : (pt.pendingTasks--, pt.forceClientRender || (pt.forceClientRender = !0, pt.errorDigest = rr, pt.parentFlushed && qe.clientRenderedBoundaries.push(pt))), qe.allPendingTasks--, qe.allPendingTasks === 0) {
                  var Or = qe.onAllReady;
                  Or();
                }
              }
            } finally {
            }
          }
        }
        Ie.splice(0, Ae), L.destination !== null && Zl(L, L.destination);
      } catch (Fr) {
        Ca(L, Fr), Is(L, Fr);
      } finally {
        Ea = xe, Xl.current = ae, ae === ku && Qr(K);
      }
    }
  }
  function Ns(L, K, ae) {
    switch (ae.parentFlushed = !0, ae.status) {
      case 0:
        var xe = ae.id = L.nextSegmentId++;
        return ae.lastPushedText = !1, ae.textEmbedded = !1, L = L.responseState, i(K, Le), i(K, L.placeholderPrefix), L = l(xe.toString(16)), i(K, L), o(K, Qe);
      case 1:
        ae.status = 2;
        var Ie = !0;
        xe = ae.chunks;
        var Ae = 0;
        ae = ae.children;
        for (var Pe = 0; Pe < ae.length; Pe++) {
          for (Ie = ae[Pe]; Ae < Ie.index; Ae++) i(K, xe[Ae]);
          Ie = Ms(L, K, Ie);
        }
        for (; Ae < xe.length - 1; Ae++) i(K, xe[Ae]);
        return Ae < xe.length && (Ie = o(K, xe[Ae])), Ie;
      default:
        throw Error(e(390));
    }
  }
  function Ms(L, K, ae) {
    var xe = ae.boundary;
    if (xe === null) return Ns(L, K, ae);
    if (xe.parentFlushed = !0, xe.forceClientRender) xe = xe.errorDigest, o(K, et), i(K, Un), xe && (i(K, Ar), i(K, l(P(xe))), i(K, Ft)), o(K, Ii), Ns(L, K, ae);
    else if (0 < xe.pendingTasks) {
      xe.rootSegmentID = L.nextSegmentId++, 0 < xe.completedSegments.length && L.partialBoundaries.push(xe);
      var Ie = L.responseState, Ae = Ie.nextSuspenseID++;
      Ie = c(Ie.boundaryPrefix + Ae.toString(16)), xe = xe.id = Ie, xn(K, L.responseState, xe), Ns(L, K, ae);
    } else if (xe.byteSize > L.progressiveChunkSize) xe.rootSegmentID = L.nextSegmentId++, L.completedBoundaries.push(xe), xn(K, L.responseState, xe.id), Ns(L, K, ae);
    else {
      if (o(K, Ze), ae = xe.completedSegments, ae.length !== 1) throw Error(e(391));
      Ms(L, K, ae[0]);
    }
    return o(K, Zt);
  }
  function Mu(L, K, ae) {
    return Qn(K, L.responseState, ae.formatContext, ae.id), Ms(L, K, ae), Gr(K, ae.formatContext);
  }
  function Bu(L, K, ae) {
    for (var xe = ae.completedSegments, Ie = 0; Ie < xe.length; Ie++) Lu(L, K, ae, xe[Ie]);
    if (xe.length = 0, L = L.responseState, xe = ae.id, ae = ae.rootSegmentID, i(K, L.startInlineScript), L.sentCompleteBoundaryFunction ? i(K, er) : (L.sentCompleteBoundaryFunction = !0, i(K, Ni)), xe === null) throw Error(e(395));
    return ae = l(ae.toString(16)), i(K, xe), i(K, Ss), i(K, L.segmentPrefix), i(K, ae), o(K, Ts);
  }
  function Lu(L, K, ae, xe) {
    if (xe.status === 2) return !0;
    var Ie = xe.id;
    if (Ie === -1) {
      if ((xe.id = ae.rootSegmentID) === -1) throw Error(e(392));
      return Mu(L, K, xe);
    }
    return Mu(L, K, xe), L = L.responseState, i(K, L.startInlineScript), L.sentCompleteSegmentFunction ? i(K, Fi) : (L.sentCompleteSegmentFunction = !0, i(K, No)), i(K, L.segmentPrefix), Ie = l(Ie.toString(16)), i(K, Ie), i(K, Ui), i(K, L.placeholderPrefix), i(K, Ie), o(K, Kr);
  }
  function Zl(L, K) {
    n = new Uint8Array(512), r = 0;
    try {
      var ae = L.completedRootSegment;
      if (ae !== null && L.pendingRootTasks === 0) {
        Ms(L, K, ae), L.completedRootSegment = null;
        var xe = L.responseState.bootstrapChunks;
        for (ae = 0; ae < xe.length - 1; ae++) i(K, xe[ae]);
        ae < xe.length && o(K, xe[ae]);
      }
      var Ie = L.clientRenderedBoundaries, Ae;
      for (Ae = 0; Ae < Ie.length; Ae++) {
        var Pe = Ie[Ae];
        xe = K;
        var qe = L.responseState, ct = Pe.id, mt = Pe.errorDigest, pt = Pe.errorMessage, jt = Pe.errorComponentStack;
        if (i(xe, qe.startInlineScript), qe.sentClientRenderFunction ? i(xe, gn) : (qe.sentClientRenderFunction = !0, i(
          xe,
          gi
        )), ct === null) throw Error(e(395));
        i(xe, ct), i(xe, Xr), (mt || pt || jt) && (i(xe, Mi), i(xe, l(Rr(mt || "")))), (pt || jt) && (i(xe, Mi), i(xe, l(Rr(pt || "")))), jt && (i(xe, Mi), i(xe, l(Rr(jt)))), o(xe, Yr);
      }
      Ie.splice(0, Ae);
      var rr = L.completedBoundaries;
      for (Ae = 0; Ae < rr.length; Ae++) Bu(L, K, rr[Ae]);
      rr.splice(0, Ae), a(K), n = new Uint8Array(512), r = 0;
      var Or = L.partialBoundaries;
      for (Ae = 0; Ae < Or.length; Ae++) {
        var Fr = Or[Ae];
        e: {
          Ie = L, Pe = K;
          var Bs = Fr.completedSegments;
          for (qe = 0; qe < Bs.length; qe++) if (!Lu(
            Ie,
            Pe,
            Fr,
            Bs[qe]
          )) {
            qe++, Bs.splice(0, qe);
            var Wu = !1;
            break e;
          }
          Bs.splice(0, qe), Wu = !0;
        }
        if (!Wu) {
          L.destination = null, Ae++, Or.splice(0, Ae);
          return;
        }
      }
      Or.splice(0, Ae);
      var ka = L.completedBoundaries;
      for (Ae = 0; Ae < ka.length; Ae++) Bu(L, K, ka[Ae]);
      ka.splice(0, Ae);
    } finally {
      a(K), L.allPendingTasks === 0 && L.pingedTasks.length === 0 && L.clientRenderedBoundaries.length === 0 && L.completedBoundaries.length === 0 && K.close();
    }
  }
  function Pu(L, K) {
    try {
      var ae = L.abortableTasks;
      ae.forEach(function(xe) {
        return Fu(xe, L, K);
      }), ae.clear(), L.destination !== null && Zl(L, L.destination);
    } catch (xe) {
      Ca(L, xe), Is(L, xe);
    }
  }
  return Ny.renderToReadableStream = function(L, K) {
    return new Promise(function(ae, xe) {
      var Ie, Ae, Pe = new Promise(function(pt, jt) {
        Ae = pt, Ie = jt;
      }), qe = Yl(L, oe(K ? K.identifierPrefix : void 0, K ? K.nonce : void 0, K ? K.bootstrapScriptContent : void 0, K ? K.bootstrapScripts : void 0, K ? K.bootstrapModules : void 0), _e(K ? K.namespaceURI : void 0), K ? K.progressiveChunkSize : void 0, K ? K.onError : void 0, Ae, function() {
        var pt = new ReadableStream({ type: "bytes", pull: function(jt) {
          if (qe.status === 1) qe.status = 2, u(jt, qe.fatalError);
          else if (qe.status !== 2 && qe.destination === null) {
            qe.destination = jt;
            try {
              Zl(qe, jt);
            } catch (rr) {
              Ca(qe, rr), Is(qe, rr);
            }
          }
        }, cancel: function() {
          Pu(qe);
        } }, { highWaterMark: 0 });
        pt.allReady = Pe, ae(pt);
      }, function(pt) {
        Pe.catch(function() {
        }), xe(pt);
      }, Ie);
      if (K && K.signal) {
        var ct = K.signal, mt = function() {
          Pu(qe, ct.reason), ct.removeEventListener("abort", mt);
        };
        ct.addEventListener("abort", mt);
      }
      Nu(qe);
    });
  }, Ny.version = "18.3.1", Ny;
}
var Rc = {};
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tF;
function qxe() {
  return tF || (tF = 1, process.env.NODE_ENV !== "production" && function() {
    var t = Lt, e = "18.3.1", n = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(h) {
      {
        for (var v = arguments.length, D = new Array(v > 1 ? v - 1 : 0), R = 1; R < v; R++)
          D[R - 1] = arguments[R];
        o("warn", h, D);
      }
    }
    function i(h) {
      {
        for (var v = arguments.length, D = new Array(v > 1 ? v - 1 : 0), R = 1; R < v; R++)
          D[R - 1] = arguments[R];
        o("error", h, D);
      }
    }
    function o(h, v, D) {
      {
        var R = n.ReactDebugCurrentFrame, $ = R.getStackAddendum();
        $ !== "" && (v += "%s", D = D.concat([$]));
        var Y = D.map(function(se) {
          return String(se);
        });
        Y.unshift("Warning: " + v), Function.prototype.apply.call(console[h], console, Y);
      }
    }
    function a(h) {
      h();
    }
    function s(h) {
    }
    function l(h, v) {
      c(h, v);
    }
    function c(h, v) {
      return h.push(v);
    }
    function u(h) {
    }
    function d(h) {
      h.push(null);
    }
    function f(h) {
      return h;
    }
    function p(h) {
      return h;
    }
    function m(h, v) {
      h.destroy(v);
    }
    function g(h) {
      {
        var v = typeof Symbol == "function" && Symbol.toStringTag, D = v && h[Symbol.toStringTag] || h.constructor.name || "Object";
        return D;
      }
    }
    function b(h) {
      try {
        return y(h), !1;
      } catch {
        return !0;
      }
    }
    function y(h) {
      return "" + h;
    }
    function w(h, v) {
      if (b(h))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", v, g(h)), y(h);
    }
    function x(h, v) {
      if (b(h))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", v, g(h)), y(h);
    }
    function k(h) {
      if (b(h))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", g(h)), y(h);
    }
    var A = Object.prototype.hasOwnProperty, U = 0, P = 1, V = 2, I = 3, le = 4, be = 5, F = 6, G = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", C = G + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", ie = new RegExp("^[" + G + "][" + C + "]*$"), ee = {}, Z = {};
    function oe(h) {
      return A.call(Z, h) ? !0 : A.call(ee, h) ? !1 : ie.test(h) ? (Z[h] = !0, !0) : (ee[h] = !0, i("Invalid attribute name: `%s`", h), !1);
    }
    function te(h, v, D, R) {
      if (D !== null && D.type === U)
        return !1;
      switch (typeof v) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (D !== null)
            return !D.acceptsBooleans;
          var $ = h.toLowerCase().slice(0, 5);
          return $ !== "data-" && $ !== "aria-";
        }
        default:
          return !1;
      }
    }
    function _e(h) {
      return N.hasOwnProperty(h) ? N[h] : null;
    }
    function q(h, v, D, R, $, Y, se) {
      this.acceptsBooleans = v === V || v === I || v === le, this.attributeName = R, this.attributeNamespace = $, this.mustUseProperty = D, this.propertyName = h, this.type = v, this.sanitizeURL = Y, this.removeEmptyString = se;
    }
    var N = {}, ce = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ce.forEach(function(h) {
      N[h] = new q(
        h,
        U,
        !1,
        // mustUseProperty
        h,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(h) {
      var v = h[0], D = h[1];
      N[v] = new q(
        v,
        P,
        !1,
        // mustUseProperty
        D,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(h) {
      N[h] = new q(
        h,
        V,
        !1,
        // mustUseProperty
        h.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(h) {
      N[h] = new q(
        h,
        V,
        !1,
        // mustUseProperty
        h,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(h) {
      N[h] = new q(
        h,
        I,
        !1,
        // mustUseProperty
        h.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(h) {
      N[h] = new q(
        h,
        I,
        !0,
        // mustUseProperty
        h,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(h) {
      N[h] = new q(
        h,
        le,
        !1,
        // mustUseProperty
        h,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(h) {
      N[h] = new q(
        h,
        F,
        !1,
        // mustUseProperty
        h,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(h) {
      N[h] = new q(
        h,
        be,
        !1,
        // mustUseProperty
        h.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var me = /[\-\:]([a-z])/g, ve = function(h) {
      return h[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(h) {
      var v = h.replace(me, ve);
      N[v] = new q(
        v,
        P,
        !1,
        // mustUseProperty
        h,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(h) {
      var v = h.replace(me, ve);
      N[v] = new q(
        v,
        P,
        !1,
        // mustUseProperty
        h,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(h) {
      var v = h.replace(me, ve);
      N[v] = new q(
        v,
        P,
        !1,
        // mustUseProperty
        h,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(h) {
      N[h] = new q(
        h,
        P,
        !1,
        // mustUseProperty
        h.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var he = "xlinkHref";
    N[he] = new q(
      "xlinkHref",
      P,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(h) {
      N[h] = new q(
        h,
        P,
        !1,
        // mustUseProperty
        h.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var H = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function W(h, v) {
      return h + v.charAt(0).toUpperCase() + v.substring(1);
    }
    var we = ["Webkit", "ms", "Moz", "O"];
    Object.keys(H).forEach(function(h) {
      we.forEach(function(v) {
        H[W(v, h)] = H[h];
      });
    });
    var ye = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function j(h, v) {
      ye[v.type] || v.onChange || v.onInput || v.readOnly || v.disabled || v.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), v.onChange || v.readOnly || v.disabled || v.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Q(h, v) {
      if (h.indexOf("-") === -1)
        return typeof v.is == "string";
      switch (h) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var De = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, T = {}, pe = new RegExp("^(aria)-[" + C + "]*$"), M = new RegExp("^(aria)[A-Z][" + C + "]*$");
    function _(h, v) {
      {
        if (A.call(T, v) && T[v])
          return !0;
        if (M.test(v)) {
          var D = "aria-" + v.slice(4).toLowerCase(), R = De.hasOwnProperty(D) ? D : null;
          if (R == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", v), T[v] = !0, !0;
          if (v !== R)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", v, R), T[v] = !0, !0;
        }
        if (pe.test(v)) {
          var $ = v.toLowerCase(), Y = De.hasOwnProperty($) ? $ : null;
          if (Y == null)
            return T[v] = !0, !1;
          if (v !== Y)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", v, Y), T[v] = !0, !0;
        }
      }
      return !0;
    }
    function S(h, v) {
      {
        var D = [];
        for (var R in v) {
          var $ = _(h, R);
          $ || D.push(R);
        }
        var Y = D.map(function(se) {
          return "`" + se + "`";
        }).join(", ");
        D.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", Y, h) : D.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", Y, h);
      }
    }
    function O(h, v) {
      Q(h, v) || S(h, v);
    }
    var ne = !1;
    function fe(h, v) {
      {
        if (h !== "input" && h !== "textarea" && h !== "select")
          return;
        v != null && v.value === null && !ne && (ne = !0, h === "select" && v.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", h) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", h));
      }
    }
    var J = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, re = function() {
    };
    {
      var de = {}, ge = /^on./, Ee = /^on[^A-Z]/, Ne = new RegExp("^(aria)-[" + C + "]*$"), Le = new RegExp("^(aria)[A-Z][" + C + "]*$");
      re = function(h, v, D, R) {
        if (A.call(de, v) && de[v])
          return !0;
        var $ = v.toLowerCase();
        if ($ === "onfocusin" || $ === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), de[v] = !0, !0;
        if (R != null) {
          var Y = R.registrationNameDependencies, se = R.possibleRegistrationNames;
          if (Y.hasOwnProperty(v))
            return !0;
          var Te = se.hasOwnProperty($) ? se[$] : null;
          if (Te != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", v, Te), de[v] = !0, !0;
          if (ge.test(v))
            return i("Unknown event handler property `%s`. It will be ignored.", v), de[v] = !0, !0;
        } else if (ge.test(v))
          return Ee.test(v) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", v), de[v] = !0, !0;
        if (Ne.test(v) || Le.test(v))
          return !0;
        if ($ === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), de[v] = !0, !0;
        if ($ === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), de[v] = !0, !0;
        if ($ === "is" && D !== null && D !== void 0 && typeof D != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof D), de[v] = !0, !0;
        if (typeof D == "number" && isNaN(D))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", v), de[v] = !0, !0;
        var ke = _e(v), We = ke !== null && ke.type === U;
        if (J.hasOwnProperty($)) {
          var He = J[$];
          if (He !== v)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", v, He), de[v] = !0, !0;
        } else if (!We && v !== $)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", v, $), de[v] = !0, !0;
        return typeof D == "boolean" && te(v, D, ke) ? (D ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', D, v, v, D, v) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', D, v, v, D, v, v, v), de[v] = !0, !0) : We ? !0 : te(v, D, ke) ? (de[v] = !0, !1) : ((D === "false" || D === "true") && ke !== null && ke.type === I && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", D, v, D === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', v, D), de[v] = !0), !0);
      };
    }
    var Qe = function(h, v, D) {
      {
        var R = [];
        for (var $ in v) {
          var Y = re(h, $, v[$], D);
          Y || R.push($);
        }
        var se = R.map(function(Te) {
          return "`" + Te + "`";
        }).join(", ");
        R.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", se, h) : R.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", se, h);
      }
    };
    function Ze(h, v, D) {
      Q(h, v) || Qe(h, v, D);
    }
    var at = function() {
    };
    {
      var gt = /^(?:webkit|moz|o)[A-Z]/, et = /^-ms-/, Zt = /-(.)/g, Un = /;\s*$/, Ft = {}, Ar = {}, Ii = !1, xn = !1, Bn = function(h) {
        return h.replace(Zt, function(v, D) {
          return D.toUpperCase();
        });
      }, Ln = function(h) {
        Ft.hasOwnProperty(h) && Ft[h] || (Ft[h] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          h,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Bn(h.replace(et, "ms-"))
        ));
      }, ht = function(h) {
        Ft.hasOwnProperty(h) && Ft[h] || (Ft[h] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", h, h.charAt(0).toUpperCase() + h.slice(1)));
      }, _n = function(h, v) {
        Ar.hasOwnProperty(v) && Ar[v] || (Ar[v] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, h, v.replace(Un, "")));
      }, Oo = function(h, v) {
        Ii || (Ii = !0, i("`NaN` is an invalid value for the `%s` css style property.", h));
      }, ao = function(h, v) {
        xn || (xn = !0, i("`Infinity` is an invalid value for the `%s` css style property.", h));
      };
      at = function(h, v) {
        h.indexOf("-") > -1 ? Ln(h) : gt.test(h) ? ht(h) : Un.test(v) && _n(h, v), typeof v == "number" && (isNaN(v) ? Oo(h, v) : isFinite(v) || ao(h, v));
      };
    }
    var Vr = at, Fo = /["'&<>]/;
    function mi(h) {
      k(h);
      var v = "" + h, D = Fo.exec(v);
      if (!D)
        return v;
      var R, $ = "", Y, se = 0;
      for (Y = D.index; Y < v.length; Y++) {
        switch (v.charCodeAt(Y)) {
          case 34:
            R = "&quot;";
            break;
          case 38:
            R = "&amp;";
            break;
          case 39:
            R = "&#x27;";
            break;
          case 60:
            R = "&lt;";
            break;
          case 62:
            R = "&gt;";
            break;
          default:
            continue;
        }
        se !== Y && ($ += v.substring(se, Y)), se = Y + 1, $ += R;
      }
      return se !== Y ? $ + v.substring(se, Y) : $;
    }
    function Sn(h) {
      return typeof h == "boolean" || typeof h == "number" ? "" + h : mi(h);
    }
    var xa = /([A-Z])/g, _a = /^ms-/;
    function _s(h) {
      return h.replace(xa, "-$1").toLowerCase().replace(_a, "-ms-");
    }
    var mn = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Sa = !1;
    function Vl(h) {
      !Sa && mn.test(h) && (Sa = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(h)));
    }
    var ql = Array.isArray;
    function qr(h) {
      return ql(h);
    }
    var Ta = "<script>";
    function Uo(h, v, D, R, $) {
      var Y = h === void 0 ? "" : h, se = Ta, Te = [];
      return {
        bootstrapChunks: Te,
        startInlineScript: se,
        placeholderPrefix: Y + "P:",
        segmentPrefix: Y + "S:",
        boundaryPrefix: Y + "B:",
        idPrefix: Y,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var Oi = 0, Qn = 1, Gr = 2, No = 3, Fi = 4, Ui = 5, Kr = 6, Ni = 7;
    function er(h, v) {
      return {
        insertionMode: h,
        selectedValue: v
      };
    }
    function Ss(h, v, D) {
      switch (v) {
        case "select":
          return er(Qn, D.value != null ? D.value : D.defaultValue);
        case "svg":
          return er(Gr, null);
        case "math":
          return er(No, null);
        case "foreignObject":
          return er(Qn, null);
        case "table":
          return er(Fi, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return er(Ui, null);
        case "colgroup":
          return er(Ni, null);
        case "tr":
          return er(Kr, null);
      }
      return h.insertionMode >= Fi || h.insertionMode === Oi ? er(Qn, null) : h;
    }
    var Ts = null;
    function gi(h) {
      var v = h.nextSuspenseID++;
      return h.boundaryPrefix + v.toString(16);
    }
    function gn(h, v, D) {
      var R = h.idPrefix, $ = ":" + R + "R" + v;
      return D > 0 && ($ += "H" + D.toString(32)), $ + ":";
    }
    function Xr(h) {
      return Sn(h);
    }
    var Yr = "<!-- -->";
    function Mi(h, v, D, R) {
      return v === "" ? R : (R && h.push(Yr), h.push(Xr(v)), !0);
    }
    function Mo(h, v, D, R) {
      D && R && h.push(Yr);
    }
    var Rr = /* @__PURE__ */ new Map();
    function Jr(h) {
      var v = Rr.get(h);
      if (v !== void 0)
        return v;
      var D = Sn(_s(h));
      return Rr.set(h, D), D;
    }
    var Pn = ' style="', Bi = ":", so = ";";
    function Bo(h, v, D) {
      if (typeof D != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var R = !0;
      for (var $ in D)
        if (A.call(D, $)) {
          var Y = D[$];
          if (!(Y == null || typeof Y == "boolean" || Y === "")) {
            var se = void 0, Te = void 0, ke = $.indexOf("--") === 0;
            ke ? (se = Sn($), x(Y, $), Te = Sn(("" + Y).trim())) : (Vr($, Y), se = Jr($), typeof Y == "number" ? Y !== 0 && !A.call(H, $) ? Te = Y + "px" : Te = "" + Y : (x(Y, $), Te = Sn(("" + Y).trim()))), R ? (R = !1, h.push(Pn, se, Bi, Te)) : h.push(so, se, Bi, Te);
          }
        }
      R || h.push(Wn);
    }
    var hr = " ", Zr = '="', Wn = '"', Lo = '=""';
    function Cn(h, v, D, R) {
      switch (D) {
        case "style": {
          Bo(h, v, R);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(D.length > 2 && (D[0] === "o" || D[0] === "O") && (D[1] === "n" || D[1] === "N"))
      ) {
        var $ = _e(D);
        if ($ !== null) {
          switch (typeof R) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!$.acceptsBooleans)
                return;
          }
          var Y = $.attributeName, se = Y;
          switch ($.type) {
            case I:
              R && h.push(hr, se, Lo);
              return;
            case le:
              R === !0 ? h.push(hr, se, Lo) : R === !1 || h.push(hr, se, Zr, Sn(R), Wn);
              return;
            case be:
              isNaN(R) || h.push(hr, se, Zr, Sn(R), Wn);
              break;
            case F:
              !isNaN(R) && R >= 1 && h.push(hr, se, Zr, Sn(R), Wn);
              break;
            default:
              $.sanitizeURL && (w(R, Y), R = "" + R, Vl(R)), h.push(hr, se, Zr, Sn(R), Wn);
          }
        } else if (oe(D)) {
          switch (typeof R) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var Te = D.toLowerCase().slice(0, 5);
              if (Te !== "data-" && Te !== "aria-")
                return;
            }
          }
          h.push(hr, D, Zr, Sn(R), Wn);
        }
      }
    }
    var tr = ">", B = "/>";
    function X(h, v, D) {
      if (v != null) {
        if (D != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof v != "object" || !("__html" in v))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var R = v.__html;
        R != null && (k(R), h.push("" + R));
      }
    }
    var ue = !1, Se = !1, Re = !1, Ce = !1, Be = !1, Ve = !1, rt = !1;
    function lt(h, v) {
      {
        var D = h[v];
        if (D != null) {
          var R = qr(D);
          h.multiple && !R ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", v) : !h.multiple && R && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", v);
        }
      }
    }
    function it(h, v, D) {
      j("select", v), lt(v, "value"), lt(v, "defaultValue"), v.value !== void 0 && v.defaultValue !== void 0 && !Re && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Re = !0), h.push(ei("select"));
      var R = null, $ = null;
      for (var Y in v)
        if (A.call(v, Y)) {
          var se = v[Y];
          if (se == null)
            continue;
          switch (Y) {
            case "children":
              R = se;
              break;
            case "dangerouslySetInnerHTML":
              $ = se;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              Cn(h, D, Y, se);
              break;
          }
        }
      return h.push(tr), X(h, $, R), R;
    }
    function Rt(h) {
      var v = "";
      return t.Children.forEach(h, function(D) {
        D != null && (v += D, !Be && typeof D != "string" && typeof D != "number" && (Be = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), v;
    }
    var zn = ' selected=""';
    function $n(h, v, D, R) {
      var $ = R.selectedValue;
      h.push(ei("option"));
      var Y = null, se = null, Te = null, ke = null;
      for (var We in v)
        if (A.call(v, We)) {
          var He = v[We];
          if (He == null)
            continue;
          switch (We) {
            case "children":
              Y = He;
              break;
            case "selected":
              Te = He, rt || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), rt = !0);
              break;
            case "dangerouslySetInnerHTML":
              ke = He;
              break;
            case "value":
              se = He;
            default:
              Cn(h, D, We, He);
              break;
          }
        }
      if ($ != null) {
        var Ke;
        if (se !== null ? (w(se, "value"), Ke = "" + se) : (ke !== null && (Ve || (Ve = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), Ke = Rt(Y)), qr($))
          for (var ut = 0; ut < $.length; ut++) {
            w($[ut], "value");
            var Ut = "" + $[ut];
            if (Ut === Ke) {
              h.push(zn);
              break;
            }
          }
        else
          w($, "select.value"), "" + $ === Ke && h.push(zn);
      } else Te && h.push(zn);
      return h.push(tr), X(h, ke, Y), Y;
    }
    function Hn(h, v, D) {
      j("input", v), v.checked !== void 0 && v.defaultChecked !== void 0 && !Se && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", v.type), Se = !0), v.value !== void 0 && v.defaultValue !== void 0 && !ue && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", v.type), ue = !0), h.push(ei("input"));
      var R = null, $ = null, Y = null, se = null;
      for (var Te in v)
        if (A.call(v, Te)) {
          var ke = v[Te];
          if (ke == null)
            continue;
          switch (Te) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              se = ke;
              break;
            case "defaultValue":
              $ = ke;
              break;
            case "checked":
              Y = ke;
              break;
            case "value":
              R = ke;
              break;
            default:
              Cn(h, D, Te, ke);
              break;
          }
        }
      return Y !== null ? Cn(h, D, "checked", Y) : se !== null && Cn(h, D, "checked", se), R !== null ? Cn(h, D, "value", R) : $ !== null && Cn(h, D, "value", $), h.push(B), null;
    }
    function Li(h, v, D) {
      j("textarea", v), v.value !== void 0 && v.defaultValue !== void 0 && !Ce && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Ce = !0), h.push(ei("textarea"));
      var R = null, $ = null, Y = null;
      for (var se in v)
        if (A.call(v, se)) {
          var Te = v[se];
          if (Te == null)
            continue;
          switch (se) {
            case "children":
              Y = Te;
              break;
            case "value":
              R = Te;
              break;
            case "defaultValue":
              $ = Te;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              Cn(h, D, se, Te);
              break;
          }
        }
      if (R === null && $ !== null && (R = $), h.push(tr), Y != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), R != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (qr(Y)) {
          if (Y.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          k(Y[0]), R = "" + Y[0];
        }
        k(Y), R = "" + Y;
      }
      return typeof R == "string" && R[0] === `
` && h.push(co), R !== null && (w(R, "value"), h.push(Xr("" + R))), null;
    }
    function Qr(h, v, D, R) {
      h.push(ei(D));
      for (var $ in v)
        if (A.call(v, $)) {
          var Y = v[$];
          if (Y == null)
            continue;
          switch ($) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(D + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              Cn(h, R, $, Y);
              break;
          }
        }
      return h.push(B), null;
    }
    function Po(h, v, D) {
      h.push(ei("menuitem"));
      for (var R in v)
        if (A.call(v, R)) {
          var $ = v[R];
          if ($ == null)
            continue;
          switch (R) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              Cn(h, D, R, $);
              break;
          }
        }
      return h.push(tr), null;
    }
    function Pi(h, v, D) {
      h.push(ei("title"));
      var R = null;
      for (var $ in v)
        if (A.call(v, $)) {
          var Y = v[$];
          if (Y == null)
            continue;
          switch ($) {
            case "children":
              R = Y;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              Cn(h, D, $, Y);
              break;
          }
        }
      h.push(tr);
      {
        var se = Array.isArray(R) && R.length < 2 ? R[0] || null : R;
        Array.isArray(R) && R.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : se != null && se.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : se != null && typeof se != "string" && typeof se != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return R;
    }
    function lo(h, v, D, R) {
      h.push(ei(D));
      var $ = null, Y = null;
      for (var se in v)
        if (A.call(v, se)) {
          var Te = v[se];
          if (Te == null)
            continue;
          switch (se) {
            case "children":
              $ = Te;
              break;
            case "dangerouslySetInnerHTML":
              Y = Te;
              break;
            default:
              Cn(h, R, se, Te);
              break;
          }
        }
      return h.push(tr), X(h, Y, $), typeof $ == "string" ? (h.push(Xr($)), null) : $;
    }
    function yi(h, v, D, R) {
      h.push(ei(D));
      var $ = null, Y = null;
      for (var se in v)
        if (A.call(v, se)) {
          var Te = v[se];
          if (Te == null)
            continue;
          switch (se) {
            case "children":
              $ = Te;
              break;
            case "dangerouslySetInnerHTML":
              Y = Te;
              break;
            case "style":
              Bo(h, R, Te);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              oe(se) && typeof Te != "function" && typeof Te != "symbol" && h.push(hr, se, Zr, Sn(Te), Wn);
              break;
          }
        }
      return h.push(tr), X(h, Y, $), $;
    }
    var co = `
`;
    function uh(h, v, D, R) {
      h.push(ei(D));
      var $ = null, Y = null;
      for (var se in v)
        if (A.call(v, se)) {
          var Te = v[se];
          if (Te == null)
            continue;
          switch (se) {
            case "children":
              $ = Te;
              break;
            case "dangerouslySetInnerHTML":
              Y = Te;
              break;
            default:
              Cn(h, R, se, Te);
              break;
          }
        }
      if (h.push(tr), Y != null) {
        if ($ != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof Y != "object" || !("__html" in Y))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var ke = Y.__html;
        ke != null && (typeof ke == "string" && ke.length > 0 && ke[0] === `
` ? h.push(co, ke) : (k(ke), h.push("" + ke)));
      }
      return typeof $ == "string" && $[0] === `
` && h.push(co), $;
    }
    var dh = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Ds = /* @__PURE__ */ new Map();
    function ei(h) {
      var v = Ds.get(h);
      if (v === void 0) {
        if (!dh.test(h))
          throw new Error("Invalid tag: " + h);
        v = "<" + h, Ds.set(h, v);
      }
      return v;
    }
    var fh = "<!DOCTYPE html>";
    function bi(h, v, D, R, $) {
      switch (O(v, D), fe(v, D), Ze(v, D, null), !D.suppressContentEditableWarning && D.contentEditable && D.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), $.insertionMode !== Gr && $.insertionMode !== No && v.indexOf("-") === -1 && typeof D.is != "string" && v.toLowerCase() !== v && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", v), v) {
        case "select":
          return it(h, D, R);
        case "option":
          return $n(h, D, R, $);
        case "textarea":
          return Li(h, D, R);
        case "input":
          return Hn(h, D, R);
        case "menuitem":
          return Po(h, D, R);
        case "title":
          return Pi(h, D, R);
        case "listing":
        case "pre":
          return uh(h, D, v, R);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Qr(h, D, v, R);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return lo(h, D, v, R);
        case "html":
          return $.insertionMode === Oi && h.push(fh), lo(h, D, v, R);
        default:
          return v.indexOf("-") === -1 && typeof D.is != "string" ? lo(h, D, v, R) : yi(h, D, v, R);
      }
    }
    var Gl = "</", Es = ">";
    function zt(h, v, D) {
      switch (v) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          h.push(Gl, v, Es);
      }
    }
    function uo(h, v) {
      for (var D = v.bootstrapChunks, R = 0; R < D.length - 1; R++)
        l(h, D[R]);
      return R < D.length ? c(h, D[R]) : !0;
    }
    var Cs = '<template id="', fo = '"></template>';
    function Wi(h, v, D) {
      l(h, Cs), l(h, v.placeholderPrefix);
      var R = D.toString(16);
      return l(h, R), c(h, fo);
    }
    var ks = "<!--$-->", zi = '<!--$?--><template id="', Ir = '"></template>', Kl = "<!--$!-->", Da = "<!--/$-->", Eu = "<template", As = '"', Cu = ' data-dgst="', hh = ' data-msg="', ph = ' data-stck="', Rs = "></template>";
    function ku(h, v) {
      return c(h, ks);
    }
    function Ea(h, v, D) {
      if (l(h, zi), D === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return l(h, D), c(h, Ir);
    }
    function Xl(h, v, D, R, $) {
      var Y;
      return Y = c(h, Kl), l(h, Eu), D && (l(h, Cu), l(h, Sn(D)), l(h, As)), R && (l(h, hh), l(h, Sn(R)), l(h, As)), $ && (l(h, ph), l(h, Sn($)), l(h, As)), Y = c(h, Rs), Y;
    }
    function mh(h, v) {
      return c(h, Da);
    }
    function Wo(h, v) {
      return c(h, Da);
    }
    function Yl(h, v) {
      return c(h, Da);
    }
    var Jl = '<div hidden id="', zo = '">', Ca = "</div>", Is = '<svg aria-hidden="true" style="display:none" id="', Au = '">', Ru = "</svg>", Iu = '<math aria-hidden="true" style="display:none" id="', Os = '">', nr = "</math>", Ou = '<table hidden id="', Fs = '">', gh = "</table>", Fu = '<table hidden><tbody id="', Us = '">', Uu = "</tbody></table>", Nu = '<table hidden><tr id="', Ns = '">', Ms = "</tr></table>", Mu = '<table hidden><colgroup id="', Bu = '">', Lu = "</colgroup></table>";
    function Zl(h, v, D, R) {
      switch (D.insertionMode) {
        case Oi:
        case Qn:
          return l(h, Jl), l(h, v.segmentPrefix), l(h, R.toString(16)), c(h, zo);
        case Gr:
          return l(h, Is), l(h, v.segmentPrefix), l(h, R.toString(16)), c(h, Au);
        case No:
          return l(h, Iu), l(h, v.segmentPrefix), l(h, R.toString(16)), c(h, Os);
        case Fi:
          return l(h, Ou), l(h, v.segmentPrefix), l(h, R.toString(16)), c(h, Fs);
        case Ui:
          return l(h, Fu), l(h, v.segmentPrefix), l(h, R.toString(16)), c(h, Us);
        case Kr:
          return l(h, Nu), l(h, v.segmentPrefix), l(h, R.toString(16)), c(h, Ns);
        case Ni:
          return l(h, Mu), l(h, v.segmentPrefix), l(h, R.toString(16)), c(h, Bu);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Pu(h, v) {
      switch (v.insertionMode) {
        case Oi:
        case Qn:
          return c(h, Ca);
        case Gr:
          return c(h, Ru);
        case No:
          return c(h, nr);
        case Fi:
          return c(h, gh);
        case Ui:
          return c(h, Uu);
        case Kr:
          return c(h, Ms);
        case Ni:
          return c(h, Lu);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var L = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", K = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', ae = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', xe = L + ';$RS("', Ie = '$RS("', Ae = '","', Pe = '")<\/script>';
    function qe(h, v, D) {
      l(h, v.startInlineScript), v.sentCompleteSegmentFunction ? l(h, Ie) : (v.sentCompleteSegmentFunction = !0, l(h, xe)), l(h, v.segmentPrefix);
      var R = D.toString(16);
      return l(h, R), l(h, Ae), l(h, v.placeholderPrefix), l(h, R), c(h, Pe);
    }
    var ct = K + ';$RC("', mt = '$RC("', pt = '","', jt = '")<\/script>';
    function rr(h, v, D, R) {
      if (l(h, v.startInlineScript), v.sentCompleteBoundaryFunction ? l(h, mt) : (v.sentCompleteBoundaryFunction = !0, l(h, ct)), D === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var $ = R.toString(16);
      return l(h, D), l(h, pt), l(h, v.segmentPrefix), l(h, $), c(h, jt);
    }
    var Or = ae + ';$RX("', Fr = '$RX("', Bs = '"', Wu = ")<\/script>", ka = ",";
    function F0(h, v, D, R, $, Y) {
      if (l(h, v.startInlineScript), v.sentClientRenderFunction ? l(h, Fr) : (v.sentClientRenderFunction = !0, l(h, Or)), D === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return l(h, D), l(h, Bs), (R || $ || Y) && (l(h, ka), l(h, yh(R || ""))), ($ || Y) && (l(h, ka), l(h, yh($ || ""))), Y && (l(h, ka), l(h, yh(Y))), c(h, Wu);
    }
    var U0 = /[<\u2028\u2029]/g;
    function yh(h) {
      var v = JSON.stringify(h);
      return v.replace(U0, function(D) {
        switch (D) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function N0(h, v) {
      var D = Uo(v);
      return {
        // Keep this in sync with ReactDOMServerFormatConfig
        bootstrapChunks: D.bootstrapChunks,
        startInlineScript: D.startInlineScript,
        placeholderPrefix: D.placeholderPrefix,
        segmentPrefix: D.segmentPrefix,
        boundaryPrefix: D.boundaryPrefix,
        idPrefix: D.idPrefix,
        nextSuspenseID: D.nextSuspenseID,
        sentCompleteSegmentFunction: D.sentCompleteSegmentFunction,
        sentCompleteBoundaryFunction: D.sentCompleteBoundaryFunction,
        sentClientRenderFunction: D.sentClientRenderFunction,
        // This is an extra field for the legacy renderer
        generateStaticMarkup: h
      };
    }
    function M0() {
      return {
        insertionMode: Qn,
        // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
        selectedValue: null
      };
    }
    function ng(h, v, D, R) {
      return D.generateStaticMarkup ? (h.push(Sn(v)), !1) : Mi(h, v, D, R);
    }
    function rg(h, v, D, R) {
      if (!v.generateStaticMarkup)
        return Mo(h, v, D, R);
    }
    function B0(h, v) {
      return v.generateStaticMarkup ? !0 : ku(h);
    }
    function L0(h, v, D, R, $) {
      return v.generateStaticMarkup ? !0 : Xl(h, v, D, R, $);
    }
    function P0(h, v) {
      return v.generateStaticMarkup ? !0 : mh(h);
    }
    function W0(h, v) {
      return v.generateStaticMarkup ? !0 : Yl(h);
    }
    var pr = Object.assign, z0 = Symbol.for("react.element"), ig = Symbol.for("react.portal"), zu = Symbol.for("react.fragment"), Ur = Symbol.for("react.strict_mode"), og = Symbol.for("react.profiler"), $u = Symbol.for("react.provider"), Hu = Symbol.for("react.context"), ju = Symbol.for("react.forward_ref"), Vu = Symbol.for("react.suspense"), Ql = Symbol.for("react.suspense_list"), ec = Symbol.for("react.memo"), Ls = Symbol.for("react.lazy"), bh = Symbol.for("react.scope"), vh = Symbol.for("react.debug_trace_mode"), wh = Symbol.for("react.legacy_hidden"), qu = Symbol.for("react.default_value"), ag = Symbol.iterator, $0 = "@@iterator";
    function H0(h) {
      if (h === null || typeof h != "object")
        return null;
      var v = ag && h[ag] || h[$0];
      return typeof v == "function" ? v : null;
    }
    function j0(h, v, D) {
      var R = h.displayName;
      if (R)
        return R;
      var $ = v.displayName || v.name || "";
      return $ !== "" ? D + "(" + $ + ")" : D;
    }
    function xh(h) {
      return h.displayName || "Context";
    }
    function on(h) {
      if (h == null)
        return null;
      if (typeof h.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof h == "function")
        return h.displayName || h.name || null;
      if (typeof h == "string")
        return h;
      switch (h) {
        case zu:
          return "Fragment";
        case ig:
          return "Portal";
        case og:
          return "Profiler";
        case Ur:
          return "StrictMode";
        case Vu:
          return "Suspense";
        case Ql:
          return "SuspenseList";
      }
      if (typeof h == "object")
        switch (h.$$typeof) {
          case Hu:
            var v = h;
            return xh(v) + ".Consumer";
          case $u:
            var D = h;
            return xh(D._context) + ".Provider";
          case ju:
            return j0(h, h.render, "ForwardRef");
          case ec:
            var R = h.displayName || null;
            return R !== null ? R : on(h.type) || "Memo";
          case Ls: {
            var $ = h, Y = $._payload, se = $._init;
            try {
              return on(se(Y));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var tc = 0, sg, _h, Qt, Ps, Sh, Th, Dh;
    function Eh() {
    }
    Eh.__reactDisabledLog = !0;
    function lg() {
      {
        if (tc === 0) {
          sg = console.log, _h = console.info, Qt = console.warn, Ps = console.error, Sh = console.group, Th = console.groupCollapsed, Dh = console.groupEnd;
          var h = {
            configurable: !0,
            enumerable: !0,
            value: Eh,
            writable: !0
          };
          Object.defineProperties(console, {
            info: h,
            log: h,
            warn: h,
            error: h,
            group: h,
            groupCollapsed: h,
            groupEnd: h
          });
        }
        tc++;
      }
    }
    function cg() {
      {
        if (tc--, tc === 0) {
          var h = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: pr({}, h, {
              value: sg
            }),
            info: pr({}, h, {
              value: _h
            }),
            warn: pr({}, h, {
              value: Qt
            }),
            error: pr({}, h, {
              value: Ps
            }),
            group: pr({}, h, {
              value: Sh
            }),
            groupCollapsed: pr({}, h, {
              value: Th
            }),
            groupEnd: pr({}, h, {
              value: Dh
            })
          });
        }
        tc < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Gu = n.ReactCurrentDispatcher, Ku;
    function nc(h, v, D) {
      {
        if (Ku === void 0)
          try {
            throw Error();
          } catch ($) {
            var R = $.stack.trim().match(/\n( *(at )?)/);
            Ku = R && R[1] || "";
          }
        return `
` + Ku + h;
      }
    }
    var Ch = !1, Ws;
    {
      var kh = typeof WeakMap == "function" ? WeakMap : Map;
      Ws = new kh();
    }
    function Aa(h, v) {
      if (!h || Ch)
        return "";
      {
        var D = Ws.get(h);
        if (D !== void 0)
          return D;
      }
      var R;
      Ch = !0;
      var $ = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Y;
      Y = Gu.current, Gu.current = null, lg();
      try {
        if (v) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Nn) {
              R = Nn;
            }
            Reflect.construct(h, [], se);
          } else {
            try {
              se.call();
            } catch (Nn) {
              R = Nn;
            }
            h.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Nn) {
            R = Nn;
          }
          h();
        }
      } catch (Nn) {
        if (Nn && R && typeof Nn.stack == "string") {
          for (var Te = Nn.stack.split(`
`), ke = R.stack.split(`
`), We = Te.length - 1, He = ke.length - 1; We >= 1 && He >= 0 && Te[We] !== ke[He]; )
            He--;
          for (; We >= 1 && He >= 0; We--, He--)
            if (Te[We] !== ke[He]) {
              if (We !== 1 || He !== 1)
                do
                  if (We--, He--, He < 0 || Te[We] !== ke[He]) {
                    var Ke = `
` + Te[We].replace(" at new ", " at ");
                    return h.displayName && Ke.includes("<anonymous>") && (Ke = Ke.replace("<anonymous>", h.displayName)), typeof h == "function" && Ws.set(h, Ke), Ke;
                  }
                while (We >= 1 && He >= 0);
              break;
            }
        }
      } finally {
        Ch = !1, Gu.current = Y, cg(), Error.prepareStackTrace = $;
      }
      var ut = h ? h.displayName || h.name : "", Ut = ut ? nc(ut) : "";
      return typeof h == "function" && Ws.set(h, Ut), Ut;
    }
    function Ah(h, v, D) {
      return Aa(h, !0);
    }
    function rc(h, v, D) {
      return Aa(h, !1);
    }
    function V0(h) {
      var v = h.prototype;
      return !!(v && v.isReactComponent);
    }
    function ic(h, v, D) {
      if (h == null)
        return "";
      if (typeof h == "function")
        return Aa(h, V0(h));
      if (typeof h == "string")
        return nc(h);
      switch (h) {
        case Vu:
          return nc("Suspense");
        case Ql:
          return nc("SuspenseList");
      }
      if (typeof h == "object")
        switch (h.$$typeof) {
          case ju:
            return rc(h.render);
          case ec:
            return ic(h.type, v, D);
          case Ls: {
            var R = h, $ = R._payload, Y = R._init;
            try {
              return ic(Y($), v, D);
            } catch {
            }
          }
        }
      return "";
    }
    var ug = {}, Rh = n.ReactDebugCurrentFrame;
    function Xu(h) {
      if (h) {
        var v = h._owner, D = ic(h.type, h._source, v ? v.type : null);
        Rh.setExtraStackFrame(D);
      } else
        Rh.setExtraStackFrame(null);
    }
    function Yu(h, v, D, R, $) {
      {
        var Y = Function.call.bind(A);
        for (var se in h)
          if (Y(h, se)) {
            var Te = void 0;
            try {
              if (typeof h[se] != "function") {
                var ke = Error((R || "React class") + ": " + D + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof h[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ke.name = "Invariant Violation", ke;
              }
              Te = h[se](v, se, R, D, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (We) {
              Te = We;
            }
            Te && !(Te instanceof Error) && (Xu($), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", R || "React class", D, se, typeof Te), Xu(null)), Te instanceof Error && !(Te.message in ug) && (ug[Te.message] = !0, Xu($), i("Failed %s type: %s", D, Te.message), Xu(null));
          }
      }
    }
    var Ju;
    Ju = {};
    var oc = {};
    Object.freeze(oc);
    function ac(h, v) {
      {
        var D = h.contextTypes;
        if (!D)
          return oc;
        var R = {};
        for (var $ in D)
          R[$] = v[$];
        {
          var Y = on(h) || "Unknown";
          Yu(D, R, "context", Y);
        }
        return R;
      }
    }
    function dg(h, v, D, R) {
      {
        if (typeof h.getChildContext != "function") {
          {
            var $ = on(v) || "Unknown";
            Ju[$] || (Ju[$] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", $, $));
          }
          return D;
        }
        var Y = h.getChildContext();
        for (var se in Y)
          if (!(se in R))
            throw new Error((on(v) || "Unknown") + '.getChildContext(): key "' + se + '" is not defined in childContextTypes.');
        {
          var Te = on(v) || "Unknown";
          Yu(R, Y, "child context", Te);
        }
        return pr({}, D, Y);
      }
    }
    var Ra;
    Ra = {};
    var Zu = null, $o = null;
    function Ih(h) {
      h.context._currentValue2 = h.parentValue;
    }
    function Ia(h) {
      h.context._currentValue2 = h.value;
    }
    function Qu(h, v) {
      if (h !== v) {
        Ih(h);
        var D = h.parent, R = v.parent;
        if (D === null) {
          if (R !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (R === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          Qu(D, R);
        }
        Ia(v);
      }
    }
    function Ho(h) {
      Ih(h);
      var v = h.parent;
      v !== null && Ho(v);
    }
    function ed(h) {
      var v = h.parent;
      v !== null && ed(v), Ia(h);
    }
    function td(h, v) {
      Ih(h);
      var D = h.parent;
      if (D === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      D.depth === v.depth ? Qu(D, v) : td(D, v);
    }
    function sc(h, v) {
      var D = v.parent;
      if (D === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      h.depth === D.depth ? Qu(h, D) : sc(h, D), Ia(v);
    }
    function lc(h) {
      var v = $o, D = h;
      v !== D && (v === null ? ed(D) : D === null ? Ho(v) : v.depth === D.depth ? Qu(v, D) : v.depth > D.depth ? td(v, D) : sc(v, D), $o = D);
    }
    function fg(h, v) {
      var D;
      D = h._currentValue2, h._currentValue2 = v, h._currentRenderer2 !== void 0 && h._currentRenderer2 !== null && h._currentRenderer2 !== Ra && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), h._currentRenderer2 = Ra;
      var R = $o, $ = {
        parent: R,
        depth: R === null ? 0 : R.depth + 1,
        context: h,
        parentValue: D,
        value: v
      };
      return $o = $, $;
    }
    function hg(h) {
      var v = $o;
      if (v === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      v.context !== h && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var D = v.parentValue;
        D === qu ? v.context._currentValue2 = v.context._defaultValue : v.context._currentValue2 = D, h._currentRenderer2 !== void 0 && h._currentRenderer2 !== null && h._currentRenderer2 !== Ra && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), h._currentRenderer2 = Ra;
      }
      return $o = v.parent;
    }
    function pg() {
      return $o;
    }
    function jo(h) {
      var v = h._currentValue2;
      return v;
    }
    function Oh(h) {
      return h._reactInternals;
    }
    function q0(h, v) {
      h._reactInternals = v;
    }
    var mg = {}, zs = {}, cc, Fh, nd, rd, id, $s, uc, dc, od;
    {
      cc = /* @__PURE__ */ new Set(), Fh = /* @__PURE__ */ new Set(), nd = /* @__PURE__ */ new Set(), uc = /* @__PURE__ */ new Set(), rd = /* @__PURE__ */ new Set(), dc = /* @__PURE__ */ new Set(), od = /* @__PURE__ */ new Set();
      var fc = /* @__PURE__ */ new Set();
      $s = function(h, v) {
        if (!(h === null || typeof h == "function")) {
          var D = v + "_" + h;
          fc.has(D) || (fc.add(D), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", v, h));
        }
      }, id = function(h, v) {
        if (v === void 0) {
          var D = on(h) || "Component";
          rd.has(D) || (rd.add(D), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", D));
        }
      };
    }
    function ad(h, v) {
      {
        var D = h.constructor, R = D && on(D) || "ReactClass", $ = R + "." + v;
        if (mg[$])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, v, v, R), mg[$] = !0;
      }
    }
    var sd = {
      isMounted: function(h) {
        return !1;
      },
      enqueueSetState: function(h, v, D) {
        var R = Oh(h);
        R.queue === null ? ad(h, "setState") : (R.queue.push(v), D != null && $s(D, "setState"));
      },
      enqueueReplaceState: function(h, v, D) {
        var R = Oh(h);
        R.replace = !0, R.queue = [v], D != null && $s(D, "setState");
      },
      enqueueForceUpdate: function(h, v) {
        var D = Oh(h);
        D.queue === null ? ad(h, "forceUpdate") : v != null && $s(v, "setState");
      }
    };
    function Uh(h, v, D, R, $) {
      var Y = D($, R);
      id(v, Y);
      var se = Y == null ? R : pr({}, R, Y);
      return se;
    }
    function gg(h, v, D) {
      var R = oc, $ = h.contextType;
      if ("contextType" in h) {
        var Y = (
          // Allow null for conditional declaration
          $ === null || $ !== void 0 && $.$$typeof === Hu && $._context === void 0
        );
        if (!Y && !od.has(h)) {
          od.add(h);
          var se = "";
          $ === void 0 ? se = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof $ != "object" ? se = " However, it is set to a " + typeof $ + "." : $.$$typeof === $u ? se = " Did you accidentally pass the Context.Provider instead?" : $._context !== void 0 ? se = " Did you accidentally pass the Context.Consumer instead?" : se = " However, it is set to an object with keys {" + Object.keys($).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", on(h) || "Component", se);
        }
      }
      typeof $ == "object" && $ !== null ? R = jo($) : R = D;
      var Te = new h(v, R);
      {
        if (typeof h.getDerivedStateFromProps == "function" && (Te.state === null || Te.state === void 0)) {
          var ke = on(h) || "Component";
          cc.has(ke) || (cc.add(ke), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", ke, Te.state === null ? "null" : "undefined", ke));
        }
        if (typeof h.getDerivedStateFromProps == "function" || typeof Te.getSnapshotBeforeUpdate == "function") {
          var We = null, He = null, Ke = null;
          if (typeof Te.componentWillMount == "function" && Te.componentWillMount.__suppressDeprecationWarning !== !0 ? We = "componentWillMount" : typeof Te.UNSAFE_componentWillMount == "function" && (We = "UNSAFE_componentWillMount"), typeof Te.componentWillReceiveProps == "function" && Te.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? He = "componentWillReceiveProps" : typeof Te.UNSAFE_componentWillReceiveProps == "function" && (He = "UNSAFE_componentWillReceiveProps"), typeof Te.componentWillUpdate == "function" && Te.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Ke = "componentWillUpdate" : typeof Te.UNSAFE_componentWillUpdate == "function" && (Ke = "UNSAFE_componentWillUpdate"), We !== null || He !== null || Ke !== null) {
            var ut = on(h) || "Component", Ut = typeof h.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            nd.has(ut) || (nd.add(ut), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, ut, Ut, We !== null ? `
  ` + We : "", He !== null ? `
  ` + He : "", Ke !== null ? `
  ` + Ke : ""));
          }
        }
      }
      return Te;
    }
    function yg(h, v, D) {
      {
        var R = on(v) || "Component", $ = h.render;
        $ || (v.prototype && typeof v.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", R) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", R)), h.getInitialState && !h.getInitialState.isReactClassApproved && !h.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", R), h.getDefaultProps && !h.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", R), h.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", R), h.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", R), h.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", R), v.contextType && v.contextTypes && !dc.has(v) && (dc.add(v), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", R)), typeof h.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", R), v.prototype && v.prototype.isPureReactComponent && typeof h.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", on(v) || "A pure component"), typeof h.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", R), typeof h.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", R), typeof h.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", R), typeof h.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", R);
        var Y = h.props !== D;
        h.props !== void 0 && Y && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", R, R), h.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", R, R), typeof h.getSnapshotBeforeUpdate == "function" && typeof h.componentDidUpdate != "function" && !Fh.has(v) && (Fh.add(v), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", on(v))), typeof h.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", R), typeof h.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", R), typeof v.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", R);
        var se = h.state;
        se && (typeof se != "object" || qr(se)) && i("%s.state: must be set to an object or null", R), typeof h.getChildContext == "function" && typeof v.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", R);
      }
    }
    function bg(h, v) {
      var D = v.state;
      if (typeof v.componentWillMount == "function") {
        if (v.componentWillMount.__suppressDeprecationWarning !== !0) {
          var R = on(h) || "Unknown";
          zs[R] || (r(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            R
          ), zs[R] = !0);
        }
        v.componentWillMount();
      }
      typeof v.UNSAFE_componentWillMount == "function" && v.UNSAFE_componentWillMount(), D !== v.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", on(h) || "Component"), sd.enqueueReplaceState(v, v.state, null));
    }
    function G0(h, v, D, R) {
      if (h.queue !== null && h.queue.length > 0) {
        var $ = h.queue, Y = h.replace;
        if (h.queue = null, h.replace = !1, Y && $.length === 1)
          v.state = $[0];
        else {
          for (var se = Y ? $[0] : v.state, Te = !0, ke = Y ? 1 : 0; ke < $.length; ke++) {
            var We = $[ke], He = typeof We == "function" ? We.call(v, se, D, R) : We;
            He != null && (Te ? (Te = !1, se = pr({}, se, He)) : pr(se, He));
          }
          v.state = se;
        }
      } else
        h.queue = null;
    }
    function vg(h, v, D, R) {
      yg(h, v, D);
      var $ = h.state !== void 0 ? h.state : null;
      h.updater = sd, h.props = D, h.state = $;
      var Y = {
        queue: [],
        replace: !1
      };
      q0(h, Y);
      var se = v.contextType;
      if (typeof se == "object" && se !== null ? h.context = jo(se) : h.context = R, h.state === D) {
        var Te = on(v) || "Component";
        uc.has(Te) || (uc.add(Te), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Te));
      }
      var ke = v.getDerivedStateFromProps;
      typeof ke == "function" && (h.state = Uh(h, v, ke, $, D)), typeof v.getDerivedStateFromProps != "function" && typeof h.getSnapshotBeforeUpdate != "function" && (typeof h.UNSAFE_componentWillMount == "function" || typeof h.componentWillMount == "function") && (bg(v, h), G0(Y, h, D, R));
    }
    var K0 = {
      id: 1,
      overflow: ""
    };
    function X0(h) {
      var v = h.overflow, D = h.id, R = D & ~Y0(D);
      return R.toString(32) + v;
    }
    function Nh(h, v, D) {
      var R = h.id, $ = h.overflow, Y = hc(R) - 1, se = R & ~(1 << Y), Te = D + 1, ke = hc(v) + Y;
      if (ke > 30) {
        var We = Y - Y % 5, He = (1 << We) - 1, Ke = (se & He).toString(32), ut = se >> We, Ut = Y - We, Nn = hc(v) + Ut, La = Te << Ut, Pa = La | ut, yo = Ke + $;
        return {
          id: 1 << Nn | Pa,
          overflow: yo
        };
      } else {
        var Xs = Te << Y, kw = Xs | se, i7 = $;
        return {
          id: 1 << ke | kw,
          overflow: i7
        };
      }
    }
    function hc(h) {
      return 32 - J0(h);
    }
    function Y0(h) {
      return 1 << hc(h) - 1;
    }
    var J0 = Math.clz32 ? Math.clz32 : Z0, Mh = Math.log, ld = Math.LN2;
    function Z0(h) {
      var v = h >>> 0;
      return v === 0 ? 32 : 31 - (Mh(v) / ld | 0) | 0;
    }
    function Q0(h, v) {
      return h === v && (h !== 0 || 1 / h === 1 / v) || h !== h && v !== v;
    }
    var ew = typeof Object.is == "function" ? Object.is : Q0, ho = null, Bh = null, cd = null, Gt = null, Nr = !1, Hs = !1, Oa = 0, It = null, Vo = 0, ud = 25, Mr = !1, Br;
    function $i() {
      if (ho === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return Mr && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), ho;
    }
    function tw(h, v) {
      if (v === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Br), !1;
      h.length !== v.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Br, "[" + h.join(", ") + "]", "[" + v.join(", ") + "]");
      for (var D = 0; D < v.length && D < h.length; D++)
        if (!ew(h[D], v[D]))
          return !1;
      return !0;
    }
    function vi() {
      if (Vo > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function qo() {
      return Gt === null ? cd === null ? (Nr = !1, cd = Gt = vi()) : (Nr = !0, Gt = cd) : Gt.next === null ? (Nr = !1, Gt = Gt.next = vi()) : (Nr = !0, Gt = Gt.next), Gt;
    }
    function Fa(h, v) {
      ho = v, Bh = h, Mr = !1, Oa = 0;
    }
    function nw(h, v, D, R) {
      for (; Hs; )
        Hs = !1, Oa = 0, Vo += 1, Gt = null, D = h(v, R);
      return pc(), D;
    }
    function Lh() {
      var h = Oa !== 0;
      return h;
    }
    function pc() {
      Mr = !1, ho = null, Bh = null, Hs = !1, cd = null, Vo = 0, It = null, Gt = null;
    }
    function rw(h) {
      return Mr && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), jo(h);
    }
    function iw(h) {
      return Br = "useContext", $i(), jo(h);
    }
    function dd(h, v) {
      return typeof v == "function" ? v(h) : v;
    }
    function Ph(h) {
      return Br = "useState", wg(
        dd,
        // useReducer has a special case to support lazy useState initializers
        h
      );
    }
    function wg(h, v, D) {
      if (h !== dd && (Br = "useReducer"), ho = $i(), Gt = qo(), Nr) {
        var R = Gt.queue, $ = R.dispatch;
        if (It !== null) {
          var Y = It.get(R);
          if (Y !== void 0) {
            It.delete(R);
            var se = Gt.memoizedState, Te = Y;
            do {
              var ke = Te.action;
              Mr = !0, se = h(se, ke), Mr = !1, Te = Te.next;
            } while (Te !== null);
            return Gt.memoizedState = se, [se, $];
          }
        }
        return [Gt.memoizedState, $];
      } else {
        Mr = !0;
        var We;
        h === dd ? We = typeof v == "function" ? v() : v : We = D !== void 0 ? D(v) : v, Mr = !1, Gt.memoizedState = We;
        var He = Gt.queue = {
          last: null,
          dispatch: null
        }, Ke = He.dispatch = _g.bind(null, ho, He);
        return [Gt.memoizedState, Ke];
      }
    }
    function xg(h, v) {
      ho = $i(), Gt = qo();
      var D = v === void 0 ? null : v;
      if (Gt !== null) {
        var R = Gt.memoizedState;
        if (R !== null && D !== null) {
          var $ = R[1];
          if (tw(D, $))
            return R[0];
        }
      }
      Mr = !0;
      var Y = h();
      return Mr = !1, Gt.memoizedState = [Y, D], Y;
    }
    function Wh(h) {
      ho = $i(), Gt = qo();
      var v = Gt.memoizedState;
      if (v === null) {
        var D = {
          current: h
        };
        return Object.seal(D), Gt.memoizedState = D, D;
      } else
        return v;
    }
    function ow(h, v) {
      Br = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function _g(h, v, D) {
      if (Vo >= ud)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (h === ho) {
        Hs = !0;
        var R = {
          action: D,
          next: null
        };
        It === null && (It = /* @__PURE__ */ new Map());
        var $ = It.get(v);
        if ($ === void 0)
          It.set(v, R);
        else {
          for (var Y = $; Y.next !== null; )
            Y = Y.next;
          Y.next = R;
        }
      }
    }
    function Sg(h, v) {
      return xg(function() {
        return h;
      }, v);
    }
    function aw(h, v, D) {
      return $i(), v(h._source);
    }
    function sw(h, v, D) {
      if (D === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return D();
    }
    function lw(h) {
      return $i(), h;
    }
    function cw() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function uw() {
      return $i(), [!1, cw];
    }
    function dw() {
      var h = Bh, v = X0(h.treeContext), D = zh;
      if (D === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var R = Oa++;
      return gn(D, v, R);
    }
    function fd() {
    }
    var Tg = {
      readContext: rw,
      useContext: iw,
      useMemo: xg,
      useReducer: wg,
      useRef: Wh,
      useState: Ph,
      useInsertionEffect: fd,
      useLayoutEffect: ow,
      useCallback: Sg,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: fd,
      // Effects are not run in the server environment.
      useEffect: fd,
      // Debugging effect
      useDebugValue: fd,
      useDeferredValue: lw,
      useTransition: uw,
      useId: dw,
      // Subscriptions are not setup in a server environment.
      useMutableSource: aw,
      useSyncExternalStore: sw
    }, zh = null;
    function Dg(h) {
      zh = h;
    }
    function hd(h) {
      try {
        var v = "", D = h;
        do {
          switch (D.tag) {
            case 0:
              v += nc(D.type, null, null);
              break;
            case 1:
              v += rc(D.type, null, null);
              break;
            case 2:
              v += Ah(D.type, null, null);
              break;
          }
          D = D.parent;
        } while (D);
        return v;
      } catch (R) {
        return `
Error generating stack: ` + R.message + `
` + R.stack;
      }
    }
    var pd = n.ReactCurrentDispatcher, mc = n.ReactDebugCurrentFrame, md = 0, js = 1, gd = 2, yd = 3, bd = 4, Vs = 0, $h = 1, Ua = 2, Eg = 12800;
    function fw(h) {
      return console.error(h), null;
    }
    function qs() {
    }
    function Gs(h, v, D, R, $, Y, se, Te, ke) {
      var We = [], He = /* @__PURE__ */ new Set(), Ke = {
        destination: null,
        responseState: v,
        progressiveChunkSize: R === void 0 ? Eg : R,
        status: Vs,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: He,
        pingedTasks: We,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: $ === void 0 ? fw : $,
        onAllReady: qs,
        onShellReady: se === void 0 ? qs : se,
        onShellError: qs,
        onFatalError: qs
      }, ut = vd(
        Ke,
        0,
        null,
        D,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      ut.parentFlushed = !0;
      var Ut = Na(Ke, h, null, ut, He, oc, Zu, K0);
      return We.push(Ut), Ke;
    }
    function hw(h, v) {
      var D = h.pingedTasks;
      D.push(v), D.length === 1 && a(function() {
        return Zh(h);
      });
    }
    function pw(h, v) {
      return {
        id: Ts,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: v,
        errorDigest: null
      };
    }
    function Na(h, v, D, R, $, Y, se, Te) {
      h.allPendingTasks++, D === null ? h.pendingRootTasks++ : D.pendingTasks++;
      var ke = {
        node: v,
        ping: function() {
          return hw(h, ke);
        },
        blockedBoundary: D,
        blockedSegment: R,
        abortSet: $,
        legacyContext: Y,
        context: se,
        treeContext: Te
      };
      return ke.componentStack = null, $.add(ke), ke;
    }
    function vd(h, v, D, R, $, Y) {
      return {
        status: md,
        id: -1,
        // lazily assigned later
        index: v,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: R,
        boundary: D,
        lastPushedText: $,
        textEmbedded: Y
      };
    }
    var po = null;
    function Hh() {
      return po === null || po.componentStack === null ? "" : hd(po.componentStack);
    }
    function Ma(h, v) {
      h.componentStack = {
        tag: 0,
        parent: h.componentStack,
        type: v
      };
    }
    function gc(h, v) {
      h.componentStack = {
        tag: 1,
        parent: h.componentStack,
        type: v
      };
    }
    function mo(h, v) {
      h.componentStack = {
        tag: 2,
        parent: h.componentStack,
        type: v
      };
    }
    function Hi(h) {
      h.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : h.componentStack = h.componentStack.parent;
    }
    var go = null;
    function wd(h, v) {
      {
        var D;
        typeof v == "string" ? D = v : v && typeof v.message == "string" ? D = v.message : D = String(v);
        var R = go || Hh();
        go = null, h.errorMessage = D, h.errorComponentStack = R;
      }
    }
    function yc(h, v) {
      var D = h.onError(v);
      if (D != null && typeof D != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof D + '" instead');
      return D;
    }
    function wi(h, v) {
      var D = h.onShellError;
      D(v);
      var R = h.onFatalError;
      R(v), h.destination !== null ? (h.status = Ua, m(h.destination, v)) : (h.status = $h, h.fatalError = v);
    }
    function bc(h, v, D) {
      Ma(v, "Suspense");
      var R = v.blockedBoundary, $ = v.blockedSegment, Y = D.fallback, se = D.children, Te = /* @__PURE__ */ new Set(), ke = pw(h, Te), We = $.chunks.length, He = vd(
        h,
        We,
        ke,
        $.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      $.children.push(He), $.lastPushedText = !1;
      var Ke = vd(
        h,
        0,
        null,
        $.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      Ke.parentFlushed = !0, v.blockedBoundary = ke, v.blockedSegment = Ke;
      try {
        if (ir(h, v, se), rg(Ke.chunks, h.responseState, Ke.lastPushedText, Ke.textEmbedded), Ke.status = js, Ks(ke, Ke), ke.pendingTasks === 0) {
          Hi(v);
          return;
        }
      } catch (Ut) {
        Ke.status = bd, ke.forceClientRender = !0, ke.errorDigest = yc(h, Ut), wd(ke, Ut);
      } finally {
        v.blockedBoundary = R, v.blockedSegment = $;
      }
      var ut = Na(h, Y, R, He, Te, v.legacyContext, v.context, v.treeContext);
      ut.componentStack = v.componentStack, h.pingedTasks.push(ut), Hi(v);
    }
    function jh(h, v, D, R) {
      Ma(v, D);
      var $ = v.blockedSegment, Y = bi($.chunks, D, R, h.responseState, $.formatContext);
      $.lastPushedText = !1;
      var se = $.formatContext;
      $.formatContext = Ss(se, D, R), ir(h, v, Y), $.formatContext = se, zt($.chunks, D), $.lastPushedText = !1, Hi(v);
    }
    function vc(h) {
      return h.prototype && h.prototype.isReactComponent;
    }
    function wc(h, v, D, R, $) {
      var Y = {};
      Fa(v, Y);
      var se = D(R, $);
      return nw(D, R, se, $);
    }
    function Cg(h, v, D, R, $) {
      var Y = D.render();
      D.props !== $ && (qh || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", on(R) || "a component"), qh = !0);
      {
        var se = R.childContextTypes;
        if (se != null) {
          var Te = v.legacyContext, ke = dg(D, R, Te, se);
          v.legacyContext = ke, Lr(h, v, Y), v.legacyContext = Te;
          return;
        }
      }
      Lr(h, v, Y);
    }
    function mw(h, v, D, R) {
      mo(v, D);
      var $ = ac(D, v.legacyContext), Y = gg(D, R, $);
      vg(Y, D, R, $), Cg(h, v, Y, D, R), Hi(v);
    }
    var kg = {}, xc = {}, Vh = {}, Ag = {}, qh = !1, _c = {}, Gh = !1, Kh = !1, Xh = !1;
    function Rg(h, v, D, R) {
      var $;
      if ($ = ac(D, v.legacyContext), gc(v, D), D.prototype && typeof D.prototype.render == "function") {
        var Y = on(D) || "Unknown";
        kg[Y] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", Y, Y), kg[Y] = !0);
      }
      var se = wc(h, v, D, R, $), Te = Lh();
      if (typeof se == "object" && se !== null && typeof se.render == "function" && se.$$typeof === void 0) {
        var ke = on(D) || "Unknown";
        xc[ke] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ke, ke, ke), xc[ke] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof se == "object" && se !== null && typeof se.render == "function" && se.$$typeof === void 0
      ) {
        {
          var We = on(D) || "Unknown";
          xc[We] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", We, We, We), xc[We] = !0);
        }
        vg(se, D, R, $), Cg(h, v, se, D, R);
      } else if (Ig(D), Te) {
        var He = v.treeContext, Ke = 1, ut = 0;
        v.treeContext = Nh(He, Ke, ut);
        try {
          Lr(h, v, se);
        } finally {
          v.treeContext = He;
        }
      } else
        Lr(h, v, se);
      Hi(v);
    }
    function Ig(h) {
      {
        if (h && h.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", h.displayName || h.name || "Component"), h.defaultProps !== void 0) {
          var v = on(h) || "Unknown";
          _c[v] || (i("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", v), _c[v] = !0);
        }
        if (typeof h.getDerivedStateFromProps == "function") {
          var D = on(h) || "Unknown";
          Ag[D] || (i("%s: Function components do not support getDerivedStateFromProps.", D), Ag[D] = !0);
        }
        if (typeof h.contextType == "object" && h.contextType !== null) {
          var R = on(h) || "Unknown";
          Vh[R] || (i("%s: Function components do not support contextType.", R), Vh[R] = !0);
        }
      }
    }
    function Yh(h, v) {
      if (h && h.defaultProps) {
        var D = pr({}, v), R = h.defaultProps;
        for (var $ in R)
          D[$] === void 0 && (D[$] = R[$]);
        return D;
      }
      return v;
    }
    function Og(h, v, D, R, $) {
      gc(v, D.render);
      var Y = wc(h, v, D.render, R, $), se = Lh();
      if (se) {
        var Te = v.treeContext, ke = 1, We = 0;
        v.treeContext = Nh(Te, ke, We);
        try {
          Lr(h, v, Y);
        } finally {
          v.treeContext = Te;
        }
      } else
        Lr(h, v, Y);
      Hi(v);
    }
    function gw(h, v, D, R, $) {
      var Y = D.type, se = Yh(Y, R);
      Jh(h, v, Y, se, $);
    }
    function yw(h, v, D, R) {
      D._context === void 0 ? D !== D.Consumer && (Xh || (Xh = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : D = D._context;
      var $ = R.children;
      typeof $ != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var Y = jo(D), se = $(Y);
      Lr(h, v, se);
    }
    function Fg(h, v, D, R) {
      var $ = D._context, Y = R.value, se = R.children, Te;
      Te = v.context, v.context = fg($, Y), Lr(h, v, se), v.context = hg($), Te !== v.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function bw(h, v, D, R, $) {
      Ma(v, "Lazy");
      var Y = D._payload, se = D._init, Te = se(Y), ke = Yh(Te, R);
      Jh(h, v, Te, ke, $), Hi(v);
    }
    function Jh(h, v, D, R, $) {
      if (typeof D == "function")
        if (vc(D)) {
          mw(h, v, D, R);
          return;
        } else {
          Rg(h, v, D, R);
          return;
        }
      if (typeof D == "string") {
        jh(h, v, D, R);
        return;
      }
      switch (D) {
        case wh:
        case vh:
        case Ur:
        case og:
        case zu: {
          Lr(h, v, R.children);
          return;
        }
        case Ql: {
          Ma(v, "SuspenseList"), Lr(h, v, R.children), Hi(v);
          return;
        }
        case bh:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case Vu: {
          bc(h, v, R);
          return;
        }
      }
      if (typeof D == "object" && D !== null)
        switch (D.$$typeof) {
          case ju: {
            Og(h, v, D, R, $);
            return;
          }
          case ec: {
            gw(h, v, D, R, $);
            return;
          }
          case $u: {
            Fg(h, v, D, R);
            return;
          }
          case Hu: {
            yw(h, v, D, R);
            return;
          }
          case Ls: {
            bw(h, v, D, R);
            return;
          }
        }
      var Y = "";
      throw (D === void 0 || typeof D == "object" && D !== null && Object.keys(D).length === 0) && (Y += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (D == null ? D : typeof D) + "." + Y));
    }
    function vw(h, v) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      h[Symbol.toStringTag] === "Generator" && (Gh || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Gh = !0), h.entries === v && (Kh || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Kh = !0);
    }
    function Lr(h, v, D) {
      try {
        return ww(h, v, D);
      } catch (R) {
        throw typeof R == "object" && R !== null && typeof R.then == "function" || (go = go !== null ? go : Hh()), R;
      }
    }
    function ww(h, v, D) {
      if (v.node = D, typeof D == "object" && D !== null) {
        switch (D.$$typeof) {
          case z0: {
            var R = D, $ = R.type, Y = R.props, se = R.ref;
            Jh(h, v, $, Y, se);
            return;
          }
          case ig:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Ls: {
            var Te = D, ke = Te._payload, We = Te._init, He;
            try {
              He = We(ke);
            } catch (Xs) {
              throw typeof Xs == "object" && Xs !== null && typeof Xs.then == "function" && Ma(v, "Lazy"), Xs;
            }
            Lr(h, v, He);
            return;
          }
        }
        if (qr(D)) {
          xd(h, v, D);
          return;
        }
        var Ke = H0(D);
        if (Ke) {
          vw(D, Ke);
          var ut = Ke.call(D);
          if (ut) {
            var Ut = ut.next();
            if (!Ut.done) {
              var Nn = [];
              do
                Nn.push(Ut.value), Ut = ut.next();
              while (!Ut.done);
              xd(h, v, Nn);
              return;
            }
            return;
          }
        }
        var La = Object.prototype.toString.call(D);
        throw new Error("Objects are not valid as a React child (found: " + (La === "[object Object]" ? "object with keys {" + Object.keys(D).join(", ") + "}" : La) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof D == "string") {
        var Pa = v.blockedSegment;
        Pa.lastPushedText = ng(v.blockedSegment.chunks, D, h.responseState, Pa.lastPushedText);
        return;
      }
      if (typeof D == "number") {
        var yo = v.blockedSegment;
        yo.lastPushedText = ng(v.blockedSegment.chunks, "" + D, h.responseState, yo.lastPushedText);
        return;
      }
      typeof D == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function xd(h, v, D) {
      for (var R = D.length, $ = 0; $ < R; $++) {
        var Y = v.treeContext;
        v.treeContext = Nh(Y, R, $);
        try {
          ir(h, v, D[$]);
        } finally {
          v.treeContext = Y;
        }
      }
    }
    function xw(h, v, D) {
      var R = v.blockedSegment, $ = R.chunks.length, Y = vd(
        h,
        $,
        null,
        R.formatContext,
        // Adopt the parent segment's leading text embed
        R.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      R.children.push(Y), R.lastPushedText = !1;
      var se = Na(h, v.node, v.blockedBoundary, Y, v.abortSet, v.legacyContext, v.context, v.treeContext);
      v.componentStack !== null && (se.componentStack = v.componentStack.parent);
      var Te = se.ping;
      D.then(Te, Te);
    }
    function ir(h, v, D) {
      var R = v.blockedSegment.formatContext, $ = v.legacyContext, Y = v.context, se = null;
      se = v.componentStack;
      try {
        return Lr(h, v, D);
      } catch (Te) {
        if (pc(), typeof Te == "object" && Te !== null && typeof Te.then == "function") {
          xw(h, v, Te), v.blockedSegment.formatContext = R, v.legacyContext = $, v.context = Y, lc(Y), v.componentStack = se;
          return;
        } else
          throw v.blockedSegment.formatContext = R, v.legacyContext = $, v.context = Y, lc(Y), v.componentStack = se, Te;
      }
    }
    function _w(h, v, D, R) {
      var $ = yc(h, R);
      if (v === null ? wi(h, R) : (v.pendingTasks--, v.forceClientRender || (v.forceClientRender = !0, v.errorDigest = $, wd(v, R), v.parentFlushed && h.clientRenderedBoundaries.push(v))), h.allPendingTasks--, h.allPendingTasks === 0) {
        var Y = h.onAllReady;
        Y();
      }
    }
    function Ug(h) {
      var v = this, D = h.blockedBoundary, R = h.blockedSegment;
      R.status = yd, Mg(v, D, R);
    }
    function Ng(h, v, D) {
      var R = h.blockedBoundary, $ = h.blockedSegment;
      if ($.status = yd, R === null)
        v.allPendingTasks--, v.status !== Ua && (v.status = Ua, v.destination !== null && d(v.destination));
      else {
        if (R.pendingTasks--, !R.forceClientRender) {
          R.forceClientRender = !0;
          var Y = D === void 0 ? new Error("The render was aborted by the server without a reason.") : D;
          R.errorDigest = v.onError(Y);
          {
            var se = "The server did not finish this Suspense boundary: ";
            Y && typeof Y.message == "string" ? Y = se + Y.message : Y = se + String(Y);
            var Te = po;
            po = h;
            try {
              wd(R, Y);
            } finally {
              po = Te;
            }
          }
          R.parentFlushed && v.clientRenderedBoundaries.push(R);
        }
        if (R.fallbackAbortableTasks.forEach(function(We) {
          return Ng(We, v, D);
        }), R.fallbackAbortableTasks.clear(), v.allPendingTasks--, v.allPendingTasks === 0) {
          var ke = v.onAllReady;
          ke();
        }
      }
    }
    function Ks(h, v) {
      if (v.chunks.length === 0 && v.children.length === 1 && v.children[0].boundary === null) {
        var D = v.children[0];
        D.id = v.id, D.parentFlushed = !0, D.status === js && Ks(h, D);
      } else {
        var R = h.completedSegments;
        R.push(v);
      }
    }
    function Mg(h, v, D) {
      if (v === null) {
        if (D.parentFlushed) {
          if (h.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          h.completedRootSegment = D;
        }
        if (h.pendingRootTasks--, h.pendingRootTasks === 0) {
          h.onShellError = qs;
          var R = h.onShellReady;
          R();
        }
      } else if (v.pendingTasks--, !v.forceClientRender) {
        if (v.pendingTasks === 0)
          D.parentFlushed && D.status === js && Ks(v, D), v.parentFlushed && h.completedBoundaries.push(v), v.fallbackAbortableTasks.forEach(Ug, h), v.fallbackAbortableTasks.clear();
        else if (D.parentFlushed && D.status === js) {
          Ks(v, D);
          var $ = v.completedSegments;
          $.length === 1 && v.parentFlushed && h.partialBoundaries.push(v);
        }
      }
      if (h.allPendingTasks--, h.allPendingTasks === 0) {
        var Y = h.onAllReady;
        Y();
      }
    }
    function Sw(h, v) {
      var D = v.blockedSegment;
      if (D.status === md) {
        lc(v.context);
        var R = null;
        R = po, po = v;
        try {
          Lr(h, v, v.node), rg(D.chunks, h.responseState, D.lastPushedText, D.textEmbedded), v.abortSet.delete(v), D.status = js, Mg(h, v.blockedBoundary, D);
        } catch (Y) {
          if (pc(), typeof Y == "object" && Y !== null && typeof Y.then == "function") {
            var $ = v.ping;
            Y.then($, $);
          } else
            v.abortSet.delete(v), D.status = bd, _w(h, v.blockedBoundary, D, Y);
        } finally {
          po = R;
        }
      }
    }
    function Zh(h) {
      if (h.status !== Ua) {
        var v = pg(), D = pd.current;
        pd.current = Tg;
        var R;
        R = mc.getCurrentStack, mc.getCurrentStack = Hh;
        var $ = zh;
        Dg(h.responseState);
        try {
          var Y = h.pingedTasks, se;
          for (se = 0; se < Y.length; se++) {
            var Te = Y[se];
            Sw(h, Te);
          }
          Y.splice(0, se), h.destination !== null && Sd(h, h.destination);
        } catch (ke) {
          yc(h, ke), wi(h, ke);
        } finally {
          Dg($), pd.current = D, mc.getCurrentStack = R, D === Tg && lc(v);
        }
      }
    }
    function Ba(h, v, D) {
      switch (D.parentFlushed = !0, D.status) {
        case md: {
          var R = D.id = h.nextSegmentId++;
          return D.lastPushedText = !1, D.textEmbedded = !1, Wi(v, h.responseState, R);
        }
        case js: {
          D.status = gd;
          for (var $ = !0, Y = D.chunks, se = 0, Te = D.children, ke = 0; ke < Te.length; ke++) {
            for (var We = Te[ke]; se < We.index; se++)
              l(v, Y[se]);
            $ = Sc(h, v, We);
          }
          for (; se < Y.length - 1; se++)
            l(v, Y[se]);
          return se < Y.length && ($ = c(v, Y[se])), $;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Sc(h, v, D) {
      var R = D.boundary;
      if (R === null)
        return Ba(h, v, D);
      if (R.parentFlushed = !0, R.forceClientRender)
        return L0(v, h.responseState, R.errorDigest, R.errorMessage, R.errorComponentStack), Ba(h, v, D), W0(v, h.responseState);
      if (R.pendingTasks > 0) {
        R.rootSegmentID = h.nextSegmentId++, R.completedSegments.length > 0 && h.partialBoundaries.push(R);
        var $ = R.id = gi(h.responseState);
        return Ea(v, h.responseState, $), Ba(h, v, D), Wo(v, h.responseState);
      } else {
        if (R.byteSize > h.progressiveChunkSize)
          return R.rootSegmentID = h.nextSegmentId++, h.completedBoundaries.push(R), Ea(v, h.responseState, R.id), Ba(h, v, D), Wo(v, h.responseState);
        B0(v, h.responseState);
        var Y = R.completedSegments;
        if (Y.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var se = Y[0];
        return Sc(h, v, se), P0(v, h.responseState);
      }
    }
    function Tw(h, v, D) {
      return F0(v, h.responseState, D.id, D.errorDigest, D.errorMessage, D.errorComponentStack);
    }
    function Qh(h, v, D) {
      return Zl(v, h.responseState, D.formatContext, D.id), Sc(h, v, D), Pu(v, D.formatContext);
    }
    function Tc(h, v, D) {
      for (var R = D.completedSegments, $ = 0; $ < R.length; $++) {
        var Y = R[$];
        Bg(h, v, D, Y);
      }
      return R.length = 0, rr(v, h.responseState, D.id, D.rootSegmentID);
    }
    function _d(h, v, D) {
      for (var R = D.completedSegments, $ = 0; $ < R.length; $++) {
        var Y = R[$];
        if (!Bg(h, v, D, Y))
          return $++, R.splice(0, $), !1;
      }
      return R.splice(0, $), !0;
    }
    function Bg(h, v, D, R) {
      if (R.status === gd)
        return !0;
      var $ = R.id;
      if ($ === -1) {
        var Y = R.id = D.rootSegmentID;
        if (Y === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Qh(h, v, R);
      } else
        return Qh(h, v, R), qe(v, h.responseState, $);
    }
    function Sd(h, v) {
      try {
        var D = h.completedRootSegment;
        D !== null && h.pendingRootTasks === 0 && (Sc(h, v, D), h.completedRootSegment = null, uo(v, h.responseState));
        var R = h.clientRenderedBoundaries, $;
        for ($ = 0; $ < R.length; $++) {
          var Y = R[$];
          if (!Tw(h, v, Y)) {
            h.destination = null, $++, R.splice(0, $);
            return;
          }
        }
        R.splice(0, $);
        var se = h.completedBoundaries;
        for ($ = 0; $ < se.length; $++) {
          var Te = se[$];
          if (!Tc(h, v, Te)) {
            h.destination = null, $++, se.splice(0, $);
            return;
          }
        }
        se.splice(0, $);
        var ke = h.partialBoundaries;
        for ($ = 0; $ < ke.length; $++) {
          var We = ke[$];
          if (!_d(h, v, We)) {
            h.destination = null, $++, ke.splice(0, $);
            return;
          }
        }
        ke.splice(0, $);
        var He = h.completedBoundaries;
        for ($ = 0; $ < He.length; $++) {
          var Ke = He[$];
          if (!Tc(h, v, Ke)) {
            h.destination = null, $++, He.splice(0, $);
            return;
          }
        }
        He.splice(0, $);
      } finally {
        h.allPendingTasks === 0 && h.pingedTasks.length === 0 && h.clientRenderedBoundaries.length === 0 && h.completedBoundaries.length === 0 && (h.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), d(v));
      }
    }
    function Lg(h) {
      a(function() {
        return Zh(h);
      });
    }
    function Dw(h, v) {
      if (h.status === $h) {
        h.status = Ua, m(v, h.fatalError);
        return;
      }
      if (h.status !== Ua && h.destination === null) {
        h.destination = v;
        try {
          Sd(h, v);
        } catch (D) {
          yc(h, D), wi(h, D);
        }
      }
    }
    function Pg(h, v) {
      try {
        var D = h.abortableTasks;
        D.forEach(function(R) {
          return Ng(R, h, v);
        }), D.clear(), h.destination !== null && Sd(h, h.destination);
      } catch (R) {
        yc(h, R), wi(h, R);
      }
    }
    function ep() {
    }
    function Wg(h, v, D, R) {
      var $ = !1, Y = null, se = "", Te = {
        push: function(Ke) {
          return Ke !== null && (se += Ke), !0;
        },
        destroy: function(Ke) {
          $ = !0, Y = Ke;
        }
      }, ke = !1;
      function We() {
        ke = !0;
      }
      var He = Gs(h, N0(D, v ? v.identifierPrefix : void 0), M0(), 1 / 0, ep, void 0, We);
      if (Lg(He), Pg(He, R), Dw(He, Te), $)
        throw Y;
      if (!ke)
        throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return se;
    }
    function Ew(h, v) {
      return Wg(h, v, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function zg(h, v) {
      return Wg(h, v, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function Cw() {
      throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
    }
    function E() {
      throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
    }
    Rc.renderToNodeStream = Cw, Rc.renderToStaticMarkup = zg, Rc.renderToStaticNodeStream = E, Rc.renderToString = Ew, Rc.version = e;
  }()), Rc;
}
var My = {};
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nF;
function Gxe() {
  return nF || (nF = 1, process.env.NODE_ENV !== "production" && function() {
    var t = Lt, e = "18.3.1", n = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(E) {
      {
        for (var h = arguments.length, v = new Array(h > 1 ? h - 1 : 0), D = 1; D < h; D++)
          v[D - 1] = arguments[D];
        o("warn", E, v);
      }
    }
    function i(E) {
      {
        for (var h = arguments.length, v = new Array(h > 1 ? h - 1 : 0), D = 1; D < h; D++)
          v[D - 1] = arguments[D];
        o("error", E, v);
      }
    }
    function o(E, h, v) {
      {
        var D = n.ReactDebugCurrentFrame, R = D.getStackAddendum();
        R !== "" && (h += "%s", v = v.concat([R]));
        var $ = v.map(function(Y) {
          return String(Y);
        });
        $.unshift("Warning: " + h), Function.prototype.apply.call(console[E], console, $);
      }
    }
    function a(E) {
      E();
    }
    var s = 512, l = null, c = 0;
    function u(E) {
      l = new Uint8Array(s), c = 0;
    }
    function d(E, h) {
      if (h.length !== 0) {
        if (h.length > s) {
          c > 0 && (E.enqueue(new Uint8Array(l.buffer, 0, c)), l = new Uint8Array(s), c = 0), E.enqueue(h);
          return;
        }
        var v = h, D = l.length - c;
        D < v.length && (D === 0 ? E.enqueue(l) : (l.set(v.subarray(0, D), c), E.enqueue(l), v = v.subarray(D)), l = new Uint8Array(s), c = 0), l.set(v, c), c += v.length;
      }
    }
    function f(E, h) {
      return d(E, h), !0;
    }
    function p(E) {
      l && c > 0 && (E.enqueue(new Uint8Array(l.buffer, 0, c)), l = null, c = 0);
    }
    function m(E) {
      E.close();
    }
    var g = new TextEncoder();
    function b(E) {
      return g.encode(E);
    }
    function y(E) {
      return g.encode(E);
    }
    function w(E, h) {
      typeof E.error == "function" ? E.error(h) : E.close();
    }
    function x(E) {
      {
        var h = typeof Symbol == "function" && Symbol.toStringTag, v = h && E[Symbol.toStringTag] || E.constructor.name || "Object";
        return v;
      }
    }
    function k(E) {
      try {
        return A(E), !1;
      } catch {
        return !0;
      }
    }
    function A(E) {
      return "" + E;
    }
    function U(E, h) {
      if (k(E))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", h, x(E)), A(E);
    }
    function P(E, h) {
      if (k(E))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", h, x(E)), A(E);
    }
    function V(E) {
      if (k(E))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", x(E)), A(E);
    }
    var I = Object.prototype.hasOwnProperty, le = 0, be = 1, F = 2, G = 3, C = 4, ie = 5, ee = 6, Z = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", oe = Z + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", te = new RegExp("^[" + Z + "][" + oe + "]*$"), _e = {}, q = {};
    function N(E) {
      return I.call(q, E) ? !0 : I.call(_e, E) ? !1 : te.test(E) ? (q[E] = !0, !0) : (_e[E] = !0, i("Invalid attribute name: `%s`", E), !1);
    }
    function ce(E, h, v, D) {
      if (v !== null && v.type === le)
        return !1;
      switch (typeof h) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (v !== null)
            return !v.acceptsBooleans;
          var R = E.toLowerCase().slice(0, 5);
          return R !== "data-" && R !== "aria-";
        }
        default:
          return !1;
      }
    }
    function me(E) {
      return he.hasOwnProperty(E) ? he[E] : null;
    }
    function ve(E, h, v, D, R, $, Y) {
      this.acceptsBooleans = h === F || h === G || h === C, this.attributeName = D, this.attributeNamespace = R, this.mustUseProperty = v, this.propertyName = E, this.type = h, this.sanitizeURL = $, this.removeEmptyString = Y;
    }
    var he = {}, H = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    H.forEach(function(E) {
      he[E] = new ve(
        E,
        le,
        !1,
        // mustUseProperty
        E,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(E) {
      var h = E[0], v = E[1];
      he[h] = new ve(
        h,
        be,
        !1,
        // mustUseProperty
        v,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(E) {
      he[E] = new ve(
        E,
        F,
        !1,
        // mustUseProperty
        E.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(E) {
      he[E] = new ve(
        E,
        F,
        !1,
        // mustUseProperty
        E,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(E) {
      he[E] = new ve(
        E,
        G,
        !1,
        // mustUseProperty
        E.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(E) {
      he[E] = new ve(
        E,
        G,
        !0,
        // mustUseProperty
        E,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(E) {
      he[E] = new ve(
        E,
        C,
        !1,
        // mustUseProperty
        E,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(E) {
      he[E] = new ve(
        E,
        ee,
        !1,
        // mustUseProperty
        E,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(E) {
      he[E] = new ve(
        E,
        ie,
        !1,
        // mustUseProperty
        E.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var W = /[\-\:]([a-z])/g, we = function(E) {
      return E[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(E) {
      var h = E.replace(W, we);
      he[h] = new ve(
        h,
        be,
        !1,
        // mustUseProperty
        E,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(E) {
      var h = E.replace(W, we);
      he[h] = new ve(
        h,
        be,
        !1,
        // mustUseProperty
        E,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(E) {
      var h = E.replace(W, we);
      he[h] = new ve(
        h,
        be,
        !1,
        // mustUseProperty
        E,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(E) {
      he[E] = new ve(
        E,
        be,
        !1,
        // mustUseProperty
        E.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ye = "xlinkHref";
    he[ye] = new ve(
      "xlinkHref",
      be,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(E) {
      he[E] = new ve(
        E,
        be,
        !1,
        // mustUseProperty
        E.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var j = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Q(E, h) {
      return E + h.charAt(0).toUpperCase() + h.substring(1);
    }
    var De = ["Webkit", "ms", "Moz", "O"];
    Object.keys(j).forEach(function(E) {
      De.forEach(function(h) {
        j[Q(h, E)] = j[E];
      });
    });
    var T = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function pe(E, h) {
      T[h.type] || h.onChange || h.onInput || h.readOnly || h.disabled || h.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), h.onChange || h.readOnly || h.disabled || h.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function M(E, h) {
      if (E.indexOf("-") === -1)
        return typeof h.is == "string";
      switch (E) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var _ = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, S = {}, O = new RegExp("^(aria)-[" + oe + "]*$"), ne = new RegExp("^(aria)[A-Z][" + oe + "]*$");
    function fe(E, h) {
      {
        if (I.call(S, h) && S[h])
          return !0;
        if (ne.test(h)) {
          var v = "aria-" + h.slice(4).toLowerCase(), D = _.hasOwnProperty(v) ? v : null;
          if (D == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", h), S[h] = !0, !0;
          if (h !== D)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", h, D), S[h] = !0, !0;
        }
        if (O.test(h)) {
          var R = h.toLowerCase(), $ = _.hasOwnProperty(R) ? R : null;
          if ($ == null)
            return S[h] = !0, !1;
          if (h !== $)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", h, $), S[h] = !0, !0;
        }
      }
      return !0;
    }
    function J(E, h) {
      {
        var v = [];
        for (var D in h) {
          var R = fe(E, D);
          R || v.push(D);
        }
        var $ = v.map(function(Y) {
          return "`" + Y + "`";
        }).join(", ");
        v.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", $, E) : v.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", $, E);
      }
    }
    function re(E, h) {
      M(E, h) || J(E, h);
    }
    var de = !1;
    function ge(E, h) {
      {
        if (E !== "input" && E !== "textarea" && E !== "select")
          return;
        h != null && h.value === null && !de && (de = !0, E === "select" && h.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", E) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", E));
      }
    }
    var Ee = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Ne = function() {
    };
    {
      var Le = {}, Qe = /^on./, Ze = /^on[^A-Z]/, at = new RegExp("^(aria)-[" + oe + "]*$"), gt = new RegExp("^(aria)[A-Z][" + oe + "]*$");
      Ne = function(E, h, v, D) {
        if (I.call(Le, h) && Le[h])
          return !0;
        var R = h.toLowerCase();
        if (R === "onfocusin" || R === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Le[h] = !0, !0;
        if (D != null) {
          var $ = D.registrationNameDependencies, Y = D.possibleRegistrationNames;
          if ($.hasOwnProperty(h))
            return !0;
          var se = Y.hasOwnProperty(R) ? Y[R] : null;
          if (se != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", h, se), Le[h] = !0, !0;
          if (Qe.test(h))
            return i("Unknown event handler property `%s`. It will be ignored.", h), Le[h] = !0, !0;
        } else if (Qe.test(h))
          return Ze.test(h) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", h), Le[h] = !0, !0;
        if (at.test(h) || gt.test(h))
          return !0;
        if (R === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Le[h] = !0, !0;
        if (R === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Le[h] = !0, !0;
        if (R === "is" && v !== null && v !== void 0 && typeof v != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof v), Le[h] = !0, !0;
        if (typeof v == "number" && isNaN(v))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", h), Le[h] = !0, !0;
        var Te = me(h), ke = Te !== null && Te.type === le;
        if (Ee.hasOwnProperty(R)) {
          var We = Ee[R];
          if (We !== h)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", h, We), Le[h] = !0, !0;
        } else if (!ke && h !== R)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", h, R), Le[h] = !0, !0;
        return typeof v == "boolean" && ce(h, v, Te) ? (v ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', v, h, h, v, h) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', v, h, h, v, h, h, h), Le[h] = !0, !0) : ke ? !0 : ce(h, v, Te) ? (Le[h] = !0, !1) : ((v === "false" || v === "true") && Te !== null && Te.type === G && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", v, h, v === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', h, v), Le[h] = !0), !0);
      };
    }
    var et = function(E, h, v) {
      {
        var D = [];
        for (var R in h) {
          var $ = Ne(E, R, h[R], v);
          $ || D.push(R);
        }
        var Y = D.map(function(se) {
          return "`" + se + "`";
        }).join(", ");
        D.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", Y, E) : D.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", Y, E);
      }
    };
    function Zt(E, h, v) {
      M(E, h) || et(E, h, v);
    }
    var Un = function() {
    };
    {
      var Ft = /^(?:webkit|moz|o)[A-Z]/, Ar = /^-ms-/, Ii = /-(.)/g, xn = /;\s*$/, Bn = {}, Ln = {}, ht = !1, _n = !1, Oo = function(E) {
        return E.replace(Ii, function(h, v) {
          return v.toUpperCase();
        });
      }, ao = function(E) {
        Bn.hasOwnProperty(E) && Bn[E] || (Bn[E] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          E,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Oo(E.replace(Ar, "ms-"))
        ));
      }, Vr = function(E) {
        Bn.hasOwnProperty(E) && Bn[E] || (Bn[E] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", E, E.charAt(0).toUpperCase() + E.slice(1)));
      }, Fo = function(E, h) {
        Ln.hasOwnProperty(h) && Ln[h] || (Ln[h] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, E, h.replace(xn, "")));
      }, mi = function(E, h) {
        ht || (ht = !0, i("`NaN` is an invalid value for the `%s` css style property.", E));
      }, Sn = function(E, h) {
        _n || (_n = !0, i("`Infinity` is an invalid value for the `%s` css style property.", E));
      };
      Un = function(E, h) {
        E.indexOf("-") > -1 ? ao(E) : Ft.test(E) ? Vr(E) : xn.test(h) && Fo(E, h), typeof h == "number" && (isNaN(h) ? mi(E, h) : isFinite(h) || Sn(E, h));
      };
    }
    var xa = Un, _a = /["'&<>]/;
    function _s(E) {
      V(E);
      var h = "" + E, v = _a.exec(h);
      if (!v)
        return h;
      var D, R = "", $, Y = 0;
      for ($ = v.index; $ < h.length; $++) {
        switch (h.charCodeAt($)) {
          case 34:
            D = "&quot;";
            break;
          case 38:
            D = "&amp;";
            break;
          case 39:
            D = "&#x27;";
            break;
          case 60:
            D = "&lt;";
            break;
          case 62:
            D = "&gt;";
            break;
          default:
            continue;
        }
        Y !== $ && (R += h.substring(Y, $)), Y = $ + 1, R += D;
      }
      return Y !== $ ? R + h.substring(Y, $) : R;
    }
    function mn(E) {
      return typeof E == "boolean" || typeof E == "number" ? "" + E : _s(E);
    }
    var Sa = /([A-Z])/g, Vl = /^ms-/;
    function ql(E) {
      return E.replace(Sa, "-$1").toLowerCase().replace(Vl, "-ms-");
    }
    var qr = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Ta = !1;
    function Uo(E) {
      !Ta && qr.test(E) && (Ta = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(E)));
    }
    var Oi = Array.isArray;
    function Qn(E) {
      return Oi(E);
    }
    var Gr = y("<script>"), No = y("<\/script>"), Fi = y('<script src="'), Ui = y('<script type="module" src="'), Kr = y('" async=""><\/script>');
    function Ni(E) {
      return V(E), ("" + E).replace(er, Ss);
    }
    var er = /(<\/|<)(s)(cript)/gi, Ss = function(E, h, v, D) {
      return "" + h + (v === "s" ? "\\u0073" : "\\u0053") + D;
    };
    function Ts(E, h, v, D, R) {
      var $ = E === void 0 ? "" : E, Y = h === void 0 ? Gr : y('<script nonce="' + mn(h) + '">'), se = [];
      if (v !== void 0 && se.push(Y, b(Ni(v)), No), D !== void 0)
        for (var Te = 0; Te < D.length; Te++)
          se.push(Fi, b(mn(D[Te])), Kr);
      if (R !== void 0)
        for (var ke = 0; ke < R.length; ke++)
          se.push(Ui, b(mn(R[ke])), Kr);
      return {
        bootstrapChunks: se,
        startInlineScript: Y,
        placeholderPrefix: y($ + "P:"),
        segmentPrefix: y($ + "S:"),
        boundaryPrefix: $ + "B:",
        idPrefix: $,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var gi = 0, gn = 1, Xr = 2, Yr = 3, Mi = 4, Mo = 5, Rr = 6, Jr = 7;
    function Pn(E, h) {
      return {
        insertionMode: E,
        selectedValue: h
      };
    }
    function Bi(E) {
      var h = E === "http://www.w3.org/2000/svg" ? Xr : E === "http://www.w3.org/1998/Math/MathML" ? Yr : gi;
      return Pn(h, null);
    }
    function so(E, h, v) {
      switch (h) {
        case "select":
          return Pn(gn, v.value != null ? v.value : v.defaultValue);
        case "svg":
          return Pn(Xr, null);
        case "math":
          return Pn(Yr, null);
        case "foreignObject":
          return Pn(gn, null);
        case "table":
          return Pn(Mi, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return Pn(Mo, null);
        case "colgroup":
          return Pn(Jr, null);
        case "tr":
          return Pn(Rr, null);
      }
      return E.insertionMode >= Mi || E.insertionMode === gi ? Pn(gn, null) : E;
    }
    var Bo = null;
    function hr(E) {
      var h = E.nextSuspenseID++;
      return y(E.boundaryPrefix + h.toString(16));
    }
    function Zr(E, h, v) {
      var D = E.idPrefix, R = ":" + D + "R" + h;
      return v > 0 && (R += "H" + v.toString(32)), R + ":";
    }
    function Wn(E) {
      return mn(E);
    }
    var Lo = y("<!-- -->");
    function Cn(E, h, v, D) {
      return h === "" ? D : (D && E.push(Lo), E.push(b(Wn(h))), !0);
    }
    function tr(E, h, v, D) {
      v && D && E.push(Lo);
    }
    var B = /* @__PURE__ */ new Map();
    function X(E) {
      var h = B.get(E);
      if (h !== void 0)
        return h;
      var v = y(mn(ql(E)));
      return B.set(E, v), v;
    }
    var ue = y(' style="'), Se = y(":"), Re = y(";");
    function Ce(E, h, v) {
      if (typeof v != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var D = !0;
      for (var R in v)
        if (I.call(v, R)) {
          var $ = v[R];
          if (!($ == null || typeof $ == "boolean" || $ === "")) {
            var Y = void 0, se = void 0, Te = R.indexOf("--") === 0;
            Te ? (Y = b(mn(R)), P($, R), se = b(mn(("" + $).trim()))) : (xa(R, $), Y = X(R), typeof $ == "number" ? $ !== 0 && !I.call(j, R) ? se = b($ + "px") : se = b("" + $) : (P($, R), se = b(mn(("" + $).trim())))), D ? (D = !1, E.push(ue, Y, Se, se)) : E.push(Re, Y, Se, se);
          }
        }
      D || E.push(rt);
    }
    var Be = y(" "), Ve = y('="'), rt = y('"'), lt = y('=""');
    function it(E, h, v, D) {
      switch (v) {
        case "style": {
          Ce(E, h, D);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(v.length > 2 && (v[0] === "o" || v[0] === "O") && (v[1] === "n" || v[1] === "N"))
      ) {
        var R = me(v);
        if (R !== null) {
          switch (typeof D) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!R.acceptsBooleans)
                return;
          }
          var $ = R.attributeName, Y = b($);
          switch (R.type) {
            case G:
              D && E.push(Be, Y, lt);
              return;
            case C:
              D === !0 ? E.push(Be, Y, lt) : D === !1 || E.push(Be, Y, Ve, b(mn(D)), rt);
              return;
            case ie:
              isNaN(D) || E.push(Be, Y, Ve, b(mn(D)), rt);
              break;
            case ee:
              !isNaN(D) && D >= 1 && E.push(Be, Y, Ve, b(mn(D)), rt);
              break;
            default:
              R.sanitizeURL && (U(D, $), D = "" + D, Uo(D)), E.push(Be, Y, Ve, b(mn(D)), rt);
          }
        } else if (N(v)) {
          switch (typeof D) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var se = v.toLowerCase().slice(0, 5);
              if (se !== "data-" && se !== "aria-")
                return;
            }
          }
          E.push(Be, b(v), Ve, b(mn(D)), rt);
        }
      }
    }
    var Rt = y(">"), zn = y("/>");
    function $n(E, h, v) {
      if (h != null) {
        if (v != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof h != "object" || !("__html" in h))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var D = h.__html;
        D != null && (V(D), E.push(b("" + D)));
      }
    }
    var Hn = !1, Li = !1, Qr = !1, Po = !1, Pi = !1, lo = !1, yi = !1;
    function co(E, h) {
      {
        var v = E[h];
        if (v != null) {
          var D = Qn(v);
          E.multiple && !D ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", h) : !E.multiple && D && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", h);
        }
      }
    }
    function uh(E, h, v) {
      pe("select", h), co(h, "value"), co(h, "defaultValue"), h.value !== void 0 && h.defaultValue !== void 0 && !Qr && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Qr = !0), E.push(Ir("select"));
      var D = null, R = null;
      for (var $ in h)
        if (I.call(h, $)) {
          var Y = h[$];
          if (Y == null)
            continue;
          switch ($) {
            case "children":
              D = Y;
              break;
            case "dangerouslySetInnerHTML":
              R = Y;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              it(E, v, $, Y);
              break;
          }
        }
      return E.push(Rt), $n(E, R, D), D;
    }
    function dh(E) {
      var h = "";
      return t.Children.forEach(E, function(v) {
        v != null && (h += v, !Pi && typeof v != "string" && typeof v != "number" && (Pi = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), h;
    }
    var Ds = y(' selected=""');
    function ei(E, h, v, D) {
      var R = D.selectedValue;
      E.push(Ir("option"));
      var $ = null, Y = null, se = null, Te = null;
      for (var ke in h)
        if (I.call(h, ke)) {
          var We = h[ke];
          if (We == null)
            continue;
          switch (ke) {
            case "children":
              $ = We;
              break;
            case "selected":
              se = We, yi || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), yi = !0);
              break;
            case "dangerouslySetInnerHTML":
              Te = We;
              break;
            case "value":
              Y = We;
            default:
              it(E, v, ke, We);
              break;
          }
        }
      if (R != null) {
        var He;
        if (Y !== null ? (U(Y, "value"), He = "" + Y) : (Te !== null && (lo || (lo = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), He = dh($)), Qn(R))
          for (var Ke = 0; Ke < R.length; Ke++) {
            U(R[Ke], "value");
            var ut = "" + R[Ke];
            if (ut === He) {
              E.push(Ds);
              break;
            }
          }
        else
          U(R, "select.value"), "" + R === He && E.push(Ds);
      } else se && E.push(Ds);
      return E.push(Rt), $n(E, Te, $), $;
    }
    function fh(E, h, v) {
      pe("input", h), h.checked !== void 0 && h.defaultChecked !== void 0 && !Li && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", h.type), Li = !0), h.value !== void 0 && h.defaultValue !== void 0 && !Hn && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", h.type), Hn = !0), E.push(Ir("input"));
      var D = null, R = null, $ = null, Y = null;
      for (var se in h)
        if (I.call(h, se)) {
          var Te = h[se];
          if (Te == null)
            continue;
          switch (se) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              Y = Te;
              break;
            case "defaultValue":
              R = Te;
              break;
            case "checked":
              $ = Te;
              break;
            case "value":
              D = Te;
              break;
            default:
              it(E, v, se, Te);
              break;
          }
        }
      return $ !== null ? it(E, v, "checked", $) : Y !== null && it(E, v, "checked", Y), D !== null ? it(E, v, "value", D) : R !== null && it(E, v, "value", R), E.push(zn), null;
    }
    function bi(E, h, v) {
      pe("textarea", h), h.value !== void 0 && h.defaultValue !== void 0 && !Po && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Po = !0), E.push(Ir("textarea"));
      var D = null, R = null, $ = null;
      for (var Y in h)
        if (I.call(h, Y)) {
          var se = h[Y];
          if (se == null)
            continue;
          switch (Y) {
            case "children":
              $ = se;
              break;
            case "value":
              D = se;
              break;
            case "defaultValue":
              R = se;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              it(E, v, Y, se);
              break;
          }
        }
      if (D === null && R !== null && (D = R), E.push(Rt), $ != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), D != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (Qn($)) {
          if ($.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          V($[0]), D = "" + $[0];
        }
        V($), D = "" + $;
      }
      return typeof D == "string" && D[0] === `
` && E.push(fo), D !== null && (U(D, "value"), E.push(b(Wn("" + D)))), null;
    }
    function Gl(E, h, v, D) {
      E.push(Ir(v));
      for (var R in h)
        if (I.call(h, R)) {
          var $ = h[R];
          if ($ == null)
            continue;
          switch (R) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(v + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              it(E, D, R, $);
              break;
          }
        }
      return E.push(zn), null;
    }
    function Es(E, h, v) {
      E.push(Ir("menuitem"));
      for (var D in h)
        if (I.call(h, D)) {
          var R = h[D];
          if (R == null)
            continue;
          switch (D) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              it(E, v, D, R);
              break;
          }
        }
      return E.push(Rt), null;
    }
    function zt(E, h, v) {
      E.push(Ir("title"));
      var D = null;
      for (var R in h)
        if (I.call(h, R)) {
          var $ = h[R];
          if ($ == null)
            continue;
          switch (R) {
            case "children":
              D = $;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              it(E, v, R, $);
              break;
          }
        }
      E.push(Rt);
      {
        var Y = Array.isArray(D) && D.length < 2 ? D[0] || null : D;
        Array.isArray(D) && D.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : Y != null && Y.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : Y != null && typeof Y != "string" && typeof Y != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return D;
    }
    function uo(E, h, v, D) {
      E.push(Ir(v));
      var R = null, $ = null;
      for (var Y in h)
        if (I.call(h, Y)) {
          var se = h[Y];
          if (se == null)
            continue;
          switch (Y) {
            case "children":
              R = se;
              break;
            case "dangerouslySetInnerHTML":
              $ = se;
              break;
            default:
              it(E, D, Y, se);
              break;
          }
        }
      return E.push(Rt), $n(E, $, R), typeof R == "string" ? (E.push(b(Wn(R))), null) : R;
    }
    function Cs(E, h, v, D) {
      E.push(Ir(v));
      var R = null, $ = null;
      for (var Y in h)
        if (I.call(h, Y)) {
          var se = h[Y];
          if (se == null)
            continue;
          switch (Y) {
            case "children":
              R = se;
              break;
            case "dangerouslySetInnerHTML":
              $ = se;
              break;
            case "style":
              Ce(E, D, se);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              N(Y) && typeof se != "function" && typeof se != "symbol" && E.push(Be, b(Y), Ve, b(mn(se)), rt);
              break;
          }
        }
      return E.push(Rt), $n(E, $, R), R;
    }
    var fo = y(`
`);
    function Wi(E, h, v, D) {
      E.push(Ir(v));
      var R = null, $ = null;
      for (var Y in h)
        if (I.call(h, Y)) {
          var se = h[Y];
          if (se == null)
            continue;
          switch (Y) {
            case "children":
              R = se;
              break;
            case "dangerouslySetInnerHTML":
              $ = se;
              break;
            default:
              it(E, D, Y, se);
              break;
          }
        }
      if (E.push(Rt), $ != null) {
        if (R != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof $ != "object" || !("__html" in $))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var Te = $.__html;
        Te != null && (typeof Te == "string" && Te.length > 0 && Te[0] === `
` ? E.push(fo, b(Te)) : (V(Te), E.push(b("" + Te))));
      }
      return typeof R == "string" && R[0] === `
` && E.push(fo), R;
    }
    var ks = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, zi = /* @__PURE__ */ new Map();
    function Ir(E) {
      var h = zi.get(E);
      if (h === void 0) {
        if (!ks.test(E))
          throw new Error("Invalid tag: " + E);
        h = y("<" + E), zi.set(E, h);
      }
      return h;
    }
    var Kl = y("<!DOCTYPE html>");
    function Da(E, h, v, D, R) {
      switch (re(h, v), ge(h, v), Zt(h, v, null), !v.suppressContentEditableWarning && v.contentEditable && v.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), R.insertionMode !== Xr && R.insertionMode !== Yr && h.indexOf("-") === -1 && typeof v.is != "string" && h.toLowerCase() !== h && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", h), h) {
        case "select":
          return uh(E, v, D);
        case "option":
          return ei(E, v, D, R);
        case "textarea":
          return bi(E, v, D);
        case "input":
          return fh(E, v, D);
        case "menuitem":
          return Es(E, v, D);
        case "title":
          return zt(E, v, D);
        case "listing":
        case "pre":
          return Wi(E, v, h, D);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return Gl(E, v, h, D);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return uo(E, v, h, D);
        case "html":
          return R.insertionMode === gi && E.push(Kl), uo(E, v, h, D);
        default:
          return h.indexOf("-") === -1 && typeof v.is != "string" ? uo(E, v, h, D) : Cs(E, v, h, D);
      }
    }
    var Eu = y("</"), As = y(">");
    function Cu(E, h, v) {
      switch (h) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          E.push(Eu, b(h), As);
      }
    }
    function hh(E, h) {
      for (var v = h.bootstrapChunks, D = 0; D < v.length - 1; D++)
        d(E, v[D]);
      return D < v.length ? f(E, v[D]) : !0;
    }
    var ph = y('<template id="'), Rs = y('"></template>');
    function ku(E, h, v) {
      d(E, ph), d(E, h.placeholderPrefix);
      var D = b(v.toString(16));
      return d(E, D), f(E, Rs);
    }
    var Ea = y("<!--$-->"), Xl = y('<!--$?--><template id="'), mh = y('"></template>'), Wo = y("<!--$!-->"), Yl = y("<!--/$-->"), Jl = y("<template"), zo = y('"'), Ca = y(' data-dgst="'), Is = y(' data-msg="'), Au = y(' data-stck="'), Ru = y("></template>");
    function Iu(E, h) {
      return f(E, Ea);
    }
    function Os(E, h, v) {
      if (d(E, Xl), v === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return d(E, v), f(E, mh);
    }
    function nr(E, h, v, D, R) {
      var $;
      return $ = f(E, Wo), d(E, Jl), v && (d(E, Ca), d(E, b(mn(v))), d(E, zo)), D && (d(E, Is), d(E, b(mn(D))), d(E, zo)), R && (d(E, Au), d(E, b(mn(R))), d(E, zo)), $ = f(E, Ru), $;
    }
    function Ou(E, h) {
      return f(E, Yl);
    }
    function Fs(E, h) {
      return f(E, Yl);
    }
    function gh(E, h) {
      return f(E, Yl);
    }
    var Fu = y('<div hidden id="'), Us = y('">'), Uu = y("</div>"), Nu = y('<svg aria-hidden="true" style="display:none" id="'), Ns = y('">'), Ms = y("</svg>"), Mu = y('<math aria-hidden="true" style="display:none" id="'), Bu = y('">'), Lu = y("</math>"), Zl = y('<table hidden id="'), Pu = y('">'), L = y("</table>"), K = y('<table hidden><tbody id="'), ae = y('">'), xe = y("</tbody></table>"), Ie = y('<table hidden><tr id="'), Ae = y('">'), Pe = y("</tr></table>"), qe = y('<table hidden><colgroup id="'), ct = y('">'), mt = y("</colgroup></table>");
    function pt(E, h, v, D) {
      switch (v.insertionMode) {
        case gi:
        case gn:
          return d(E, Fu), d(E, h.segmentPrefix), d(E, b(D.toString(16))), f(E, Us);
        case Xr:
          return d(E, Nu), d(E, h.segmentPrefix), d(E, b(D.toString(16))), f(E, Ns);
        case Yr:
          return d(E, Mu), d(E, h.segmentPrefix), d(E, b(D.toString(16))), f(E, Bu);
        case Mi:
          return d(E, Zl), d(E, h.segmentPrefix), d(E, b(D.toString(16))), f(E, Pu);
        case Mo:
          return d(E, K), d(E, h.segmentPrefix), d(E, b(D.toString(16))), f(E, ae);
        case Rr:
          return d(E, Ie), d(E, h.segmentPrefix), d(E, b(D.toString(16))), f(E, Ae);
        case Jr:
          return d(E, qe), d(E, h.segmentPrefix), d(E, b(D.toString(16))), f(E, ct);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function jt(E, h) {
      switch (h.insertionMode) {
        case gi:
        case gn:
          return f(E, Uu);
        case Xr:
          return f(E, Ms);
        case Yr:
          return f(E, Lu);
        case Mi:
          return f(E, L);
        case Mo:
          return f(E, xe);
        case Rr:
          return f(E, Pe);
        case Jr:
          return f(E, mt);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var rr = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", Or = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', Fr = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', Bs = y(rr + ';$RS("'), Wu = y('$RS("'), ka = y('","'), F0 = y('")<\/script>');
    function U0(E, h, v) {
      d(E, h.startInlineScript), h.sentCompleteSegmentFunction ? d(E, Wu) : (h.sentCompleteSegmentFunction = !0, d(E, Bs)), d(E, h.segmentPrefix);
      var D = b(v.toString(16));
      return d(E, D), d(E, ka), d(E, h.placeholderPrefix), d(E, D), f(E, F0);
    }
    var yh = y(Or + ';$RC("'), N0 = y('$RC("'), M0 = y('","'), ng = y('")<\/script>');
    function rg(E, h, v, D) {
      if (d(E, h.startInlineScript), h.sentCompleteBoundaryFunction ? d(E, N0) : (h.sentCompleteBoundaryFunction = !0, d(E, yh)), v === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var R = b(D.toString(16));
      return d(E, v), d(E, M0), d(E, h.segmentPrefix), d(E, R), f(E, ng);
    }
    var B0 = y(Fr + ';$RX("'), L0 = y('$RX("'), P0 = y('"'), W0 = y(")<\/script>"), pr = y(",");
    function z0(E, h, v, D, R, $) {
      if (d(E, h.startInlineScript), h.sentClientRenderFunction ? d(E, L0) : (h.sentClientRenderFunction = !0, d(E, B0)), v === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return d(E, v), d(E, P0), (D || R || $) && (d(E, pr), d(E, b(zu(D || "")))), (R || $) && (d(E, pr), d(E, b(zu(R || "")))), $ && (d(E, pr), d(E, b(zu($)))), f(E, W0);
    }
    var ig = /[<\u2028\u2029]/g;
    function zu(E) {
      var h = JSON.stringify(E);
      return h.replace(ig, function(v) {
        switch (v) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var Ur = Object.assign, og = Symbol.for("react.element"), $u = Symbol.for("react.portal"), Hu = Symbol.for("react.fragment"), ju = Symbol.for("react.strict_mode"), Vu = Symbol.for("react.profiler"), Ql = Symbol.for("react.provider"), ec = Symbol.for("react.context"), Ls = Symbol.for("react.forward_ref"), bh = Symbol.for("react.suspense"), vh = Symbol.for("react.suspense_list"), wh = Symbol.for("react.memo"), qu = Symbol.for("react.lazy"), ag = Symbol.for("react.scope"), $0 = Symbol.for("react.debug_trace_mode"), H0 = Symbol.for("react.legacy_hidden"), j0 = Symbol.for("react.default_value"), xh = Symbol.iterator, on = "@@iterator";
    function tc(E) {
      if (E === null || typeof E != "object")
        return null;
      var h = xh && E[xh] || E[on];
      return typeof h == "function" ? h : null;
    }
    function sg(E, h, v) {
      var D = E.displayName;
      if (D)
        return D;
      var R = h.displayName || h.name || "";
      return R !== "" ? v + "(" + R + ")" : v;
    }
    function _h(E) {
      return E.displayName || "Context";
    }
    function Qt(E) {
      if (E == null)
        return null;
      if (typeof E.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof E == "function")
        return E.displayName || E.name || null;
      if (typeof E == "string")
        return E;
      switch (E) {
        case Hu:
          return "Fragment";
        case $u:
          return "Portal";
        case Vu:
          return "Profiler";
        case ju:
          return "StrictMode";
        case bh:
          return "Suspense";
        case vh:
          return "SuspenseList";
      }
      if (typeof E == "object")
        switch (E.$$typeof) {
          case ec:
            var h = E;
            return _h(h) + ".Consumer";
          case Ql:
            var v = E;
            return _h(v._context) + ".Provider";
          case Ls:
            return sg(E, E.render, "ForwardRef");
          case wh:
            var D = E.displayName || null;
            return D !== null ? D : Qt(E.type) || "Memo";
          case qu: {
            var R = E, $ = R._payload, Y = R._init;
            try {
              return Qt(Y($));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Ps = 0, Sh, Th, Dh, Eh, lg, cg, Gu;
    function Ku() {
    }
    Ku.__reactDisabledLog = !0;
    function nc() {
      {
        if (Ps === 0) {
          Sh = console.log, Th = console.info, Dh = console.warn, Eh = console.error, lg = console.group, cg = console.groupCollapsed, Gu = console.groupEnd;
          var E = {
            configurable: !0,
            enumerable: !0,
            value: Ku,
            writable: !0
          };
          Object.defineProperties(console, {
            info: E,
            log: E,
            warn: E,
            error: E,
            group: E,
            groupCollapsed: E,
            groupEnd: E
          });
        }
        Ps++;
      }
    }
    function Ch() {
      {
        if (Ps--, Ps === 0) {
          var E = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Ur({}, E, {
              value: Sh
            }),
            info: Ur({}, E, {
              value: Th
            }),
            warn: Ur({}, E, {
              value: Dh
            }),
            error: Ur({}, E, {
              value: Eh
            }),
            group: Ur({}, E, {
              value: lg
            }),
            groupCollapsed: Ur({}, E, {
              value: cg
            }),
            groupEnd: Ur({}, E, {
              value: Gu
            })
          });
        }
        Ps < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Ws = n.ReactCurrentDispatcher, kh;
    function Aa(E, h, v) {
      {
        if (kh === void 0)
          try {
            throw Error();
          } catch (R) {
            var D = R.stack.trim().match(/\n( *(at )?)/);
            kh = D && D[1] || "";
          }
        return `
` + kh + E;
      }
    }
    var Ah = !1, rc;
    {
      var V0 = typeof WeakMap == "function" ? WeakMap : Map;
      rc = new V0();
    }
    function ic(E, h) {
      if (!E || Ah)
        return "";
      {
        var v = rc.get(E);
        if (v !== void 0)
          return v;
      }
      var D;
      Ah = !0;
      var R = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var $;
      $ = Ws.current, Ws.current = null, nc();
      try {
        if (h) {
          var Y = function() {
            throw Error();
          };
          if (Object.defineProperty(Y.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Y, []);
            } catch (Ut) {
              D = Ut;
            }
            Reflect.construct(E, [], Y);
          } else {
            try {
              Y.call();
            } catch (Ut) {
              D = Ut;
            }
            E.call(Y.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ut) {
            D = Ut;
          }
          E();
        }
      } catch (Ut) {
        if (Ut && D && typeof Ut.stack == "string") {
          for (var se = Ut.stack.split(`
`), Te = D.stack.split(`
`), ke = se.length - 1, We = Te.length - 1; ke >= 1 && We >= 0 && se[ke] !== Te[We]; )
            We--;
          for (; ke >= 1 && We >= 0; ke--, We--)
            if (se[ke] !== Te[We]) {
              if (ke !== 1 || We !== 1)
                do
                  if (ke--, We--, We < 0 || se[ke] !== Te[We]) {
                    var He = `
` + se[ke].replace(" at new ", " at ");
                    return E.displayName && He.includes("<anonymous>") && (He = He.replace("<anonymous>", E.displayName)), typeof E == "function" && rc.set(E, He), He;
                  }
                while (ke >= 1 && We >= 0);
              break;
            }
        }
      } finally {
        Ah = !1, Ws.current = $, Ch(), Error.prepareStackTrace = R;
      }
      var Ke = E ? E.displayName || E.name : "", ut = Ke ? Aa(Ke) : "";
      return typeof E == "function" && rc.set(E, ut), ut;
    }
    function ug(E, h, v) {
      return ic(E, !0);
    }
    function Rh(E, h, v) {
      return ic(E, !1);
    }
    function Xu(E) {
      var h = E.prototype;
      return !!(h && h.isReactComponent);
    }
    function Yu(E, h, v) {
      if (E == null)
        return "";
      if (typeof E == "function")
        return ic(E, Xu(E));
      if (typeof E == "string")
        return Aa(E);
      switch (E) {
        case bh:
          return Aa("Suspense");
        case vh:
          return Aa("SuspenseList");
      }
      if (typeof E == "object")
        switch (E.$$typeof) {
          case Ls:
            return Rh(E.render);
          case wh:
            return Yu(E.type, h, v);
          case qu: {
            var D = E, R = D._payload, $ = D._init;
            try {
              return Yu($(R), h, v);
            } catch {
            }
          }
        }
      return "";
    }
    var Ju = {}, oc = n.ReactDebugCurrentFrame;
    function ac(E) {
      if (E) {
        var h = E._owner, v = Yu(E.type, E._source, h ? h.type : null);
        oc.setExtraStackFrame(v);
      } else
        oc.setExtraStackFrame(null);
    }
    function dg(E, h, v, D, R) {
      {
        var $ = Function.call.bind(I);
        for (var Y in E)
          if ($(E, Y)) {
            var se = void 0;
            try {
              if (typeof E[Y] != "function") {
                var Te = Error((D || "React class") + ": " + v + " type `" + Y + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof E[Y] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Te.name = "Invariant Violation", Te;
              }
              se = E[Y](h, Y, D, v, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ke) {
              se = ke;
            }
            se && !(se instanceof Error) && (ac(R), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", D || "React class", v, Y, typeof se), ac(null)), se instanceof Error && !(se.message in Ju) && (Ju[se.message] = !0, ac(R), i("Failed %s type: %s", v, se.message), ac(null));
          }
      }
    }
    var Ra;
    Ra = {};
    var Zu = {};
    Object.freeze(Zu);
    function $o(E, h) {
      {
        var v = E.contextTypes;
        if (!v)
          return Zu;
        var D = {};
        for (var R in v)
          D[R] = h[R];
        {
          var $ = Qt(E) || "Unknown";
          dg(v, D, "context", $);
        }
        return D;
      }
    }
    function Ih(E, h, v, D) {
      {
        if (typeof E.getChildContext != "function") {
          {
            var R = Qt(h) || "Unknown";
            Ra[R] || (Ra[R] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", R, R));
          }
          return v;
        }
        var $ = E.getChildContext();
        for (var Y in $)
          if (!(Y in D))
            throw new Error((Qt(h) || "Unknown") + '.getChildContext(): key "' + Y + '" is not defined in childContextTypes.');
        {
          var se = Qt(h) || "Unknown";
          dg(D, $, "child context", se);
        }
        return Ur({}, v, $);
      }
    }
    var Ia;
    Ia = {};
    var Qu = null, Ho = null;
    function ed(E) {
      E.context._currentValue = E.parentValue;
    }
    function td(E) {
      E.context._currentValue = E.value;
    }
    function sc(E, h) {
      if (E !== h) {
        ed(E);
        var v = E.parent, D = h.parent;
        if (v === null) {
          if (D !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (D === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          sc(v, D);
        }
        td(h);
      }
    }
    function lc(E) {
      ed(E);
      var h = E.parent;
      h !== null && lc(h);
    }
    function fg(E) {
      var h = E.parent;
      h !== null && fg(h), td(E);
    }
    function hg(E, h) {
      ed(E);
      var v = E.parent;
      if (v === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      v.depth === h.depth ? sc(v, h) : hg(v, h);
    }
    function pg(E, h) {
      var v = h.parent;
      if (v === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      E.depth === v.depth ? sc(E, v) : pg(E, v), td(h);
    }
    function jo(E) {
      var h = Ho, v = E;
      h !== v && (h === null ? fg(v) : v === null ? lc(h) : h.depth === v.depth ? sc(h, v) : h.depth > v.depth ? hg(h, v) : pg(h, v), Ho = v);
    }
    function Oh(E, h) {
      var v;
      v = E._currentValue, E._currentValue = h, E._currentRenderer !== void 0 && E._currentRenderer !== null && E._currentRenderer !== Ia && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), E._currentRenderer = Ia;
      var D = Ho, R = {
        parent: D,
        depth: D === null ? 0 : D.depth + 1,
        context: E,
        parentValue: v,
        value: h
      };
      return Ho = R, R;
    }
    function q0(E) {
      var h = Ho;
      if (h === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      h.context !== E && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var v = h.parentValue;
        v === j0 ? h.context._currentValue = h.context._defaultValue : h.context._currentValue = v, E._currentRenderer !== void 0 && E._currentRenderer !== null && E._currentRenderer !== Ia && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), E._currentRenderer = Ia;
      }
      return Ho = h.parent;
    }
    function mg() {
      return Ho;
    }
    function zs(E) {
      var h = E._currentValue;
      return h;
    }
    function cc(E) {
      return E._reactInternals;
    }
    function Fh(E, h) {
      E._reactInternals = h;
    }
    var nd = {}, rd = {}, id, $s, uc, dc, od, fc, ad, sd, Uh;
    {
      id = /* @__PURE__ */ new Set(), $s = /* @__PURE__ */ new Set(), uc = /* @__PURE__ */ new Set(), ad = /* @__PURE__ */ new Set(), dc = /* @__PURE__ */ new Set(), sd = /* @__PURE__ */ new Set(), Uh = /* @__PURE__ */ new Set();
      var gg = /* @__PURE__ */ new Set();
      fc = function(E, h) {
        if (!(E === null || typeof E == "function")) {
          var v = h + "_" + E;
          gg.has(v) || (gg.add(v), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", h, E));
        }
      }, od = function(E, h) {
        if (h === void 0) {
          var v = Qt(E) || "Component";
          dc.has(v) || (dc.add(v), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", v));
        }
      };
    }
    function yg(E, h) {
      {
        var v = E.constructor, D = v && Qt(v) || "ReactClass", R = D + "." + h;
        if (nd[R])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, h, h, D), nd[R] = !0;
      }
    }
    var bg = {
      isMounted: function(E) {
        return !1;
      },
      enqueueSetState: function(E, h, v) {
        var D = cc(E);
        D.queue === null ? yg(E, "setState") : (D.queue.push(h), v != null && fc(v, "setState"));
      },
      enqueueReplaceState: function(E, h, v) {
        var D = cc(E);
        D.replace = !0, D.queue = [h], v != null && fc(v, "setState");
      },
      enqueueForceUpdate: function(E, h) {
        var v = cc(E);
        v.queue === null ? yg(E, "forceUpdate") : h != null && fc(h, "setState");
      }
    };
    function G0(E, h, v, D, R) {
      var $ = v(R, D);
      od(h, $);
      var Y = $ == null ? D : Ur({}, D, $);
      return Y;
    }
    function vg(E, h, v) {
      var D = Zu, R = E.contextType;
      if ("contextType" in E) {
        var $ = (
          // Allow null for conditional declaration
          R === null || R !== void 0 && R.$$typeof === ec && R._context === void 0
        );
        if (!$ && !Uh.has(E)) {
          Uh.add(E);
          var Y = "";
          R === void 0 ? Y = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof R != "object" ? Y = " However, it is set to a " + typeof R + "." : R.$$typeof === Ql ? Y = " Did you accidentally pass the Context.Provider instead?" : R._context !== void 0 ? Y = " Did you accidentally pass the Context.Consumer instead?" : Y = " However, it is set to an object with keys {" + Object.keys(R).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Qt(E) || "Component", Y);
        }
      }
      typeof R == "object" && R !== null ? D = zs(R) : D = v;
      var se = new E(h, D);
      {
        if (typeof E.getDerivedStateFromProps == "function" && (se.state === null || se.state === void 0)) {
          var Te = Qt(E) || "Component";
          id.has(Te) || (id.add(Te), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Te, se.state === null ? "null" : "undefined", Te));
        }
        if (typeof E.getDerivedStateFromProps == "function" || typeof se.getSnapshotBeforeUpdate == "function") {
          var ke = null, We = null, He = null;
          if (typeof se.componentWillMount == "function" && se.componentWillMount.__suppressDeprecationWarning !== !0 ? ke = "componentWillMount" : typeof se.UNSAFE_componentWillMount == "function" && (ke = "UNSAFE_componentWillMount"), typeof se.componentWillReceiveProps == "function" && se.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? We = "componentWillReceiveProps" : typeof se.UNSAFE_componentWillReceiveProps == "function" && (We = "UNSAFE_componentWillReceiveProps"), typeof se.componentWillUpdate == "function" && se.componentWillUpdate.__suppressDeprecationWarning !== !0 ? He = "componentWillUpdate" : typeof se.UNSAFE_componentWillUpdate == "function" && (He = "UNSAFE_componentWillUpdate"), ke !== null || We !== null || He !== null) {
            var Ke = Qt(E) || "Component", ut = typeof E.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            uc.has(Ke) || (uc.add(Ke), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Ke, ut, ke !== null ? `
  ` + ke : "", We !== null ? `
  ` + We : "", He !== null ? `
  ` + He : ""));
          }
        }
      }
      return se;
    }
    function K0(E, h, v) {
      {
        var D = Qt(h) || "Component", R = E.render;
        R || (h.prototype && typeof h.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", D) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", D)), E.getInitialState && !E.getInitialState.isReactClassApproved && !E.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", D), E.getDefaultProps && !E.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", D), E.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", D), E.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", D), E.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", D), h.contextType && h.contextTypes && !sd.has(h) && (sd.add(h), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", D)), typeof E.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", D), h.prototype && h.prototype.isPureReactComponent && typeof E.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Qt(h) || "A pure component"), typeof E.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", D), typeof E.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", D), typeof E.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", D), typeof E.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", D);
        var $ = E.props !== v;
        E.props !== void 0 && $ && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", D, D), E.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", D, D), typeof E.getSnapshotBeforeUpdate == "function" && typeof E.componentDidUpdate != "function" && !$s.has(h) && ($s.add(h), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Qt(h))), typeof E.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", D), typeof E.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", D), typeof h.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", D);
        var Y = E.state;
        Y && (typeof Y != "object" || Qn(Y)) && i("%s.state: must be set to an object or null", D), typeof E.getChildContext == "function" && typeof h.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", D);
      }
    }
    function X0(E, h) {
      var v = h.state;
      if (typeof h.componentWillMount == "function") {
        if (h.componentWillMount.__suppressDeprecationWarning !== !0) {
          var D = Qt(E) || "Unknown";
          rd[D] || (r(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            D
          ), rd[D] = !0);
        }
        h.componentWillMount();
      }
      typeof h.UNSAFE_componentWillMount == "function" && h.UNSAFE_componentWillMount(), v !== h.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Qt(E) || "Component"), bg.enqueueReplaceState(h, h.state, null));
    }
    function Nh(E, h, v, D) {
      if (E.queue !== null && E.queue.length > 0) {
        var R = E.queue, $ = E.replace;
        if (E.queue = null, E.replace = !1, $ && R.length === 1)
          h.state = R[0];
        else {
          for (var Y = $ ? R[0] : h.state, se = !0, Te = $ ? 1 : 0; Te < R.length; Te++) {
            var ke = R[Te], We = typeof ke == "function" ? ke.call(h, Y, v, D) : ke;
            We != null && (se ? (se = !1, Y = Ur({}, Y, We)) : Ur(Y, We));
          }
          h.state = Y;
        }
      } else
        E.queue = null;
    }
    function hc(E, h, v, D) {
      K0(E, h, v);
      var R = E.state !== void 0 ? E.state : null;
      E.updater = bg, E.props = v, E.state = R;
      var $ = {
        queue: [],
        replace: !1
      };
      Fh(E, $);
      var Y = h.contextType;
      if (typeof Y == "object" && Y !== null ? E.context = zs(Y) : E.context = D, E.state === v) {
        var se = Qt(h) || "Component";
        ad.has(se) || (ad.add(se), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", se));
      }
      var Te = h.getDerivedStateFromProps;
      typeof Te == "function" && (E.state = G0(E, h, Te, R, v)), typeof h.getDerivedStateFromProps != "function" && typeof E.getSnapshotBeforeUpdate != "function" && (typeof E.UNSAFE_componentWillMount == "function" || typeof E.componentWillMount == "function") && (X0(h, E), Nh($, E, v, D));
    }
    var Y0 = {
      id: 1,
      overflow: ""
    };
    function J0(E) {
      var h = E.overflow, v = E.id, D = v & ~Z0(v);
      return D.toString(32) + h;
    }
    function Mh(E, h, v) {
      var D = E.id, R = E.overflow, $ = ld(D) - 1, Y = D & ~(1 << $), se = v + 1, Te = ld(h) + $;
      if (Te > 30) {
        var ke = $ - $ % 5, We = (1 << ke) - 1, He = (Y & We).toString(32), Ke = Y >> ke, ut = $ - ke, Ut = ld(h) + ut, Nn = se << ut, La = Nn | Ke, Pa = He + R;
        return {
          id: 1 << Ut | La,
          overflow: Pa
        };
      } else {
        var yo = se << $, Xs = yo | Y, kw = R;
        return {
          id: 1 << Te | Xs,
          overflow: kw
        };
      }
    }
    function ld(E) {
      return 32 - Q0(E);
    }
    function Z0(E) {
      return 1 << ld(E) - 1;
    }
    var Q0 = Math.clz32 ? Math.clz32 : Bh, ew = Math.log, ho = Math.LN2;
    function Bh(E) {
      var h = E >>> 0;
      return h === 0 ? 32 : 31 - (ew(h) / ho | 0) | 0;
    }
    function cd(E, h) {
      return E === h && (E !== 0 || 1 / E === 1 / h) || E !== E && h !== h;
    }
    var Gt = typeof Object.is == "function" ? Object.is : cd, Nr = null, Hs = null, Oa = null, It = null, Vo = !1, ud = !1, Mr = 0, Br = null, $i = 0, tw = 25, vi = !1, qo;
    function Fa() {
      if (Nr === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return vi && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), Nr;
    }
    function nw(E, h) {
      if (h === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", qo), !1;
      E.length !== h.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, qo, "[" + E.join(", ") + "]", "[" + h.join(", ") + "]");
      for (var v = 0; v < h.length && v < E.length; v++)
        if (!Gt(E[v], h[v]))
          return !1;
      return !0;
    }
    function Lh() {
      if ($i > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function pc() {
      return It === null ? Oa === null ? (Vo = !1, Oa = It = Lh()) : (Vo = !0, It = Oa) : It.next === null ? (Vo = !1, It = It.next = Lh()) : (Vo = !0, It = It.next), It;
    }
    function rw(E, h) {
      Nr = h, Hs = E, vi = !1, Mr = 0;
    }
    function iw(E, h, v, D) {
      for (; ud; )
        ud = !1, Mr = 0, $i += 1, It = null, v = E(h, D);
      return Ph(), v;
    }
    function dd() {
      var E = Mr !== 0;
      return E;
    }
    function Ph() {
      vi = !1, Nr = null, Hs = null, ud = !1, Oa = null, $i = 0, Br = null, It = null;
    }
    function wg(E) {
      return vi && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), zs(E);
    }
    function xg(E) {
      return qo = "useContext", Fa(), zs(E);
    }
    function Wh(E, h) {
      return typeof h == "function" ? h(E) : h;
    }
    function ow(E) {
      return qo = "useState", _g(
        Wh,
        // useReducer has a special case to support lazy useState initializers
        E
      );
    }
    function _g(E, h, v) {
      if (E !== Wh && (qo = "useReducer"), Nr = Fa(), It = pc(), Vo) {
        var D = It.queue, R = D.dispatch;
        if (Br !== null) {
          var $ = Br.get(D);
          if ($ !== void 0) {
            Br.delete(D);
            var Y = It.memoizedState, se = $;
            do {
              var Te = se.action;
              vi = !0, Y = E(Y, Te), vi = !1, se = se.next;
            } while (se !== null);
            return It.memoizedState = Y, [Y, R];
          }
        }
        return [It.memoizedState, R];
      } else {
        vi = !0;
        var ke;
        E === Wh ? ke = typeof h == "function" ? h() : h : ke = v !== void 0 ? v(h) : h, vi = !1, It.memoizedState = ke;
        var We = It.queue = {
          last: null,
          dispatch: null
        }, He = We.dispatch = lw.bind(null, Nr, We);
        return [It.memoizedState, He];
      }
    }
    function Sg(E, h) {
      Nr = Fa(), It = pc();
      var v = h === void 0 ? null : h;
      if (It !== null) {
        var D = It.memoizedState;
        if (D !== null && v !== null) {
          var R = D[1];
          if (nw(v, R))
            return D[0];
        }
      }
      vi = !0;
      var $ = E();
      return vi = !1, It.memoizedState = [$, v], $;
    }
    function aw(E) {
      Nr = Fa(), It = pc();
      var h = It.memoizedState;
      if (h === null) {
        var v = {
          current: E
        };
        return Object.seal(v), It.memoizedState = v, v;
      } else
        return h;
    }
    function sw(E, h) {
      qo = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function lw(E, h, v) {
      if ($i >= tw)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (E === Nr) {
        ud = !0;
        var D = {
          action: v,
          next: null
        };
        Br === null && (Br = /* @__PURE__ */ new Map());
        var R = Br.get(h);
        if (R === void 0)
          Br.set(h, D);
        else {
          for (var $ = R; $.next !== null; )
            $ = $.next;
          $.next = D;
        }
      }
    }
    function cw(E, h) {
      return Sg(function() {
        return E;
      }, h);
    }
    function uw(E, h, v) {
      return Fa(), h(E._source);
    }
    function dw(E, h, v) {
      if (v === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return v();
    }
    function fd(E) {
      return Fa(), E;
    }
    function Tg() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function zh() {
      return Fa(), [!1, Tg];
    }
    function Dg() {
      var E = Hs, h = J0(E.treeContext), v = mc;
      if (v === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var D = Mr++;
      return Zr(v, h, D);
    }
    function hd() {
    }
    var pd = {
      readContext: wg,
      useContext: xg,
      useMemo: Sg,
      useReducer: _g,
      useRef: aw,
      useState: ow,
      useInsertionEffect: hd,
      useLayoutEffect: sw,
      useCallback: cw,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: hd,
      // Effects are not run in the server environment.
      useEffect: hd,
      // Debugging effect
      useDebugValue: hd,
      useDeferredValue: fd,
      useTransition: zh,
      useId: Dg,
      // Subscriptions are not setup in a server environment.
      useMutableSource: uw,
      useSyncExternalStore: dw
    }, mc = null;
    function md(E) {
      mc = E;
    }
    function js(E) {
      try {
        var h = "", v = E;
        do {
          switch (v.tag) {
            case 0:
              h += Aa(v.type, null, null);
              break;
            case 1:
              h += Rh(v.type, null, null);
              break;
            case 2:
              h += ug(v.type, null, null);
              break;
          }
          v = v.parent;
        } while (v);
        return h;
      } catch (D) {
        return `
Error generating stack: ` + D.message + `
` + D.stack;
      }
    }
    var gd = n.ReactCurrentDispatcher, yd = n.ReactDebugCurrentFrame, bd = 0, Vs = 1, $h = 2, Ua = 3, Eg = 4, fw = 0, qs = 1, Gs = 2, hw = 12800;
    function pw(E) {
      return console.error(E), null;
    }
    function Na() {
    }
    function vd(E, h, v, D, R, $, Y, se, Te) {
      var ke = [], We = /* @__PURE__ */ new Set(), He = {
        destination: null,
        responseState: h,
        progressiveChunkSize: D === void 0 ? hw : D,
        status: fw,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: We,
        pingedTasks: ke,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: R === void 0 ? pw : R,
        onAllReady: $ === void 0 ? Na : $,
        onShellReady: Y === void 0 ? Na : Y,
        onShellError: se === void 0 ? Na : se,
        onFatalError: Te === void 0 ? Na : Te
      }, Ke = gc(
        He,
        0,
        null,
        v,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      Ke.parentFlushed = !0;
      var ut = Ma(He, E, null, Ke, We, Zu, Qu, Y0);
      return ke.push(ut), He;
    }
    function po(E, h) {
      var v = E.pingedTasks;
      v.push(h), v.length === 1 && a(function() {
        return Qh(E);
      });
    }
    function Hh(E, h) {
      return {
        id: Bo,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: h,
        errorDigest: null
      };
    }
    function Ma(E, h, v, D, R, $, Y, se) {
      E.allPendingTasks++, v === null ? E.pendingRootTasks++ : v.pendingTasks++;
      var Te = {
        node: h,
        ping: function() {
          return po(E, Te);
        },
        blockedBoundary: v,
        blockedSegment: D,
        abortSet: R,
        legacyContext: $,
        context: Y,
        treeContext: se
      };
      return Te.componentStack = null, R.add(Te), Te;
    }
    function gc(E, h, v, D, R, $) {
      return {
        status: bd,
        id: -1,
        // lazily assigned later
        index: h,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: D,
        boundary: v,
        lastPushedText: R,
        textEmbedded: $
      };
    }
    var mo = null;
    function Hi() {
      return mo === null || mo.componentStack === null ? "" : js(mo.componentStack);
    }
    function go(E, h) {
      E.componentStack = {
        tag: 0,
        parent: E.componentStack,
        type: h
      };
    }
    function wd(E, h) {
      E.componentStack = {
        tag: 1,
        parent: E.componentStack,
        type: h
      };
    }
    function yc(E, h) {
      E.componentStack = {
        tag: 2,
        parent: E.componentStack,
        type: h
      };
    }
    function wi(E) {
      E.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : E.componentStack = E.componentStack.parent;
    }
    var bc = null;
    function jh(E, h) {
      {
        var v;
        typeof h == "string" ? v = h : h && typeof h.message == "string" ? v = h.message : v = String(h);
        var D = bc || Hi();
        bc = null, E.errorMessage = v, E.errorComponentStack = D;
      }
    }
    function vc(E, h) {
      var v = E.onError(h);
      if (v != null && typeof v != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof v + '" instead');
      return v;
    }
    function wc(E, h) {
      var v = E.onShellError;
      v(h);
      var D = E.onFatalError;
      D(h), E.destination !== null ? (E.status = Gs, w(E.destination, h)) : (E.status = qs, E.fatalError = h);
    }
    function Cg(E, h, v) {
      go(h, "Suspense");
      var D = h.blockedBoundary, R = h.blockedSegment, $ = v.fallback, Y = v.children, se = /* @__PURE__ */ new Set(), Te = Hh(E, se), ke = R.chunks.length, We = gc(
        E,
        ke,
        Te,
        R.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      R.children.push(We), R.lastPushedText = !1;
      var He = gc(
        E,
        0,
        null,
        R.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      He.parentFlushed = !0, h.blockedBoundary = Te, h.blockedSegment = He;
      try {
        if (Ks(E, h, Y), tr(He.chunks, E.responseState, He.lastPushedText, He.textEmbedded), He.status = Vs, Ba(Te, He), Te.pendingTasks === 0) {
          wi(h);
          return;
        }
      } catch (ut) {
        He.status = Eg, Te.forceClientRender = !0, Te.errorDigest = vc(E, ut), jh(Te, ut);
      } finally {
        h.blockedBoundary = D, h.blockedSegment = R;
      }
      var Ke = Ma(E, $, D, We, se, h.legacyContext, h.context, h.treeContext);
      Ke.componentStack = h.componentStack, E.pingedTasks.push(Ke), wi(h);
    }
    function mw(E, h, v, D) {
      go(h, v);
      var R = h.blockedSegment, $ = Da(R.chunks, v, D, E.responseState, R.formatContext);
      R.lastPushedText = !1;
      var Y = R.formatContext;
      R.formatContext = so(Y, v, D), Ks(E, h, $), R.formatContext = Y, Cu(R.chunks, v), R.lastPushedText = !1, wi(h);
    }
    function kg(E) {
      return E.prototype && E.prototype.isReactComponent;
    }
    function xc(E, h, v, D, R) {
      var $ = {};
      rw(h, $);
      var Y = v(D, R);
      return iw(v, D, Y, R);
    }
    function Vh(E, h, v, D, R) {
      var $ = v.render();
      v.props !== R && (Xh || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Qt(D) || "a component"), Xh = !0);
      {
        var Y = D.childContextTypes;
        if (Y != null) {
          var se = h.legacyContext, Te = Ih(v, D, se, Y);
          h.legacyContext = Te, ir(E, h, $), h.legacyContext = se;
          return;
        }
      }
      ir(E, h, $);
    }
    function Ag(E, h, v, D) {
      yc(h, v);
      var R = $o(v, h.legacyContext), $ = vg(v, D, R);
      hc($, v, D, R), Vh(E, h, $, v, D), wi(h);
    }
    var qh = {}, _c = {}, Gh = {}, Kh = {}, Xh = !1, Rg = {}, Ig = !1, Yh = !1, Og = !1;
    function gw(E, h, v, D) {
      var R;
      if (R = $o(v, h.legacyContext), wd(h, v), v.prototype && typeof v.prototype.render == "function") {
        var $ = Qt(v) || "Unknown";
        qh[$] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", $, $), qh[$] = !0);
      }
      var Y = xc(E, h, v, D, R), se = dd();
      if (typeof Y == "object" && Y !== null && typeof Y.render == "function" && Y.$$typeof === void 0) {
        var Te = Qt(v) || "Unknown";
        _c[Te] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Te, Te, Te), _c[Te] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof Y == "object" && Y !== null && typeof Y.render == "function" && Y.$$typeof === void 0
      ) {
        {
          var ke = Qt(v) || "Unknown";
          _c[ke] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ke, ke, ke), _c[ke] = !0);
        }
        hc(Y, v, D, R), Vh(E, h, Y, v, D);
      } else if (yw(v), se) {
        var We = h.treeContext, He = 1, Ke = 0;
        h.treeContext = Mh(We, He, Ke);
        try {
          ir(E, h, Y);
        } finally {
          h.treeContext = We;
        }
      } else
        ir(E, h, Y);
      wi(h);
    }
    function yw(E) {
      {
        if (E && E.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", E.displayName || E.name || "Component"), E.defaultProps !== void 0) {
          var h = Qt(E) || "Unknown";
          Rg[h] || (i("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", h), Rg[h] = !0);
        }
        if (typeof E.getDerivedStateFromProps == "function") {
          var v = Qt(E) || "Unknown";
          Kh[v] || (i("%s: Function components do not support getDerivedStateFromProps.", v), Kh[v] = !0);
        }
        if (typeof E.contextType == "object" && E.contextType !== null) {
          var D = Qt(E) || "Unknown";
          Gh[D] || (i("%s: Function components do not support contextType.", D), Gh[D] = !0);
        }
      }
    }
    function Fg(E, h) {
      if (E && E.defaultProps) {
        var v = Ur({}, h), D = E.defaultProps;
        for (var R in D)
          v[R] === void 0 && (v[R] = D[R]);
        return v;
      }
      return h;
    }
    function bw(E, h, v, D, R) {
      wd(h, v.render);
      var $ = xc(E, h, v.render, D, R), Y = dd();
      if (Y) {
        var se = h.treeContext, Te = 1, ke = 0;
        h.treeContext = Mh(se, Te, ke);
        try {
          ir(E, h, $);
        } finally {
          h.treeContext = se;
        }
      } else
        ir(E, h, $);
      wi(h);
    }
    function Jh(E, h, v, D, R) {
      var $ = v.type, Y = Fg($, D);
      xd(E, h, $, Y, R);
    }
    function vw(E, h, v, D) {
      v._context === void 0 ? v !== v.Consumer && (Og || (Og = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : v = v._context;
      var R = D.children;
      typeof R != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var $ = zs(v), Y = R($);
      ir(E, h, Y);
    }
    function Lr(E, h, v, D) {
      var R = v._context, $ = D.value, Y = D.children, se;
      se = h.context, h.context = Oh(R, $), ir(E, h, Y), h.context = q0(R), se !== h.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function ww(E, h, v, D, R) {
      go(h, "Lazy");
      var $ = v._payload, Y = v._init, se = Y($), Te = Fg(se, D);
      xd(E, h, se, Te, R), wi(h);
    }
    function xd(E, h, v, D, R) {
      if (typeof v == "function")
        if (kg(v)) {
          Ag(E, h, v, D);
          return;
        } else {
          gw(E, h, v, D);
          return;
        }
      if (typeof v == "string") {
        mw(E, h, v, D);
        return;
      }
      switch (v) {
        case H0:
        case $0:
        case ju:
        case Vu:
        case Hu: {
          ir(E, h, D.children);
          return;
        }
        case vh: {
          go(h, "SuspenseList"), ir(E, h, D.children), wi(h);
          return;
        }
        case ag:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case bh: {
          Cg(E, h, D);
          return;
        }
      }
      if (typeof v == "object" && v !== null)
        switch (v.$$typeof) {
          case Ls: {
            bw(E, h, v, D, R);
            return;
          }
          case wh: {
            Jh(E, h, v, D, R);
            return;
          }
          case Ql: {
            Lr(E, h, v, D);
            return;
          }
          case ec: {
            vw(E, h, v, D);
            return;
          }
          case qu: {
            ww(E, h, v, D);
            return;
          }
        }
      var $ = "";
      throw (v === void 0 || typeof v == "object" && v !== null && Object.keys(v).length === 0) && ($ += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (v == null ? v : typeof v) + "." + $));
    }
    function xw(E, h) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      E[Symbol.toStringTag] === "Generator" && (Ig || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Ig = !0), E.entries === h && (Yh || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Yh = !0);
    }
    function ir(E, h, v) {
      try {
        return _w(E, h, v);
      } catch (D) {
        throw typeof D == "object" && D !== null && typeof D.then == "function" || (bc = bc !== null ? bc : Hi()), D;
      }
    }
    function _w(E, h, v) {
      if (h.node = v, typeof v == "object" && v !== null) {
        switch (v.$$typeof) {
          case og: {
            var D = v, R = D.type, $ = D.props, Y = D.ref;
            xd(E, h, R, $, Y);
            return;
          }
          case $u:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case qu: {
            var se = v, Te = se._payload, ke = se._init, We;
            try {
              We = ke(Te);
            } catch (yo) {
              throw typeof yo == "object" && yo !== null && typeof yo.then == "function" && go(h, "Lazy"), yo;
            }
            ir(E, h, We);
            return;
          }
        }
        if (Qn(v)) {
          Ug(E, h, v);
          return;
        }
        var He = tc(v);
        if (He) {
          xw(v, He);
          var Ke = He.call(v);
          if (Ke) {
            var ut = Ke.next();
            if (!ut.done) {
              var Ut = [];
              do
                Ut.push(ut.value), ut = Ke.next();
              while (!ut.done);
              Ug(E, h, Ut);
              return;
            }
            return;
          }
        }
        var Nn = Object.prototype.toString.call(v);
        throw new Error("Objects are not valid as a React child (found: " + (Nn === "[object Object]" ? "object with keys {" + Object.keys(v).join(", ") + "}" : Nn) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof v == "string") {
        var La = h.blockedSegment;
        La.lastPushedText = Cn(h.blockedSegment.chunks, v, E.responseState, La.lastPushedText);
        return;
      }
      if (typeof v == "number") {
        var Pa = h.blockedSegment;
        Pa.lastPushedText = Cn(h.blockedSegment.chunks, "" + v, E.responseState, Pa.lastPushedText);
        return;
      }
      typeof v == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function Ug(E, h, v) {
      for (var D = v.length, R = 0; R < D; R++) {
        var $ = h.treeContext;
        h.treeContext = Mh($, D, R);
        try {
          Ks(E, h, v[R]);
        } finally {
          h.treeContext = $;
        }
      }
    }
    function Ng(E, h, v) {
      var D = h.blockedSegment, R = D.chunks.length, $ = gc(
        E,
        R,
        null,
        D.formatContext,
        // Adopt the parent segment's leading text embed
        D.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      D.children.push($), D.lastPushedText = !1;
      var Y = Ma(E, h.node, h.blockedBoundary, $, h.abortSet, h.legacyContext, h.context, h.treeContext);
      h.componentStack !== null && (Y.componentStack = h.componentStack.parent);
      var se = Y.ping;
      v.then(se, se);
    }
    function Ks(E, h, v) {
      var D = h.blockedSegment.formatContext, R = h.legacyContext, $ = h.context, Y = null;
      Y = h.componentStack;
      try {
        return ir(E, h, v);
      } catch (se) {
        if (Ph(), typeof se == "object" && se !== null && typeof se.then == "function") {
          Ng(E, h, se), h.blockedSegment.formatContext = D, h.legacyContext = R, h.context = $, jo($), h.componentStack = Y;
          return;
        } else
          throw h.blockedSegment.formatContext = D, h.legacyContext = R, h.context = $, jo($), h.componentStack = Y, se;
      }
    }
    function Mg(E, h, v, D) {
      var R = vc(E, D);
      if (h === null ? wc(E, D) : (h.pendingTasks--, h.forceClientRender || (h.forceClientRender = !0, h.errorDigest = R, jh(h, D), h.parentFlushed && E.clientRenderedBoundaries.push(h))), E.allPendingTasks--, E.allPendingTasks === 0) {
        var $ = E.onAllReady;
        $();
      }
    }
    function Sw(E) {
      var h = this, v = E.blockedBoundary, D = E.blockedSegment;
      D.status = Ua, Sc(h, v, D);
    }
    function Zh(E, h, v) {
      var D = E.blockedBoundary, R = E.blockedSegment;
      if (R.status = Ua, D === null)
        h.allPendingTasks--, h.status !== Gs && (h.status = Gs, h.destination !== null && m(h.destination));
      else {
        if (D.pendingTasks--, !D.forceClientRender) {
          D.forceClientRender = !0;
          var $ = v === void 0 ? new Error("The render was aborted by the server without a reason.") : v;
          D.errorDigest = h.onError($);
          {
            var Y = "The server did not finish this Suspense boundary: ";
            $ && typeof $.message == "string" ? $ = Y + $.message : $ = Y + String($);
            var se = mo;
            mo = E;
            try {
              jh(D, $);
            } finally {
              mo = se;
            }
          }
          D.parentFlushed && h.clientRenderedBoundaries.push(D);
        }
        if (D.fallbackAbortableTasks.forEach(function(ke) {
          return Zh(ke, h, v);
        }), D.fallbackAbortableTasks.clear(), h.allPendingTasks--, h.allPendingTasks === 0) {
          var Te = h.onAllReady;
          Te();
        }
      }
    }
    function Ba(E, h) {
      if (h.chunks.length === 0 && h.children.length === 1 && h.children[0].boundary === null) {
        var v = h.children[0];
        v.id = h.id, v.parentFlushed = !0, v.status === Vs && Ba(E, v);
      } else {
        var D = E.completedSegments;
        D.push(h);
      }
    }
    function Sc(E, h, v) {
      if (h === null) {
        if (v.parentFlushed) {
          if (E.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          E.completedRootSegment = v;
        }
        if (E.pendingRootTasks--, E.pendingRootTasks === 0) {
          E.onShellError = Na;
          var D = E.onShellReady;
          D();
        }
      } else if (h.pendingTasks--, !h.forceClientRender) {
        if (h.pendingTasks === 0)
          v.parentFlushed && v.status === Vs && Ba(h, v), h.parentFlushed && E.completedBoundaries.push(h), h.fallbackAbortableTasks.forEach(Sw, E), h.fallbackAbortableTasks.clear();
        else if (v.parentFlushed && v.status === Vs) {
          Ba(h, v);
          var R = h.completedSegments;
          R.length === 1 && h.parentFlushed && E.partialBoundaries.push(h);
        }
      }
      if (E.allPendingTasks--, E.allPendingTasks === 0) {
        var $ = E.onAllReady;
        $();
      }
    }
    function Tw(E, h) {
      var v = h.blockedSegment;
      if (v.status === bd) {
        jo(h.context);
        var D = null;
        D = mo, mo = h;
        try {
          ir(E, h, h.node), tr(v.chunks, E.responseState, v.lastPushedText, v.textEmbedded), h.abortSet.delete(h), v.status = Vs, Sc(E, h.blockedBoundary, v);
        } catch ($) {
          if (Ph(), typeof $ == "object" && $ !== null && typeof $.then == "function") {
            var R = h.ping;
            $.then(R, R);
          } else
            h.abortSet.delete(h), v.status = Eg, Mg(E, h.blockedBoundary, v, $);
        } finally {
          mo = D;
        }
      }
    }
    function Qh(E) {
      if (E.status !== Gs) {
        var h = mg(), v = gd.current;
        gd.current = pd;
        var D;
        D = yd.getCurrentStack, yd.getCurrentStack = Hi;
        var R = mc;
        md(E.responseState);
        try {
          var $ = E.pingedTasks, Y;
          for (Y = 0; Y < $.length; Y++) {
            var se = $[Y];
            Tw(E, se);
          }
          $.splice(0, Y), E.destination !== null && ep(E, E.destination);
        } catch (Te) {
          vc(E, Te), wc(E, Te);
        } finally {
          md(R), gd.current = v, yd.getCurrentStack = D, v === pd && jo(h);
        }
      }
    }
    function Tc(E, h, v) {
      switch (v.parentFlushed = !0, v.status) {
        case bd: {
          var D = v.id = E.nextSegmentId++;
          return v.lastPushedText = !1, v.textEmbedded = !1, ku(h, E.responseState, D);
        }
        case Vs: {
          v.status = $h;
          for (var R = !0, $ = v.chunks, Y = 0, se = v.children, Te = 0; Te < se.length; Te++) {
            for (var ke = se[Te]; Y < ke.index; Y++)
              d(h, $[Y]);
            R = _d(E, h, ke);
          }
          for (; Y < $.length - 1; Y++)
            d(h, $[Y]);
          return Y < $.length && (R = f(h, $[Y])), R;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function _d(E, h, v) {
      var D = v.boundary;
      if (D === null)
        return Tc(E, h, v);
      if (D.parentFlushed = !0, D.forceClientRender)
        return nr(h, E.responseState, D.errorDigest, D.errorMessage, D.errorComponentStack), Tc(E, h, v), gh(h, E.responseState);
      if (D.pendingTasks > 0) {
        D.rootSegmentID = E.nextSegmentId++, D.completedSegments.length > 0 && E.partialBoundaries.push(D);
        var R = D.id = hr(E.responseState);
        return Os(h, E.responseState, R), Tc(E, h, v), Fs(h, E.responseState);
      } else {
        if (D.byteSize > E.progressiveChunkSize)
          return D.rootSegmentID = E.nextSegmentId++, E.completedBoundaries.push(D), Os(h, E.responseState, D.id), Tc(E, h, v), Fs(h, E.responseState);
        Iu(h, E.responseState);
        var $ = D.completedSegments;
        if ($.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var Y = $[0];
        return _d(E, h, Y), Ou(h, E.responseState);
      }
    }
    function Bg(E, h, v) {
      return z0(h, E.responseState, v.id, v.errorDigest, v.errorMessage, v.errorComponentStack);
    }
    function Sd(E, h, v) {
      return pt(h, E.responseState, v.formatContext, v.id), _d(E, h, v), jt(h, v.formatContext);
    }
    function Lg(E, h, v) {
      for (var D = v.completedSegments, R = 0; R < D.length; R++) {
        var $ = D[R];
        Pg(E, h, v, $);
      }
      return D.length = 0, rg(h, E.responseState, v.id, v.rootSegmentID);
    }
    function Dw(E, h, v) {
      for (var D = v.completedSegments, R = 0; R < D.length; R++) {
        var $ = D[R];
        if (!Pg(E, h, v, $))
          return R++, D.splice(0, R), !1;
      }
      return D.splice(0, R), !0;
    }
    function Pg(E, h, v, D) {
      if (D.status === $h)
        return !0;
      var R = D.id;
      if (R === -1) {
        var $ = D.id = v.rootSegmentID;
        if ($ === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Sd(E, h, D);
      } else
        return Sd(E, h, D), U0(h, E.responseState, R);
    }
    function ep(E, h) {
      u();
      try {
        var v = E.completedRootSegment;
        v !== null && E.pendingRootTasks === 0 && (_d(E, h, v), E.completedRootSegment = null, hh(h, E.responseState));
        var D = E.clientRenderedBoundaries, R;
        for (R = 0; R < D.length; R++) {
          var $ = D[R];
          Bg(E, h, $);
        }
        D.splice(0, R);
        var Y = E.completedBoundaries;
        for (R = 0; R < Y.length; R++) {
          var se = Y[R];
          Lg(E, h, se);
        }
        Y.splice(0, R), p(h), u(h);
        var Te = E.partialBoundaries;
        for (R = 0; R < Te.length; R++) {
          var ke = Te[R];
          if (!Dw(E, h, ke)) {
            E.destination = null, R++, Te.splice(0, R);
            return;
          }
        }
        Te.splice(0, R);
        var We = E.completedBoundaries;
        for (R = 0; R < We.length; R++) {
          var He = We[R];
          Lg(E, h, He);
        }
        We.splice(0, R);
      } finally {
        p(h), E.allPendingTasks === 0 && E.pingedTasks.length === 0 && E.clientRenderedBoundaries.length === 0 && E.completedBoundaries.length === 0 && (E.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), m(h));
      }
    }
    function Wg(E) {
      a(function() {
        return Qh(E);
      });
    }
    function Ew(E, h) {
      if (E.status === qs) {
        E.status = Gs, w(h, E.fatalError);
        return;
      }
      if (E.status !== Gs && E.destination === null) {
        E.destination = h;
        try {
          ep(E, h);
        } catch (v) {
          vc(E, v), wc(E, v);
        }
      }
    }
    function zg(E, h) {
      try {
        var v = E.abortableTasks;
        v.forEach(function(D) {
          return Zh(D, E, h);
        }), v.clear(), E.destination !== null && ep(E, E.destination);
      } catch (D) {
        vc(E, D), wc(E, D);
      }
    }
    function Cw(E, h) {
      return new Promise(function(v, D) {
        var R, $, Y = new Promise(function(Ke, ut) {
          $ = Ke, R = ut;
        });
        function se() {
          var Ke = new ReadableStream(
            {
              type: "bytes",
              pull: function(ut) {
                Ew(ke, ut);
              },
              cancel: function(ut) {
                zg(ke);
              }
            },
            // $FlowFixMe size() methods are not allowed on byte streams.
            {
              highWaterMark: 0
            }
          );
          Ke.allReady = Y, v(Ke);
        }
        function Te(Ke) {
          Y.catch(function() {
          }), D(Ke);
        }
        var ke = vd(E, Ts(h ? h.identifierPrefix : void 0, h ? h.nonce : void 0, h ? h.bootstrapScriptContent : void 0, h ? h.bootstrapScripts : void 0, h ? h.bootstrapModules : void 0), Bi(h ? h.namespaceURI : void 0), h ? h.progressiveChunkSize : void 0, h ? h.onError : void 0, $, se, Te, R);
        if (h && h.signal) {
          var We = h.signal, He = function() {
            zg(ke, We.reason), We.removeEventListener("abort", He);
          };
          We.addEventListener("abort", He);
        }
        Wg(ke);
      });
    }
    My.renderToReadableStream = Cw, My.version = e;
  }()), My;
}
var lu, GT;
process.env.NODE_ENV === "production" ? (lu = jxe(), GT = Vxe()) : (lu = qxe(), GT = Gxe());
Du.version = lu.version;
Du.renderToString = lu.renderToString;
Du.renderToStaticMarkup = lu.renderToStaticMarkup;
Du.renderToNodeStream = lu.renderToNodeStream;
Du.renderToStaticNodeStream = lu.renderToStaticNodeStream;
Du.renderToReadableStream = GT.renderToReadableStream;
function Kxe(t) {
  const e = Du.renderToStaticMarkup(t), i = new DOMParser().parseFromString(e, "image/svg+xml").documentElement, o = [
    "svg",
    {
      ...Array.from(i.attributes).reduce((a, s) => (a[s.name] = s.value, a), {})
    }
  ];
  return Array.from(i.childNodes).forEach((a) => {
    if (a.nodeType === 1) {
      const s = [
        a.tagName.toLowerCase(),
        Array.from(a.attributes).reduce((l, c) => (l[c.name] = c.value, l), {})
      ];
      a.textContent && s.push(a.textContent), o.push(s);
    }
  }), o;
}
const Xxe = {
  audio: /* @__PURE__ */ z(SW, {}),
  video: /* @__PURE__ */ z(TW, {}),
  file: /* @__PURE__ */ z(DW, {}),
  image: /* @__PURE__ */ z(EW, {}),
  pdf: /* @__PURE__ */ z(sN, {}),
  word: /* @__PURE__ */ z(lN, {}),
  excel: /* @__PURE__ */ z(CW, {}),
  ppt: /* @__PURE__ */ z(kW, {})
};
function n7(t, e = !1) {
  const n = jle(t), r = Xxe[n] || /* @__PURE__ */ z(pn, {});
  return e ? Kxe(r) : r;
}
const Yxe = "_attachment_1x1ms_1", Jxe = "_wrap_1x1ms_2", J_ = {
  attachment: Yxe,
  wrap: Jxe
};
function Zxe({ editor: t, node: e, updateAttributes: n, deleteNode: r, extension: i }) {
  var A;
  const o = Wr(), a = WD(), { hasTrigger: s, fileName: l, fileSize: c, fileExt: u, fileType: d, url: f, error: p } = e.attrs, [m, g] = nt(!1), { t: b } = Wt(), y = (A = i == null ? void 0 : i.options) == null ? void 0 : A.upload, w = Et(() => {
    !a || f || a && o.current.click();
  }, [a, f]), x = Et(
    async (U) => {
      const P = U.target.files && U.target.files[0];
      if (!P)
        return;
      const V = {
        fileName: $le(P.name),
        fileSize: P.size,
        fileType: P.type,
        fileExt: Hle(P.name)
      };
      g(!0);
      try {
        const I = await y(P);
        n({ ...V, url: I }), g(!1);
      } catch (I) {
        n({ error: `File upload fail: ${I && I.message}` || "Unknown error" }), g(!1), o.current.value = "";
      }
    },
    [g, n]
  );
  Tt(() => {
    !f && !s && (w(), n({ hasTrigger: !0 }));
  }, [f, s, w, n]);
  const k = Et(() => r(), [t]);
  return a && !f ? /* @__PURE__ */ z(xl, { children: /* @__PURE__ */ Fe("div", { className: xo(J_.wrap, "render-wrapper"), children: [
    /* @__PURE__ */ z("p", { style: { cursor: "pointer" }, onClick: w, children: m ? /* @__PURE__ */ z("span", { children: b("editor.attachment.uploading") }) : /* @__PURE__ */ z("span", { children: b("editor.attachment.please_upload") }) }),
    /* @__PURE__ */ z("input", { ref: o, type: "file", hidden: !0, onChange: x })
  ] }) }) : f ? /* @__PURE__ */ z(xl, { children: /* @__PURE__ */ Fe("div", { className: xo(J_.wrap, "render-wrapper"), onClick: w, children: [
    /* @__PURE__ */ Fe("div", { className: "richtext-flex richtext-items-center richtext-gap-[4px]", children: [
      /* @__PURE__ */ z("span", { children: n7(d) }),
      /* @__PURE__ */ Fe("span", { children: [
        l,
        ".",
        u
      ] }),
      /* @__PURE__ */ Fe("span", { children: [
        "(",
        gM(c),
        ")"
      ] })
    ] }),
    /* @__PURE__ */ z(
      Je,
      {
        icon: "Trash2",
        action: k,
        tooltip: b("editor.delete")
      }
    )
  ] }) }) : p !== "null" ? /* @__PURE__ */ z(xl, { children: /* @__PURE__ */ z("div", { className: xo(J_.wrap, "render-wrapper"), onClick: w, children: /* @__PURE__ */ z("p", { children: p }) }) }) : /* @__PURE__ */ z(pn, {});
}
const c_e = rn.create({
  name: "attachment",
  content: "",
  marks: "",
  group: "block",
  selectable: !0,
  atom: !0,
  draggable: !0,
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      HTMLAttributes: {
        class: "attachment"
      },
      button: ({ editor: e, t: n }) => ({
        component: Je,
        componentProps: {
          action: () => e.chain().focus().setAttachment().run(),
          isActive: () => !1,
          disabled: !1,
          icon: "Attachment",
          tooltip: n("editor.attachment.tooltip")
        }
      })
    };
  },
  parseHTML() {
    return [{ tag: "div[class=attachment]" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    const {
      url: e = "",
      fileName: n = "",
      fileSize: r = "",
      fileType: i = "",
      fileExt: o = ""
    } = t || {};
    return [
      "div",
      bt(
        // @ts-expect-error
        this.options.HTMLAttributes || {},
        t || {}
      ),
      e ? [
        "a",
        { href: e || "#" },
        [
          "span",
          { class: "attachment__icon" },
          n7(i, !0)
        ],
        [
          "span",
          { class: "attachment__text" },
          `${n}.${o} (${gM(r)})`
        ]
      ] : ["div", { class: "attachment__placeholder" }]
    ];
  },
  addAttributes() {
    return {
      fileName: {
        default: null,
        parseHTML: Yi("filename")
      },
      fileSize: {
        default: null,
        parseHTML: Yi("filesize")
      },
      fileType: {
        default: null,
        parseHTML: Yi("filetype")
      },
      fileExt: {
        default: null,
        parseHTML: Yi("fileext")
      },
      url: {
        default: null,
        parseHTML: Yi("url")
      },
      hasTrigger: {
        default: !1,
        parseHTML: (t) => Yi("hastrigger")(t) === "true"
      },
      error: {
        default: null,
        parseHTML: Yi("error")
      }
    };
  },
  addCommands() {
    return {
      setAttachment: (t = {}) => ({ chain: e }) => e().insertContent({ type: this.name, attrs: t }).run()
    };
  },
  addNodeView() {
    return Vf(Zxe);
  }
}), By = {
  TOP_LEFT: "tl",
  TOP_RIGHT: "tr",
  BOTTOM_LEFT: "bl",
  BOTTOM_RIGHT: "br"
};
function Qxe(t) {
  var U, P;
  const [e, n] = nt({
    width: zb,
    height: zb
  }), [r, i] = nt({
    width: 0,
    height: 0
  }), [o] = nt([
    By.TOP_LEFT,
    By.TOP_RIGHT,
    By.BOTTOM_LEFT,
    By.BOTTOM_RIGHT
  ]), [a, s] = nt(!1), [l, c] = nt({
    x: 0,
    y: 0,
    w: 0,
    h: 0,
    dir: ""
  }), { align: u } = (U = t == null ? void 0 : t.node) == null ? void 0 : U.attrs, d = Yt(() => {
    var C;
    const { src: V, alt: I, width: le, height: be } = (C = t == null ? void 0 : t.node) == null ? void 0 : C.attrs, F = Gb(le) ? `${le}px` : le, G = Gb(be) ? `${be}px` : be;
    return {
      src: V || void 0,
      alt: I || void 0,
      style: {
        width: F || void 0,
        height: G || void 0
      }
    };
  }, [(P = t == null ? void 0 : t.node) == null ? void 0 : P.attrs]), f = Yt(() => {
    const {
      style: { width: V }
    } = d;
    return { width: V === "100%" ? V : void 0 };
  }, [d]);
  function p(V) {
    i({
      width: V.target.width,
      height: V.target.height
    });
  }
  function m() {
    const { editor: V, getPos: I } = t;
    V.commands.setNodeSelection(I());
  }
  const g = Et(
    am(() => {
      const { editor: V } = t, { width: I } = getComputedStyle(V.view.dom);
      n((le) => ({
        ...le,
        width: Number.parseInt(I, 10)
      }));
    }, $b),
    [t == null ? void 0 : t.editor]
  );
  function b(V, I) {
    V.preventDefault(), V.stopPropagation();
    const le = r.width, be = r.height, F = le / be;
    let G = Number(t.node.attrs.width), C = Number(t.node.attrs.height);
    const ie = e.width;
    G && !C ? (G = G > ie ? ie : G, C = Math.round(G / F)) : C && !G ? (G = Math.round(C * F), G = G > ie ? ie : G) : !G && !C ? (G = le > ie ? ie : le, C = Math.round(G / F)) : G = G > ie ? ie : G, jp(() => {
      s(!0), c({
        x: V.clientX,
        y: V.clientY,
        w: G,
        h: C,
        dir: I
      });
    });
  }
  const y = Et(
    am((V) => {
      if (V.preventDefault(), V.stopPropagation(), !a)
        return;
      const { x: I, w: le, dir: be } = l, F = (V.clientX - I) * (/l/.test(be) ? -1 : 1), G = H4(le + F, g4, e.width);
      t.updateAttributes({
        width: G,
        height: null
      });
    }, $b),
    [a, l, e, t.updateAttributes]
  ), w = Et(
    (V) => {
      V.preventDefault(), V.stopPropagation(), a && (jp(() => {
        c({
          x: 0,
          y: 0,
          w: 0,
          h: 0,
          dir: ""
        }), s(!1);
      }), m());
    },
    [a, m]
  ), x = Et(() => {
    document == null || document.addEventListener("mousemove", y, !0), document == null || document.addEventListener("mouseup", w, !0);
  }, [y, w]), k = Et(() => {
    document == null || document.removeEventListener("mousemove", y, !0), document == null || document.removeEventListener("mouseup", w, !0);
  }, [y, w]);
  Tt(() => (a ? x() : k(), () => {
    k();
  }), [a, x, k]);
  const A = Yt(() => new ResizeObserver(() => g()), [g]);
  return Tt(() => (A.observe(t.editor.view.dom), () => {
    A.disconnect();
  }), [t.editor.view.dom, A]), /* @__PURE__ */ z(xl, { className: "image-view", style: { ...f, width: "100%", textAlign: u }, children: /* @__PURE__ */ Fe(
    "div",
    {
      draggable: "true",
      "data-drag-handle": !0,
      className: `image-view__body ${t != null && t.selected ? "image-view__body--focused" : ""} ${a ? "image-view__body--resizing" : ""}`,
      style: f,
      children: [
        /* @__PURE__ */ z(
          "img",
          {
            src: d.src,
            alt: d.alt,
            style: d.style,
            height: "auto",
            className: "image-view__body__image block",
            onLoad: p,
            onClick: m
          }
        ),
        (t == null ? void 0 : t.editor.view.editable) && ((t == null ? void 0 : t.selected) || a) && /* @__PURE__ */ z("div", { className: "image-resizer", children: o == null ? void 0 : o.map((V) => /* @__PURE__ */ z(
          "span",
          {
            className: `image-resizer__handler image-resizer__handler--${V}`,
            onMouseDown: (I) => b(I, V)
          },
          `image-dir-${V}`
        )) })
      ]
    }
  ) });
}
function e2e({ selectImage: t, giphyApiKey: e, children: n }) {
  const [r, i] = nt([]), [o] = nt(15), a = Wr(null), s = (c, u = "search") => {
    if (!e)
      return;
    const f = `${u === "search" ? `https://api.giphy.com/v1/gifs/search?q=${c}` : `https://api.giphy.com/v1/gifs/trending?q=${c}`}&limit=${o}&api_key=${e}`;
    fetch(f).then((p) => p.json()).then((p) => {
      i(p.data);
    }).catch((p) => {
      console.log(p);
    });
  };
  Tt(() => {
    s("", "trend");
  }, []);
  const l = Et(
    k1((c) => {
      if (!c.target.value) {
        s("", "trend");
        return;
      }
      s(c.target.value);
    }, 350),
    // Adjust the debounce delay as needed
    []
  );
  return /* @__PURE__ */ Fe(Eo, { modal: !0, children: [
    /* @__PURE__ */ z(Co, { asChild: !0, children: n }),
    /* @__PURE__ */ z(oo, { hideWhenDetached: !0, className: "richtext-w-full richtext-h-full richtext-p-2", align: "start", side: "bottom", children: e ? /* @__PURE__ */ Fe(pn, { children: [
      /* @__PURE__ */ z("div", { className: "richtext-w-full richtext-mb-[10px]", children: /* @__PURE__ */ z(
        Pr,
        {
          ref: a,
          type: "text",
          placeholder: "Search GIF",
          onChange: l
        }
      ) }),
      /* @__PURE__ */ z("div", { className: "richtext-max-h-[280px] richtext-overflow-y-auto", children: /* @__PURE__ */ z("div", { className: "richtext-grid richtext-grid-cols-2 richtext-gap-1 ", children: r != null && r.length ? r == null ? void 0 : r.map((c) => /* @__PURE__ */ z(
        "img",
        {
          alt: "giphy",
          className: "richtext-text-center richtext-cursor-pointer",
          onClick: (u) => t(c),
          height: c.images.fixed_width_downsampled.height,
          width: c.images.fixed_width_downsampled.width,
          src: c.images.fixed_width_downsampled.url
        },
        `giphy-${c.id}`
      )) : /* @__PURE__ */ z("p", { children: "No GIFs found" }) }) })
    ] }) : /* @__PURE__ */ z("div", { children: /* @__PURE__ */ z("p", { children: "Missing Giphy API Key" }) }) })
  ] });
}
function t2e({ editor: t, icon: e, giphyApiKey: n, ...r }) {
  return /* @__PURE__ */ z(
    e2e,
    {
      selectImage: (o) => {
        const { url: a } = o.images.original;
        t.chain().focus().setImageGif({ src: a }).run();
      },
      giphyApiKey: n,
      children: /* @__PURE__ */ z(
        Je,
        {
          tooltip: r == null ? void 0 : r.tooltip,
          icon: e
        }
      )
    }
  );
}
const r7 = mM.extend({
  name: "imageGif",
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      inline: !1,
      content: "",
      marks: "",
      group: "block",
      GIPHY_API_KEY: "",
      draggable: !1,
      selectable: !0,
      atom: !0,
      button: ({ editor: e, extension: n, t: r }) => {
        var o;
        const i = ((o = n == null ? void 0 : n.options) == null ? void 0 : o.GIPHY_API_KEY) || "";
        return {
          component: t2e,
          componentProps: {
            editor: e,
            action: () => {
            },
            isActive: () => !1,
            disabled: !1,
            icon: "GifIcon",
            tooltip: r("editor.imageGif.tooltip"),
            giphyApiKey: i
          }
        };
      }
    };
  },
  addAttributes() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      width: {
        default: null,
        parseHTML: (e) => {
          const n = e.style.width || e.getAttribute("width") || "10";
          return n === void 0 ? null : Number.parseInt(`${n}`, 10);
        },
        renderHTML: (e) => ({
          width: e.width
        })
      },
      align: {
        default: "center",
        parseHTML: (e) => e.getAttribute("align"),
        renderHTML: (e) => ({
          align: e.align
        })
      }
    };
  },
  addNodeView() {
    return Vf(Qxe);
  },
  addCommands() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      setImageGif: (e) => ({ commands: n }) => n.insertContent({
        type: this.name,
        attrs: e
      }),
      updateImageGif: (e) => ({ commands: n }) => n.updateAttributes(this.name, e),
      setAlignImageGif: (e) => ({ commands: n }) => n.updateAttributes(this.name, { align: e })
    };
  },
  renderHTML({ HTMLAttributes: t }) {
    const { align: e } = t;
    return [
      "div",
      // Parent element
      {
        style: e ? `text-align: ${e};` : "",
        class: "imageGIf"
      },
      [
        "img",
        bt(
          // Always render the `height="auto"`
          {
            height: "auto"
          },
          this.options.HTMLAttributes,
          t
        )
      ]
    ];
  },
  parseHTML() {
    return [
      {
        tag: "div[class=imageGIf]",
        getAttrs: (t) => {
          const e = t.querySelector("img"), n = e == null ? void 0 : e.getAttribute("width");
          return {
            src: e == null ? void 0 : e.getAttribute("src"),
            alt: e == null ? void 0 : e.getAttribute("alt"),
            title: e == null ? void 0 : e.getAttribute("title"),
            width: n ? Number.parseInt(n, 10) : null,
            align: (e == null ? void 0 : e.getAttribute("align")) || t.style.textAlign || null
          };
        }
      }
    ];
  }
});
function u_e() {
  var o;
  const t = Wr({ editor: null }), [e, n] = nt(!1), [r, i] = nt(null);
  return Tt(() => {
    var a;
    (a = t.current) != null && a.editor && (n(!0), i(t.current.editor));
  }, [t, (o = t.current) == null ? void 0 : o.editor]), { isReady: e, editor: r, editorRef: t };
}
export {
  c_e as Attachment,
  W2e as BaseKit,
  N2e as Blockquote,
  w2e as Bold,
  hs as BubbleMenu,
  I2e as BulletList,
  O2e as Clear,
  T2e as Code,
  A2e as Color,
  vE as Column,
  P2e as ColumnActionButton,
  Y2e as Emoji,
  J2e as ExportPdf,
  a_e as ExportWord,
  D2e as FontFamily,
  k2e as FontSize,
  K2e as FormatPainter,
  E2e as Heading,
  R2e as Highlight,
  L2e as History,
  B2e as HorizontalRule,
  jd as Iframe,
  nce as Image,
  r7 as ImageGif,
  Z2e as ImportWord,
  H2e as Indent,
  x2e as Italic,
  j2e as LineHeight,
  M2e as Link,
  l_e as Mention,
  $2e as MoreMark,
  bm as MultiColumn,
  F2e as OrderedList,
  Eue as SearchAndReplace,
  V2e as SlashCommand,
  S2e as Strike,
  z2e as SubAndSuperScript,
  G2e as Table,
  Uxe as TableOfContents,
  U2e as TaskList,
  C2e as TextAlign,
  s_e as TextDirection,
  GS as Twitter,
  _2e as Underline,
  ace as Video,
  v2e as default,
  hZ as en,
  xZ as hu_HU,
  b2e as locale,
  mZ as pt_BR,
  u_e as useEditorState,
  yZ as vi,
  vZ as zh_CN
};

import um, { useSyncExternalStore as r_ } from "react";
function dn(t) {
  this.content = t;
}
dn.prototype = {
  constructor: dn,
  find: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t) return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(t, e, n) {
    var r = n && n != t ? this.remove(n) : this, i = r.find(t), o = r.content.slice();
    return i == -1 ? o.push(n || t, e) : (o[i + 1] = e, n && (o[i] = n)), new dn(o);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(t) {
    var e = this.find(t);
    if (e == -1) return this;
    var n = this.content.slice();
    return n.splice(e, 2), new dn(n);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(t, e) {
    return new dn([t, e].concat(this.remove(t).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(t, e) {
    var n = this.remove(t).content.slice();
    return n.push(t, e), new dn(n);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(t, e, n) {
    var r = this.remove(e), i = r.content.slice(), o = r.find(t);
    return i.splice(o == -1 ? i.length : o, 0, e, n), new dn(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(t) {
    return t = dn.from(t), t.size ? new dn(t.content.concat(this.subtract(t).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(t) {
    return t = dn.from(t), t.size ? new dn(this.subtract(t).content.concat(t.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(t) {
    var e = this;
    t = dn.from(t);
    for (var n = 0; n < t.content.length; n += 2)
      e = e.remove(t.content[n]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var t = {};
    return this.forEach(function(e, n) {
      t[e] = n;
    }), t;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
dn.from = function(t) {
  if (t instanceof dn) return t;
  var e = [];
  if (t) for (var n in t) e.push(n, t[n]);
  return new dn(e);
};
function i_(t, e, n) {
  for (let r = 0; ; r++) {
    if (r == t.childCount || r == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let i = t.child(r), o = e.child(r);
    if (i == o) {
      n += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(o))
      return n;
    if (i.isText && i.text != o.text) {
      for (let a = 0; i.text[a] == o.text[a]; a++)
        n++;
      return n;
    }
    if (i.content.size || o.content.size) {
      let a = i_(i.content, o.content, n + 1);
      if (a != null)
        return a;
    }
    n += i.nodeSize;
  }
}
function o_(t, e, n, r) {
  for (let i = t.childCount, o = e.childCount; ; ) {
    if (i == 0 || o == 0)
      return i == o ? null : { a: n, b: r };
    let a = t.child(--i), s = e.child(--o), l = a.nodeSize;
    if (a == s) {
      n -= l, r -= l;
      continue;
    }
    if (!a.sameMarkup(s))
      return { a: n, b: r };
    if (a.isText && a.text != s.text) {
      let u = 0, f = Math.min(a.text.length, s.text.length);
      for (; u < f && a.text[a.text.length - u - 1] == s.text[s.text.length - u - 1]; )
        u++, n--, r--;
      return { a: n, b: r };
    }
    if (a.content.size || s.content.size) {
      let u = o_(a.content, s.content, n - 1, r - 1);
      if (u)
        return u;
    }
    n -= l, r -= l;
  }
}
class Fe {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, r, i = 0, o) {
    for (let a = 0, s = 0; s < n; a++) {
      let l = this.content[a], u = s + l.nodeSize;
      if (u > e && r(l, i + s, o || null, a) !== !1 && l.content.size) {
        let f = s + 1;
        l.nodesBetween(Math.max(0, e - f), Math.min(l.content.size, n - f), r, i + f);
      }
      s = u;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, r, i) {
    let o = "", a = !0;
    return this.nodesBetween(e, n, (s, l) => {
      let u = s.isText ? s.text.slice(Math.max(e, l) - l, n - l) : s.isLeaf ? i ? typeof i == "function" ? i(s) : i : s.type.spec.leafText ? s.type.spec.leafText(s) : "" : "";
      s.isBlock && (s.isLeaf && u || s.isTextblock) && r && (a ? a = !1 : o += r), o += u;
    }, 0), o;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, r = e.firstChild, i = this.content.slice(), o = 0;
    for (n.isText && n.sameMarkup(r) && (i[i.length - 1] = n.withText(n.text + r.text), o = 1); o < e.content.length; o++)
      i.push(e.content[o]);
    return new Fe(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let r = [], i = 0;
    if (n > e)
      for (let o = 0, a = 0; a < n; o++) {
        let s = this.content[o], l = a + s.nodeSize;
        l > e && ((a < e || l > n) && (s.isText ? s = s.cut(Math.max(0, e - a), Math.min(s.text.length, n - a)) : s = s.cut(Math.max(0, e - a - 1), Math.min(s.content.size, n - a - 1))), r.push(s), i += s.nodeSize), a = l;
      }
    return new Fe(r, i);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? Fe.empty : e == 0 && n == this.content.length ? this : new Fe(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let r = this.content[e];
    if (r == n)
      return this;
    let i = this.content.slice(), o = this.size + n.nodeSize - r.nodeSize;
    return i[e] = n, new Fe(i, o);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new Fe([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new Fe(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let i = this.content[n];
      e(i, r, n), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return i_(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, r = e.size) {
    return o_(this, e, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e, n = -1) {
    if (e == 0)
      return $h(0, e);
    if (e == this.size)
      return $h(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let r = 0, i = 0; ; r++) {
      let o = this.child(r), a = i + o.nodeSize;
      if (a >= e)
        return a == e || n > 0 ? $h(r + 1, a) : $h(r, i);
      i = a;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return Fe.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fe(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return Fe.empty;
    let n, r = 0;
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      r += o.nodeSize, i && o.isText && e[i - 1].sameMarkup(o) ? (n || (n = e.slice(0, i)), n[n.length - 1] = o.withText(n[n.length - 1].text + o.text)) : n && n.push(o);
    }
    return new Fe(n || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return Fe.empty;
    if (e instanceof Fe)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new Fe([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Fe.empty = new Fe([], 0);
const pb = { index: 0, offset: 0 };
function $h(t, e) {
  return pb.index = t, pb.offset = e, pb;
}
function zp(t, e) {
  if (t === e)
    return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object"))
    return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n)
    return !1;
  if (n) {
    if (t.length != e.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (!zp(t[r], e[r]))
        return !1;
  } else {
    for (let r in t)
      if (!(r in e) || !zp(t[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in t))
        return !1;
  }
  return !0;
}
class mt {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n, r = !1;
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      if (this.eq(o))
        return e;
      if (this.type.excludes(o.type))
        n || (n = e.slice(0, i));
      else {
        if (o.type.excludes(this.type))
          return e;
        !r && o.type.rank > this.type.rank && (n || (n = e.slice(0, i)), n.push(this), r = !0), n && n.push(o);
      }
    }
    return n || (n = e.slice()), r || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && zp(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let i = r.create(n.attrs);
    return r.checkAttrs(i.attrs), i;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n)
      return !0;
    if (e.length != n.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(n[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return mt.none;
    if (e instanceof mt)
      return [e];
    let n = e.slice();
    return n.sort((r, i) => r.type.rank - i.type.rank), n;
  }
}
mt.none = [];
class $p extends Error {
}
class We {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, r) {
    this.content = e, this.openStart = n, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let r = s_(this.content, e + this.openStart, n);
    return r && new We(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new We(a_(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return We.empty;
    let r = n.openStart || 0, i = n.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new We(Fe.fromJSON(e, n.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let r = 0, i = 0;
    for (let o = e.firstChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.firstChild)
      r++;
    for (let o = e.lastChild; o && !o.isLeaf && (n || !o.type.spec.isolating); o = o.lastChild)
      i++;
    return new We(e, r, i);
  }
}
We.empty = new We(Fe.empty, 0, 0);
function a_(t, e, n) {
  let { index: r, offset: i } = t.findIndex(e), o = t.maybeChild(r), { index: a, offset: s } = t.findIndex(n);
  if (i == e || o.isText) {
    if (s != n && !t.child(a).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (r != a)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(r, o.copy(a_(o.content, e - i - 1, n - i - 1)));
}
function s_(t, e, n, r) {
  let { index: i, offset: o } = t.findIndex(e), a = t.maybeChild(i);
  if (o == e || a.isText)
    return t.cut(0, e).append(n).append(t.cut(e));
  let s = s_(a.content, e - o - 1, n);
  return s && t.replaceChild(i, a.copy(s));
}
function k8(t, e, n) {
  if (n.openStart > t.depth)
    throw new $p("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new $p("Inconsistent open depths");
  return l_(t, e, n, 0);
}
function l_(t, e, n, r) {
  let i = t.index(r), o = t.node(r);
  if (i == e.index(r) && r < t.depth - n.openStart) {
    let a = l_(t, e, n, r + 1);
    return o.copy(o.content.replaceChild(i, a));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
      let a = t.parent, s = a.content;
      return tl(a, s.cut(0, t.parentOffset).append(n.content).append(s.cut(e.parentOffset)));
    } else {
      let { start: a, end: s } = A8(n, t);
      return tl(o, u_(t, a, s, e, r));
    }
  else return tl(o, jp(t, e, r));
}
function c_(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new $p("Cannot join " + e.type.name + " onto " + t.type.name);
}
function _1(t, e, n) {
  let r = t.node(n);
  return c_(r, e.node(n)), r;
}
function el(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t);
}
function qf(t, e, n, r) {
  let i = (e || t).node(n), o = 0, a = e ? e.index(n) : i.childCount;
  t && (o = t.index(n), t.depth > n ? o++ : t.textOffset && (el(t.nodeAfter, r), o++));
  for (let s = o; s < a; s++)
    el(i.child(s), r);
  e && e.depth == n && e.textOffset && el(e.nodeBefore, r);
}
function tl(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function u_(t, e, n, r, i) {
  let o = t.depth > i && _1(t, e, i + 1), a = r.depth > i && _1(n, r, i + 1), s = [];
  return qf(null, t, i, s), o && a && e.index(i) == n.index(i) ? (c_(o, a), el(tl(o, u_(t, e, n, r, i + 1)), s)) : (o && el(tl(o, jp(t, e, i + 1)), s), qf(e, n, i, s), a && el(tl(a, jp(n, r, i + 1)), s)), qf(r, null, i, s), new Fe(s);
}
function jp(t, e, n) {
  let r = [];
  if (qf(null, t, n, r), t.depth > n) {
    let i = _1(t, e, n + 1);
    el(tl(i, jp(t, e, n + 1)), r);
  }
  return qf(e, null, n, r), new Fe(r);
}
function A8(t, e) {
  let n = e.depth - t.openStart, i = e.node(n).copy(t.content);
  for (let o = n - 1; o >= 0; o--)
    i = e.node(o).copy(Fe.from(i));
  return {
    start: i.resolveNoCache(t.openStart + n),
    end: i.resolveNoCache(i.content.size - t.openEnd - n)
  };
}
class ad {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, n = this.index(this.depth);
    if (n == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = e.child(n);
    return r ? e.child(n).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3], i = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let o = 0; o < e; o++)
      i += r.child(o).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, n = this.index();
    if (e.content.size == 0)
      return mt.none;
    if (this.textOffset)
      return e.child(n).marks;
    let r = e.maybeChild(n - 1), i = e.maybeChild(n);
    if (!r) {
      let s = r;
      r = i, i = s;
    }
    let o = r.marks;
    for (var a = 0; a < o.length; a++)
      o[a].type.spec.inclusive === !1 && (!i || !o[a].isInSet(i.marks)) && (o = o[a--].removeFromSet(o));
    return o;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let r = n.marks, i = e.parent.maybeChild(e.index());
    for (var o = 0; o < r.length; o++)
      r[o].type.spec.inclusive === !1 && (!i || !r[o].isInSet(i.marks)) && (r = r[o--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!n || n(this.node(r))))
        return new Hp(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [], i = 0, o = n;
    for (let a = e; ; ) {
      let { index: s, offset: l } = a.content.findIndex(o), u = o - l;
      if (r.push(a, s, i + l), !u || (a = a.child(s), a.isText))
        break;
      o = u - 1, i += l + 1;
    }
    return new ad(n, r, o);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    let r = mD.get(e);
    if (r)
      for (let o = 0; o < r.elts.length; o++) {
        let a = r.elts[o];
        if (a.pos == n)
          return a;
      }
    else
      mD.set(e, r = new U8());
    let i = r.elts[r.i] = ad.resolve(e, n);
    return r.i = (r.i + 1) % F8, i;
  }
}
class U8 {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const F8 = 12, mD = /* @__PURE__ */ new WeakMap();
class Hp {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const R8 = /* @__PURE__ */ Object.create(null);
let nl = class k1 {
  /**
  @internal
  */
  constructor(e, n, r, i = mt.none) {
    this.type = e, this.attrs = n, this.marks = i, this.content = r || Fe.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, n, r, i = 0) {
    this.content.nodesBetween(e, n, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, n, r, i) {
    return this.content.textBetween(e, n, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, r) {
    return this.type == e && zp(this.attrs, n || e.defaultAttrs || R8) && mt.sameSet(this.marks, r || mt.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new k1(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new k1(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, r = !1) {
    if (e == n)
      return We.empty;
    let i = this.resolve(e), o = this.resolve(n), a = r ? 0 : i.sharedDepth(n), s = i.start(a), u = i.node(a).content.cut(i.pos - s, o.pos - s);
    return new We(u, i.depth - a, o.depth - a);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, r) {
    return k8(this.resolve(e), this.resolve(n), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: r, offset: i } = n.content.findIndex(e);
      if (n = n.maybeChild(r), !n)
        return null;
      if (i == e || n.isText)
        return n;
      e -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(n), index: n, offset: r };
    let i = this.content.child(n - 1);
    return { node: i, index: n - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return ad.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return ad.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, r) {
    let i = !1;
    return n > e && this.nodesBetween(e, n, (o) => (r.isInSet(o.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), f_(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, r = Fe.empty, i = 0, o = r.childCount) {
    let a = this.contentMatchAt(e).matchFragment(r, i, o), s = a && a.matchFragment(this.content, n);
    if (!s || !s.validEnd)
      return !1;
    for (let l = i; l < o; l++)
      if (!this.type.allowsMarks(r.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let o = this.contentMatchAt(e).matchType(r), a = o && o.matchFragment(this.content, n);
    return a ? a.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = mt.none;
    for (let n = 0; n < this.marks.length; n++) {
      let r = this.marks[n];
      r.type.checkAttrs(r.attrs), e = r.addToSet(e);
    }
    if (!mt.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, r);
    }
    let i = Fe.fromJSON(e, n.content), o = e.nodeType(n.type).create(n.attrs, i, r);
    return o.type.checkAttrs(o.attrs), o;
  }
};
nl.prototype.text = void 0;
class Vp extends nl {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    if (super(e, n, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : f_(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new Vp(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new Vp(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function f_(t, e) {
  for (let n = t.length - 1; n >= 0; n--)
    e = t[n].type.name + "(" + e + ")";
  return e;
}
class cl {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, n) {
    let r = new O8(e, n);
    if (r.next == null)
      return cl.empty;
    let i = d_(r);
    r.next && r.err("Unexpected trailing text");
    let o = L8(W8(i));
    return z8(o, r), o;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, n = 0, r = e.childCount) {
    let i = this;
    for (let o = n; i && o < r; o++)
      i = i.matchType(e.child(o).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[n].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, n = !1, r = 0) {
    let i = [this];
    function o(a, s) {
      let l = a.matchFragment(e, r);
      if (l && (!n || l.validEnd))
        return Fe.from(s.map((u) => u.createAndFill()));
      for (let u = 0; u < a.next.length; u++) {
        let { type: f, next: h } = a.next[u];
        if (!(f.isText || f.hasRequiredAttrs()) && i.indexOf(h) == -1) {
          i.push(h);
          let p = o(h, s.concat(f));
          if (p)
            return p;
        }
      }
      return null;
    }
    return o(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let n = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), o = i.match;
      if (o.matchType(e)) {
        let a = [];
        for (let s = i; s.type; s = s.via)
          a.push(s.type);
        return a.reverse();
      }
      for (let a = 0; a < o.next.length; a++) {
        let { type: s, next: l } = o.next[a];
        !s.isLeaf && !s.hasRequiredAttrs() && !(s.name in n) && (!i.type || l.validEnd) && (r.push({ match: s.contentMatch, type: s, via: i }), n[s.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function n(r) {
      e.push(r);
      for (let i = 0; i < r.next.length; i++)
        e.indexOf(r.next[i].next) == -1 && n(r.next[i].next);
    }
    return n(this), e.map((r, i) => {
      let o = i + (r.validEnd ? "*" : " ") + " ";
      for (let a = 0; a < r.next.length; a++)
        o += (a ? ", " : "") + r.next[a].type.name + "->" + e.indexOf(r.next[a].next);
      return o;
    }).join(`
`);
  }
}
cl.empty = new cl(!0);
class O8 {
  constructor(e, n) {
    this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function d_(t) {
  let e = [];
  do
    e.push(I8(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function I8(t) {
  let e = [];
  do
    e.push(B8(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function B8(t) {
  let e = P8(t);
  for (; ; )
    if (t.eat("+"))
      e = { type: "plus", expr: e };
    else if (t.eat("*"))
      e = { type: "star", expr: e };
    else if (t.eat("?"))
      e = { type: "opt", expr: e };
    else if (t.eat("{"))
      e = M8(t, e);
    else
      break;
  return e;
}
function yD(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function M8(t, e) {
  let n = yD(t), r = n;
  return t.eat(",") && (t.next != "}" ? r = yD(t) : r = -1), t.eat("}") || t.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: e };
}
function N8(t, e) {
  let n = t.nodeTypes, r = n[e];
  if (r)
    return [r];
  let i = [];
  for (let o in n) {
    let a = n[o];
    a.isInGroup(e) && i.push(a);
  }
  return i.length == 0 && t.err("No node type or group '" + e + "' found"), i;
}
function P8(t) {
  if (t.eat("(")) {
    let e = d_(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next))
    t.err("Unexpected token '" + t.next + "'");
  else {
    let e = N8(t, t.next).map((n) => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"), { type: "name", value: n }));
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function W8(t) {
  let e = [[]];
  return i(o(t, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function r(a, s, l) {
    let u = { term: l, to: s };
    return e[a].push(u), u;
  }
  function i(a, s) {
    a.forEach((l) => l.to = s);
  }
  function o(a, s) {
    if (a.type == "choice")
      return a.exprs.reduce((l, u) => l.concat(o(u, s)), []);
    if (a.type == "seq")
      for (let l = 0; ; l++) {
        let u = o(a.exprs[l], s);
        if (l == a.exprs.length - 1)
          return u;
        i(u, s = n());
      }
    else if (a.type == "star") {
      let l = n();
      return r(s, l), i(o(a.expr, l), l), [r(l)];
    } else if (a.type == "plus") {
      let l = n();
      return i(o(a.expr, s), l), i(o(a.expr, l), l), [r(l)];
    } else {
      if (a.type == "opt")
        return [r(s)].concat(o(a.expr, s));
      if (a.type == "range") {
        let l = s;
        for (let u = 0; u < a.min; u++) {
          let f = n();
          i(o(a.expr, l), f), l = f;
        }
        if (a.max == -1)
          i(o(a.expr, l), l);
        else
          for (let u = a.min; u < a.max; u++) {
            let f = n();
            r(l, f), i(o(a.expr, l), f), l = f;
          }
        return [r(l)];
      } else {
        if (a.type == "name")
          return [r(s, void 0, a.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function h_(t, e) {
  return e - t;
}
function bD(t, e) {
  let n = [];
  return r(e), n.sort(h_);
  function r(i) {
    let o = t[i];
    if (o.length == 1 && !o[0].term)
      return r(o[0].to);
    n.push(i);
    for (let a = 0; a < o.length; a++) {
      let { term: s, to: l } = o[a];
      !s && n.indexOf(l) == -1 && r(l);
    }
  }
}
function L8(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return n(bD(t, 0));
  function n(r) {
    let i = [];
    r.forEach((a) => {
      t[a].forEach(({ term: s, to: l }) => {
        if (!s)
          return;
        let u;
        for (let f = 0; f < i.length; f++)
          i[f][0] == s && (u = i[f][1]);
        bD(t, l).forEach((f) => {
          u || i.push([s, u = []]), u.indexOf(f) == -1 && u.push(f);
        });
      });
    });
    let o = e[r.join(",")] = new cl(r.indexOf(t.length - 1) > -1);
    for (let a = 0; a < i.length; a++) {
      let s = i[a][1].sort(h_);
      o.next.push({ type: i[a][0], next: e[s.join(",")] || n(s) });
    }
    return o;
  }
}
function z8(t, e) {
  for (let n = 0, r = [t]; n < r.length; n++) {
    let i = r[n], o = !i.validEnd, a = [];
    for (let s = 0; s < i.next.length; s++) {
      let { type: l, next: u } = i.next[s];
      a.push(l.name), o && !(l.isText || l.hasRequiredAttrs()) && (o = !1), r.indexOf(u) == -1 && r.push(u);
    }
    o && e.err("Only non-generatable nodes (" + a.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function p_(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let r = t[n];
    if (!r.hasDefault)
      return null;
    e[n] = r.default;
  }
  return e;
}
function g_(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let i = e && e[r];
    if (i === void 0) {
      let o = t[r];
      if (o.hasDefault)
        i = o.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = i;
  }
  return n;
}
function m_(t, e, n, r) {
  for (let i in e)
    if (!(i in t))
      throw new RangeError(`Unsupported attribute ${i} for ${n} of type ${i}`);
  for (let i in t) {
    let o = t[i];
    o.validate && o.validate(e[i]);
  }
}
function y_(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let r in e)
      n[r] = new j8(t, r, e[r]);
  return n;
}
let vD = class b_ {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.name = e, this.schema = n, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = y_(e, r.attrs), this.defaultAttrs = p_(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == cl.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : g_(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new nl(this, this.computeAttrs(e), Fe.from(n), mt.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, n, r) {
    return n = Fe.from(n), this.checkContent(n), new nl(this, this.computeAttrs(e), n, mt.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, n, r) {
    if (e = this.computeAttrs(e), n = Fe.from(n), n.size) {
      let a = this.contentMatch.fillBefore(n);
      if (!a)
        return null;
      n = a.append(n);
    }
    let i = this.contentMatch.matchFragment(n), o = i && i.fillBefore(Fe.empty, !0);
    return o ? new nl(this, e, n.append(o), mt.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    m_(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let n;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r));
    return n ? n.length ? n : mt.none : e;
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((o, a) => r[o] = new b_(o, n, a));
    let i = n.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let o in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function $8(t, e, n) {
  let r = n.split("|");
  return (i) => {
    let o = i === null ? "null" : typeof i;
    if (r.indexOf(o) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${t}, got ${o}`);
  };
}
class j8 {
  constructor(e, n, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? $8(e, n, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class fm {
  /**
  @internal
  */
  constructor(e, n, r, i) {
    this.name = e, this.rank = n, this.schema = r, this.spec = i, this.attrs = y_(e, i.attrs), this.excluded = null;
    let o = p_(this.attrs);
    this.instance = o ? new mt(this, o) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new mt(this, g_(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((o, a) => r[o] = new fm(o, i++, n, a)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].type == this)
        return e[n];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    m_(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class VG {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let i in e)
      n[i] = e[i];
    n.nodes = dn.from(e.nodes), n.marks = dn.from(e.marks || {}), this.nodes = vD.compile(this.spec.nodes, this), this.marks = fm.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let o = this.nodes[i], a = o.spec.content || "", s = o.spec.marks;
      if (o.contentMatch = r[a] || (r[a] = cl.parse(a, this.nodes)), o.inlineContent = o.contentMatch.inlineContent, o.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!o.isInline || !o.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = o;
      }
      o.markSet = s == "_" ? null : s ? xD(this, s.split(" ")) : s == "" || !o.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let o = this.marks[i], a = o.spec.excludes;
      o.excluded = a == null ? [o] : a == "" ? [] : xD(this, a.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, n = null, r, i) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof vD) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, n) {
    let r = this.nodes.text;
    return new Vp(r, r.defaultAttrs, e, mt.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return nl.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return mt.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let n = this.nodes[e];
    if (!n)
      throw new RangeError("Unknown node type: " + e);
    return n;
  }
}
function xD(t, e) {
  let n = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r], o = t.marks[i], a = o;
    if (o)
      n.push(o);
    else
      for (let s in t.marks) {
        let l = t.marks[s];
        (i == "_" || l.spec.group && l.spec.group.split(" ").indexOf(i) > -1) && n.push(a = l);
      }
    if (!a)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return n;
}
function H8(t) {
  return t.tag != null;
}
function V8(t) {
  return t.style != null;
}
let v_ = class A1 {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    this.schema = e, this.rules = n, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    n.forEach((i) => {
      if (H8(i))
        this.tags.push(i);
      else if (V8(i)) {
        let o = /[^=]*/.exec(i.style)[0];
        r.indexOf(o) < 0 && r.push(o), this.styles.push(i);
      }
    }), this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
        return !1;
      let o = e.nodes[i.node];
      return o.contentMatch.matchType(o);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let r = new wD(this, n, !1);
    return r.addAll(e, mt.none, n.from, n.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let r = new wD(this, n, !0);
    return r.addAll(e, mt.none, n.from, n.to), We.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let o = this.tags[i];
      if (G8(e, o.tag) && (o.namespace === void 0 || e.namespaceURI == o.namespace) && (!o.context || n.matchesContext(o.context))) {
        if (o.getAttrs) {
          let a = o.getAttrs(e);
          if (a === !1)
            continue;
          o.attrs = a || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, r, i) {
    for (let o = i ? this.styles.indexOf(i) + 1 : 0; o < this.styles.length; o++) {
      let a = this.styles[o], s = a.style;
      if (!(s.indexOf(e) != 0 || a.context && !r.matchesContext(a.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      s.length > e.length && (s.charCodeAt(e.length) != 61 || s.slice(e.length + 1) != n))) {
        if (a.getAttrs) {
          let l = a.getAttrs(n);
          if (l === !1)
            continue;
          a.attrs = l || void 0;
        }
        return a;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function r(i) {
      let o = i.priority == null ? 50 : i.priority, a = 0;
      for (; a < n.length; a++) {
        let s = n[a];
        if ((s.priority == null ? 50 : s.priority) < o)
          break;
      }
      n.splice(a, 0, i);
    }
    for (let i in e.marks) {
      let o = e.marks[i].spec.parseDOM;
      o && o.forEach((a) => {
        r(a = SD(a)), a.mark || a.ignore || a.clearMark || (a.mark = i);
      });
    }
    for (let i in e.nodes) {
      let o = e.nodes[i].spec.parseDOM;
      o && o.forEach((a) => {
        r(a = SD(a)), a.node || a.ignore || a.mark || (a.node = i);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new A1(e, A1.schemaRules(e)));
  }
};
const x_ = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, q8 = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, D_ = { ol: !0, ul: !0 }, sd = 1, U1 = 2, Xf = 4;
function DD(t, e, n) {
  return e != null ? (e ? sd : 0) | (e === "full" ? U1 : 0) : t && t.whitespace == "pre" ? sd | U1 : n & ~Xf;
}
class jh {
  constructor(e, n, r, i, o, a) {
    this.type = e, this.attrs = n, this.marks = r, this.solid = i, this.options = a, this.content = [], this.activeMarks = mt.none, this.match = o || (a & Xf ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(Fe.from(e));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & sd)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let o = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = o.withText(o.text.slice(0, o.text.length - i[0].length));
      }
    }
    let n = Fe.from(this.content);
    return !e && this.match && (n = n.append(this.match.fillBefore(Fe.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !x_.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class wD {
  constructor(e, n, r) {
    this.parser = e, this.options = n, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let i = n.topNode, o, a = DD(null, n.preserveWhitespace, 0) | (r ? Xf : 0);
    i ? o = new jh(i.type, i.attrs, mt.none, !0, n.topMatch || i.type.contentMatch, a) : r ? o = new jh(null, null, mt.none, !0, null, a) : o = new jh(e.schema.topNodeType, null, mt.none, !0, null, a), this.nodes = [o], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, n) {
    e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n);
  }
  addTextNode(e, n) {
    let r = e.nodeValue, i = this.top, o = i.options & U1 ? "full" : this.localPreserveWS || (i.options & sd) > 0;
    if (o === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (o)
        o !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`);
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let a = i.content[i.content.length - 1], s = e.previousSibling;
        (!a || s && s.nodeName == "BR" || a.isText && /[ \t\r\n\u000c]$/.test(a.text)) && (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r), n), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n, r) {
    let i = this.localPreserveWS, o = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let a = e.nodeName.toLowerCase(), s;
    D_.hasOwnProperty(a) && this.parser.normalizeLists && X8(e);
    let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (s = this.parser.matchTag(e, this, r));
    e: if (l ? l.ignore : q8.hasOwnProperty(a))
      this.findInside(e), this.ignoreFallback(e, n);
    else if (!l || l.skip || l.closeParent) {
      l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
      let u, f = this.needsBlock;
      if (x_.hasOwnProperty(a))
        o.content.length && o.content[0].isInline && this.open && (this.open--, o = this.top), u = !0, o.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, n);
        break e;
      }
      let h = l && l.skip ? n : this.readStyles(e, n);
      h && this.addAll(e, h), u && this.sync(o), this.needsBlock = f;
    } else {
      let u = this.readStyles(e, n);
      u && this.addElementByRule(e, l, u, l.consuming === !1 ? s : void 0);
    }
    this.localPreserveWS = i;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, n) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n);
  }
  // Called for ignored nodes
  ignoreFallback(e, n) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, n) {
    let r = e.style;
    if (r && r.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let o = this.parser.matchedStyles[i], a = r.getPropertyValue(o);
        if (a)
          for (let s = void 0; ; ) {
            let l = this.parser.matchStyle(o, a, this, s);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? n = n.filter((u) => !l.clearMark(u)) : n = n.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1)
              s = l;
            else
              break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, r, i) {
    let o, a;
    if (n.node)
      if (a = this.parser.schema.nodes[n.node], a.isLeaf)
        this.insertNode(a.create(n.attrs), r) || this.leafFallback(e, r);
      else {
        let l = this.enter(a, n.attrs || null, r, n.preserveWhitespace);
        l && (o = !0, r = l);
      }
    else {
      let l = this.parser.schema.marks[n.mark];
      r = r.concat(l.create(n.attrs));
    }
    let s = this.top;
    if (a && a.isLeaf)
      this.findInside(e);
    else if (i)
      this.addElement(e, r, i);
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, r));
    else {
      let l = e;
      typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement), this.findAround(e, l, !0), this.addAll(l, r), this.findAround(e, l, !1);
    }
    o && this.sync(s) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, r, i) {
    let o = r || 0;
    for (let a = r ? e.childNodes[r] : e.firstChild, s = i == null ? null : e.childNodes[i]; a != s; a = a.nextSibling, ++o)
      this.findAtPoint(e, o), this.addDOM(a, n);
    this.findAtPoint(e, o);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, n) {
    let r, i;
    for (let o = this.open; o >= 0; o--) {
      let a = this.nodes[o], s = a.findWrapping(e);
      if (s && (!r || r.length > s.length) && (r = s, i = a, !s.length) || a.solid)
        break;
    }
    if (!r)
      return null;
    this.sync(i);
    for (let o = 0; o < r.length; o++)
      n = this.enterInner(r[o], null, n, !1);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, n) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let i = this.textblockFromContext();
      i && (n = this.enterInner(i, null, n));
    }
    let r = this.findPlace(e, n);
    if (r) {
      this.closeExtra();
      let i = this.top;
      i.match && (i.match = i.match.matchType(e.type));
      let o = mt.none;
      for (let a of r.concat(e.marks))
        (i.type ? i.type.allowsMarkType(a.type) : TD(a.type, e.type)) && (o = a.addToSet(o));
      return i.content.push(e.mark(o)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, r, i) {
    let o = this.findPlace(e.create(n), r);
    return o && (o = this.enterInner(e, n, r, !0, i)), o;
  }
  // Open a node of the given type
  enterInner(e, n, r, i = !1, o) {
    this.closeExtra();
    let a = this.top;
    a.match = a.match && a.match.matchType(e);
    let s = DD(e, o, a.options);
    a.options & Xf && a.content.length == 0 && (s |= Xf);
    let l = mt.none;
    return r = r.filter((u) => (a.type ? a.type.allowsMarkType(u.type) : TD(u.type, e)) ? (l = u.addToSet(l), !1) : !0), this.nodes.push(new jh(e, n, l, i, null, s)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == e)
        return this.open = n, !0;
      this.localPreserveWS && (this.nodes[n].options |= sd);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let i = r.length - 1; i >= 0; i--)
        e += r[i].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, r) {
    if (e != n && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && n.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), o = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), a = (s, l) => {
      for (; s >= 0; s--) {
        let u = n[s];
        if (u == "") {
          if (s == n.length - 1 || s == 0)
            continue;
          for (; l >= o; l--)
            if (a(s - 1, l))
              return !0;
          return !1;
        } else {
          let f = l > 0 || l == 0 && i ? this.nodes[l].type : r && l >= o ? r.node(l - o).type : null;
          if (!f || f.name != u && !f.isInGroup(u))
            return !1;
          l--;
        }
      }
      return !0;
    };
    return a(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function X8(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && D_.hasOwnProperty(r) && n ? (n.appendChild(e), e = n) : r == "li" ? n = e : r && (n = null);
  }
}
function G8(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function SD(t) {
  let e = {};
  for (let n in t)
    e[n] = t[n];
  return e;
}
function TD(t, e) {
  let n = e.schema.nodes;
  for (let r in n) {
    let i = n[r];
    if (!i.allowsMarkType(t))
      continue;
    let o = [], a = (s) => {
      o.push(s);
      for (let l = 0; l < s.edgeCount; l++) {
        let { type: u, next: f } = s.edge(l);
        if (u == e || o.indexOf(f) < 0 && a(f))
          return !0;
      }
    };
    if (a(i.contentMatch))
      return !0;
  }
}
class vu {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, r) {
    r || (r = gb(n).createDocumentFragment());
    let i = r, o = [];
    return e.forEach((a) => {
      if (o.length || a.marks.length) {
        let s = 0, l = 0;
        for (; s < o.length && l < a.marks.length; ) {
          let u = a.marks[l];
          if (!this.marks[u.type.name]) {
            l++;
            continue;
          }
          if (!u.eq(o[s][0]) || u.type.spec.spanning === !1)
            break;
          s++, l++;
        }
        for (; s < o.length; )
          i = o.pop()[1];
        for (; l < a.marks.length; ) {
          let u = a.marks[l++], f = this.serializeMark(u, a.isInline, n);
          f && (o.push([u, i]), i.appendChild(f.dom), i = f.contentDOM || f.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(a, n));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: r, contentDOM: i } = bp(gb(n), this.nodes[e.type.name](e), null, e.attrs);
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let r = this.serializeNodeInner(e, n);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let o = this.serializeMark(e.marks[i], e.isInline, n);
      o && ((o.contentDOM || o.dom).appendChild(r), r = o.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, n, r = {}) {
    let i = this.marks[e.type.name];
    return i && bp(gb(r), i(e, n), null, e.attrs);
  }
  static renderSpec(e, n, r = null, i) {
    return bp(e, n, r, i);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new vu(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = CD(e.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return CD(e.marks);
  }
}
function CD(t) {
  let e = {};
  for (let n in t) {
    let r = t[n].spec.toDOM;
    r && (e[n] = r);
  }
  return e;
}
function gb(t) {
  return t.document || window.document;
}
const ED = /* @__PURE__ */ new WeakMap();
function J8(t) {
  let e = ED.get(t);
  return e === void 0 && ED.set(t, e = Y8(t)), e;
}
function Y8(t) {
  let e = null;
  function n(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          e || (e = []), e.push(r);
        else
          for (let i = 0; i < r.length; i++)
            n(r[i]);
      else
        for (let i in r)
          n(r[i]);
  }
  return n(t), e;
}
function bp(t, e, n, r) {
  if (typeof e == "string")
    return { dom: t.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let i = e[0], o;
  if (typeof i != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (o = J8(r)) && o.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let a = i.indexOf(" ");
  a > 0 && (n = i.slice(0, a), i = i.slice(a + 1));
  let s, l = n ? t.createElementNS(n, i) : t.createElement(i), u = e[1], f = 1;
  if (u && typeof u == "object" && u.nodeType == null && !Array.isArray(u)) {
    f = 2;
    for (let h in u)
      if (u[h] != null) {
        let p = h.indexOf(" ");
        p > 0 ? l.setAttributeNS(h.slice(0, p), h.slice(p + 1), u[h]) : l.setAttribute(h, u[h]);
      }
  }
  for (let h = f; h < e.length; h++) {
    let p = e[h];
    if (p === 0) {
      if (h < e.length - 1 || h > f)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: y, contentDOM: b } = bp(t, p, n, r);
      if (l.appendChild(y), b) {
        if (s)
          throw new RangeError("Multiple content holes");
        s = b;
      }
    }
  }
  return { dom: l, contentDOM: s };
}
const w_ = 65535, S_ = Math.pow(2, 16);
function Z8(t, e) {
  return t + e * S_;
}
function _D(t) {
  return t & w_;
}
function K8(t) {
  return (t - (t & w_)) / S_;
}
const T_ = 1, C_ = 2, vp = 4, E_ = 8;
class F1 {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.delInfo = n, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & E_) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (T_ | vp)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (C_ | vp)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & vp) > 0;
  }
}
class Cr {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (this.ranges = e, this.inverted = n, !e.length && Cr.empty)
      return Cr.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, r = _D(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + n + K8(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let i = 0, o = this.inverted ? 2 : 1, a = this.inverted ? 1 : 2;
    for (let s = 0; s < this.ranges.length; s += 3) {
      let l = this.ranges[s] - (this.inverted ? i : 0);
      if (l > e)
        break;
      let u = this.ranges[s + o], f = this.ranges[s + a], h = l + u;
      if (e <= h) {
        let p = u ? e == l ? -1 : e == h ? 1 : n : n, y = l + i + (p < 0 ? 0 : f);
        if (r)
          return y;
        let b = e == (n < 0 ? l : h) ? null : Z8(s / 3, e - l), x = e == l ? C_ : e == h ? T_ : vp;
        return (n < 0 ? e != l : e != h) && (x |= E_), new F1(y, x, b);
      }
      i += f - u;
    }
    return r ? e + i : new F1(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let r = 0, i = _D(n), o = this.inverted ? 2 : 1, a = this.inverted ? 1 : 2;
    for (let s = 0; s < this.ranges.length; s += 3) {
      let l = this.ranges[s] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let u = this.ranges[s + o], f = l + u;
      if (e <= f && s == i * 3)
        return !0;
      r += this.ranges[s + a] - u;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, o = 0; i < this.ranges.length; i += 3) {
      let a = this.ranges[i], s = a - (this.inverted ? o : 0), l = a + (this.inverted ? 0 : o), u = this.ranges[i + n], f = this.ranges[i + r];
      e(s, s + u, l, l + f), o += f - u;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Cr(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Cr.empty : new Cr(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
Cr.empty = new Cr([]);
class jc {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e = [], n, r = 0, i = e.length) {
    this.maps = e, this.mirror = n, this.from = r, this.to = i;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new jc(this.maps, this.mirror, e, n);
  }
  /**
  @internal
  */
  copy() {
    return new jc(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    this.to = this.maps.push(e), n != null && this.setMirror(this.maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
      let i = e.getMirror(n);
      this.appendMap(e.maps[n], i != null && i < n ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, r = this.maps.length + e.maps.length; n >= 0; n--) {
      let i = e.getMirror(n);
      this.appendMap(e.maps[n].invert(), i != null && i > n ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new jc();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror)
      return this._map(e, n, !0);
    for (let r = this.from; r < this.to; r++)
      e = this.maps[r].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let i = 0;
    for (let o = this.from; o < this.to; o++) {
      let a = this.maps[o], s = a.mapResult(e, n);
      if (s.recover != null) {
        let l = this.getMirror(o);
        if (l != null && l > o && l < this.to) {
          o = l, e = this.maps[l].recover(s.recover);
          continue;
        }
      }
      i |= s.delInfo, e = s.pos;
    }
    return r ? e : new F1(e, i, null);
  }
}
const mb = /* @__PURE__ */ Object.create(null);
class Rn {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Cr.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = mb[n.stepType];
    if (!r)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in mb)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return mb[e] = n, n.prototype.jsonID = e, n;
  }
}
class Ht {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new Ht(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new Ht(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, r, i) {
    try {
      return Ht.ok(e.replace(n, r, i));
    } catch (o) {
      if (o instanceof $p)
        return Ht.fail(o.message);
      throw o;
    }
  }
}
function G0(t, e, n) {
  let r = [];
  for (let i = 0; i < t.childCount; i++) {
    let o = t.child(i);
    o.content.size && (o = o.copy(G0(o.content, e, o))), o.isInline && (o = e(o, n, i)), r.push(o);
  }
  return Fe.fromArray(r);
}
class za extends Rn {
  /**
  Create a mark step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), o = new We(G0(n.content, (a, s) => !a.isAtom || !s.type.allowsMarkType(this.mark.type) ? a : a.mark(this.mark.addToSet(a.marks)), i), n.openStart, n.openEnd);
    return Ht.fromReplace(e, this.from, this.to, o);
  }
  invert() {
    return new ji(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new za(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof za && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new za(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new za(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Rn.jsonID("addMark", za);
class ji extends Rn {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = new We(G0(n.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), n.openStart, n.openEnd);
    return Ht.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new za(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new ji(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof ji && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ji(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new ji(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Rn.jsonID("removeMark", ji);
class $a extends Rn {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Ht.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return Ht.fromReplace(e, this.pos, this.pos + 1, new We(Fe.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let i = 0; i < n.marks.length; i++)
          if (!n.marks[i].isInSet(r))
            return new $a(this.pos, n.marks[i]);
        return new $a(this.pos, this.mark);
      }
    }
    return new Qc(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new $a(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new $a(n.pos, e.markFromJSON(n.mark));
  }
}
Rn.jsonID("addNodeMark", $a);
class Qc extends Rn {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Ht.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return Ht.fromReplace(e, this.pos, this.pos + 1, new We(Fe.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new $a(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Qc(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new Qc(n.pos, e.markFromJSON(n.mark));
  }
}
Rn.jsonID("removeNodeMark", Qc);
class hn extends Rn {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, r, i = !1) {
    super(), this.from = e, this.to = n, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && R1(e, this.from, this.to) ? Ht.fail("Structure replace would overwrite content") : Ht.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Cr([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new hn(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross ? null : new hn(n.pos, Math.max(n.pos, r.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof hn) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? We.empty : new We(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new hn(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? We.empty : new We(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new hn(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new hn(n.from, n.to, We.fromJSON(e, n.slice), !!n.structure);
  }
}
Rn.jsonID("replace", hn);
class mn extends Rn {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, r, i, o, a, s = !1) {
    super(), this.from = e, this.to = n, this.gapFrom = r, this.gapTo = i, this.slice = o, this.insert = a, this.structure = s;
  }
  apply(e) {
    if (this.structure && (R1(e, this.from, this.gapFrom) || R1(e, this.gapTo, this.to)))
      return Ht.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return Ht.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r ? Ht.fromReplace(e, this.from, this.to, r) : Ht.fail("Content does not fit in gap");
  }
  getMap() {
    return new Cr([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new mn(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), o = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return n.deletedAcross && r.deletedAcross || i < n.pos || o > r.pos ? null : new mn(n.pos, r.pos, i, o, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new mn(n.from, n.to, n.gapFrom, n.gapTo, We.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
}
Rn.jsonID("replaceAround", mn);
function R1(t, e, n) {
  let r = t.resolve(e), i = n - e, o = r.depth;
  for (; i > 0 && o > 0 && r.indexAfter(o) == r.node(o).childCount; )
    o--, i--;
  if (i > 0) {
    let a = r.node(o).maybeChild(r.indexAfter(o));
    for (; i > 0; ) {
      if (!a || a.isLeaf)
        return !0;
      a = a.firstChild, i--;
    }
  }
  return !1;
}
function Q8(t, e, n, r) {
  let i = [], o = [], a, s;
  t.doc.nodesBetween(e, n, (l, u, f) => {
    if (!l.isInline)
      return;
    let h = l.marks;
    if (!r.isInSet(h) && f.type.allowsMarkType(r.type)) {
      let p = Math.max(u, e), y = Math.min(u + l.nodeSize, n), b = r.addToSet(h);
      for (let x = 0; x < h.length; x++)
        h[x].isInSet(b) || (a && a.to == p && a.mark.eq(h[x]) ? a.to = y : i.push(a = new ji(p, y, h[x])));
      s && s.to == p ? s.to = y : o.push(s = new za(p, y, r));
    }
  }), i.forEach((l) => t.step(l)), o.forEach((l) => t.step(l));
}
function e5(t, e, n, r) {
  let i = [], o = 0;
  t.doc.nodesBetween(e, n, (a, s) => {
    if (!a.isInline)
      return;
    o++;
    let l = null;
    if (r instanceof fm) {
      let u = a.marks, f;
      for (; f = r.isInSet(u); )
        (l || (l = [])).push(f), u = f.removeFromSet(u);
    } else r ? r.isInSet(a.marks) && (l = [r]) : l = a.marks;
    if (l && l.length) {
      let u = Math.min(s + a.nodeSize, n);
      for (let f = 0; f < l.length; f++) {
        let h = l[f], p;
        for (let y = 0; y < i.length; y++) {
          let b = i[y];
          b.step == o - 1 && h.eq(i[y].style) && (p = b);
        }
        p ? (p.to = u, p.step = o) : i.push({ style: h, from: Math.max(s, e), to: u, step: o });
      }
    }
  }), i.forEach((a) => t.step(new ji(a.from, a.to, a.style)));
}
function J0(t, e, n, r = n.contentMatch, i = !0) {
  let o = t.doc.nodeAt(e), a = [], s = e + 1;
  for (let l = 0; l < o.childCount; l++) {
    let u = o.child(l), f = s + u.nodeSize, h = r.matchType(u.type);
    if (!h)
      a.push(new hn(s, f, We.empty));
    else {
      r = h;
      for (let p = 0; p < u.marks.length; p++)
        n.allowsMarkType(u.marks[p].type) || t.step(new ji(s, f, u.marks[p]));
      if (i && u.isText && n.whitespace != "pre") {
        let p, y = /\r?\n|\r/g, b;
        for (; p = y.exec(u.text); )
          b || (b = new We(Fe.from(n.schema.text(" ", n.allowedMarks(u.marks))), 0, 0)), a.push(new hn(s + p.index, s + p.index + p[0].length, b));
      }
    }
    s = f;
  }
  if (!r.validEnd) {
    let l = r.fillBefore(Fe.empty, !0);
    t.replace(s, s, new We(l, 0, 0));
  }
  for (let l = a.length - 1; l >= 0; l--)
    t.step(a[l]);
}
function t5(t, e, n) {
  return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n));
}
function Ld(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let r = t.depth; ; --r) {
    let i = t.$from.node(r), o = t.$from.index(r), a = t.$to.indexAfter(r);
    if (r < t.depth && i.canReplace(o, a, n))
      return r;
    if (r == 0 || i.type.spec.isolating || !t5(i, o, a))
      break;
  }
  return null;
}
function n5(t, e, n) {
  let { $from: r, $to: i, depth: o } = e, a = r.before(o + 1), s = i.after(o + 1), l = a, u = s, f = Fe.empty, h = 0;
  for (let b = o, x = !1; b > n; b--)
    x || r.index(b) > 0 ? (x = !0, f = Fe.from(r.node(b).copy(f)), h++) : l--;
  let p = Fe.empty, y = 0;
  for (let b = o, x = !1; b > n; b--)
    x || i.after(b + 1) < i.end(b) ? (x = !0, p = Fe.from(i.node(b).copy(p)), y++) : u++;
  t.step(new mn(l, u, a, s, new We(f.append(p), h, y), f.size - h, !0));
}
function __(t, e, n = null, r = t) {
  let i = r5(t, e), o = i && i5(r, e);
  return o ? i.map(kD).concat({ type: e, attrs: n }).concat(o.map(kD)) : null;
}
function kD(t) {
  return { type: t, attrs: null };
}
function r5(t, e) {
  let { parent: n, startIndex: r, endIndex: i } = t, o = n.contentMatchAt(r).findWrapping(e);
  if (!o)
    return null;
  let a = o.length ? o[0] : e;
  return n.canReplaceWith(r, i, a) ? o : null;
}
function i5(t, e) {
  let { parent: n, startIndex: r, endIndex: i } = t, o = n.child(r), a = e.contentMatch.findWrapping(o.type);
  if (!a)
    return null;
  let l = (a.length ? a[a.length - 1] : e).contentMatch;
  for (let u = r; l && u < i; u++)
    l = l.matchType(n.child(u).type);
  return !l || !l.validEnd ? null : a;
}
function o5(t, e, n) {
  let r = Fe.empty;
  for (let a = n.length - 1; a >= 0; a--) {
    if (r.size) {
      let s = n[a].type.contentMatch.matchFragment(r);
      if (!s || !s.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = Fe.from(n[a].type.create(n[a].attrs, r));
  }
  let i = e.start, o = e.end;
  t.step(new mn(i, o, i, o, new We(r, 0, 0), n.length, !0));
}
function a5(t, e, n, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let o = t.steps.length;
  t.doc.nodesBetween(e, n, (a, s) => {
    let l = typeof i == "function" ? i(a) : i;
    if (a.isTextblock && !a.hasMarkup(r, l) && s5(t.doc, t.mapping.slice(o).map(s), r)) {
      let u = null;
      if (r.schema.linebreakReplacement) {
        let y = r.whitespace == "pre", b = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        y && !b ? u = !1 : !y && b && (u = !0);
      }
      u === !1 && A_(t, a, s, o), J0(t, t.mapping.slice(o).map(s, 1), r, void 0, u === null);
      let f = t.mapping.slice(o), h = f.map(s, 1), p = f.map(s + a.nodeSize, 1);
      return t.step(new mn(h, p, h + 1, p - 1, new We(Fe.from(r.create(l, null, a.marks)), 0, 0), 1, !0)), u === !0 && k_(t, a, s, o), !1;
    }
  });
}
function k_(t, e, n, r) {
  e.forEach((i, o) => {
    if (i.isText) {
      let a, s = /\r?\n|\r/g;
      for (; a = s.exec(i.text); ) {
        let l = t.mapping.slice(r).map(n + 1 + o + a.index);
        t.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function A_(t, e, n, r) {
  e.forEach((i, o) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let a = t.mapping.slice(r).map(n + 1 + o);
      t.replaceWith(a, a + 1, e.type.schema.text(`
`));
    }
  });
}
function s5(t, e, n) {
  let r = t.resolve(e), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, n);
}
function l5(t, e, n, r, i) {
  let o = t.doc.nodeAt(e);
  if (!o)
    throw new RangeError("No node at given position");
  n || (n = o.type);
  let a = n.create(r, null, i || o.marks);
  if (o.isLeaf)
    return t.replaceWith(e, e + o.nodeSize, a);
  if (!n.validContent(o.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(new mn(e, e + o.nodeSize, e + 1, e + o.nodeSize - 1, new We(Fe.from(a), 0, 0), 1, !0));
}
function U_(t, e, n = 1, r) {
  let i = t.resolve(e), o = i.depth - n, a = r && r[r.length - 1] || i.parent;
  if (o < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !a.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let u = i.depth - 1, f = n - 2; u > o; u--, f--) {
    let h = i.node(u), p = i.index(u);
    if (h.type.spec.isolating)
      return !1;
    let y = h.content.cutByIndex(p, h.childCount), b = r && r[f + 1];
    b && (y = y.replaceChild(0, b.type.create(b.attrs)));
    let x = r && r[f] || h;
    if (!h.canReplace(p + 1, h.childCount) || !x.type.validContent(y))
      return !1;
  }
  let s = i.indexAfter(o), l = r && r[0];
  return i.node(o).canReplaceWith(s, s, l ? l.type : i.node(o + 1).type);
}
function c5(t, e, n = 1, r) {
  let i = t.doc.resolve(e), o = Fe.empty, a = Fe.empty;
  for (let s = i.depth, l = i.depth - n, u = n - 1; s > l; s--, u--) {
    o = Fe.from(i.node(s).copy(o));
    let f = r && r[u];
    a = Fe.from(f ? f.type.create(f.attrs, a) : i.node(s).copy(a));
  }
  t.step(new hn(e, e, new We(o.append(a), n, n), !0));
}
function zd(t, e) {
  let n = t.resolve(e), r = n.index();
  return F_(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function u5(t, e) {
  e.content.size || t.type.compatibleContent(e.type);
  let n = t.contentMatchAt(t.childCount), { linebreakReplacement: r } = t.type.schema;
  for (let i = 0; i < e.childCount; i++) {
    let o = e.child(i), a = o.type == r ? t.type.schema.nodes.text : o.type;
    if (n = n.matchType(a), !n || !t.type.allowsMarks(o.marks))
      return !1;
  }
  return n.validEnd;
}
function F_(t, e) {
  return !!(t && e && !t.isLeaf && u5(t, e));
}
function R_(t, e, n = -1) {
  let r = t.resolve(e);
  for (let i = r.depth; ; i--) {
    let o, a, s = r.index(i);
    if (i == r.depth ? (o = r.nodeBefore, a = r.nodeAfter) : n > 0 ? (o = r.node(i + 1), s++, a = r.node(i).maybeChild(s)) : (o = r.node(i).maybeChild(s - 1), a = r.node(i + 1)), o && !o.isTextblock && F_(o, a) && r.node(i).canReplace(s, s + 1))
      return e;
    if (i == 0)
      break;
    e = n < 0 ? r.before(i) : r.after(i);
  }
}
function f5(t, e, n) {
  let r = null, { linebreakReplacement: i } = t.doc.type.schema, o = t.doc.resolve(e - n), a = o.node().type;
  if (i && a.inlineContent) {
    let f = a.whitespace == "pre", h = !!a.contentMatch.matchType(i);
    f && !h ? r = !1 : !f && h && (r = !0);
  }
  let s = t.steps.length;
  if (r === !1) {
    let f = t.doc.resolve(e + n);
    A_(t, f.node(), f.before(), s);
  }
  a.inlineContent && J0(t, e + n - 1, a, o.node().contentMatchAt(o.index()), r == null);
  let l = t.mapping.slice(s), u = l.map(e - n);
  if (t.step(new hn(u, l.map(e + n, -1), We.empty, !0)), r === !0) {
    let f = t.doc.resolve(u);
    k_(t, f.node(), f.before(), t.steps.length);
  }
  return t;
}
function d5(t, e, n) {
  let r = t.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), n))
    return e;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.index(i);
      if (r.node(i).canReplaceWith(o, o, n))
        return r.before(i + 1);
      if (o > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.indexAfter(i);
      if (r.node(i).canReplaceWith(o, o, n))
        return r.after(i + 1);
      if (o < r.node(i).childCount)
        return null;
    }
  return null;
}
function O_(t, e, n) {
  let r = t.resolve(e);
  if (!n.content.size)
    return e;
  let i = n.content;
  for (let o = 0; o < n.openStart; o++)
    i = i.firstChild.content;
  for (let o = 1; o <= (n.openStart == 0 && n.size ? 2 : 1); o++)
    for (let a = r.depth; a >= 0; a--) {
      let s = a == r.depth ? 0 : r.pos <= (r.start(a + 1) + r.end(a + 1)) / 2 ? -1 : 1, l = r.index(a) + (s > 0 ? 1 : 0), u = r.node(a), f = !1;
      if (o == 1)
        f = u.canReplace(l, l, i);
      else {
        let h = u.contentMatchAt(l).findWrapping(i.firstChild.type);
        f = h && u.canReplaceWith(l, l, h[0]);
      }
      if (f)
        return s == 0 ? r.pos : s < 0 ? r.before(a + 1) : r.after(a + 1);
    }
  return null;
}
function dm(t, e, n = e, r = We.empty) {
  if (e == n && !r.size)
    return null;
  let i = t.resolve(e), o = t.resolve(n);
  return I_(i, o, r) ? new hn(e, n, r) : new h5(i, o, r).fit();
}
function I_(t, e, n) {
  return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
}
class h5 {
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = Fe.empty;
    for (let i = 0; i <= e.depth; i++) {
      let o = e.node(i);
      this.frontier.push({
        type: o.type,
        match: o.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = Fe.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let u = this.findFittable();
      u ? this.placeNodes(u) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!i)
      return null;
    let o = this.placed, a = r.depth, s = i.depth;
    for (; a && s && o.childCount == 1; )
      o = o.firstChild.content, a--, s--;
    let l = new We(o, a, s);
    return e > -1 ? new mn(r.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || r.pos != this.$to.pos ? new hn(r.pos, i.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let o = n.firstChild;
      if (n.childCount > 1 && (i = 0), o.type.spec.isolating && i <= r) {
        e = r;
        break;
      }
      n = o.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, o = null;
        r ? (o = yb(this.unplaced.content, r - 1).firstChild, i = o.content) : i = this.unplaced.content;
        let a = i.firstChild;
        for (let s = this.depth; s >= 0; s--) {
          let { type: l, match: u } = this.frontier[s], f, h = null;
          if (n == 1 && (a ? u.matchType(a.type) || (h = u.fillBefore(Fe.from(a), !1)) : o && l.compatibleContent(o.type)))
            return { sliceDepth: r, frontierDepth: s, parent: o, inject: h };
          if (n == 2 && a && (f = u.findWrapping(a.type)))
            return { sliceDepth: r, frontierDepth: s, parent: o, wrap: f };
          if (o && u.matchType(o.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, i = yb(e, n);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new We(e, n + 1, Math.max(r, i.size + n >= e.size - r ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, i = yb(e, n);
    if (i.childCount <= 1 && n > 0) {
      let o = e.size - n <= n + i.size;
      this.unplaced = new We(Lf(e, n - 1, 1), n - 1, o ? n - 1 : r);
    } else
      this.unplaced = new We(Lf(e, n, 1), n, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: r, inject: i, wrap: o }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (o)
      for (let x = 0; x < o.length; x++)
        this.openFrontierNode(o[x]);
    let a = this.unplaced, s = r ? r.content : a.content, l = a.openStart - e, u = 0, f = [], { match: h, type: p } = this.frontier[n];
    if (i) {
      for (let x = 0; x < i.childCount; x++)
        f.push(i.child(x));
      h = h.matchFragment(i);
    }
    let y = s.size + e - (a.content.size - a.openEnd);
    for (; u < s.childCount; ) {
      let x = s.child(u), v = h.matchType(x.type);
      if (!v)
        break;
      u++, (u > 1 || l == 0 || x.content.size) && (h = v, f.push(B_(x.mark(p.allowedMarks(x.marks)), u == 1 ? l : 0, u == s.childCount ? y : -1)));
    }
    let b = u == s.childCount;
    b || (y = -1), this.placed = zf(this.placed, n, Fe.from(f)), this.frontier[n].match = h, b && y < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let x = 0, v = s; x < y; x++) {
      let D = v.lastChild;
      this.frontier.push({ type: D.type, match: D.contentMatchAt(D.childCount) }), v = D.content;
    }
    this.unplaced = b ? e == 0 ? We.empty : new We(Lf(a.content, e - 1, 1), e - 1, y < 0 ? a.openEnd : e - 1) : new We(Lf(a.content, e, u), a.openStart, a.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], n;
    if (!e.type.isTextblock || !bb(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
      let { match: r, type: i } = this.frontier[n], o = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), a = bb(e, n, i, r, o);
      if (a) {
        for (let s = n - 1; s >= 0; s--) {
          let { match: l, type: u } = this.frontier[s], f = bb(e, s, u, l, !0);
          if (!f || f.childCount)
            continue e;
        }
        return { depth: n, fit: a, move: o ? e.doc.resolve(e.after(n + 1)) : e };
      }
    }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = zf(this.placed, n.depth, n.fit)), e = n.move;
    for (let r = n.depth + 1; r <= e.depth; r++) {
      let i = e.node(r), o = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
      this.openFrontierNode(i.type, i.attrs, o);
    }
    return e;
  }
  openFrontierNode(e, n = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = zf(this.placed, this.depth, Fe.from(e.create(n, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(Fe.empty, !0);
    n.childCount && (this.placed = zf(this.placed, this.frontier.length, n));
  }
}
function Lf(t, e, n) {
  return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(Lf(t.firstChild.content, e - 1, n)));
}
function zf(t, e, n) {
  return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(zf(t.lastChild.content, e - 1, n)));
}
function yb(t, e) {
  for (let n = 0; n < e; n++)
    t = t.firstChild.content;
  return t;
}
function B_(t, e, n) {
  if (e <= 0)
    return t;
  let r = t.content;
  return e > 1 && (r = r.replaceChild(0, B_(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))), e > 0 && (r = t.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(Fe.empty, !0)))), t.copy(r);
}
function bb(t, e, n, r, i) {
  let o = t.node(e), a = i ? t.indexAfter(e) : t.index(e);
  if (a == o.childCount && !n.compatibleContent(o.type))
    return null;
  let s = r.fillBefore(o.content, !0, a);
  return s && !p5(n, o.content, a) ? s : null;
}
function p5(t, e, n) {
  for (let r = n; r < e.childCount; r++)
    if (!t.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function g5(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function m5(t, e, n, r) {
  if (!r.size)
    return t.deleteRange(e, n);
  let i = t.doc.resolve(e), o = t.doc.resolve(n);
  if (I_(i, o, r))
    return t.step(new hn(e, n, r));
  let a = N_(i, t.doc.resolve(n));
  a[a.length - 1] == 0 && a.pop();
  let s = -(i.depth + 1);
  a.unshift(s);
  for (let p = i.depth, y = i.pos - 1; p > 0; p--, y--) {
    let b = i.node(p).type.spec;
    if (b.defining || b.definingAsContext || b.isolating)
      break;
    a.indexOf(p) > -1 ? s = p : i.before(p) == y && a.splice(1, 0, -p);
  }
  let l = a.indexOf(s), u = [], f = r.openStart;
  for (let p = r.content, y = 0; ; y++) {
    let b = p.firstChild;
    if (u.push(b), y == r.openStart)
      break;
    p = b.content;
  }
  for (let p = f - 1; p >= 0; p--) {
    let y = u[p], b = g5(y.type);
    if (b && !y.sameMarkup(i.node(Math.abs(s) - 1)))
      f = p;
    else if (b || !y.type.isTextblock)
      break;
  }
  for (let p = r.openStart; p >= 0; p--) {
    let y = (p + f + 1) % (r.openStart + 1), b = u[y];
    if (b)
      for (let x = 0; x < a.length; x++) {
        let v = a[(x + l) % a.length], D = !0;
        v < 0 && (D = !1, v = -v);
        let S = i.node(v - 1), E = i.index(v - 1);
        if (S.canReplaceWith(E, E, b.type, b.marks))
          return t.replace(i.before(v), D ? o.after(v) : n, new We(M_(r.content, 0, r.openStart, y), y, r.openEnd));
      }
  }
  let h = t.steps.length;
  for (let p = a.length - 1; p >= 0 && (t.replace(e, n, r), !(t.steps.length > h)); p--) {
    let y = a[p];
    y < 0 || (e = i.before(y), n = o.after(y));
  }
}
function M_(t, e, n, r, i) {
  if (e < n) {
    let o = t.firstChild;
    t = t.replaceChild(0, o.copy(M_(o.content, e + 1, n, r, o)));
  }
  if (e > r) {
    let o = i.contentMatchAt(0), a = o.fillBefore(t).append(t);
    t = a.append(o.matchFragment(a).fillBefore(Fe.empty, !0));
  }
  return t;
}
function y5(t, e, n, r) {
  if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let i = d5(t.doc, e, r.type);
    i != null && (e = n = i);
  }
  t.replaceRange(e, n, new We(Fe.from(r), 0, 0));
}
function b5(t, e, n) {
  let r = t.doc.resolve(e), i = t.doc.resolve(n), o = N_(r, i);
  for (let a = 0; a < o.length; a++) {
    let s = o[a], l = a == o.length - 1;
    if (l && s == 0 || r.node(s).type.contentMatch.validEnd)
      return t.delete(r.start(s), i.end(s));
    if (s > 0 && (l || r.node(s - 1).canReplace(r.index(s - 1), i.indexAfter(s - 1))))
      return t.delete(r.before(s), i.after(s));
  }
  for (let a = 1; a <= r.depth && a <= i.depth; a++)
    if (e - r.start(a) == r.depth - a && n > r.end(a) && i.end(a) - n != i.depth - a && r.start(a - 1) == i.start(a - 1) && r.node(a - 1).canReplace(r.index(a - 1), i.index(a - 1)))
      return t.delete(r.before(a), n);
  t.delete(e, n);
}
function N_(t, e) {
  let n = [], r = Math.min(t.depth, e.depth);
  for (let i = r; i >= 0; i--) {
    let o = t.start(i);
    if (o < t.pos - (t.depth - i) || e.end(i) > e.pos + (e.depth - i) || t.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (o == e.start(i) || i == t.depth && i == e.depth && t.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == o - 1) && n.push(i);
  }
  return n;
}
class Hc extends Rn {
  /**
  Construct an attribute step.
  */
  constructor(e, n, r) {
    super(), this.pos = e, this.attr = n, this.value = r;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Ht.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let o in n.attrs)
      r[o] = n.attrs[o];
    r[this.attr] = this.value;
    let i = n.type.create(r, null, n.marks);
    return Ht.fromReplace(e, this.pos, this.pos + 1, new We(Fe.from(i), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return Cr.empty;
  }
  invert(e) {
    return new Hc(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Hc(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new Hc(n.pos, n.attr, n.value);
  }
}
Rn.jsonID("attr", Hc);
class ld extends Rn {
  /**
  Construct an attribute step.
  */
  constructor(e, n) {
    super(), this.attr = e, this.value = n;
  }
  apply(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let i in e.attrs)
      n[i] = e.attrs[i];
    n[this.attr] = this.value;
    let r = e.type.create(n, e.content, e.marks);
    return Ht.ok(r);
  }
  getMap() {
    return Cr.empty;
  }
  invert(e) {
    return new ld(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new ld(n.attr, n.value);
  }
}
Rn.jsonID("docAttr", ld);
let eu = class extends Error {
};
eu = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
eu.prototype = Object.create(Error.prototype);
eu.prototype.constructor = eu;
eu.prototype.name = "TransformError";
class P_ {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new jc();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed)
      throw new eu(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, r = We.empty) {
    let i = dm(this.doc, e, n, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, r) {
    return this.replace(e, n, new We(Fe.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, We.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, r) {
    return m5(this, e, n, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, r) {
    return y5(this, e, n, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return b5(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return n5(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return f5(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return o5(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, r, i = null) {
    return a5(this, e, n, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, r = null, i) {
    return l5(this, e, n, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, n, r) {
    return this.step(new Hc(e, n, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, n) {
    return this.step(new ld(e, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new $a(e, n)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    if (!(n instanceof mt)) {
      let r = this.doc.nodeAt(e);
      if (!r)
        throw new RangeError("No node at position " + e);
      if (n = n.isInSet(r.marks), !n)
        return this;
    }
    return this.step(new Qc(e, n)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(e, n = 1, r) {
    return c5(this, e, n, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, r) {
    return Q8(this, e, n, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, r) {
    return e5(this, e, n, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, r) {
    return J0(this, e, n, r), this;
  }
}
const vb = /* @__PURE__ */ Object.create(null);
class et {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, n, r) {
    this.$anchor = e, this.$head = n, this.ranges = r || [new W_(e.min(n), e.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, n = We.empty) {
    let r = n.content.lastChild, i = null;
    for (let s = 0; s < n.openEnd; s++)
      i = r, r = r.lastChild;
    let o = e.steps.length, a = this.ranges;
    for (let s = 0; s < a.length; s++) {
      let { $from: l, $to: u } = a[s], f = e.mapping.slice(o);
      e.replaceRange(f.map(l.pos), f.map(u.pos), s ? We.empty : n), s == 0 && FD(e, o, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, n) {
    let r = e.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      let { $from: a, $to: s } = i[o], l = e.mapping.slice(r), u = l.map(a.pos), f = l.map(s.pos);
      o ? e.deleteRange(u, f) : (e.replaceRangeWith(u, f, n), FD(e, r, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, n, r = !1) {
    let i = e.parent.inlineContent ? new st(e) : Bc(e.node(0), e.parent, e.pos, e.index(), n, r);
    if (i)
      return i;
    for (let o = e.depth - 1; o >= 0; o--) {
      let a = n < 0 ? Bc(e.node(0), e.node(o), e.before(o + 1), e.index(o), n, r) : Bc(e.node(0), e.node(o), e.after(o + 1), e.index(o) + 1, n, r);
      if (a)
        return a;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new di(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return Bc(e, e, 0, 0, 1) || new di(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return Bc(e, e, e.content.size, e.childCount, -1) || new di(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = vb[n.type];
    if (!r)
      throw new RangeError(`No selection type ${n.type} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, n) {
    if (e in vb)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return vb[e] = n, n.prototype.jsonID = e, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return st.between(this.$anchor, this.$head).getBookmark();
  }
}
et.prototype.visible = !0;
class W_ {
  /**
  Create a range.
  */
  constructor(e, n) {
    this.$from = e, this.$to = n;
  }
}
let AD = !1;
function UD(t) {
  !AD && !t.parent.inlineContent && (AD = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"));
}
class st extends et {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, n = e) {
    UD(e), UD(n), super(e, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    if (!r.parent.inlineContent)
      return et.near(r);
    let i = e.resolve(n.map(this.anchor));
    return new st(i.parent.inlineContent ? i : r, r);
  }
  replace(e, n = We.empty) {
    if (super.replace(e, n), n == We.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof st && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new hm(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new st(e.resolve(n.anchor), e.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, n, r = n) {
    let i = e.resolve(n);
    return new this(i, r == n ? i : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, n, r) {
    let i = e.pos - n.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let o = et.findFrom(n, r, !0) || et.findFrom(n, -r, !0);
      if (o)
        n = o.$head;
      else
        return et.near(n, r);
    }
    return e.parent.inlineContent || (i == 0 ? e = n : (e = (et.findFrom(e, -r, !0) || et.findFrom(e, r, !0)).$anchor, e.pos < n.pos != i < 0 && (e = n))), new st(e, n);
  }
}
et.jsonID("text", st);
class hm {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new hm(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return st.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class Ye extends et {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let n = e.nodeAfter, r = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, r), this.node = n;
  }
  map(e, n) {
    let { deleted: r, pos: i } = n.mapResult(this.anchor), o = e.resolve(i);
    return r ? et.near(o) : new Ye(o);
  }
  content() {
    return new We(Fe.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof Ye && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new Y0(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new Ye(e.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, n) {
    return new Ye(e.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
Ye.prototype.visible = !1;
et.jsonID("node", Ye);
class Y0 {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: r } = e.mapResult(this.anchor);
    return n ? new hm(r, r) : new Y0(r);
  }
  resolve(e) {
    let n = e.resolve(this.anchor), r = n.nodeAfter;
    return r && Ye.isSelectable(r) ? new Ye(n) : et.near(n);
  }
}
class di extends et {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = We.empty) {
    if (n == We.empty) {
      e.delete(0, e.doc.content.size);
      let r = et.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new di(e);
  }
  map(e) {
    return new di(e);
  }
  eq(e) {
    return e instanceof di;
  }
  getBookmark() {
    return v5;
  }
}
et.jsonID("all", di);
const v5 = {
  map() {
    return this;
  },
  resolve(t) {
    return new di(t);
  }
};
function Bc(t, e, n, r, i, o = !1) {
  if (e.inlineContent)
    return st.create(t, n);
  for (let a = r - (i > 0 ? 0 : 1); i > 0 ? a < e.childCount : a >= 0; a += i) {
    let s = e.child(a);
    if (s.isAtom) {
      if (!o && Ye.isSelectable(s))
        return Ye.create(t, n - (i < 0 ? s.nodeSize : 0));
    } else {
      let l = Bc(t, s, n + i, i < 0 ? s.childCount : 0, i, o);
      if (l)
        return l;
    }
    n += s.nodeSize * i;
  }
  return null;
}
function FD(t, e, n) {
  let r = t.steps.length - 1;
  if (r < e)
    return;
  let i = t.steps[r];
  if (!(i instanceof hn || i instanceof mn))
    return;
  let o = t.mapping.maps[r], a;
  o.forEach((s, l, u, f) => {
    a == null && (a = f);
  }), t.setSelection(et.near(t.doc.resolve(a), n));
}
const RD = 1, Hh = 2, OD = 4;
let x5 = class extends P_ {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | RD) & ~Hh, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & RD) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= Hh, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return mt.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & Hh) > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    super.addStep(e, n), this.updated = this.updated & ~Hh, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, n = !0) {
    let r = this.selection;
    return n && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || mt.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, n, r) {
    let i = this.doc.type.schema;
    if (n == null)
      return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = n), r = r ?? n, !e)
        return this.deleteRange(n, r);
      let o = this.storedMarks;
      if (!o) {
        let a = this.doc.resolve(n);
        o = r == n ? a.marks() : a.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(n, r, i.text(e, o)), this.selection.empty || this.setSelection(et.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, n) {
    return this.meta[typeof e == "string" ? e : e.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= OD, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & OD) > 0;
  }
};
function ID(t, e) {
  return !e || !t ? t : t.bind(e);
}
class $f {
  constructor(e, n, r) {
    this.name = e, this.init = ID(n.init, r), this.apply = ID(n.apply, r);
  }
}
const D5 = [
  new $f("doc", {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply(t) {
      return t.doc;
    }
  }),
  new $f("selection", {
    init(t, e) {
      return t.selection || et.atStart(e.doc);
    },
    apply(t) {
      return t.selection;
    }
  }),
  new $f("storedMarks", {
    init(t) {
      return t.storedMarks || null;
    },
    apply(t, e, n, r) {
      return r.selection.$cursor ? t.storedMarks : null;
    }
  }),
  new $f("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    }
  })
];
class xb {
  constructor(e, n) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = D5.slice(), n && n.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new $f(r.key, r.spec.state, r));
    });
  }
}
class jf {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let n = [e], r = this.applyInner(e), i = null;
    for (; ; ) {
      let o = !1;
      for (let a = 0; a < this.config.plugins.length; a++) {
        let s = this.config.plugins[a];
        if (s.spec.appendTransaction) {
          let l = i ? i[a].n : 0, u = i ? i[a].state : this, f = l < n.length && s.spec.appendTransaction.call(s, l ? n.slice(l) : n, u, r);
          if (f && r.filterTransaction(f, a)) {
            if (f.setMeta("appendedTransaction", e), !i) {
              i = [];
              for (let h = 0; h < this.config.plugins.length; h++)
                i.push(h < a ? { state: r, n: n.length } : { state: this, n: 0 });
            }
            n.push(f), r = r.applyInner(f), o = !0;
          }
          i && (i[a] = { state: r, n: n.length });
        }
      }
      if (!o)
        return { state: r, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new jf(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let o = r[i];
      n[o.name] = o.apply(e, this[o.name], this, n);
    }
    return n;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new x5(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let n = new xb(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new jf(n);
    for (let i = 0; i < n.fields.length; i++)
      r[n.fields[i].name] = n.fields[i].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let n = new xb(this.schema, e.plugins), r = n.fields, i = new jf(n);
    for (let o = 0; o < r.length; o++) {
      let a = r[o].name;
      i[a] = this.hasOwnProperty(a) ? this[a] : r[o].init(e, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[r], o = i.spec.state;
        o && o.toJSON && (n[r] = o.toJSON.call(i, this[i.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, n, r) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new xb(e.schema, e.plugins), o = new jf(i);
    return i.fields.forEach((a) => {
      if (a.name == "doc")
        o.doc = nl.fromJSON(e.schema, n.doc);
      else if (a.name == "selection")
        o.selection = et.fromJSON(o.doc, n.selection);
      else if (a.name == "storedMarks")
        n.storedMarks && (o.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let s in r) {
            let l = r[s], u = l.spec.state;
            if (l.key == a.name && u && u.fromJSON && Object.prototype.hasOwnProperty.call(n, s)) {
              o[a.name] = u.fromJSON.call(l, e, n[s], o);
              return;
            }
          }
        o[a.name] = a.init(e, o);
      }
    }), o;
  }
}
function L_(t, e, n) {
  for (let r in t) {
    let i = t[r];
    i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = L_(i, e, {})), n[r] = i;
  }
  return n;
}
class xu {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && L_(e.props, this, this.props), this.key = e.key ? e.key.key : z_("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Db = /* @__PURE__ */ Object.create(null);
function z_(t) {
  return t in Db ? t + "$" + ++Db[t] : (Db[t] = 0, t + "$");
}
class ns {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = z_(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const pn = function(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}, cd = function(t) {
  let e = t.assignedSlot || t.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let O1 = null;
const Io = function(t, e, n) {
  let r = O1 || (O1 = document.createRange());
  return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
}, w5 = function() {
  O1 = null;
}, ul = function(t, e, n, r) {
  return n && (BD(t, e, n, r, -1) || BD(t, e, n, r, 1));
}, S5 = /^(img|br|input|textarea|hr)$/i;
function BD(t, e, n, r, i) {
  for (; ; ) {
    if (t == n && e == r)
      return !0;
    if (e == (i < 0 ? 0 : Jr(t))) {
      let o = t.parentNode;
      if (!o || o.nodeType != 1 || $d(t) || S5.test(t.nodeName) || t.contentEditable == "false")
        return !1;
      e = pn(t) + (i < 0 ? 0 : 1), t = o;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.contentEditable == "false")
        return !1;
      e = i < 0 ? Jr(t) : 0;
    } else
      return !1;
  }
}
function Jr(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function T5(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e)
      return t;
    if (t.nodeType == 1 && e > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e - 1], e = Jr(t);
    } else if (t.parentNode && !$d(t))
      e = pn(t), t = t.parentNode;
    else
      return null;
  }
}
function C5(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e < t.nodeValue.length)
      return t;
    if (t.nodeType == 1 && e < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e], e = 0;
    } else if (t.parentNode && !$d(t))
      e = pn(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
function E5(t, e, n) {
  for (let r = e == 0, i = e == Jr(t); r || i; ) {
    if (t == n)
      return !0;
    let o = pn(t);
    if (t = t.parentNode, !t)
      return !1;
    r = r && o == 0, i = i && o == Jr(t);
  }
}
function $d(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const pm = function(t) {
  return t.focusNode && ul(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function Ys(t, e) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n;
}
function _5(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function k5(t, e, n) {
  if (t.caretPositionFromPoint)
    try {
      let r = t.caretPositionFromPoint(e, n);
      if (r)
        return { node: r.offsetNode, offset: Math.min(Jr(r.offsetNode), r.offset) };
    } catch {
    }
  if (t.caretRangeFromPoint) {
    let r = t.caretRangeFromPoint(e, n);
    if (r)
      return { node: r.startContainer, offset: Math.min(Jr(r.startContainer), r.startOffset) };
  }
}
const Gi = typeof navigator < "u" ? navigator : null, MD = typeof document < "u" ? document : null, rs = Gi && Gi.userAgent || "", I1 = /Edge\/(\d+)/.exec(rs), $_ = /MSIE \d/.exec(rs), B1 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(rs), fr = !!($_ || B1 || I1), qa = $_ ? document.documentMode : B1 ? +B1[1] : I1 ? +I1[1] : 0, gi = !fr && /gecko\/(\d+)/i.test(rs);
gi && +(/Firefox\/(\d+)/.exec(rs) || [0, 0])[1];
const M1 = !fr && /Chrome\/(\d+)/.exec(rs), En = !!M1, j_ = M1 ? +M1[1] : 0, Xn = !fr && !!Gi && /Apple Computer/.test(Gi.vendor), tu = Xn && (/Mobile\/\w+/.test(rs) || !!Gi && Gi.maxTouchPoints > 2), Xr = tu || (Gi ? /Mac/.test(Gi.platform) : !1), A5 = Gi ? /Win/.test(Gi.platform) : !1, Bo = /Android \d/.test(rs), jd = !!MD && "webkitFontSmoothing" in MD.documentElement.style, U5 = jd ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function F5(t) {
  let e = t.defaultView && t.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.documentElement.clientWidth,
    top: 0,
    bottom: t.documentElement.clientHeight
  };
}
function Co(t, e) {
  return typeof t == "number" ? t : t[e];
}
function R5(t) {
  let e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, r = e.height / t.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * r
  };
}
function ND(t, e, n) {
  let r = t.someProp("scrollThreshold") || 0, i = t.someProp("scrollMargin") || 5, o = t.dom.ownerDocument;
  for (let a = n || t.dom; a; a = cd(a)) {
    if (a.nodeType != 1)
      continue;
    let s = a, l = s == o.body, u = l ? F5(o) : R5(s), f = 0, h = 0;
    if (e.top < u.top + Co(r, "top") ? h = -(u.top - e.top + Co(i, "top")) : e.bottom > u.bottom - Co(r, "bottom") && (h = e.bottom - e.top > u.bottom - u.top ? e.top + Co(i, "top") - u.top : e.bottom - u.bottom + Co(i, "bottom")), e.left < u.left + Co(r, "left") ? f = -(u.left - e.left + Co(i, "left")) : e.right > u.right - Co(r, "right") && (f = e.right - u.right + Co(i, "right")), f || h)
      if (l)
        o.defaultView.scrollBy(f, h);
      else {
        let p = s.scrollLeft, y = s.scrollTop;
        h && (s.scrollTop += h), f && (s.scrollLeft += f);
        let b = s.scrollLeft - p, x = s.scrollTop - y;
        e = { left: e.left - b, top: e.top - x, right: e.right - b, bottom: e.bottom - x };
      }
    if (l || /^(fixed|sticky)$/.test(getComputedStyle(a).position))
      break;
  }
}
function O5(t) {
  let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), r, i;
  for (let o = (e.left + e.right) / 2, a = n + 1; a < Math.min(innerHeight, e.bottom); a += 5) {
    let s = t.root.elementFromPoint(o, a);
    if (!s || s == t.dom || !t.dom.contains(s))
      continue;
    let l = s.getBoundingClientRect();
    if (l.top >= n - 20) {
      r = s, i = l.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: H_(t.dom) };
}
function H_(t) {
  let e = [], n = t.ownerDocument;
  for (let r = t; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n); r = cd(r))
    ;
  return e;
}
function I5({ refDOM: t, refTop: e, stack: n }) {
  let r = t ? t.getBoundingClientRect().top : 0;
  V_(n, r == 0 ? 0 : r - e);
}
function V_(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: r, top: i, left: o } = t[n];
    r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != o && (r.scrollLeft = o);
  }
}
let Cc = null;
function B5(t) {
  if (t.setActive)
    return t.setActive();
  if (Cc)
    return t.focus(Cc);
  let e = H_(t);
  t.focus(Cc == null ? {
    get preventScroll() {
      return Cc = { preventScroll: !0 }, !0;
    }
  } : void 0), Cc || (Cc = !1, V_(e, 0));
}
function q_(t, e) {
  let n, r = 2e8, i, o = 0, a = e.top, s = e.top, l, u;
  for (let f = t.firstChild, h = 0; f; f = f.nextSibling, h++) {
    let p;
    if (f.nodeType == 1)
      p = f.getClientRects();
    else if (f.nodeType == 3)
      p = Io(f).getClientRects();
    else
      continue;
    for (let y = 0; y < p.length; y++) {
      let b = p[y];
      if (b.top <= a && b.bottom >= s) {
        a = Math.max(b.bottom, a), s = Math.min(b.top, s);
        let x = b.left > e.left ? b.left - e.left : b.right < e.left ? e.left - b.right : 0;
        if (x < r) {
          n = f, r = x, i = x && n.nodeType == 3 ? {
            left: b.right < e.left ? b.right : b.left,
            top: e.top
          } : e, f.nodeType == 1 && x && (o = h + (e.left >= (b.left + b.right) / 2 ? 1 : 0));
          continue;
        }
      } else b.top > e.top && !l && b.left <= e.left && b.right >= e.left && (l = f, u = { left: Math.max(b.left, Math.min(b.right, e.left)), top: b.top });
      !n && (e.left >= b.right && e.top >= b.top || e.left >= b.left && e.top >= b.bottom) && (o = h + 1);
    }
  }
  return !n && l && (n = l, i = u, r = 0), n && n.nodeType == 3 ? M5(n, i) : !n || r && n.nodeType == 1 ? { node: t, offset: o } : q_(n, i);
}
function M5(t, e) {
  let n = t.nodeValue.length, r = document.createRange();
  for (let i = 0; i < n; i++) {
    r.setEnd(t, i + 1), r.setStart(t, i);
    let o = Ua(r, 1);
    if (o.top != o.bottom && Z0(e, o))
      return { node: t, offset: i + (e.left >= (o.left + o.right) / 2 ? 1 : 0) };
  }
  return { node: t, offset: 0 };
}
function Z0(t, e) {
  return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
}
function N5(t, e) {
  let n = t.parentNode;
  return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
}
function P5(t, e, n) {
  let { node: r, offset: i } = q_(e, n), o = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let a = r.getBoundingClientRect();
    o = a.left != a.right && n.left > (a.left + a.right) / 2 ? 1 : -1;
  }
  return t.docView.posFromDOM(r, i, o);
}
function W5(t, e, n, r) {
  let i = -1;
  for (let o = e, a = !1; o != t.dom; ) {
    let s = t.docView.nearestDesc(o, !0), l;
    if (!s)
      return null;
    if (s.dom.nodeType == 1 && (s.node.isBlock && s.parent || !s.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((l = s.dom.getBoundingClientRect()).width || l.height) && (s.node.isBlock && s.parent && (!a && l.left > r.left || l.top > r.top ? i = s.posBefore : (!a && l.right < r.left || l.bottom < r.top) && (i = s.posAfter), a = !0), !s.contentDOM && i < 0 && !s.node.isText))
      return (s.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? s.posBefore : s.posAfter;
    o = s.dom.parentNode;
  }
  return i > -1 ? i : t.docView.posFromDOM(e, n, -1);
}
function X_(t, e, n) {
  let r = t.childNodes.length;
  if (r && n.top < n.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - n.top) / (n.bottom - n.top)) - 2)), o = i; ; ) {
      let a = t.childNodes[o];
      if (a.nodeType == 1) {
        let s = a.getClientRects();
        for (let l = 0; l < s.length; l++) {
          let u = s[l];
          if (Z0(e, u))
            return X_(a, e, u);
        }
      }
      if ((o = (o + 1) % r) == i)
        break;
    }
  return t;
}
function L5(t, e) {
  let n = t.dom.ownerDocument, r, i = 0, o = k5(n, e.left, e.top);
  o && ({ node: r, offset: i } = o);
  let a = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), s;
  if (!a || !t.dom.contains(a.nodeType != 1 ? a.parentNode : a)) {
    let u = t.dom.getBoundingClientRect();
    if (!Z0(e, u) || (a = X_(t.dom, e, u), !a))
      return null;
  }
  if (Xn)
    for (let u = a; r && u; u = cd(u))
      u.draggable && (r = void 0);
  if (a = N5(a, e), r) {
    if (gi && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let f = r.childNodes[i], h;
      f.nodeName == "IMG" && (h = f.getBoundingClientRect()).right <= e.left && h.bottom > e.top && i++;
    }
    let u;
    jd && i && r.nodeType == 1 && (u = r.childNodes[i - 1]).nodeType == 1 && u.contentEditable == "false" && u.getBoundingClientRect().top >= e.top && i--, r == t.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? s = t.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (s = W5(t, r, i, e));
  }
  s == null && (s = P5(t, a, e));
  let l = t.docView.nearestDesc(a, !0);
  return { pos: s, inside: l ? l.posAtStart - l.border : -1 };
}
function PD(t) {
  return t.top < t.bottom || t.left < t.right;
}
function Ua(t, e) {
  let n = t.getClientRects();
  if (n.length) {
    let r = n[e < 0 ? 0 : n.length - 1];
    if (PD(r))
      return r;
  }
  return Array.prototype.find.call(n, PD) || t.getBoundingClientRect();
}
const z5 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function G_(t, e, n) {
  let { node: r, offset: i, atom: o } = t.docView.domFromPos(e, n < 0 ? -1 : 1), a = jd || gi;
  if (r.nodeType == 3)
    if (a && (z5.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))) {
      let l = Ua(Io(r, i, i), n);
      if (gi && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let u = Ua(Io(r, i - 1, i - 1), -1);
        if (u.top == l.top) {
          let f = Ua(Io(r, i, i + 1), -1);
          if (f.top != l.top)
            return kf(f, f.left < u.left);
        }
      }
      return l;
    } else {
      let l = i, u = i, f = n < 0 ? 1 : -1;
      return n < 0 && !i ? (u++, f = -1) : n >= 0 && i == r.nodeValue.length ? (l--, f = 1) : n < 0 ? l-- : u++, kf(Ua(Io(r, l, u), f), f < 0);
    }
  if (!t.state.doc.resolve(e - (o || 0)).parent.inlineContent) {
    if (o == null && i && (n < 0 || i == Jr(r))) {
      let l = r.childNodes[i - 1];
      if (l.nodeType == 1)
        return wb(l.getBoundingClientRect(), !1);
    }
    if (o == null && i < Jr(r)) {
      let l = r.childNodes[i];
      if (l.nodeType == 1)
        return wb(l.getBoundingClientRect(), !0);
    }
    return wb(r.getBoundingClientRect(), n >= 0);
  }
  if (o == null && i && (n < 0 || i == Jr(r))) {
    let l = r.childNodes[i - 1], u = l.nodeType == 3 ? Io(l, Jr(l) - (a ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (u)
      return kf(Ua(u, 1), !1);
  }
  if (o == null && i < Jr(r)) {
    let l = r.childNodes[i];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let u = l ? l.nodeType == 3 ? Io(l, 0, a ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (u)
      return kf(Ua(u, -1), !0);
  }
  return kf(Ua(r.nodeType == 3 ? Io(r) : r, -n), n >= 0);
}
function kf(t, e) {
  if (t.width == 0)
    return t;
  let n = e ? t.left : t.right;
  return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function wb(t, e) {
  if (t.height == 0)
    return t;
  let n = e ? t.top : t.bottom;
  return { top: n, bottom: n, left: t.left, right: t.right };
}
function J_(t, e, n) {
  let r = t.state, i = t.root.activeElement;
  r != e && t.updateState(e), i != t.dom && t.focus();
  try {
    return n();
  } finally {
    r != e && t.updateState(r), i != t.dom && i && i.focus();
  }
}
function $5(t, e, n) {
  let r = e.selection, i = n == "up" ? r.$from : r.$to;
  return J_(t, e, () => {
    let { node: o } = t.docView.domFromPos(i.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let s = t.docView.nearestDesc(o, !0);
      if (!s)
        break;
      if (s.node.isBlock) {
        o = s.contentDOM || s.dom;
        break;
      }
      o = s.dom.parentNode;
    }
    let a = G_(t, i.pos, 1);
    for (let s = o.firstChild; s; s = s.nextSibling) {
      let l;
      if (s.nodeType == 1)
        l = s.getClientRects();
      else if (s.nodeType == 3)
        l = Io(s, 0, s.nodeValue.length).getClientRects();
      else
        continue;
      for (let u = 0; u < l.length; u++) {
        let f = l[u];
        if (f.bottom > f.top + 1 && (n == "up" ? a.top - f.top > (f.bottom - a.top) * 2 : f.bottom - a.bottom > (a.bottom - f.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const j5 = /[\u0590-\u08ac]/;
function H5(t, e, n) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, o = !i, a = i == r.parent.content.size, s = t.domSelection();
  return s ? !j5.test(r.parent.textContent) || !s.modify ? n == "left" || n == "backward" ? o : a : J_(t, e, () => {
    let { focusNode: l, focusOffset: u, anchorNode: f, anchorOffset: h } = t.domSelectionRange(), p = s.caretBidiLevel;
    s.modify("move", n, "character");
    let y = r.depth ? t.docView.domAfterPos(r.before()) : t.dom, { focusNode: b, focusOffset: x } = t.domSelectionRange(), v = b && !y.contains(b.nodeType == 1 ? b : b.parentNode) || l == b && u == x;
    try {
      s.collapse(f, h), l && (l != f || u != h) && s.extend && s.extend(l, u);
    } catch {
    }
    return p != null && (s.caretBidiLevel = p), v;
  }) : r.pos == r.start() || r.pos == r.end();
}
let WD = null, LD = null, zD = !1;
function V5(t, e, n) {
  return WD == e && LD == n ? zD : (WD = e, LD = n, zD = n == "up" || n == "down" ? $5(t, e, n) : H5(t, e, n));
}
const Yr = 0, $D = 1, Zs = 2, Ji = 3;
class Hd {
  constructor(e, n, r, i) {
    this.parent = e, this.children = n, this.dom = r, this.contentDOM = i, this.dirty = Yr, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, n, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++)
      e += this.children[n].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let i = this.children[n];
      if (i == e)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let o, a;
        if (e == this.contentDOM)
          o = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          o = e.previousSibling;
        }
        for (; o && !((a = o.pmViewDesc) && a.parent == this); )
          o = o.previousSibling;
        return o ? this.posBeforeChild(a) + a.size : this.posAtStart;
      } else {
        let o, a;
        if (e == this.contentDOM)
          o = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          o = e.nextSibling;
        }
        for (; o && !((a = o.pmViewDesc) && a.parent == this); )
          o = o.nextSibling;
        return o ? this.posBeforeChild(a) : this.posAtEnd;
      }
    let i;
    if (e == this.dom && this.contentDOM)
      i = n > pn(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !1;
            break;
          }
          if (o.previousSibling)
            break;
        }
      if (i == null && n == e.childNodes.length)
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !0;
            break;
          }
          if (o.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      let o = this.getDesc(i), a;
      if (o && (!n || o.node))
        if (r && (a = o.nodeDOM) && !(a.nodeType == 1 ? a.contains(e.nodeType == 1 ? e : e.parentNode) : a == e))
          r = !1;
        else
          return o;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let r = n; r; r = r.parent)
      if (r == this)
        return n;
  }
  posFromDOM(e, n, r) {
    for (let i = e; i; i = i.parentNode) {
      let o = this.getDesc(i);
      if (o)
        return o.localPosFromDOM(e, n, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let i = this.children[n], o = r + i.size;
      if (r == e && o != r) {
        for (; !i.border && i.children.length; )
          i = i.children[0];
        return i;
      }
      if (e < o)
        return i.descAt(e - r - i.border);
      r = o;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, i = 0;
    for (let o = 0; r < this.children.length; r++) {
      let a = this.children[r], s = o + a.size;
      if (s > e || a instanceof Z_) {
        i = e - o;
        break;
      }
      o = s;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, n);
    for (let o; r && !(o = this.children[r - 1]).size && o instanceof Y_ && o.side >= 0; r--)
      ;
    if (n <= 0) {
      let o, a = !0;
      for (; o = r ? this.children[r - 1] : null, !(!o || o.dom.parentNode == this.contentDOM); r--, a = !1)
        ;
      return o && n && a && !o.border && !o.domAtom ? o.domFromPos(o.size, n) : { node: this.contentDOM, offset: o ? pn(o.dom) + 1 : 0 };
    } else {
      let o, a = !0;
      for (; o = r < this.children.length ? this.children[r] : null, !(!o || o.dom.parentNode == this.contentDOM); r++, a = !1)
        ;
      return o && a && !o.border && !o.domAtom ? o.domFromPos(0, n) : { node: this.contentDOM, offset: o ? pn(o.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, n, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, o = -1;
    for (let a = r, s = 0; ; s++) {
      let l = this.children[s], u = a + l.size;
      if (i == -1 && e <= u) {
        let f = a + l.border;
        if (e >= f && n <= u - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, n, f);
        e = a;
        for (let h = s; h > 0; h--) {
          let p = this.children[h - 1];
          if (p.size && p.dom.parentNode == this.contentDOM && !p.emptyChildAt(1)) {
            i = pn(p.dom) + 1;
            break;
          }
          e -= p.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (u > n || s == this.children.length - 1)) {
        n = u;
        for (let f = s + 1; f < this.children.length; f++) {
          let h = this.children[f];
          if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(-1)) {
            o = pn(h.dom);
            break;
          }
          n += h.size;
        }
        o == -1 && (o = this.contentDOM.childNodes.length);
        break;
      }
      a = u;
    }
    return { node: this.contentDOM, from: e, to: n, fromOffset: i, toOffset: o };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: r } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, n, r, i = !1) {
    let o = Math.min(e, n), a = Math.max(e, n);
    for (let y = 0, b = 0; y < this.children.length; y++) {
      let x = this.children[y], v = b + x.size;
      if (o > b && a < v)
        return x.setSelection(e - b - x.border, n - b - x.border, r, i);
      b = v;
    }
    let s = this.domFromPos(e, e ? -1 : 1), l = n == e ? s : this.domFromPos(n, n ? -1 : 1), u = r.root.getSelection(), f = r.domSelectionRange(), h = !1;
    if ((gi || Xn) && e == n) {
      let { node: y, offset: b } = s;
      if (y.nodeType == 3) {
        if (h = !!(b && y.nodeValue[b - 1] == `
`), h && b == y.nodeValue.length)
          for (let x = y, v; x; x = x.parentNode) {
            if (v = x.nextSibling) {
              v.nodeName == "BR" && (s = l = { node: v.parentNode, offset: pn(v) + 1 });
              break;
            }
            let D = x.pmViewDesc;
            if (D && D.node && D.node.isBlock)
              break;
          }
      } else {
        let x = y.childNodes[b - 1];
        h = x && (x.nodeName == "BR" || x.contentEditable == "false");
      }
    }
    if (gi && f.focusNode && f.focusNode != l.node && f.focusNode.nodeType == 1) {
      let y = f.focusNode.childNodes[f.focusOffset];
      y && y.contentEditable == "false" && (i = !0);
    }
    if (!(i || h && Xn) && ul(s.node, s.offset, f.anchorNode, f.anchorOffset) && ul(l.node, l.offset, f.focusNode, f.focusOffset))
      return;
    let p = !1;
    if ((u.extend || e == n) && !h) {
      u.collapse(s.node, s.offset);
      try {
        e != n && u.extend(l.node, l.offset), p = !0;
      } catch {
      }
    }
    if (!p) {
      if (e > n) {
        let b = s;
        s = l, l = b;
      }
      let y = document.createRange();
      y.setEnd(l.node, l.offset), y.setStart(s.node, s.offset), u.removeAllRanges(), u.addRange(y);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, n) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let o = this.children[i], a = r + o.size;
      if (r == a ? e <= a && n >= r : e < a && n > r) {
        let s = r + o.border, l = a - o.border;
        if (e >= s && n <= l) {
          this.dirty = e == r || n == a ? Zs : $D, e == s && n == l && (o.contentLost || o.dom.parentNode != this.contentDOM) ? o.dirty = Ji : o.markDirty(e - s, n - s);
          return;
        } else
          o.dirty = o.dom == o.contentDOM && o.dom.parentNode == this.contentDOM && !o.children.length ? Zs : Ji;
      }
      r = a;
    }
    this.dirty = Zs;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let r = e == 1 ? Zs : $D;
      n.dirty < r && (n.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class Y_ extends Hd {
  constructor(e, n, r, i) {
    let o, a = n.type.toDOM;
    if (typeof a == "function" && (a = a(r, () => {
      if (!o)
        return i;
      if (o.parent)
        return o.parent.posBeforeChild(o);
    })), !n.type.spec.raw) {
      if (a.nodeType != 1) {
        let s = document.createElement("span");
        s.appendChild(a), a = s;
      }
      a.contentEditable = "false", a.classList.add("ProseMirror-widget");
    }
    super(e, [], a, null), this.widget = n, this.widget = n, o = this;
  }
  matchesWidget(e) {
    return this.dirty == Yr && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class q5 extends Hd {
  constructor(e, n, r, i) {
    super(e, [], n, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class fl extends Hd {
  constructor(e, n, r, i, o) {
    super(e, [], r, i), this.mark = n, this.spec = o;
  }
  static create(e, n, r, i) {
    let o = i.nodeViews[n.type.name], a = o && o(n, i, r);
    return (!a || !a.dom) && (a = vu.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)), new fl(e, n, a.dom, a.contentDOM || a.dom, a);
  }
  parseRule() {
    return this.dirty & Ji || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != Ji && this.mark.eq(e);
  }
  markDirty(e, n) {
    if (super.markDirty(e, n), this.dirty != Yr) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = Yr;
    }
  }
  slice(e, n, r) {
    let i = fl.create(this.parent, this.mark, !0, r), o = this.children, a = this.size;
    n < a && (o = P1(o, n, a, r)), e > 0 && (o = P1(o, 0, e, r));
    for (let s = 0; s < o.length; s++)
      o[s].parent = i;
    return i.children = o, i;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class Xa extends Hd {
  constructor(e, n, r, i, o, a, s, l, u) {
    super(e, [], o, a), this.node = n, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = s;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, n, r, i, o, a) {
    let s = o.nodeViews[n.type.name], l, u = s && s(n, o, () => {
      if (!l)
        return a;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, r, i), f = u && u.dom, h = u && u.contentDOM;
    if (n.isText) {
      if (!f)
        f = document.createTextNode(n.text);
      else if (f.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else f || ({ dom: f, contentDOM: h } = vu.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !h && !n.isText && f.nodeName != "BR" && (f.hasAttribute("contenteditable") || (f.contentEditable = "false"), n.type.spec.draggable && (f.draggable = !0));
    let p = f;
    return f = ek(f, r, n), u ? l = new X5(e, n, r, i, f, h || null, p, u, o, a + 1) : n.isText ? new gm(e, n, r, i, f, p, o) : new Xa(e, n, r, i, f, h || null, p, o, a + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => Fe.empty);
    }
    return e;
  }
  matchesNode(e, n, r) {
    return this.dirty == Yr && e.eq(this.node) && qp(n, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, n) {
    let r = this.node.inlineContent, i = n, o = e.composing ? this.localCompositionInfo(e, n) : null, a = o && o.pos > -1 ? o : null, s = o && o.pos < 0, l = new J5(this, a && a.node, e);
    K5(this.node, this.innerDeco, (u, f, h) => {
      u.spec.marks ? l.syncToMarks(u.spec.marks, r, e) : u.type.side >= 0 && !h && l.syncToMarks(f == this.node.childCount ? mt.none : this.node.child(f).marks, r, e), l.placeWidget(u, e, i);
    }, (u, f, h, p) => {
      l.syncToMarks(u.marks, r, e);
      let y;
      l.findNodeMatch(u, f, h, p) || s && e.state.selection.from > i && e.state.selection.to < i + u.nodeSize && (y = l.findIndexWithChild(o.node)) > -1 && l.updateNodeAt(u, f, h, y, e) || l.updateNextNode(u, f, h, e, p, i) || l.addNode(u, f, h, e, i), i += u.nodeSize;
    }), l.syncToMarks([], r, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == Zs) && (a && this.protectLocalComposition(e, a), K_(this.contentDOM, this.children, e), tu && Q5(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: r, to: i } = e.state.selection;
    if (!(e.state.selection instanceof st) || r < n || i > n + this.node.content.size)
      return null;
    let o = e.input.compositionNode;
    if (!o || !this.dom.contains(o.parentNode))
      return null;
    if (this.node.inlineContent) {
      let a = o.nodeValue, s = eO(this.node.content, a, r - n, i - n);
      return s < 0 ? null : { node: o, pos: s, text: a };
    } else
      return { node: o, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: r, text: i }) {
    if (this.getDesc(n))
      return;
    let o = n;
    for (; o.parentNode != this.contentDOM; o = o.parentNode) {
      for (; o.previousSibling; )
        o.parentNode.removeChild(o.previousSibling);
      for (; o.nextSibling; )
        o.parentNode.removeChild(o.nextSibling);
      o.pmViewDesc && (o.pmViewDesc = void 0);
    }
    let a = new q5(this, o, n, i);
    e.input.compositionNodes.push(a), this.children = P1(this.children, r, r + i.length, e, a);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, n, r, i) {
    return this.dirty == Ji || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, i), !0);
  }
  updateInner(e, n, r, i) {
    this.updateOuterDeco(n), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = Yr;
  }
  updateOuterDeco(e) {
    if (qp(e, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = Q_(this.dom, this.nodeDOM, N1(this.outerDeco, this.node, n), N1(e, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function jD(t, e, n, r, i) {
  ek(r, e, t);
  let o = new Xa(void 0, t, e, n, r, r, r, i, 0);
  return o.contentDOM && o.updateChildren(i, 0), o;
}
class gm extends Xa {
  constructor(e, n, r, i, o, a, s) {
    super(e, n, r, i, o, null, a, s, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, n, r, i) {
    return this.dirty == Ji || this.dirty != Yr && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != Yr || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = Yr, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, r) {
    let i = this.node.cut(e, n), o = document.createTextNode(i.text);
    return new gm(this.parent, i, this.outerDeco, this.innerDeco, o, o, r);
  }
  markDirty(e, n) {
    super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = Ji);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class Z_ extends Hd {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == Yr && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class X5 extends Xa {
  constructor(e, n, r, i, o, a, s, l, u, f) {
    super(e, n, r, i, o, a, s, u, f), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, n, r, i) {
    if (this.dirty == Ji)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let o = this.spec.update(e, n, r);
      return o && this.updateInner(e, n, r, i), o;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, r, i) {
    this.spec.setSelection ? this.spec.setSelection(e, n, r.root) : super.setSelection(e, n, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function K_(t, e, n) {
  let r = t.firstChild, i = !1;
  for (let o = 0; o < e.length; o++) {
    let a = e[o], s = a.dom;
    if (s.parentNode == t) {
      for (; s != r; )
        r = HD(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, t.insertBefore(s, r);
    if (a instanceof fl) {
      let l = r ? r.previousSibling : t.lastChild;
      K_(a.contentDOM, a.children, n), r = l ? l.nextSibling : t.firstChild;
    }
  }
  for (; r; )
    r = HD(r), i = !0;
  i && n.trackWrites == t && (n.trackWrites = null);
}
const Gf = function(t) {
  t && (this.nodeName = t);
};
Gf.prototype = /* @__PURE__ */ Object.create(null);
const Ks = [new Gf()];
function N1(t, e, n) {
  if (t.length == 0)
    return Ks;
  let r = n ? Ks[0] : new Gf(), i = [r];
  for (let o = 0; o < t.length; o++) {
    let a = t[o].type.attrs;
    if (a) {
      a.nodeName && i.push(r = new Gf(a.nodeName));
      for (let s in a) {
        let l = a[s];
        l != null && (n && i.length == 1 && i.push(r = new Gf(e.isInline ? "span" : "div")), s == "class" ? r.class = (r.class ? r.class + " " : "") + l : s == "style" ? r.style = (r.style ? r.style + ";" : "") + l : s != "nodeName" && (r[s] = l));
      }
    }
  }
  return i;
}
function Q_(t, e, n, r) {
  if (n == Ks && r == Ks)
    return e;
  let i = e;
  for (let o = 0; o < r.length; o++) {
    let a = r[o], s = n[o];
    if (o) {
      let l;
      s && s.nodeName == a.nodeName && i != t && (l = i.parentNode) && l.nodeName.toLowerCase() == a.nodeName || (l = document.createElement(a.nodeName), l.pmIsDeco = !0, l.appendChild(i), s = Ks[0]), i = l;
    }
    G5(i, s || Ks[0], a);
  }
  return i;
}
function G5(t, e, n) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in n) && t.removeAttribute(r);
  for (let r in n)
    r != "class" && r != "style" && r != "nodeName" && n[r] != e[r] && t.setAttribute(r, n[r]);
  if (e.class != n.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let o = 0; o < r.length; o++)
      i.indexOf(r[o]) == -1 && t.classList.remove(r[o]);
    for (let o = 0; o < i.length; o++)
      r.indexOf(i[o]) == -1 && t.classList.add(i[o]);
    t.classList.length == 0 && t.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(e.style); )
        t.style.removeProperty(i[1]);
    }
    n.style && (t.style.cssText += n.style);
  }
}
function ek(t, e, n) {
  return Q_(t, t, Ks, N1(e, n, t.nodeType != 1));
}
function qp(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].type.eq(e[n].type))
      return !1;
  return !0;
}
function HD(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class J5 {
  constructor(e, n, r) {
    this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = Y5(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, n) {
    if (e != n) {
      for (let r = e; r < n; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, n - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, n, r) {
    let i = 0, o = this.stack.length >> 1, a = Math.min(o, e.length);
    for (; i < a && (i == o - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < o; )
      this.destroyRest(), this.top.dirty = Yr, this.index = this.stack.pop(), this.top = this.stack.pop(), o--;
    for (; o < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let s = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let u = this.top.children[l];
        if (u.matchesMark(e[o]) && !this.isLocked(u.dom)) {
          s = l;
          break;
        }
      }
      if (s > -1)
        s > this.index && (this.changed = !0, this.destroyBetween(this.index, s)), this.top = this.top.children[this.index];
      else {
        let l = fl.create(this.top, e[o], n, r);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, o++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, n, r, i) {
    let o = -1, a;
    if (i >= this.preMatch.index && (a = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && a.matchesNode(e, n, r))
      o = this.top.children.indexOf(a, this.index);
    else
      for (let s = this.index, l = Math.min(this.top.children.length, s + 5); s < l; s++) {
        let u = this.top.children[s];
        if (u.matchesNode(e, n, r) && !this.preMatch.matched.has(u)) {
          o = s;
          break;
        }
      }
    return o < 0 ? !1 : (this.destroyBetween(this.index, o), this.index++, !0);
  }
  updateNodeAt(e, n, r, i, o) {
    let a = this.top.children[i];
    return a.dirty == Ji && a.dom == a.contentDOM && (a.dirty = Zs), a.update(e, n, r, o) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let n = e.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      e = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, n, r, i, o, a) {
    for (let s = this.index; s < this.top.children.length; s++) {
      let l = this.top.children[s];
      if (l instanceof Xa) {
        let u = this.preMatch.matched.get(l);
        if (u != null && u != o)
          return !1;
        let f = l.dom, h, p = this.isLocked(f) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != Ji && qp(n, l.outerDeco));
        if (!p && l.update(e, n, r, i))
          return this.destroyBetween(this.index, s), l.dom != f && (this.changed = !0), this.index++, !0;
        if (!p && (h = this.recreateWrapper(l, e, n, r, i, a)))
          return this.destroyBetween(this.index, s), this.top.children[this.index] = h, h.contentDOM && (h.dirty = Zs, h.updateChildren(i, a + 1), h.dirty = Yr), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, n, r, i, o, a) {
    if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !qp(r, e.outerDeco) || !i.eq(e.innerDeco))
      return null;
    let s = Xa.create(this.top, n, r, i, o, a);
    if (s.contentDOM) {
      s.children = e.children, e.children = [];
      for (let l of s.children)
        l.parent = s;
    }
    return e.destroy(), s;
  }
  // Insert the node as a newly created node desc.
  addNode(e, n, r, i, o) {
    let a = Xa.create(this.top, e, n, r, i, o);
    a.contentDOM && a.updateChildren(i, o + 1), this.top.children.splice(this.index++, 0, a), this.changed = !0;
  }
  placeWidget(e, n, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let o = new Y_(this.top, e, n, r);
      this.top.children.splice(this.index++, 0, o), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], n = this.top;
    for (; e instanceof fl; )
      n = e, e = n.children[n.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof gm) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Xn || En) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new Z_(this.top, [], r, null);
      n != this.top ? n.children.push(i) : n.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function Y5(t, e) {
  let n = e, r = n.children.length, i = t.childCount, o = /* @__PURE__ */ new Map(), a = [];
  e: for (; i > 0; ) {
    let s;
    for (; ; )
      if (r) {
        let u = n.children[r - 1];
        if (u instanceof fl)
          n = u, r = u.children.length;
        else {
          s = u, r--;
          break;
        }
      } else {
        if (n == e)
          break e;
        r = n.parent.children.indexOf(n), n = n.parent;
      }
    let l = s.node;
    if (l) {
      if (l != t.child(i - 1))
        break;
      --i, o.set(s, i), a.push(s);
    }
  }
  return { index: i, matched: o, matches: a.reverse() };
}
function Z5(t, e) {
  return t.type.side - e.type.side;
}
function K5(t, e, n, r) {
  let i = e.locals(t), o = 0;
  if (i.length == 0) {
    for (let u = 0; u < t.childCount; u++) {
      let f = t.child(u);
      r(f, i, e.forChild(o, f), u), o += f.nodeSize;
    }
    return;
  }
  let a = 0, s = [], l = null;
  for (let u = 0; ; ) {
    let f, h;
    for (; a < i.length && i[a].to == o; ) {
      let v = i[a++];
      v.widget && (f ? (h || (h = [f])).push(v) : f = v);
    }
    if (f)
      if (h) {
        h.sort(Z5);
        for (let v = 0; v < h.length; v++)
          n(h[v], u, !!l);
      } else
        n(f, u, !!l);
    let p, y;
    if (l)
      y = -1, p = l, l = null;
    else if (u < t.childCount)
      y = u, p = t.child(u++);
    else
      break;
    for (let v = 0; v < s.length; v++)
      s[v].to <= o && s.splice(v--, 1);
    for (; a < i.length && i[a].from <= o && i[a].to > o; )
      s.push(i[a++]);
    let b = o + p.nodeSize;
    if (p.isText) {
      let v = b;
      a < i.length && i[a].from < v && (v = i[a].from);
      for (let D = 0; D < s.length; D++)
        s[D].to < v && (v = s[D].to);
      v < b && (l = p.cut(v - o), p = p.cut(0, v - o), b = v, y = -1);
    } else
      for (; a < i.length && i[a].to < b; )
        a++;
    let x = p.isInline && !p.isLeaf ? s.filter((v) => !v.inline) : s.slice();
    r(p, x, e.forChild(o, p), y), o = b;
  }
}
function Q5(t) {
  if (t.nodeName == "UL" || t.nodeName == "OL") {
    let e = t.style.cssText;
    t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e;
  }
}
function eO(t, e, n, r) {
  for (let i = 0, o = 0; i < t.childCount && o <= r; ) {
    let a = t.child(i++), s = o;
    if (o += a.nodeSize, !a.isText)
      continue;
    let l = a.text;
    for (; i < t.childCount; ) {
      let u = t.child(i++);
      if (o += u.nodeSize, !u.isText)
        break;
      l += u.text;
    }
    if (o >= n) {
      if (o >= r && l.slice(r - e.length - s, r - s) == e)
        return r - e.length;
      let u = s < r ? l.lastIndexOf(e, r - s - 1) : -1;
      if (u >= 0 && u + e.length + s >= n)
        return s + u;
      if (n == r && l.length >= r + e.length - s && l.slice(r - s, r - s + e.length) == e)
        return r;
    }
  }
  return -1;
}
function P1(t, e, n, r, i) {
  let o = [];
  for (let a = 0, s = 0; a < t.length; a++) {
    let l = t[a], u = s, f = s += l.size;
    u >= n || f <= e ? o.push(l) : (u < e && o.push(l.slice(0, e - u, r)), i && (o.push(i), i = void 0), f > n && o.push(l.slice(n - u, l.size, r)));
  }
  return o;
}
function K0(t, e = null) {
  let n = t.domSelectionRange(), r = t.state.doc;
  if (!n.focusNode)
    return null;
  let i = t.docView.nearestDesc(n.focusNode), o = i && i.size == 0, a = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (a < 0)
    return null;
  let s = r.resolve(a), l, u;
  if (pm(n)) {
    for (l = a; i && !i.node; )
      i = i.parent;
    let h = i.node;
    if (i && h.isAtom && Ye.isSelectable(h) && i.parent && !(h.isInline && E5(n.focusNode, n.focusOffset, i.dom))) {
      let p = i.posBefore;
      u = new Ye(a == p ? s : r.resolve(p));
    }
  } else {
    if (n instanceof t.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
      let h = a, p = a;
      for (let y = 0; y < n.rangeCount; y++) {
        let b = n.getRangeAt(y);
        h = Math.min(h, t.docView.posFromDOM(b.startContainer, b.startOffset, 1)), p = Math.max(p, t.docView.posFromDOM(b.endContainer, b.endOffset, -1));
      }
      if (h < 0)
        return null;
      [l, a] = p == t.state.selection.anchor ? [p, h] : [h, p], s = r.resolve(a);
    } else
      l = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (l < 0)
      return null;
  }
  let f = r.resolve(l);
  if (!u) {
    let h = e == "pointer" || t.state.selection.head < s.pos && !o ? 1 : -1;
    u = Q0(t, f, s, h);
  }
  return u;
}
function tk(t) {
  return t.editable ? t.hasFocus() : rk(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function No(t, e = !1) {
  let n = t.state.selection;
  if (nk(t, n), !!tk(t)) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && En) {
      let r = t.domSelectionRange(), i = t.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && ul(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection();
        return;
      }
    }
    if (t.domObserver.disconnectSelection(), t.cursorWrapper)
      nO(t);
    else {
      let { anchor: r, head: i } = n, o, a;
      VD && !(n instanceof st) && (n.$from.parent.inlineContent || (o = qD(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (a = qD(t, n.to))), t.docView.setSelection(r, i, t, e), VD && (o && XD(o), a && XD(a)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && tO(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const VD = Xn || En && j_ < 63;
function qD(t, e) {
  let { node: n, offset: r } = t.docView.domFromPos(e, 0), i = r < n.childNodes.length ? n.childNodes[r] : null, o = r ? n.childNodes[r - 1] : null;
  if (Xn && i && i.contentEditable == "false")
    return Sb(i);
  if ((!i || i.contentEditable == "false") && (!o || o.contentEditable == "false")) {
    if (i)
      return Sb(i);
    if (o)
      return Sb(o);
  }
}
function Sb(t) {
  return t.contentEditable = "true", Xn && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
}
function XD(t) {
  t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
}
function tO(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(), r = n.anchorNode, i = n.anchorOffset;
  e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
    (n.anchorNode != r || n.anchorOffset != i) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
      (!tk(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function nO(t) {
  let e = t.domSelection(), n = document.createRange();
  if (!e)
    return;
  let r = t.cursorWrapper.dom, i = r.nodeName == "IMG";
  i ? n.setStart(r.parentNode, pn(r) + 1) : n.setStart(r, 0), n.collapse(!0), e.removeAllRanges(), e.addRange(n), !i && !t.state.selection.visible && fr && qa <= 11 && (r.disabled = !0, r.disabled = !1);
}
function nk(t, e) {
  if (e instanceof Ye) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc && (GD(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
  } else
    GD(t);
}
function GD(t) {
  t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
}
function Q0(t, e, n, r) {
  return t.someProp("createSelectionBetween", (i) => i(t, e, n)) || st.between(e, n, r);
}
function JD(t) {
  return t.editable && !t.hasFocus() ? !1 : rk(t);
}
function rk(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function rO(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0), n = t.domSelectionRange();
  return ul(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function W1(t, e) {
  let { $anchor: n, $head: r } = t.selection, i = e > 0 ? n.max(r) : n.min(r), o = i.parent.inlineContent ? i.depth ? t.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return o && et.findFrom(o, e);
}
function Fa(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function YD(t, e, n) {
  let r = t.state.selection;
  if (r instanceof st)
    if (n.indexOf("s") > -1) {
      let { $head: i } = r, o = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
      if (!o || o.isText || !o.isLeaf)
        return !1;
      let a = t.state.doc.resolve(i.pos + o.nodeSize * (e < 0 ? -1 : 1));
      return Fa(t, new st(r.$anchor, a));
    } else if (r.empty) {
      if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let i = W1(t.state, e);
        return i && i instanceof Ye ? Fa(t, i) : !1;
      } else if (!(Xr && n.indexOf("m") > -1)) {
        let i = r.$head, o = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, a;
        if (!o || o.isText)
          return !1;
        let s = e < 0 ? i.pos - o.nodeSize : i.pos;
        return o.isAtom || (a = t.docView.descAt(s)) && !a.contentDOM ? Ye.isSelectable(o) ? Fa(t, new Ye(e < 0 ? t.state.doc.resolve(i.pos - o.nodeSize) : i)) : jd ? Fa(t, new st(t.state.doc.resolve(e < 0 ? s : s + o.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof Ye && r.node.isInline)
      return Fa(t, new st(e > 0 ? r.$to : r.$from));
    {
      let i = W1(t.state, e);
      return i ? Fa(t, i) : !1;
    }
  }
}
function Xp(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Jf(t, e) {
  let n = t.pmViewDesc;
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function Ec(t, e) {
  return e < 0 ? iO(t) : oO(t);
}
function iO(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let i, o, a = !1;
  for (gi && n.nodeType == 1 && r < Xp(n) && Jf(n.childNodes[r], -1) && (a = !0); ; )
    if (r > 0) {
      if (n.nodeType != 1)
        break;
      {
        let s = n.childNodes[r - 1];
        if (Jf(s, -1))
          i = n, o = --r;
        else if (s.nodeType == 3)
          n = s, r = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (ik(n))
        break;
      {
        let s = n.previousSibling;
        for (; s && Jf(s, -1); )
          i = n.parentNode, o = pn(s), s = s.previousSibling;
        if (s)
          n = s, r = Xp(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = 0;
        }
      }
    }
  a ? L1(t, n, r) : i && L1(t, i, o);
}
function oO(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let i = Xp(n), o, a;
  for (; ; )
    if (r < i) {
      if (n.nodeType != 1)
        break;
      let s = n.childNodes[r];
      if (Jf(s, 1))
        o = n, a = ++r;
      else
        break;
    } else {
      if (ik(n))
        break;
      {
        let s = n.nextSibling;
        for (; s && Jf(s, 1); )
          o = s.parentNode, a = pn(s) + 1, s = s.nextSibling;
        if (s)
          n = s, r = 0, i = Xp(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = i = 0;
        }
      }
    }
  o && L1(t, o, a);
}
function ik(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function aO(t, e) {
  for (; t && e == t.childNodes.length && !$d(t); )
    e = pn(t) + 1, t = t.parentNode;
  for (; t && e < t.childNodes.length; ) {
    let n = t.childNodes[e];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = 0;
  }
}
function sO(t, e) {
  for (; t && !e && !$d(t); )
    e = pn(t), t = t.parentNode;
  for (; t && e; ) {
    let n = t.childNodes[e - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = t.childNodes.length;
  }
}
function L1(t, e, n) {
  if (e.nodeType != 3) {
    let o, a;
    (a = aO(e, n)) ? (e = a, n = 0) : (o = sO(e, n)) && (e = o, n = o.nodeValue.length);
  }
  let r = t.domSelection();
  if (!r)
    return;
  if (pm(r)) {
    let o = document.createRange();
    o.setEnd(e, n), o.setStart(e, n), r.removeAllRanges(), r.addRange(o);
  } else r.extend && r.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: i } = t;
  setTimeout(() => {
    t.state == i && No(t);
  }, 50);
}
function ZD(t, e) {
  let n = t.state.doc.resolve(e);
  if (!(En || A5) && n.parent.inlineContent) {
    let i = t.coordsAtPos(e);
    if (e > n.start()) {
      let o = t.coordsAtPos(e - 1), a = (o.top + o.bottom) / 2;
      if (a > i.top && a < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left < i.left ? "ltr" : "rtl";
    }
    if (e < n.end()) {
      let o = t.coordsAtPos(e + 1), a = (o.top + o.bottom) / 2;
      if (a > i.top && a < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function KD(t, e, n) {
  let r = t.state.selection;
  if (r instanceof st && !r.empty || n.indexOf("s") > -1 || Xr && n.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: o } = r;
  if (!i.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let a = W1(t.state, e);
    if (a && a instanceof Ye)
      return Fa(t, a);
  }
  if (!i.parent.inlineContent) {
    let a = e < 0 ? i : o, s = r instanceof di ? et.near(a, e) : et.findFrom(a, e);
    return s ? Fa(t, s) : !1;
  }
  return !1;
}
function QD(t, e) {
  if (!(t.state.selection instanceof st))
    return !0;
  let { $head: n, $anchor: r, empty: i } = t.state.selection;
  if (!n.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let o = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (o && !o.isText) {
    let a = t.state.tr;
    return e < 0 ? a.delete(n.pos - o.nodeSize, n.pos) : a.delete(n.pos, n.pos + o.nodeSize), t.dispatch(a), !0;
  }
  return !1;
}
function ew(t, e, n) {
  t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
}
function lO(t) {
  if (!Xn || t.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    ew(t, r, "true"), setTimeout(() => ew(t, r, "false"), 20);
  }
  return !1;
}
function cO(t) {
  let e = "";
  return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
}
function uO(t, e) {
  let n = e.keyCode, r = cO(e);
  if (n == 8 || Xr && n == 72 && r == "c")
    return QD(t, -1) || Ec(t, -1);
  if (n == 46 && !e.shiftKey || Xr && n == 68 && r == "c")
    return QD(t, 1) || Ec(t, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || Xr && n == 66 && r == "c") {
    let i = n == 37 ? ZD(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return YD(t, i, r) || Ec(t, i);
  } else if (n == 39 || Xr && n == 70 && r == "c") {
    let i = n == 39 ? ZD(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return YD(t, i, r) || Ec(t, i);
  } else {
    if (n == 38 || Xr && n == 80 && r == "c")
      return KD(t, -1, r) || Ec(t, -1);
    if (n == 40 || Xr && n == 78 && r == "c")
      return lO(t) || KD(t, 1, r) || Ec(t, 1);
    if (r == (Xr ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function ok(t, e) {
  t.someProp("transformCopied", (y) => {
    e = y(e, t);
  });
  let n = [], { content: r, openStart: i, openEnd: o } = e;
  for (; i > 1 && o > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, o--;
    let y = r.firstChild;
    n.push(y.type.name, y.attrs != y.type.defaultAttrs ? y.attrs : null), r = y.content;
  }
  let a = t.someProp("clipboardSerializer") || vu.fromSchema(t.state.schema), s = fk(), l = s.createElement("div");
  l.appendChild(a.serializeFragment(r, { document: s }));
  let u = l.firstChild, f, h = 0;
  for (; u && u.nodeType == 1 && (f = uk[u.nodeName.toLowerCase()]); ) {
    for (let y = f.length - 1; y >= 0; y--) {
      let b = s.createElement(f[y]);
      for (; l.firstChild; )
        b.appendChild(l.firstChild);
      l.appendChild(b), h++;
    }
    u = l.firstChild;
  }
  u && u.nodeType == 1 && u.setAttribute("data-pm-slice", `${i} ${o}${h ? ` -${h}` : ""} ${JSON.stringify(n)}`);
  let p = t.someProp("clipboardTextSerializer", (y) => y(e, t)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: p, slice: e };
}
function ak(t, e, n, r, i) {
  let o = i.parent.type.spec.code, a, s;
  if (!n && !e)
    return null;
  let l = e && (r || o || !n);
  if (l) {
    if (t.someProp("transformPastedText", (p) => {
      e = p(e, o || r, t);
    }), o)
      return e ? new We(Fe.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : We.empty;
    let h = t.someProp("clipboardTextParser", (p) => p(e, i, r, t));
    if (h)
      s = h;
    else {
      let p = i.marks(), { schema: y } = t.state, b = vu.fromSchema(y);
      a = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((x) => {
        let v = a.appendChild(document.createElement("p"));
        x && v.appendChild(b.serializeNode(y.text(x, p)));
      });
    }
  } else
    t.someProp("transformPastedHTML", (h) => {
      n = h(n, t);
    }), a = pO(n), jd && gO(a);
  let u = a && a.querySelector("[data-pm-slice]"), f = u && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(u.getAttribute("data-pm-slice") || "");
  if (f && f[3])
    for (let h = +f[3]; h > 0; h--) {
      let p = a.firstChild;
      for (; p && p.nodeType != 1; )
        p = p.nextSibling;
      if (!p)
        break;
      a = p;
    }
  if (s || (s = (t.someProp("clipboardParser") || t.someProp("domParser") || v_.fromSchema(t.state.schema)).parseSlice(a, {
    preserveWhitespace: !!(l || f),
    context: i,
    ruleFromNode(p) {
      return p.nodeName == "BR" && !p.nextSibling && p.parentNode && !fO.test(p.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), f)
    s = mO(tw(s, +f[1], +f[2]), f[4]);
  else if (s = We.maxOpen(dO(s.content, i), !0), s.openStart || s.openEnd) {
    let h = 0, p = 0;
    for (let y = s.content.firstChild; h < s.openStart && !y.type.spec.isolating; h++, y = y.firstChild)
      ;
    for (let y = s.content.lastChild; p < s.openEnd && !y.type.spec.isolating; p++, y = y.lastChild)
      ;
    s = tw(s, h, p);
  }
  return t.someProp("transformPasted", (h) => {
    s = h(s, t);
  }), s;
}
const fO = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function dO(t, e) {
  if (t.childCount < 2)
    return t;
  for (let n = e.depth; n >= 0; n--) {
    let i = e.node(n).contentMatchAt(e.index(n)), o, a = [];
    if (t.forEach((s) => {
      if (!a)
        return;
      let l = i.findWrapping(s.type), u;
      if (!l)
        return a = null;
      if (u = a.length && o.length && lk(l, o, s, a[a.length - 1], 0))
        a[a.length - 1] = u;
      else {
        a.length && (a[a.length - 1] = ck(a[a.length - 1], o.length));
        let f = sk(s, l);
        a.push(f), i = i.matchType(f.type), o = l;
      }
    }), a)
      return Fe.from(a);
  }
  return t;
}
function sk(t, e, n = 0) {
  for (let r = e.length - 1; r >= n; r--)
    t = e[r].create(null, Fe.from(t));
  return t;
}
function lk(t, e, n, r, i) {
  if (i < t.length && i < e.length && t[i] == e[i]) {
    let o = lk(t, e, n, r.lastChild, i + 1);
    if (o)
      return r.copy(r.content.replaceChild(r.childCount - 1, o));
    if (r.contentMatchAt(r.childCount).matchType(i == t.length - 1 ? n.type : t[i + 1]))
      return r.copy(r.content.append(Fe.from(sk(n, t, i + 1))));
  }
}
function ck(t, e) {
  if (e == 0)
    return t;
  let n = t.content.replaceChild(t.childCount - 1, ck(t.lastChild, e - 1)), r = t.contentMatchAt(t.childCount).fillBefore(Fe.empty, !0);
  return t.copy(n.append(r));
}
function z1(t, e, n, r, i, o) {
  let a = e < 0 ? t.firstChild : t.lastChild, s = a.content;
  return t.childCount > 1 && (o = 0), i < r - 1 && (s = z1(s, e, n, r, i + 1, o)), i >= n && (s = e < 0 ? a.contentMatchAt(0).fillBefore(s, o <= i).append(s) : s.append(a.contentMatchAt(a.childCount).fillBefore(Fe.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, a.copy(s));
}
function tw(t, e, n) {
  return e < t.openStart && (t = new We(z1(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new We(z1(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t;
}
const uk = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let nw = null;
function fk() {
  return nw || (nw = document.implementation.createHTMLDocument("title"));
}
let Tb = null;
function hO(t) {
  let e = window.trustedTypes;
  return e ? (Tb || (Tb = e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), Tb.createHTML(t)) : t;
}
function pO(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = fk().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t), i;
  if ((i = r && uk[r[1].toLowerCase()]) && (t = i.map((o) => "<" + o + ">").join("") + t + i.map((o) => "</" + o + ">").reverse().join("")), n.innerHTML = hO(t), i)
    for (let o = 0; o < i.length; o++)
      n = n.querySelector(i[o]) || n;
  return n;
}
function gO(t) {
  let e = t.querySelectorAll(En ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
  }
}
function mO(t, e) {
  if (!t.size)
    return t;
  let n = t.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: i, openStart: o, openEnd: a } = t;
  for (let s = r.length - 2; s >= 0; s -= 2) {
    let l = n.nodes[r[s]];
    if (!l || l.hasRequiredAttrs())
      break;
    i = Fe.from(l.create(r[s + 1], i)), o++, a++;
  }
  return new We(i, o, a);
}
const Gn = {}, Jn = {}, yO = { touchstart: !0, touchmove: !0 };
class bO {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function vO(t) {
  for (let e in Gn) {
    let n = Gn[e];
    t.dom.addEventListener(e, t.input.eventHandlers[e] = (r) => {
      DO(t, r) && !e2(t, r) && (t.editable || !(r.type in Jn)) && n(t, r);
    }, yO[e] ? { passive: !0 } : void 0);
  }
  Xn && t.dom.addEventListener("input", () => null), $1(t);
}
function ja(t, e) {
  t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
}
function xO(t) {
  t.domObserver.stop();
  for (let e in t.input.eventHandlers)
    t.dom.removeEventListener(e, t.input.eventHandlers[e]);
  clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function $1(t) {
  t.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = (r) => e2(t, r));
  });
}
function e2(t, e) {
  return t.someProp("handleDOMEvents", (n) => {
    let r = n[e.type];
    return r ? r(t, e) || e.defaultPrevented : !1;
  });
}
function DO(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function wO(t, e) {
  !e2(t, e) && Gn[e.type] && (t.editable || !(e.type in Jn)) && Gn[e.type](t, e);
}
Jn.keydown = (t, e) => {
  let n = e;
  if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !hk(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !(Bo && En && n.keyCode == 13)))
    if (n.keyCode != 229 && t.domObserver.forceFlush(), tu && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let r = Date.now();
      t.input.lastIOSEnter = r, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == r && (t.someProp("handleKeyDown", (i) => i(t, Ys(13, "Enter"))), t.input.lastIOSEnter = 0);
      }, 200);
    } else t.someProp("handleKeyDown", (r) => r(t, n)) || uO(t, n) ? n.preventDefault() : ja(t, "key");
};
Jn.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
Jn.keypress = (t, e) => {
  let n = e;
  if (hk(t, n) || !n.charCode || n.ctrlKey && !n.altKey || Xr && n.metaKey)
    return;
  if (t.someProp("handleKeyPress", (i) => i(t, n))) {
    n.preventDefault();
    return;
  }
  let r = t.state.selection;
  if (!(r instanceof st) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(n.charCode);
    !/[\r\n]/.test(i) && !t.someProp("handleTextInput", (o) => o(t, r.$from.pos, r.$to.pos, i)) && t.dispatch(t.state.tr.insertText(i).scrollIntoView()), n.preventDefault();
  }
};
function mm(t) {
  return { left: t.clientX, top: t.clientY };
}
function SO(t, e) {
  let n = e.x - t.clientX, r = e.y - t.clientY;
  return n * n + r * r < 100;
}
function t2(t, e, n, r, i) {
  if (r == -1)
    return !1;
  let o = t.state.doc.resolve(r);
  for (let a = o.depth + 1; a > 0; a--)
    if (t.someProp(e, (s) => a > o.depth ? s(t, n, o.nodeAfter, o.before(a), i, !0) : s(t, n, o.node(a), o.before(a), i, !1)))
      return !0;
  return !1;
}
function Vc(t, e, n) {
  if (t.focused || t.focus(), t.state.selection.eq(e))
    return;
  let r = t.state.tr.setSelection(e);
  r.setMeta("pointer", !0), t.dispatch(r);
}
function TO(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.doc.resolve(e), r = n.nodeAfter;
  return r && r.isAtom && Ye.isSelectable(r) ? (Vc(t, new Ye(n)), !0) : !1;
}
function CO(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.selection, r, i;
  n instanceof Ye && (r = n.node);
  let o = t.state.doc.resolve(e);
  for (let a = o.depth + 1; a > 0; a--) {
    let s = a > o.depth ? o.nodeAfter : o.node(a);
    if (Ye.isSelectable(s)) {
      r && n.$from.depth > 0 && a >= n.$from.depth && o.before(n.$from.depth + 1) == n.$from.pos ? i = o.before(n.$from.depth) : i = o.before(a);
      break;
    }
  }
  return i != null ? (Vc(t, Ye.create(t.state.doc, i)), !0) : !1;
}
function EO(t, e, n, r, i) {
  return t2(t, "handleClickOn", e, n, r) || t.someProp("handleClick", (o) => o(t, e, r)) || (i ? CO(t, n) : TO(t, n));
}
function _O(t, e, n, r) {
  return t2(t, "handleDoubleClickOn", e, n, r) || t.someProp("handleDoubleClick", (i) => i(t, e, r));
}
function kO(t, e, n, r) {
  return t2(t, "handleTripleClickOn", e, n, r) || t.someProp("handleTripleClick", (i) => i(t, e, r)) || AO(t, n, r);
}
function AO(t, e, n) {
  if (n.button != 0)
    return !1;
  let r = t.state.doc;
  if (e == -1)
    return r.inlineContent ? (Vc(t, st.create(r, 0, r.content.size)), !0) : !1;
  let i = r.resolve(e);
  for (let o = i.depth + 1; o > 0; o--) {
    let a = o > i.depth ? i.nodeAfter : i.node(o), s = i.before(o);
    if (a.inlineContent)
      Vc(t, st.create(r, s + 1, s + 1 + a.content.size));
    else if (Ye.isSelectable(a))
      Vc(t, Ye.create(r, s));
    else
      continue;
    return !0;
  }
}
function n2(t) {
  return Gp(t);
}
const dk = Xr ? "metaKey" : "ctrlKey";
Gn.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let r = n2(t), i = Date.now(), o = "singleClick";
  i - t.input.lastClick.time < 500 && SO(n, t.input.lastClick) && !n[dk] && (t.input.lastClick.type == "singleClick" ? o = "doubleClick" : t.input.lastClick.type == "doubleClick" && (o = "tripleClick")), t.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: o };
  let a = t.posAtCoords(mm(n));
  a && (o == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new UO(t, a, n, !!r)) : (o == "doubleClick" ? _O : kO)(t, a.pos, a.inside, n) ? n.preventDefault() : ja(t, "pointer"));
};
class UO {
  constructor(e, n, r, i) {
    this.view = e, this.pos = n, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[dk], this.allowDefault = r.shiftKey;
    let o, a;
    if (n.inside > -1)
      o = e.state.doc.nodeAt(n.inside), a = n.inside;
    else {
      let f = e.state.doc.resolve(n.pos);
      o = f.parent, a = f.depth ? f.before() : 0;
    }
    const s = i ? null : r.target, l = s ? e.docView.nearestDesc(s, !0) : null;
    this.target = l && l.dom.nodeType == 1 ? l.dom : null;
    let { selection: u } = e.state;
    (r.button == 0 && o.type.spec.draggable && o.type.spec.selectable !== !1 || u instanceof Ye && u.from <= a && u.to > a) && (this.mightDrag = {
      node: o,
      pos: a,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && gi && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), ja(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => No(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(mm(e))), this.updateAllowDefault(e), this.allowDefault || !n ? ja(this.view, "pointer") : EO(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    Xn && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    En && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (Vc(this.view, et.near(this.view.state.doc.resolve(n.pos))), e.preventDefault()) : ja(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), ja(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
Gn.touchstart = (t) => {
  t.input.lastTouch = Date.now(), n2(t), ja(t, "pointer");
};
Gn.touchmove = (t) => {
  t.input.lastTouch = Date.now(), ja(t, "pointer");
};
Gn.contextmenu = (t) => n2(t);
function hk(t, e) {
  return t.composing ? !0 : Xn && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1;
}
const FO = Bo ? 5e3 : -1;
Jn.compositionstart = Jn.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t, n = e.selection.$to;
    if (e.selection instanceof st && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      t.markCursor = t.state.storedMarks || n.marks(), Gp(t, !0), t.markCursor = null;
    else if (Gp(t, !e.selection.empty), gi && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let r = t.domSelectionRange();
      for (let i = r.focusNode, o = r.focusOffset; i && i.nodeType == 1 && o != 0; ) {
        let a = o < 0 ? i.lastChild : i.childNodes[o - 1];
        if (!a)
          break;
        if (a.nodeType == 3) {
          let s = t.domSelection();
          s && s.collapse(a, a.nodeValue.length);
          break;
        } else
          i = a, o = -1;
      }
    }
    t.input.composing = !0;
  }
  pk(t, FO);
};
Jn.compositionend = (t, e) => {
  t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0, t.input.compositionNode = null, t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()), t.input.compositionID++, pk(t, 20));
};
function pk(t, e) {
  clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => Gp(t), e));
}
function gk(t) {
  for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = OO()); t.input.compositionNodes.length > 0; )
    t.input.compositionNodes.pop().markParentsDirty();
}
function RO(t) {
  let e = t.domSelectionRange();
  if (!e.focusNode)
    return null;
  let n = T5(e.focusNode, e.focusOffset), r = C5(e.focusNode, e.focusOffset);
  if (n && r && n != r) {
    let i = r.pmViewDesc, o = t.domObserver.lastChangedTextNode;
    if (n == o || r == o)
      return o;
    if (!i || !i.isText(r.nodeValue))
      return r;
    if (t.input.compositionNode == r) {
      let a = n.pmViewDesc;
      if (!(!a || !a.isText(n.nodeValue)))
        return r;
    }
  }
  return n || r;
}
function OO() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function Gp(t, e = !1) {
  if (!(Bo && t.domObserver.flushingSoon >= 0)) {
    if (t.domObserver.forceFlush(), gk(t), e || t.docView && t.docView.dirty) {
      let n = K0(t);
      return n && !n.eq(t.state.selection) ? t.dispatch(t.state.tr.setSelection(n)) : (t.markCursor || e) && !t.state.selection.empty ? t.dispatch(t.state.tr.deleteSelection()) : t.updateState(t.state), !0;
    }
    return !1;
  }
}
function IO(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(e), t.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t.focus();
  }, 50);
}
const ud = fr && qa < 15 || tu && U5 < 604;
Gn.copy = Jn.cut = (t, e) => {
  let n = e, r = t.state.selection, i = n.type == "cut";
  if (r.empty)
    return;
  let o = ud ? null : n.clipboardData, a = r.content(), { dom: s, text: l } = ok(t, a);
  o ? (n.preventDefault(), o.clearData(), o.setData("text/html", s.innerHTML), o.setData("text/plain", l)) : IO(t, s), i && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function BO(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function MO(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, r = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = t.input.shiftKey && t.input.lastKeyCode != 45;
  setTimeout(() => {
    t.focus(), r.parentNode && r.parentNode.removeChild(r), n ? fd(t, r.value, null, i, e) : fd(t, r.textContent, r.innerHTML, i, e);
  }, 50);
}
function fd(t, e, n, r, i) {
  let o = ak(t, e, n, r, t.state.selection.$from);
  if (t.someProp("handlePaste", (l) => l(t, i, o || We.empty)))
    return !0;
  if (!o)
    return !1;
  let a = BO(o), s = a ? t.state.tr.replaceSelectionWith(a, r) : t.state.tr.replaceSelection(o);
  return t.dispatch(s.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function mk(t) {
  let e = t.getData("text/plain") || t.getData("Text");
  if (e)
    return e;
  let n = t.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
Jn.paste = (t, e) => {
  let n = e;
  if (t.composing && !Bo)
    return;
  let r = ud ? null : n.clipboardData, i = t.input.shiftKey && t.input.lastKeyCode != 45;
  r && fd(t, mk(r), r.getData("text/html"), i, n) ? n.preventDefault() : MO(t, n);
};
class yk {
  constructor(e, n, r) {
    this.slice = e, this.move = n, this.node = r;
  }
}
const bk = Xr ? "altKey" : "ctrlKey";
Gn.dragstart = (t, e) => {
  let n = e, r = t.input.mouseDown;
  if (r && r.done(), !n.dataTransfer)
    return;
  let i = t.state.selection, o = i.empty ? null : t.posAtCoords(mm(n)), a;
  if (!(o && o.pos >= i.from && o.pos <= (i instanceof Ye ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      a = Ye.create(t.state.doc, r.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let h = t.docView.nearestDesc(n.target, !0);
      h && h.node.type.spec.draggable && h != t.docView && (a = Ye.create(t.state.doc, h.posBefore));
    }
  }
  let s = (a || t.state.selection).content(), { dom: l, text: u, slice: f } = ok(t, s);
  (!n.dataTransfer.files.length || !En || j_ > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(ud ? "Text" : "text/html", l.innerHTML), n.dataTransfer.effectAllowed = "copyMove", ud || n.dataTransfer.setData("text/plain", u), t.dragging = new yk(f, !n[bk], a);
};
Gn.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
Jn.dragover = Jn.dragenter = (t, e) => e.preventDefault();
Jn.drop = (t, e) => {
  let n = e, r = t.dragging;
  if (t.dragging = null, !n.dataTransfer)
    return;
  let i = t.posAtCoords(mm(n));
  if (!i)
    return;
  let o = t.state.doc.resolve(i.pos), a = r && r.slice;
  a ? t.someProp("transformPasted", (b) => {
    a = b(a, t);
  }) : a = ak(t, mk(n.dataTransfer), ud ? null : n.dataTransfer.getData("text/html"), !1, o);
  let s = !!(r && !n[bk]);
  if (t.someProp("handleDrop", (b) => b(t, n, a || We.empty, s))) {
    n.preventDefault();
    return;
  }
  if (!a)
    return;
  n.preventDefault();
  let l = a ? O_(t.state.doc, o.pos, a) : o.pos;
  l == null && (l = o.pos);
  let u = t.state.tr;
  if (s) {
    let { node: b } = r;
    b ? b.replace(u) : u.deleteSelection();
  }
  let f = u.mapping.map(l), h = a.openStart == 0 && a.openEnd == 0 && a.content.childCount == 1, p = u.doc;
  if (h ? u.replaceRangeWith(f, f, a.content.firstChild) : u.replaceRange(f, f, a), u.doc.eq(p))
    return;
  let y = u.doc.resolve(f);
  if (h && Ye.isSelectable(a.content.firstChild) && y.nodeAfter && y.nodeAfter.sameMarkup(a.content.firstChild))
    u.setSelection(new Ye(y));
  else {
    let b = u.mapping.map(l);
    u.mapping.maps[u.mapping.maps.length - 1].forEach((x, v, D, S) => b = S), u.setSelection(Q0(t, y, u.doc.resolve(b)));
  }
  t.focus(), t.dispatch(u.setMeta("uiEvent", "drop"));
};
Gn.focus = (t) => {
  t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => {
    t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && No(t);
  }, 20));
};
Gn.blur = (t, e) => {
  let n = e;
  t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1);
};
Gn.beforeinput = (t, e) => {
  if (En && Bo && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: r } = t.input;
    setTimeout(() => {
      if (t.input.domChangeCount != r || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (o) => o(t, Ys(8, "Backspace")))))
        return;
      let { $cursor: i } = t.state.selection;
      i && i.pos > 0 && t.dispatch(t.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in Jn)
  Gn[t] = Jn[t];
function dd(t, e) {
  if (t == e)
    return !0;
  for (let n in t)
    if (t[n] !== e[n])
      return !1;
  for (let n in e)
    if (!(n in t))
      return !1;
  return !0;
}
class Jp {
  constructor(e, n) {
    this.toDOM = e, this.spec = n || rl, this.side = this.spec.side || 0;
  }
  map(e, n, r, i) {
    let { pos: o, deleted: a } = e.mapResult(n.from + i, this.side < 0 ? -1 : 1);
    return a ? null : new qn(o - r, o - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof Jp && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && dd(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class Ga {
  constructor(e, n) {
    this.attrs = e, this.spec = n || rl;
  }
  map(e, n, r, i) {
    let o = e.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r, a = e.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return o >= a ? null : new qn(o, a, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return this == e || e instanceof Ga && dd(this.attrs, e.attrs) && dd(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Ga;
  }
  destroy() {
  }
}
let NO = class vk {
  constructor(e, n) {
    this.attrs = e, this.spec = n || rl;
  }
  map(e, n, r, i) {
    let o = e.mapResult(n.from + i, 1);
    if (o.deleted)
      return null;
    let a = e.mapResult(n.to + i, -1);
    return a.deleted || a.pos <= o.pos ? null : new qn(o.pos - r, a.pos - r, this);
  }
  valid(e, n) {
    let { index: r, offset: i } = e.content.findIndex(n.from), o;
    return i == n.from && !(o = e.child(r)).isText && i + o.nodeSize == n.to;
  }
  eq(e) {
    return this == e || e instanceof vk && dd(this.attrs, e.attrs) && dd(this.spec, e.spec);
  }
  destroy() {
  }
};
class qn {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.from = e, this.to = n, this.type = r;
  }
  /**
  @internal
  */
  copy(e, n) {
    return new qn(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
  }
  /**
  @internal
  */
  map(e, n, r) {
    return this.type.map(e, this, n, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, r) {
    return new qn(e, e, new Jp(n, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, r, i) {
    return new qn(e, n, new Ga(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, r, i) {
    return new qn(e, n, new NO(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Ga;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof Jp;
  }
}
const Mc = [], rl = {};
class Nt {
  /**
  @internal
  */
  constructor(e, n) {
    this.local = e.length ? e : Mc, this.children = n.length ? n : Mc;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, n) {
    return n.length ? Yp(n, e, 0, rl) : Cn;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, r) {
    let i = [];
    return this.findInner(e ?? 0, n ?? 1e9, i, 0, r), i;
  }
  findInner(e, n, r, i, o) {
    for (let a = 0; a < this.local.length; a++) {
      let s = this.local[a];
      s.from <= n && s.to >= e && (!o || o(s.spec)) && r.push(s.copy(s.from + i, s.to + i));
    }
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] < n && this.children[a + 1] > e) {
        let s = this.children[a] + 1;
        this.children[a + 2].findInner(e - s, n - s, r, i + s, o);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, r) {
    return this == Cn || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || rl);
  }
  /**
  @internal
  */
  mapInner(e, n, r, i, o) {
    let a;
    for (let s = 0; s < this.local.length; s++) {
      let l = this.local[s].map(e, r, i);
      l && l.type.valid(n, l) ? (a || (a = [])).push(l) : o.onRemove && o.onRemove(this.local[s].spec);
    }
    return this.children.length ? PO(this.children, a || [], e, n, r, i, o) : a ? new Nt(a.sort(il), Mc) : Cn;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, n) {
    return n.length ? this == Cn ? Nt.create(e, n) : this.addInner(e, n, 0) : this;
  }
  addInner(e, n, r) {
    let i, o = 0;
    e.forEach((s, l) => {
      let u = l + r, f;
      if (f = Dk(n, s, u)) {
        for (i || (i = this.children.slice()); o < i.length && i[o] < l; )
          o += 3;
        i[o] == l ? i[o + 2] = i[o + 2].addInner(s, f, u + 1) : i.splice(o, 0, l, l + s.nodeSize, Yp(f, s, u + 1, rl)), o += 3;
      }
    });
    let a = xk(o ? wk(n) : n, -r);
    for (let s = 0; s < a.length; s++)
      a[s].type.valid(e, a[s]) || a.splice(s--, 1);
    return new Nt(a.length ? this.local.concat(a).sort(il) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == Cn ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let r = this.children, i = this.local;
    for (let o = 0; o < r.length; o += 3) {
      let a, s = r[o] + n, l = r[o + 1] + n;
      for (let f = 0, h; f < e.length; f++)
        (h = e[f]) && h.from > s && h.to < l && (e[f] = null, (a || (a = [])).push(h));
      if (!a)
        continue;
      r == this.children && (r = this.children.slice());
      let u = r[o + 2].removeInner(a, s + 1);
      u != Cn ? r[o + 2] = u : (r.splice(o, 3), o -= 3);
    }
    if (i.length) {
      for (let o = 0, a; o < e.length; o++)
        if (a = e[o])
          for (let s = 0; s < i.length; s++)
            i[s].eq(a, n) && (i == this.local && (i = this.local.slice()), i.splice(s--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new Nt(i, r) : Cn;
  }
  forChild(e, n) {
    if (this == Cn)
      return this;
    if (n.isLeaf)
      return Nt.empty;
    let r, i;
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] >= e) {
        this.children[s] == e && (r = this.children[s + 2]);
        break;
      }
    let o = e + 1, a = o + n.content.size;
    for (let s = 0; s < this.local.length; s++) {
      let l = this.local[s];
      if (l.from < a && l.to > o && l.type instanceof Ga) {
        let u = Math.max(o, l.from) - o, f = Math.min(a, l.to) - o;
        u < f && (i || (i = [])).push(l.copy(u, f));
      }
    }
    if (i) {
      let s = new Nt(i.sort(il), Mc);
      return r ? new Na([s, r]) : s;
    }
    return r || Cn;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Nt) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return r2(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == Cn)
      return Mc;
    if (e.inlineContent || !this.local.some(Ga.is))
      return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof Ga || n.push(this.local[r]);
    return n;
  }
  forEachSet(e) {
    e(this);
  }
}
Nt.empty = new Nt([], []);
Nt.removeOverlap = r2;
const Cn = Nt.empty;
class Na {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const r = this.members.map((i) => i.map(e, n, rl));
    return Na.from(r);
  }
  forChild(e, n) {
    if (n.isLeaf)
      return Nt.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].forChild(e, n);
      o != Cn && (o instanceof Na ? r = r.concat(o.members) : r.push(o));
    }
    return Na.from(r);
  }
  eq(e) {
    if (!(e instanceof Na) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n]))
        return !1;
    return !0;
  }
  locals(e) {
    let n, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].localsInner(e);
      if (o.length)
        if (!n)
          n = o;
        else {
          r && (n = n.slice(), r = !1);
          for (let a = 0; a < o.length; a++)
            n.push(o[a]);
        }
    }
    return n ? r2(r ? n : n.sort(il)) : Mc;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return Cn;
      case 1:
        return e[0];
      default:
        return new Na(e.every((n) => n instanceof Nt) ? e : e.reduce((n, r) => n.concat(r instanceof Nt ? r : r.members), []));
    }
  }
  forEachSet(e) {
    for (let n = 0; n < this.members.length; n++)
      this.members[n].forEachSet(e);
  }
}
function PO(t, e, n, r, i, o, a) {
  let s = t.slice();
  for (let u = 0, f = o; u < n.maps.length; u++) {
    let h = 0;
    n.maps[u].forEach((p, y, b, x) => {
      let v = x - b - (y - p);
      for (let D = 0; D < s.length; D += 3) {
        let S = s[D + 1];
        if (S < 0 || p > S + f - h)
          continue;
        let E = s[D] + f - h;
        y >= E ? s[D + 1] = p <= E ? -2 : -1 : p >= f && v && (s[D] += v, s[D + 1] += v);
      }
      h += v;
    }), f = n.maps[u].map(f, -1);
  }
  let l = !1;
  for (let u = 0; u < s.length; u += 3)
    if (s[u + 1] < 0) {
      if (s[u + 1] == -2) {
        l = !0, s[u + 1] = -1;
        continue;
      }
      let f = n.map(t[u] + o), h = f - i;
      if (h < 0 || h >= r.content.size) {
        l = !0;
        continue;
      }
      let p = n.map(t[u + 1] + o, -1), y = p - i, { index: b, offset: x } = r.content.findIndex(h), v = r.maybeChild(b);
      if (v && x == h && x + v.nodeSize == y) {
        let D = s[u + 2].mapInner(n, v, f + 1, t[u] + o + 1, a);
        D != Cn ? (s[u] = h, s[u + 1] = y, s[u + 2] = D) : (s[u + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let u = WO(s, t, e, n, i, o, a), f = Yp(u, r, 0, a);
    e = f.local;
    for (let h = 0; h < s.length; h += 3)
      s[h + 1] < 0 && (s.splice(h, 3), h -= 3);
    for (let h = 0, p = 0; h < f.children.length; h += 3) {
      let y = f.children[h];
      for (; p < s.length && s[p] < y; )
        p += 3;
      s.splice(p, 0, f.children[h], f.children[h + 1], f.children[h + 2]);
    }
  }
  return new Nt(e.sort(il), s);
}
function xk(t, e) {
  if (!e || !t.length)
    return t;
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let i = t[r];
    n.push(new qn(i.from + e, i.to + e, i.type));
  }
  return n;
}
function WO(t, e, n, r, i, o, a) {
  function s(l, u) {
    for (let f = 0; f < l.local.length; f++) {
      let h = l.local[f].map(r, i, u);
      h ? n.push(h) : a.onRemove && a.onRemove(l.local[f].spec);
    }
    for (let f = 0; f < l.children.length; f += 3)
      s(l.children[f + 2], l.children[f] + u + 1);
  }
  for (let l = 0; l < t.length; l += 3)
    t[l + 1] == -1 && s(t[l + 2], e[l] + o + 1);
  return n;
}
function Dk(t, e, n) {
  if (e.isLeaf)
    return null;
  let r = n + e.nodeSize, i = null;
  for (let o = 0, a; o < t.length; o++)
    (a = t[o]) && a.from > n && a.to < r && ((i || (i = [])).push(a), t[o] = null);
  return i;
}
function wk(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    t[n] != null && e.push(t[n]);
  return e;
}
function Yp(t, e, n, r) {
  let i = [], o = !1;
  e.forEach((s, l) => {
    let u = Dk(t, s, l + n);
    if (u) {
      o = !0;
      let f = Yp(u, s, n + l + 1, r);
      f != Cn && i.push(l, l + s.nodeSize, f);
    }
  });
  let a = xk(o ? wk(t) : t, -n).sort(il);
  for (let s = 0; s < a.length; s++)
    a[s].type.valid(e, a[s]) || (r.onRemove && r.onRemove(a[s].spec), a.splice(s--, 1));
  return a.length || i.length ? new Nt(a, i) : Cn;
}
function il(t, e) {
  return t.from - e.from || t.to - e.to;
}
function r2(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let r = e[n];
    if (r.from != r.to)
      for (let i = n + 1; i < e.length; i++) {
        let o = e[i];
        if (o.from == r.from) {
          o.to != r.to && (e == t && (e = t.slice()), e[i] = o.copy(o.from, r.to), rw(e, i + 1, o.copy(r.to, o.to)));
          continue;
        } else {
          o.from < r.to && (e == t && (e = t.slice()), e[n] = r.copy(r.from, o.from), rw(e, i, r.copy(o.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function rw(t, e, n) {
  for (; e < t.length && il(n, t[e]) > 0; )
    e++;
  t.splice(e, 0, n);
}
function Cb(t) {
  let e = [];
  return t.someProp("decorations", (n) => {
    let r = n(t.state);
    r && r != Cn && e.push(r);
  }), t.cursorWrapper && e.push(Nt.create(t.state.doc, [t.cursorWrapper.deco])), Na.from(e);
}
const LO = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, zO = fr && qa <= 11;
class $O {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class jO {
  constructor(e, n) {
    this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new $O(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      fr && qa <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), zO && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, LO)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++)
          this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (JD(this.view)) {
      if (this.suppressingSelectionUpdates)
        return No(this.view);
      if (fr && qa <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && ul(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), r;
    for (let o = e.focusNode; o; o = cd(o))
      n.add(o);
    for (let o = e.anchorNode; o; o = cd(o))
      if (n.has(o)) {
        r = o;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && JD(e) && !this.ignoreSelectionChange(r), o = -1, a = -1, s = !1, l = [];
    if (e.editable)
      for (let f = 0; f < n.length; f++) {
        let h = this.registerMutation(n[f], l);
        h && (o = o < 0 ? h.from : Math.min(h.from, o), a = a < 0 ? h.to : Math.max(h.to, a), h.typeOver && (s = !0));
      }
    if (gi && l.length) {
      let f = l.filter((h) => h.nodeName == "BR");
      if (f.length == 2) {
        let [h, p] = f;
        h.parentNode && h.parentNode.parentNode == p.parentNode ? p.remove() : h.remove();
      } else {
        let { focusNode: h } = this.currentSelection;
        for (let p of f) {
          let y = p.parentNode;
          y && y.nodeName == "LI" && (!h || qO(e, h) != y) && p.remove();
        }
      }
    }
    let u = null;
    o < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && pm(r) && (u = K0(e)) && u.eq(et.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, No(e), this.currentSelection.set(r), e.scrollToSelection()) : (o > -1 || i) && (o > -1 && (e.docView.markDirty(o, a), HO(e)), this.handleDOMChange(o, a, s, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || No(e), this.currentSelection.set(r));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let f = 0; f < e.addedNodes.length; f++) {
        let h = e.addedNodes[f];
        n.push(h), h.nodeType == 3 && (this.lastChangedTextNode = h);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = e.previousSibling, o = e.nextSibling;
      if (fr && qa <= 11 && e.addedNodes.length)
        for (let f = 0; f < e.addedNodes.length; f++) {
          let { previousSibling: h, nextSibling: p } = e.addedNodes[f];
          (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) && (i = h), (!p || Array.prototype.indexOf.call(e.addedNodes, p) < 0) && (o = p);
        }
      let a = i && i.parentNode == e.target ? pn(i) + 1 : 0, s = r.localPosFromDOM(e.target, a, -1), l = o && o.parentNode == e.target ? pn(o) : e.target.childNodes.length, u = r.localPosFromDOM(e.target, l, 1);
      return { from: s, to: u };
    } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let iw = /* @__PURE__ */ new WeakMap(), ow = !1;
function HO(t) {
  if (!iw.has(t) && (iw.set(t, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
    if (t.requiresGeckoHackNode = gi, ow)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), ow = !0;
  }
}
function aw(t, e) {
  let n = e.startContainer, r = e.startOffset, i = e.endContainer, o = e.endOffset, a = t.domAtPos(t.state.selection.anchor);
  return ul(a.node, a.offset, i, o) && ([n, r, i, o] = [i, o, n, r]), { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o };
}
function VO(t, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(t.root)[0];
    if (i)
      return aw(t, i);
  }
  let n;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
  }
  return t.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), t.dom.removeEventListener("beforeinput", r, !0), n ? aw(t, n) : null;
}
function qO(t, e) {
  for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
    let r = t.docView.nearestDesc(n, !0);
    if (r && r.node.isBlock)
      return n;
  }
  return null;
}
function XO(t, e, n) {
  let { node: r, fromOffset: i, toOffset: o, from: a, to: s } = t.docView.parseRange(e, n), l = t.domSelectionRange(), u, f = l.anchorNode;
  if (f && t.dom.contains(f.nodeType == 1 ? f : f.parentNode) && (u = [{ node: f, offset: l.anchorOffset }], pm(l) || u.push({ node: l.focusNode, offset: l.focusOffset })), En && t.input.lastKeyCode === 8)
    for (let v = o; v > i; v--) {
      let D = r.childNodes[v - 1], S = D.pmViewDesc;
      if (D.nodeName == "BR" && !S) {
        o = v;
        break;
      }
      if (!S || S.size)
        break;
    }
  let h = t.state.doc, p = t.someProp("domParser") || v_.fromSchema(t.state.schema), y = h.resolve(a), b = null, x = p.parse(r, {
    topNode: y.parent,
    topMatch: y.parent.contentMatchAt(y.index()),
    topOpen: !0,
    from: i,
    to: o,
    preserveWhitespace: y.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: u,
    ruleFromNode: GO,
    context: y
  });
  if (u && u[0].pos != null) {
    let v = u[0].pos, D = u[1] && u[1].pos;
    D == null && (D = v), b = { anchor: v + a, head: D + a };
  }
  return { doc: x, sel: b, from: a, to: s };
}
function GO(t) {
  let e = t.pmViewDesc;
  if (e)
    return e.parseRule();
  if (t.nodeName == "BR" && t.parentNode) {
    if (Xn && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (t.parentNode.lastChild == t || Xn && /^(tr|table)$/i.test(t.parentNode.nodeName))
      return { ignore: !0 };
  } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const JO = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function YO(t, e, n, r, i) {
  let o = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
  if (t.input.compositionPendingChanges = 0, e < 0) {
    let $ = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null, le = K0(t, $);
    if (le && !t.state.selection.eq(le)) {
      if (En && Bo && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", (M) => M(t, Ys(13, "Enter"))))
        return;
      let ve = t.state.tr.setSelection(le);
      $ == "pointer" ? ve.setMeta("pointer", !0) : $ == "key" && ve.scrollIntoView(), o && ve.setMeta("composition", o), t.dispatch(ve);
    }
    return;
  }
  let a = t.state.doc.resolve(e), s = a.sharedDepth(n);
  e = a.before(s + 1), n = t.state.doc.resolve(n).after(s + 1);
  let l = t.state.selection, u = XO(t, e, n), f = t.state.doc, h = f.slice(u.from, u.to), p, y;
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (p = t.state.selection.to, y = "end") : (p = t.state.selection.from, y = "start"), t.input.lastKeyCode = null;
  let b = QO(h.content, u.doc.content, u.from, p, y);
  if (b && t.input.domChangeCount++, (tu && t.input.lastIOSEnter > Date.now() - 225 || Bo) && i.some(($) => $.nodeType == 1 && !JO.test($.nodeName)) && (!b || b.endA >= b.endB) && t.someProp("handleKeyDown", ($) => $(t, Ys(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (!b)
    if (r && l instanceof st && !l.empty && l.$head.sameParent(l.$anchor) && !t.composing && !(u.sel && u.sel.anchor != u.sel.head))
      b = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (u.sel) {
        let $ = sw(t, t.state.doc, u.sel);
        if ($ && !$.eq(t.state.selection)) {
          let le = t.state.tr.setSelection($);
          o && le.setMeta("composition", o), t.dispatch(le);
        }
      }
      return;
    }
  t.state.selection.from < t.state.selection.to && b.start == b.endB && t.state.selection instanceof st && (b.start > t.state.selection.from && b.start <= t.state.selection.from + 2 && t.state.selection.from >= u.from ? b.start = t.state.selection.from : b.endA < t.state.selection.to && b.endA >= t.state.selection.to - 2 && t.state.selection.to <= u.to && (b.endB += t.state.selection.to - b.endA, b.endA = t.state.selection.to)), fr && qa <= 11 && b.endB == b.start + 1 && b.endA == b.start && b.start > u.from && u.doc.textBetween(b.start - u.from - 1, b.start - u.from + 1) == "  " && (b.start--, b.endA--, b.endB--);
  let x = u.doc.resolveNoCache(b.start - u.from), v = u.doc.resolveNoCache(b.endB - u.from), D = f.resolve(b.start), S = x.sameParent(v) && x.parent.inlineContent && D.end() >= b.endA, E;
  if ((tu && t.input.lastIOSEnter > Date.now() - 225 && (!S || i.some(($) => $.nodeName == "DIV" || $.nodeName == "P")) || !S && x.pos < u.doc.content.size && !x.sameParent(v) && (E = et.findFrom(u.doc.resolve(x.pos + 1), 1, !0)) && E.head == v.pos) && t.someProp("handleKeyDown", ($) => $(t, Ys(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (t.state.selection.anchor > b.start && KO(f, b.start, b.endA, x, v) && t.someProp("handleKeyDown", ($) => $(t, Ys(8, "Backspace")))) {
    Bo && En && t.domObserver.suppressSelectionUpdates();
    return;
  }
  En && b.endB == b.start && (t.input.lastChromeDelete = Date.now()), Bo && !S && x.start() != v.start() && v.parentOffset == 0 && x.depth == v.depth && u.sel && u.sel.anchor == u.sel.head && u.sel.head == b.endA && (b.endB -= 2, v = u.doc.resolveNoCache(b.endB - u.from), setTimeout(() => {
    t.someProp("handleKeyDown", function($) {
      return $(t, Ys(13, "Enter"));
    });
  }, 20));
  let I = b.start, R = b.endA, O, N, q;
  if (S) {
    if (x.pos == v.pos)
      fr && qa <= 11 && x.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(), setTimeout(() => No(t), 20)), O = t.state.tr.delete(I, R), N = f.resolve(b.start).marksAcross(f.resolve(b.endA));
    else if (
      // Adding or removing a mark
      b.endA == b.endB && (q = ZO(x.parent.content.cut(x.parentOffset, v.parentOffset), D.parent.content.cut(D.parentOffset, b.endA - D.start())))
    )
      O = t.state.tr, q.type == "add" ? O.addMark(I, R, q.mark) : O.removeMark(I, R, q.mark);
    else if (x.parent.child(x.index()).isText && x.index() == v.index() - (v.textOffset ? 0 : 1)) {
      let $ = x.parent.textBetween(x.parentOffset, v.parentOffset);
      if (t.someProp("handleTextInput", (le) => le(t, I, R, $)))
        return;
      O = t.state.tr.insertText($, I, R);
    }
  }
  if (O || (O = t.state.tr.replace(I, R, u.doc.slice(b.start - u.from, b.endB - u.from))), u.sel) {
    let $ = sw(t, O.doc, u.sel);
    $ && !(En && t.composing && $.empty && (b.start != b.endB || t.input.lastChromeDelete < Date.now() - 100) && ($.head == I || $.head == O.mapping.map(R) - 1) || fr && $.empty && $.head == I) && O.setSelection($);
  }
  N && O.ensureMarks(N), o && O.setMeta("composition", o), t.dispatch(O.scrollIntoView());
}
function sw(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size ? null : Q0(t, e.resolve(n.anchor), e.resolve(n.head));
}
function ZO(t, e) {
  let n = t.firstChild.marks, r = e.firstChild.marks, i = n, o = r, a, s, l;
  for (let f = 0; f < r.length; f++)
    i = r[f].removeFromSet(i);
  for (let f = 0; f < n.length; f++)
    o = n[f].removeFromSet(o);
  if (i.length == 1 && o.length == 0)
    s = i[0], a = "add", l = (f) => f.mark(s.addToSet(f.marks));
  else if (i.length == 0 && o.length == 1)
    s = o[0], a = "remove", l = (f) => f.mark(s.removeFromSet(f.marks));
  else
    return null;
  let u = [];
  for (let f = 0; f < e.childCount; f++)
    u.push(l(e.child(f)));
  if (Fe.from(u).eq(t))
    return { mark: s, type: a };
}
function KO(t, e, n, r, i) {
  if (
    // The content must have shrunk
    n - e <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    Eb(r, !0, !1) < i.pos
  )
    return !1;
  let o = t.resolve(e);
  if (!r.parent.isTextblock) {
    let s = o.nodeAfter;
    return s != null && n == e + s.nodeSize;
  }
  if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock)
    return !1;
  let a = t.resolve(Eb(o, !0, !0));
  return !a.parent.isTextblock || a.pos > n || Eb(a, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(a.parent.content);
}
function Eb(t, e, n) {
  let r = t.depth, i = e ? t.end() : t.pos;
  for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
    r--, i++, e = !1;
  if (n) {
    let o = t.node(r).maybeChild(t.indexAfter(r));
    for (; o && !o.isLeaf; )
      o = o.firstChild, i++;
  }
  return i;
}
function QO(t, e, n, r, i) {
  let o = t.findDiffStart(e, n);
  if (o == null)
    return null;
  let { a, b: s } = t.findDiffEnd(e, n + t.size, n + e.size);
  if (i == "end") {
    let l = Math.max(0, o - Math.min(a, s));
    r -= a + l - o;
  }
  if (a < o && t.size < e.size) {
    let l = r <= o && r >= a ? o - r : 0;
    o -= l, o && o < e.size && lw(e.textBetween(o - 1, o + 1)) && (o += l ? 1 : -1), s = o + (s - a), a = o;
  } else if (s < o) {
    let l = r <= o && r >= s ? o - r : 0;
    o -= l, o && o < t.size && lw(t.textBetween(o - 1, o + 1)) && (o += l ? 1 : -1), a = o + (a - s), s = o;
  }
  return { start: o, endA: a, endB: s };
}
function lw(t) {
  if (t.length != 2)
    return !1;
  let e = t.charCodeAt(0), n = t.charCodeAt(1);
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
class XG {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new bO(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(hw), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = fw(this), uw(this), this.nodeViews = dw(this), this.docView = jD(this.state.doc, cw(this), Cb(this), this.dom, this), this.domObserver = new jO(this, (r, i, o, a) => YO(this, r, i, o, a)), this.domObserver.start(), vO(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e)
        this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && $1(this);
    let n = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(hw), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let n = {};
    for (let r in this._props)
      n[r] = this._props[r];
    n.state = this.state;
    for (let r in e)
      n[r] = e[r];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    var r;
    let i = this.state, o = !1, a = !1;
    e.storedMarks && this.composing && (gk(this), a = !0), this.state = e;
    let s = i.plugins != e.plugins || this._props.plugins != n.plugins;
    if (s || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let y = dw(this);
      tI(y, this.nodeViews) && (this.nodeViews = y, o = !0);
    }
    (s || n.handleDOMEvents != this._props.handleDOMEvents) && $1(this), this.editable = fw(this), uw(this);
    let l = Cb(this), u = cw(this), f = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", h = o || !this.docView.matchesNode(e.doc, u, l);
    (h || !e.selection.eq(i.selection)) && (a = !0);
    let p = f == "preserve" && a && this.dom.style.overflowAnchor == null && O5(this);
    if (a) {
      this.domObserver.stop();
      let y = h && (fr || En) && !this.composing && !i.selection.empty && !e.selection.empty && eI(i.selection, e.selection);
      if (h) {
        let b = En ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = RO(this)), (o || !this.docView.update(e.doc, u, l, this)) && (this.docView.updateOuterDeco(u), this.docView.destroy(), this.docView = jD(e.doc, u, l, this.dom, this)), b && !this.trackWrites && (y = !0);
      }
      y || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && rO(this)) ? No(this, y) : (nk(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), f == "reset" ? this.dom.scrollTop = 0 : f == "to selection" ? this.scrollToSelection() : p && I5(p);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof Ye) {
      let n = this.docView.domAfterPos(this.state.selection.from);
      n.nodeType == 1 && ND(this, n.getBoundingClientRect(), e);
    } else
      ND(this, this.coordsAtPos(this.state.selection.head, 1), e);
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, n) {
    let r = e.node, i = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      i = r.from;
    else {
      let o = r.from + (this.state.doc.content.size - n.doc.content.size);
      (o > 0 && this.state.doc.nodeAt(o)) == r.node && (i = o);
    }
    this.dragging = new yk(e.slice, e.move, i < 0 ? void 0 : Ye.create(this.state.doc, i));
  }
  someProp(e, n) {
    let r = this._props && this._props[e], i;
    if (r != null && (i = n ? n(r) : r))
      return i;
    for (let a = 0; a < this.directPlugins.length; a++) {
      let s = this.directPlugins[a].props[e];
      if (s != null && (i = n ? n(s) : s))
        return i;
    }
    let o = this.state.plugins;
    if (o)
      for (let a = 0; a < o.length; a++) {
        let s = o[a].props[e];
        if (s != null && (i = n ? n(s) : s))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (fr) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && B5(this.dom), No(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return L5(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, n = 1) {
    return G_(this, e, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, n, r = -1) {
    let i = this.docView.posFromDOM(e, n, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, n) {
    return V5(this, n || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, n) {
    return fd(this, "", e, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, n) {
    return fd(this, e, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (xO(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Cb(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, w5());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return wO(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let n = this._props.dispatchTransaction;
    n ? n.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? Xn && this.root.nodeType === 11 && _5(this.dom.ownerDocument) == this.dom && VO(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function cw(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(t.editable), t.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(t.state)), n)
      for (let r in n)
        r == "class" ? e.class += " " + n[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + n[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(n[r]));
  }), e.translate || (e.translate = "no"), [qn.node(0, t.state.doc.content.size, e)];
}
function uw(t) {
  if (t.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t.cursorWrapper = { dom: e, deco: qn.widget(t.state.selection.from, e, { raw: !0, marks: t.markCursor }) };
  } else
    t.cursorWrapper = null;
}
function fw(t) {
  return !t.someProp("editable", (e) => e(t.state) === !1);
}
function eI(t, e) {
  let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
  return t.$anchor.start(n) != e.$anchor.start(n);
}
function dw(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
  }
  return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function tI(t, e) {
  let n = 0, r = 0;
  for (let i in t) {
    if (t[i] != e[i])
      return !0;
    n++;
  }
  for (let i in e)
    r++;
  return n != r;
}
function hw(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Ya = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Zp = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, nI = typeof navigator < "u" && /Mac/.test(navigator.platform), rI = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var gn = 0; gn < 10; gn++) Ya[48 + gn] = Ya[96 + gn] = String(gn);
for (var gn = 1; gn <= 24; gn++) Ya[gn + 111] = "F" + gn;
for (var gn = 65; gn <= 90; gn++)
  Ya[gn] = String.fromCharCode(gn + 32), Zp[gn] = String.fromCharCode(gn);
for (var _b in Ya) Zp.hasOwnProperty(_b) || (Zp[_b] = Ya[_b]);
function iI(t) {
  var e = nI && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || rI && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? Zp : Ya)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const oI = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function aI(t) {
  let e = t.split(/-(?!$)/), n = e[e.length - 1];
  n == "Space" && (n = " ");
  let r, i, o, a;
  for (let s = 0; s < e.length - 1; s++) {
    let l = e[s];
    if (/^(cmd|meta|m)$/i.test(l))
      a = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      o = !0;
    else if (/^mod$/i.test(l))
      oI ? a = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return r && (n = "Alt-" + n), i && (n = "Ctrl-" + n), a && (n = "Meta-" + n), o && (n = "Shift-" + n), n;
}
function sI(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t)
    e[aI(n)] = t[n];
  return e;
}
function kb(t, e, n = !0) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n && e.shiftKey && (t = "Shift-" + t), t;
}
function GG(t) {
  return new xu({ props: { handleKeyDown: i2(t) } });
}
function i2(t) {
  let e = sI(t);
  return function(n, r) {
    let i = iI(r), o, a = e[kb(i, r)];
    if (a && a(n.state, n.dispatch, n))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let s = e[kb(i, r, !1)];
        if (s && s(n.state, n.dispatch, n))
          return !0;
      }
      if ((r.shiftKey || r.altKey || r.metaKey || i.charCodeAt(0) > 127) && (o = Ya[r.keyCode]) && o != i) {
        let s = e[kb(o, r)];
        if (s && s(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
const JG = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function Sk(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n;
}
const YG = (t, e, n) => {
  let r = Sk(t, n);
  if (!r)
    return !1;
  let i = o2(r);
  if (!i) {
    let a = r.blockRange(), s = a && Ld(a);
    return s == null ? !1 : (e && e(t.tr.lift(a, s).scrollIntoView()), !0);
  }
  let o = i.nodeBefore;
  if (_k(t, i, e, -1))
    return !0;
  if (r.parent.content.size == 0 && (nu(o, "end") || Ye.isSelectable(o)))
    for (let a = r.depth; ; a--) {
      let s = dm(t.doc, r.before(a), r.after(a), We.empty);
      if (s && s.slice.size < s.to - s.from) {
        if (e) {
          let l = t.tr.step(s);
          l.setSelection(nu(o, "end") ? et.findFrom(l.doc.resolve(l.mapping.map(i.pos, -1)), -1) : Ye.create(l.doc, i.pos - o.nodeSize)), e(l.scrollIntoView());
        }
        return !0;
      }
      if (a == 1 || r.node(a - 1).childCount > 1)
        break;
    }
  return o.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos - o.nodeSize, i.pos).scrollIntoView()), !0) : !1;
}, ZG = (t, e, n) => {
  let r = Sk(t, n);
  if (!r)
    return !1;
  let i = o2(r);
  return i ? Tk(t, i, e) : !1;
}, KG = (t, e, n) => {
  let r = Ck(t, n);
  if (!r)
    return !1;
  let i = a2(r);
  return i ? Tk(t, i, e) : !1;
};
function Tk(t, e, n) {
  let r = e.nodeBefore, i = r, o = e.pos - 1;
  for (; !i.isTextblock; o--) {
    if (i.type.spec.isolating)
      return !1;
    let f = i.lastChild;
    if (!f)
      return !1;
    i = f;
  }
  let a = e.nodeAfter, s = a, l = e.pos + 1;
  for (; !s.isTextblock; l++) {
    if (s.type.spec.isolating)
      return !1;
    let f = s.firstChild;
    if (!f)
      return !1;
    s = f;
  }
  let u = dm(t.doc, o, l, We.empty);
  if (!u || u.from != o || u instanceof hn && u.slice.size >= l - o)
    return !1;
  if (n) {
    let f = t.tr.step(u);
    f.setSelection(st.create(f.doc, o)), n(f.scrollIntoView());
  }
  return !0;
}
function nu(t, e, n = !1) {
  for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (n && r.childCount != 1)
      return !1;
  }
  return !1;
}
const QG = (t, e, n) => {
  let { $head: r, empty: i } = t.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
      return !1;
    o = o2(r);
  }
  let a = o && o.nodeBefore;
  return !a || !Ye.isSelectable(a) ? !1 : (e && e(t.tr.setSelection(Ye.create(t.doc, o.pos - a.nodeSize)).scrollIntoView()), !0);
};
function o2(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0)
        return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function Ck(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n;
}
const eJ = (t, e, n) => {
  let r = Ck(t, n);
  if (!r)
    return !1;
  let i = a2(r);
  if (!i)
    return !1;
  let o = i.nodeAfter;
  if (_k(t, i, e, 1))
    return !0;
  if (r.parent.content.size == 0 && (nu(o, "start") || Ye.isSelectable(o))) {
    let a = dm(t.doc, r.before(), r.after(), We.empty);
    if (a && a.slice.size < a.to - a.from) {
      if (e) {
        let s = t.tr.step(a);
        s.setSelection(nu(o, "start") ? et.findFrom(s.doc.resolve(s.mapping.map(i.pos)), 1) : Ye.create(s.doc, s.mapping.map(i.pos))), e(s.scrollIntoView());
      }
      return !0;
    }
  }
  return o.isAtom && i.depth == r.depth - 1 ? (e && e(t.tr.delete(i.pos, i.pos + o.nodeSize).scrollIntoView()), !0) : !1;
}, tJ = (t, e, n) => {
  let { $head: r, empty: i } = t.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size)
      return !1;
    o = a2(r);
  }
  let a = o && o.nodeAfter;
  return !a || !Ye.isSelectable(a) ? !1 : (e && e(t.tr.setSelection(Ye.create(t.doc, o.pos)).scrollIntoView()), !0);
};
function a2(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e);
      if (t.index(e) + 1 < n.childCount)
        return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const nJ = (t, e) => {
  let n = t.selection, r = n instanceof Ye, i;
  if (r) {
    if (n.node.isTextblock || !zd(t.doc, n.from))
      return !1;
    i = n.from;
  } else if (i = R_(t.doc, n.from, -1), i == null)
    return !1;
  if (e) {
    let o = t.tr.join(i);
    r && o.setSelection(Ye.create(o.doc, i - t.doc.resolve(i).nodeBefore.nodeSize)), e(o.scrollIntoView());
  }
  return !0;
}, rJ = (t, e) => {
  let n = t.selection, r;
  if (n instanceof Ye) {
    if (n.node.isTextblock || !zd(t.doc, n.to))
      return !1;
    r = n.to;
  } else if (r = R_(t.doc, n.to, 1), r == null)
    return !1;
  return e && e(t.tr.join(r).scrollIntoView()), !0;
}, iJ = (t, e) => {
  let { $from: n, $to: r } = t.selection, i = n.blockRange(r), o = i && Ld(i);
  return o == null ? !1 : (e && e(t.tr.lift(i, o).scrollIntoView()), !0);
}, oJ = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0);
};
function Ek(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const aJ = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  if (!n.parent.type.spec.code || !n.sameParent(r))
    return !1;
  let i = n.node(-1), o = n.indexAfter(-1), a = Ek(i.contentMatchAt(o));
  if (!a || !i.canReplaceWith(o, o, a))
    return !1;
  if (e) {
    let s = n.after(), l = t.tr.replaceWith(s, s, a.createAndFill());
    l.setSelection(et.near(l.doc.resolve(s), 1)), e(l.scrollIntoView());
  }
  return !0;
}, sJ = (t, e) => {
  let n = t.selection, { $from: r, $to: i } = n;
  if (n instanceof di || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let o = Ek(i.parent.contentMatchAt(i.indexAfter()));
  if (!o || !o.isTextblock)
    return !1;
  if (e) {
    let a = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, s = t.tr.insert(a, o.createAndFill());
    s.setSelection(st.create(s.doc, a + 1)), e(s.scrollIntoView());
  }
  return !0;
}, lJ = (t, e) => {
  let { $cursor: n } = t.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let o = n.before();
    if (U_(t.doc, o))
      return e && e(t.tr.split(o).scrollIntoView()), !0;
  }
  let r = n.blockRange(), i = r && Ld(r);
  return i == null ? !1 : (e && e(t.tr.lift(r, i).scrollIntoView()), !0);
}, cJ = (t, e) => {
  let { $from: n, to: r } = t.selection, i, o = n.sharedDepth(r);
  return o == 0 ? !1 : (i = n.before(o), e && e(t.tr.setSelection(Ye.create(t.doc, i))), !0);
};
function lI(t, e, n) {
  let r = e.nodeBefore, i = e.nodeAfter, o = e.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(o - 1, o) ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(o, o + 1) || !(i.isTextblock || zd(t.doc, e.pos)) ? !1 : (n && n(t.tr.join(e.pos).scrollIntoView()), !0);
}
function _k(t, e, n, r) {
  let i = e.nodeBefore, o = e.nodeAfter, a, s, l = i.type.spec.isolating || o.type.spec.isolating;
  if (!l && lI(t, e, n))
    return !0;
  let u = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (u && (a = (s = i.contentMatchAt(i.childCount)).findWrapping(o.type)) && s.matchType(a[0] || o.type).validEnd) {
    if (n) {
      let y = e.pos + o.nodeSize, b = Fe.empty;
      for (let D = a.length - 1; D >= 0; D--)
        b = Fe.from(a[D].create(null, b));
      b = Fe.from(i.copy(b));
      let x = t.tr.step(new mn(e.pos - 1, y, e.pos, y, new We(b, 1, 0), a.length, !0)), v = x.doc.resolve(y + 2 * a.length);
      v.nodeAfter && v.nodeAfter.type == i.type && zd(x.doc, v.pos) && x.join(v.pos), n(x.scrollIntoView());
    }
    return !0;
  }
  let f = o.type.spec.isolating || r > 0 && l ? null : et.findFrom(e, 1), h = f && f.$from.blockRange(f.$to), p = h && Ld(h);
  if (p != null && p >= e.depth)
    return n && n(t.tr.lift(h, p).scrollIntoView()), !0;
  if (u && nu(o, "start", !0) && nu(i, "end")) {
    let y = i, b = [];
    for (; b.push(y), !y.isTextblock; )
      y = y.lastChild;
    let x = o, v = 1;
    for (; !x.isTextblock; x = x.firstChild)
      v++;
    if (y.canReplace(y.childCount, y.childCount, x.content)) {
      if (n) {
        let D = Fe.empty;
        for (let E = b.length - 1; E >= 0; E--)
          D = Fe.from(b[E].copy(D));
        let S = t.tr.step(new mn(e.pos - b.length, e.pos + o.nodeSize, e.pos + v, e.pos + o.nodeSize - v, new We(D, b.length, 0), 0, !0));
        n(S.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function kk(t) {
  return function(e, n) {
    let r = e.selection, i = t < 0 ? r.$from : r.$to, o = i.depth;
    for (; i.node(o).isInline; ) {
      if (!o)
        return !1;
      o--;
    }
    return i.node(o).isTextblock ? (n && n(e.tr.setSelection(st.create(e.doc, t < 0 ? i.start(o) : i.end(o)))), !0) : !1;
  };
}
const uJ = kk(-1), fJ = kk(1);
function dJ(t, e = null) {
  return function(n, r) {
    let { $from: i, $to: o } = n.selection, a = i.blockRange(o), s = a && __(a, t, e);
    return s ? (r && r(n.tr.wrap(a, s).scrollIntoView()), !0) : !1;
  };
}
function hJ(t, e = null) {
  return function(n, r) {
    let i = !1;
    for (let o = 0; o < n.selection.ranges.length && !i; o++) {
      let { $from: { pos: a }, $to: { pos: s } } = n.selection.ranges[o];
      n.doc.nodesBetween(a, s, (l, u) => {
        if (i)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(t, e)))
          if (l.type == t)
            i = !0;
          else {
            let f = n.doc.resolve(u), h = f.index();
            i = f.parent.canReplaceWith(h, h + 1, t);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let o = n.tr;
      for (let a = 0; a < n.selection.ranges.length; a++) {
        let { $from: { pos: s }, $to: { pos: l } } = n.selection.ranges[a];
        o.setBlockType(s, l, t, e);
      }
      r(o.scrollIntoView());
    }
    return !0;
  };
}
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function pJ(t, e = null) {
  return function(n, r) {
    let { $from: i, $to: o } = n.selection, a = i.blockRange(o), s = !1, l = a;
    if (!a)
      return !1;
    if (a.depth >= 2 && i.node(a.depth - 1).type.compatibleContent(t) && a.startIndex == 0) {
      if (i.index(a.depth - 1) == 0)
        return !1;
      let f = n.doc.resolve(a.start - 2);
      l = new Hp(f, f, a.depth), a.endIndex < a.parent.childCount && (a = new Hp(i, n.doc.resolve(o.end(a.depth)), a.depth)), s = !0;
    }
    let u = __(l, t, e, a);
    return u ? (r && r(cI(n.tr, a, u, s, t).scrollIntoView()), !0) : !1;
  };
}
function cI(t, e, n, r, i) {
  let o = Fe.empty;
  for (let f = n.length - 1; f >= 0; f--)
    o = Fe.from(n[f].type.create(n[f].attrs, o));
  t.step(new mn(e.start - (r ? 2 : 0), e.end, e.start, e.end, new We(o, 0, 0), n.length, !0));
  let a = 0;
  for (let f = 0; f < n.length; f++)
    n[f].type == i && (a = f + 1);
  let s = n.length - a, l = e.start + n.length - (r ? 2 : 0), u = e.parent;
  for (let f = e.startIndex, h = e.endIndex, p = !0; f < h; f++, p = !1)
    !p && U_(t.doc, l, s) && (t.split(l, s), l += 2 * s), l += u.child(f).nodeSize;
  return t;
}
function gJ(t) {
  return function(e, n) {
    let { $from: r, $to: i } = e.selection, o = r.blockRange(i, (a) => a.childCount > 0 && a.firstChild.type == t);
    return o ? n ? r.node(o.depth - 1).type == t ? uI(e, n, t, o) : fI(e, n, o) : !0 : !1;
  };
}
function uI(t, e, n, r) {
  let i = t.tr, o = r.end, a = r.$to.end(r.depth);
  o < a && (i.step(new mn(o - 1, a, o, a, new We(Fe.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new Hp(i.doc.resolve(r.$from.pos), i.doc.resolve(a), r.depth));
  const s = Ld(r);
  if (s == null)
    return !1;
  i.lift(r, s);
  let l = i.mapping.map(o, -1) - 1;
  return zd(i.doc, l) && i.join(l), e(i.scrollIntoView()), !0;
}
function fI(t, e, n) {
  let r = t.tr, i = n.parent;
  for (let y = n.end, b = n.endIndex - 1, x = n.startIndex; b > x; b--)
    y -= i.child(b).nodeSize, r.delete(y - 1, y + 1);
  let o = r.doc.resolve(n.start), a = o.nodeAfter;
  if (r.mapping.map(n.end) != n.start + o.nodeAfter.nodeSize)
    return !1;
  let s = n.startIndex == 0, l = n.endIndex == i.childCount, u = o.node(-1), f = o.index(-1);
  if (!u.canReplace(f + (s ? 0 : 1), f + 1, a.content.append(l ? Fe.empty : Fe.from(i))))
    return !1;
  let h = o.pos, p = h + a.nodeSize;
  return r.step(new mn(h - (s ? 1 : 0), p + (l ? 1 : 0), h + 1, p - 1, new We((s ? Fe.empty : Fe.from(i.copy(Fe.empty))).append(l ? Fe.empty : Fe.from(i.copy(Fe.empty))), s ? 0 : 1, l ? 0 : 1), s ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function mJ(t) {
  return function(e, n) {
    let { $from: r, $to: i } = e.selection, o = r.blockRange(i, (u) => u.childCount > 0 && u.firstChild.type == t);
    if (!o)
      return !1;
    let a = o.startIndex;
    if (a == 0)
      return !1;
    let s = o.parent, l = s.child(a - 1);
    if (l.type != t)
      return !1;
    if (n) {
      let u = l.lastChild && l.lastChild.type == s.type, f = Fe.from(u ? t.create() : null), h = new We(Fe.from(t.create(null, Fe.from(s.type.create(null, f)))), u ? 3 : 1, 0), p = o.start, y = o.end;
      n(e.tr.step(new mn(p - (u ? 3 : 1), y, p, y, h, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function Ak(t) {
  var e, n, r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var i = t.length;
    for (e = 0; e < i; e++) t[e] && (n = Ak(t[e])) && (r && (r += " "), r += n);
  } else for (n in t) t[n] && (r && (r += " "), r += n);
  return r;
}
function dI() {
  for (var t, e, n = 0, r = "", i = arguments.length; n < i; n++) (t = arguments[n]) && (e = Ak(t)) && (r && (r += " "), r += e);
  return r;
}
const s2 = "-", hI = (t) => {
  const e = gI(t), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: r
  } = t;
  return {
    getClassGroupId: (a) => {
      const s = a.split(s2);
      return s[0] === "" && s.length !== 1 && s.shift(), Uk(s, e) || pI(a);
    },
    getConflictingClassGroupIds: (a, s) => {
      const l = n[a] || [];
      return s && r[a] ? [...l, ...r[a]] : l;
    }
  };
}, Uk = (t, e) => {
  var a;
  if (t.length === 0)
    return e.classGroupId;
  const n = t[0], r = e.nextPart.get(n), i = r ? Uk(t.slice(1), r) : void 0;
  if (i)
    return i;
  if (e.validators.length === 0)
    return;
  const o = t.join(s2);
  return (a = e.validators.find(({
    validator: s
  }) => s(o))) == null ? void 0 : a.classGroupId;
}, pw = /^\[(.+)\]$/, pI = (t) => {
  if (pw.test(t)) {
    const e = pw.exec(t)[1], n = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}, gI = (t) => {
  const {
    theme: e,
    prefix: n
  } = t, r = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return yI(Object.entries(t.classGroups), n).forEach(([o, a]) => {
    j1(a, r, o, e);
  }), r;
}, j1 = (t, e, n, r) => {
  t.forEach((i) => {
    if (typeof i == "string") {
      const o = i === "" ? e : gw(e, i);
      o.classGroupId = n;
      return;
    }
    if (typeof i == "function") {
      if (mI(i)) {
        j1(i(r), e, n, r);
        return;
      }
      e.validators.push({
        validator: i,
        classGroupId: n
      });
      return;
    }
    Object.entries(i).forEach(([o, a]) => {
      j1(a, gw(e, o), n, r);
    });
  });
}, gw = (t, e) => {
  let n = t;
  return e.split(s2).forEach((r) => {
    n.nextPart.has(r) || n.nextPart.set(r, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(r);
  }), n;
}, mI = (t) => t.isThemeGetter, yI = (t, e) => e ? t.map(([n, r]) => {
  const i = r.map((o) => typeof o == "string" ? e + o : typeof o == "object" ? Object.fromEntries(Object.entries(o).map(([a, s]) => [e + a, s])) : o);
  return [n, i];
}) : t, bI = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  const i = (o, a) => {
    n.set(o, a), e++, e > t && (e = 0, r = n, n = /* @__PURE__ */ new Map());
  };
  return {
    get(o) {
      let a = n.get(o);
      if (a !== void 0)
        return a;
      if ((a = r.get(o)) !== void 0)
        return i(o, a), a;
    },
    set(o, a) {
      n.has(o) ? n.set(o, a) : i(o, a);
    }
  };
}, Fk = "!", vI = (t) => {
  const {
    separator: e,
    experimentalParseClassName: n
  } = t, r = e.length === 1, i = e[0], o = e.length, a = (s) => {
    const l = [];
    let u = 0, f = 0, h;
    for (let v = 0; v < s.length; v++) {
      let D = s[v];
      if (u === 0) {
        if (D === i && (r || s.slice(v, v + o) === e)) {
          l.push(s.slice(f, v)), f = v + o;
          continue;
        }
        if (D === "/") {
          h = v;
          continue;
        }
      }
      D === "[" ? u++ : D === "]" && u--;
    }
    const p = l.length === 0 ? s : s.substring(f), y = p.startsWith(Fk), b = y ? p.substring(1) : p, x = h && h > f ? h - f : void 0;
    return {
      modifiers: l,
      hasImportantModifier: y,
      baseClassName: b,
      maybePostfixModifierPosition: x
    };
  };
  return n ? (s) => n({
    className: s,
    parseClassName: a
  }) : a;
}, xI = (t) => {
  if (t.length <= 1)
    return t;
  const e = [];
  let n = [];
  return t.forEach((r) => {
    r[0] === "[" ? (e.push(...n.sort(), r), n = []) : n.push(r);
  }), e.push(...n.sort()), e;
}, DI = (t) => ({
  cache: bI(t.cacheSize),
  parseClassName: vI(t),
  ...hI(t)
}), wI = /\s+/, SI = (t, e) => {
  const {
    parseClassName: n,
    getClassGroupId: r,
    getConflictingClassGroupIds: i
  } = e, o = [], a = t.trim().split(wI);
  let s = "";
  for (let l = a.length - 1; l >= 0; l -= 1) {
    const u = a[l], {
      modifiers: f,
      hasImportantModifier: h,
      baseClassName: p,
      maybePostfixModifierPosition: y
    } = n(u);
    let b = !!y, x = r(b ? p.substring(0, y) : p);
    if (!x) {
      if (!b) {
        s = u + (s.length > 0 ? " " + s : s);
        continue;
      }
      if (x = r(p), !x) {
        s = u + (s.length > 0 ? " " + s : s);
        continue;
      }
      b = !1;
    }
    const v = xI(f).join(":"), D = h ? v + Fk : v, S = D + x;
    if (o.includes(S))
      continue;
    o.push(S);
    const E = i(x, b);
    for (let I = 0; I < E.length; ++I) {
      const R = E[I];
      o.push(D + R);
    }
    s = u + (s.length > 0 ? " " + s : s);
  }
  return s;
};
function TI() {
  let t = 0, e, n, r = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (n = Rk(e)) && (r && (r += " "), r += n);
  return r;
}
const Rk = (t) => {
  if (typeof t == "string")
    return t;
  let e, n = "";
  for (let r = 0; r < t.length; r++)
    t[r] && (e = Rk(t[r])) && (n && (n += " "), n += e);
  return n;
};
function CI(t, ...e) {
  let n, r, i, o = a;
  function a(l) {
    const u = e.reduce((f, h) => h(f), t());
    return n = DI(u), r = n.cache.get, i = n.cache.set, o = s, s(l);
  }
  function s(l) {
    const u = r(l);
    if (u)
      return u;
    const f = SI(l, n);
    return i(l, f), f;
  }
  return function() {
    return o(TI.apply(null, arguments));
  };
}
const Ct = (t) => {
  const e = (n) => n[t] || [];
  return e.isThemeGetter = !0, e;
}, Ok = /^\[(?:([a-z-]+):)?(.+)\]$/i, EI = /^\d+\/\d+$/, _I = /* @__PURE__ */ new Set(["px", "full", "screen"]), kI = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, AI = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, UI = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, FI = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, RI = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Eo = (t) => qc(t) || _I.has(t) || EI.test(t), Ca = (t) => Du(t, "length", LI), qc = (t) => !!t && !Number.isNaN(Number(t)), Ab = (t) => Du(t, "number", qc), Af = (t) => !!t && Number.isInteger(Number(t)), OI = (t) => t.endsWith("%") && qc(t.slice(0, -1)), rt = (t) => Ok.test(t), Ea = (t) => kI.test(t), II = /* @__PURE__ */ new Set(["length", "size", "percentage"]), BI = (t) => Du(t, II, Ik), MI = (t) => Du(t, "position", Ik), NI = /* @__PURE__ */ new Set(["image", "url"]), PI = (t) => Du(t, NI, $I), WI = (t) => Du(t, "", zI), Uf = () => !0, Du = (t, e, n) => {
  const r = Ok.exec(t);
  return r ? r[1] ? typeof e == "string" ? r[1] === e : e.has(r[1]) : n(r[2]) : !1;
}, LI = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  AI.test(t) && !UI.test(t)
), Ik = () => !1, zI = (t) => FI.test(t), $I = (t) => RI.test(t), jI = () => {
  const t = Ct("colors"), e = Ct("spacing"), n = Ct("blur"), r = Ct("brightness"), i = Ct("borderColor"), o = Ct("borderRadius"), a = Ct("borderSpacing"), s = Ct("borderWidth"), l = Ct("contrast"), u = Ct("grayscale"), f = Ct("hueRotate"), h = Ct("invert"), p = Ct("gap"), y = Ct("gradientColorStops"), b = Ct("gradientColorStopPositions"), x = Ct("inset"), v = Ct("margin"), D = Ct("opacity"), S = Ct("padding"), E = Ct("saturate"), I = Ct("scale"), R = Ct("sepia"), O = Ct("skew"), N = Ct("space"), q = Ct("translate"), $ = () => ["auto", "contain", "none"], le = () => ["auto", "hidden", "clip", "visible", "scroll"], ve = () => ["auto", rt, e], M = () => [rt, e], ee = () => ["", Eo, Ca], A = () => ["auto", qc, rt], oe = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], j = () => ["solid", "dashed", "dotted", "double", "none"], Q = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], G = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], Z = () => ["", "0", rt], re = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], V = () => [qc, rt];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Uf],
      spacing: [Eo, Ca],
      blur: ["none", "", Ea, rt],
      brightness: V(),
      borderColor: [t],
      borderRadius: ["none", "", "full", Ea, rt],
      borderSpacing: M(),
      borderWidth: ee(),
      contrast: V(),
      grayscale: Z(),
      hueRotate: V(),
      invert: Z(),
      gap: M(),
      gradientColorStops: [t],
      gradientColorStopPositions: [OI, Ca],
      inset: ve(),
      margin: ve(),
      opacity: V(),
      padding: M(),
      saturate: V(),
      scale: V(),
      sepia: Z(),
      skew: V(),
      space: M(),
      translate: M()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", rt]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Ea]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": re()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": re()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...oe(), rt]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: le()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": le()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": le()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: $()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": $()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": $()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [x]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [x]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [x]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [x]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [x]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [x]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [x]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [x]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [x]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Af, rt]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: ve()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", rt]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: Z()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: Z()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Af, rt]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Uf]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Af, rt]
        }, rt]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": A()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": A()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Uf]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Af, rt]
        }, rt]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": A()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": A()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", rt]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", rt]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [p]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [p]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [p]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...G()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...G(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...G(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [S]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [S]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [S]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [S]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [S]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [S]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [S]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [S]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [S]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [v]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [v]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [v]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [v]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [v]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [v]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [v]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [v]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [v]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [N]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [N]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", rt, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [rt, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [rt, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [Ea]
        }, Ea]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [rt, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [rt, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [rt, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [rt, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", Ea, Ca]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Ab]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Uf]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", rt]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", qc, Ab]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Eo, rt]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", rt]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", rt]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [t]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [D]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [t]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [D]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...j(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", Eo, Ca]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", Eo, rt]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [t]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: M()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", rt]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", rt]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [D]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...oe(), MI]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", BI]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, PI]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [t]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [b]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [b]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [b]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [y]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [y]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [y]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [o]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [o]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [o]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [o]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [o]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [o]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [o]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [o]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [o]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [o]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [o]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [o]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [o]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [o]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [o]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [s]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [s]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [s]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [s]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [s]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [s]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [s]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [s]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [s]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [D]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...j(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [s]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [s]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [D]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: j()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [i]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...j()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Eo, rt]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [Eo, Ca]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [t]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: ee()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [t]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [D]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [Eo, Ca]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [t]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", Ea, WI]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Uf]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [D]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...Q(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": Q()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [n]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [r]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", Ea, rt]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [u]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [f]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [h]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [E]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [R]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [n]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [r]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [u]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [f]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [h]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [D]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [E]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [R]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [a]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [a]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [a]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", rt]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: V()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", rt]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: V()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", rt]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [I]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [I]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [I]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Af, rt]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [q]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [q]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [O]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [O]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", rt]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", t]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", rt]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [t]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": M()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": M()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": M()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": M()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": M()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": M()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": M()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": M()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": M()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": M()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": M()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": M()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": M()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": M()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": M()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": M()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": M()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": M()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", rt]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [t, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Eo, Ca, Ab]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [t, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, yJ = /* @__PURE__ */ CI(jI);
var it = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function HI(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function Bk(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
var mw = Object.prototype.toString, Mk = function(e) {
  var n = mw.call(e), r = n === "[object Arguments]";
  return r || (r = n !== "[object Array]" && e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && mw.call(e.callee) === "[object Function]"), r;
}, Ub, yw;
function VI() {
  if (yw) return Ub;
  yw = 1;
  var t;
  if (!Object.keys) {
    var e = Object.prototype.hasOwnProperty, n = Object.prototype.toString, r = Mk, i = Object.prototype.propertyIsEnumerable, o = !i.call({ toString: null }, "toString"), a = i.call(function() {
    }, "prototype"), s = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], l = function(p) {
      var y = p.constructor;
      return y && y.prototype === p;
    }, u = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, f = function() {
      if (typeof window > "u")
        return !1;
      for (var p in window)
        try {
          if (!u["$" + p] && e.call(window, p) && window[p] !== null && typeof window[p] == "object")
            try {
              l(window[p]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), h = function(p) {
      if (typeof window > "u" || !f)
        return l(p);
      try {
        return l(p);
      } catch {
        return !1;
      }
    };
    t = function(y) {
      var b = y !== null && typeof y == "object", x = n.call(y) === "[object Function]", v = r(y), D = b && n.call(y) === "[object String]", S = [];
      if (!b && !x && !v)
        throw new TypeError("Object.keys called on a non-object");
      var E = a && x;
      if (D && y.length > 0 && !e.call(y, 0))
        for (var I = 0; I < y.length; ++I)
          S.push(String(I));
      if (v && y.length > 0)
        for (var R = 0; R < y.length; ++R)
          S.push(String(R));
      else
        for (var O in y)
          !(E && O === "prototype") && e.call(y, O) && S.push(String(O));
      if (o)
        for (var N = h(y), q = 0; q < s.length; ++q)
          !(N && s[q] === "constructor") && e.call(y, s[q]) && S.push(s[q]);
      return S;
    };
  }
  return Ub = t, Ub;
}
var qI = Array.prototype.slice, XI = Mk, bw = Object.keys, xp = bw ? function(e) {
  return bw(e);
} : VI(), vw = Object.keys;
xp.shim = function() {
  if (Object.keys) {
    var e = function() {
      var n = Object.keys(arguments);
      return n && n.length === arguments.length;
    }(1, 2);
    e || (Object.keys = function(r) {
      return XI(r) ? vw(qI.call(r)) : vw(r);
    });
  } else
    Object.keys = xp;
  return Object.keys || xp;
};
var l2 = xp, GI = Error, JI = EvalError, YI = RangeError, ZI = ReferenceError, Nk = SyntaxError, is = TypeError, KI = URIError, ym = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var e = {}, n = Symbol("test"), r = Object(n);
  if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
    return !1;
  var i = 42;
  e[n] = i;
  for (n in e)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
    return !1;
  var o = Object.getOwnPropertySymbols(e);
  if (o.length !== 1 || o[0] !== n || !Object.prototype.propertyIsEnumerable.call(e, n))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var a = Object.getOwnPropertyDescriptor(e, n);
    if (a.value !== i || a.enumerable !== !0)
      return !1;
  }
  return !0;
}, xw = typeof Symbol < "u" && Symbol, QI = ym, c2 = function() {
  return typeof xw != "function" || typeof Symbol != "function" || typeof xw("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : QI();
}, Fb = {
  __proto__: null,
  foo: {}
}, e6 = Object, t6 = function() {
  return { __proto__: Fb }.foo === Fb.foo && !(Fb instanceof e6);
}, n6 = "Function.prototype.bind called on incompatible ", r6 = Object.prototype.toString, i6 = Math.max, o6 = "[object Function]", Dw = function(e, n) {
  for (var r = [], i = 0; i < e.length; i += 1)
    r[i] = e[i];
  for (var o = 0; o < n.length; o += 1)
    r[o + e.length] = n[o];
  return r;
}, a6 = function(e, n) {
  for (var r = [], i = n, o = 0; i < e.length; i += 1, o += 1)
    r[o] = e[i];
  return r;
}, s6 = function(t, e) {
  for (var n = "", r = 0; r < t.length; r += 1)
    n += t[r], r + 1 < t.length && (n += e);
  return n;
}, l6 = function(e) {
  var n = this;
  if (typeof n != "function" || r6.apply(n) !== o6)
    throw new TypeError(n6 + n);
  for (var r = a6(arguments, 1), i, o = function() {
    if (this instanceof i) {
      var f = n.apply(
        this,
        Dw(r, arguments)
      );
      return Object(f) === f ? f : this;
    }
    return n.apply(
      e,
      Dw(r, arguments)
    );
  }, a = i6(0, n.length - r.length), s = [], l = 0; l < a; l++)
    s[l] = "$" + l;
  if (i = Function("binder", "return function (" + s6(s, ",") + "){ return binder.apply(this,arguments); }")(o), n.prototype) {
    var u = function() {
    };
    u.prototype = n.prototype, i.prototype = new u(), u.prototype = null;
  }
  return i;
}, c6 = l6, u2 = Function.prototype.bind || c6, u6 = Function.prototype.call, f6 = Object.prototype.hasOwnProperty, d6 = u2, Pk = d6.call(u6, f6), ct, h6 = GI, p6 = JI, g6 = YI, m6 = ZI, ru = Nk, Xc = is, y6 = KI, Wk = Function, Rb = function(t) {
  try {
    return Wk('"use strict"; return (' + t + ").constructor;")();
  } catch {
  }
}, ol = Object.getOwnPropertyDescriptor;
if (ol)
  try {
    ol({}, "");
  } catch {
    ol = null;
  }
var Ob = function() {
  throw new Xc();
}, b6 = ol ? function() {
  try {
    return arguments.callee, Ob;
  } catch {
    try {
      return ol(arguments, "callee").get;
    } catch {
      return Ob;
    }
  }
}() : Ob, _c = c2(), v6 = t6(), Kt = Object.getPrototypeOf || (v6 ? function(t) {
  return t.__proto__;
} : null), Nc = {}, x6 = typeof Uint8Array > "u" || !Kt ? ct : Kt(Uint8Array), al = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? ct : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? ct : ArrayBuffer,
  "%ArrayIteratorPrototype%": _c && Kt ? Kt([][Symbol.iterator]()) : ct,
  "%AsyncFromSyncIteratorPrototype%": ct,
  "%AsyncFunction%": Nc,
  "%AsyncGenerator%": Nc,
  "%AsyncGeneratorFunction%": Nc,
  "%AsyncIteratorPrototype%": Nc,
  "%Atomics%": typeof Atomics > "u" ? ct : Atomics,
  "%BigInt%": typeof BigInt > "u" ? ct : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? ct : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? ct : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? ct : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": h6,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": p6,
  "%Float32Array%": typeof Float32Array > "u" ? ct : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? ct : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? ct : FinalizationRegistry,
  "%Function%": Wk,
  "%GeneratorFunction%": Nc,
  "%Int8Array%": typeof Int8Array > "u" ? ct : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? ct : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? ct : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": _c && Kt ? Kt(Kt([][Symbol.iterator]())) : ct,
  "%JSON%": typeof JSON == "object" ? JSON : ct,
  "%Map%": typeof Map > "u" ? ct : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !_c || !Kt ? ct : Kt((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? ct : Promise,
  "%Proxy%": typeof Proxy > "u" ? ct : Proxy,
  "%RangeError%": g6,
  "%ReferenceError%": m6,
  "%Reflect%": typeof Reflect > "u" ? ct : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? ct : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !_c || !Kt ? ct : Kt((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? ct : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": _c && Kt ? Kt(""[Symbol.iterator]()) : ct,
  "%Symbol%": _c ? Symbol : ct,
  "%SyntaxError%": ru,
  "%ThrowTypeError%": b6,
  "%TypedArray%": x6,
  "%TypeError%": Xc,
  "%Uint8Array%": typeof Uint8Array > "u" ? ct : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? ct : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? ct : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? ct : Uint32Array,
  "%URIError%": y6,
  "%WeakMap%": typeof WeakMap > "u" ? ct : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? ct : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? ct : WeakSet
};
if (Kt)
  try {
    null.error;
  } catch (t) {
    var D6 = Kt(Kt(t));
    al["%Error.prototype%"] = D6;
  }
var w6 = function t(e) {
  var n;
  if (e === "%AsyncFunction%")
    n = Rb("async function () {}");
  else if (e === "%GeneratorFunction%")
    n = Rb("function* () {}");
  else if (e === "%AsyncGeneratorFunction%")
    n = Rb("async function* () {}");
  else if (e === "%AsyncGenerator%") {
    var r = t("%AsyncGeneratorFunction%");
    r && (n = r.prototype);
  } else if (e === "%AsyncIteratorPrototype%") {
    var i = t("%AsyncGenerator%");
    i && Kt && (n = Kt(i.prototype));
  }
  return al[e] = n, n;
}, ww = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Vd = u2, Kp = Pk, S6 = Vd.call(Function.call, Array.prototype.concat), T6 = Vd.call(Function.apply, Array.prototype.splice), Sw = Vd.call(Function.call, String.prototype.replace), Qp = Vd.call(Function.call, String.prototype.slice), C6 = Vd.call(Function.call, RegExp.prototype.exec), E6 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, _6 = /\\(\\)?/g, k6 = function(e) {
  var n = Qp(e, 0, 1), r = Qp(e, -1);
  if (n === "%" && r !== "%")
    throw new ru("invalid intrinsic syntax, expected closing `%`");
  if (r === "%" && n !== "%")
    throw new ru("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return Sw(e, E6, function(o, a, s, l) {
    i[i.length] = s ? Sw(l, _6, "$1") : a || o;
  }), i;
}, A6 = function(e, n) {
  var r = e, i;
  if (Kp(ww, r) && (i = ww[r], r = "%" + i[0] + "%"), Kp(al, r)) {
    var o = al[r];
    if (o === Nc && (o = w6(r)), typeof o > "u" && !n)
      throw new Xc("intrinsic " + e + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: r,
      value: o
    };
  }
  throw new ru("intrinsic " + e + " does not exist!");
}, Qi = function(e, n) {
  if (typeof e != "string" || e.length === 0)
    throw new Xc("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof n != "boolean")
    throw new Xc('"allowMissing" argument must be a boolean');
  if (C6(/^%?[^%]*%?$/, e) === null)
    throw new ru("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var r = k6(e), i = r.length > 0 ? r[0] : "", o = A6("%" + i + "%", n), a = o.name, s = o.value, l = !1, u = o.alias;
  u && (i = u[0], T6(r, S6([0, 1], u)));
  for (var f = 1, h = !0; f < r.length; f += 1) {
    var p = r[f], y = Qp(p, 0, 1), b = Qp(p, -1);
    if ((y === '"' || y === "'" || y === "`" || b === '"' || b === "'" || b === "`") && y !== b)
      throw new ru("property names with quotes must have matching quotes");
    if ((p === "constructor" || !h) && (l = !0), i += "." + p, a = "%" + i + "%", Kp(al, a))
      s = al[a];
    else if (s != null) {
      if (!(p in s)) {
        if (!n)
          throw new Xc("base intrinsic for " + e + " exists, but the property is not available.");
        return;
      }
      if (ol && f + 1 >= r.length) {
        var x = ol(s, p);
        h = !!x, h && "get" in x && !("originalValue" in x.get) ? s = x.get : s = s[p];
      } else
        h = Kp(s, p), s = s[p];
      h && !l && (al[a] = s);
    }
  }
  return s;
}, U6 = Qi, Dp = U6("%Object.defineProperty%", !0) || !1;
if (Dp)
  try {
    Dp({}, "a", { value: 1 });
  } catch {
    Dp = !1;
  }
var f2 = Dp, F6 = Qi, wp = F6("%Object.getOwnPropertyDescriptor%", !0);
if (wp)
  try {
    wp([], "length");
  } catch {
    wp = null;
  }
var d2 = wp, Tw = f2, R6 = Nk, kc = is, Cw = d2, h2 = function(e, n, r) {
  if (!e || typeof e != "object" && typeof e != "function")
    throw new kc("`obj` must be an object or a function`");
  if (typeof n != "string" && typeof n != "symbol")
    throw new kc("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new kc("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new kc("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new kc("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new kc("`loose`, if provided, must be a boolean");
  var i = arguments.length > 3 ? arguments[3] : null, o = arguments.length > 4 ? arguments[4] : null, a = arguments.length > 5 ? arguments[5] : null, s = arguments.length > 6 ? arguments[6] : !1, l = !!Cw && Cw(e, n);
  if (Tw)
    Tw(e, n, {
      configurable: a === null && l ? l.configurable : !a,
      enumerable: i === null && l ? l.enumerable : !i,
      value: r,
      writable: o === null && l ? l.writable : !o
    });
  else if (s || !i && !o && !a)
    e[n] = r;
  else
    throw new R6("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, H1 = f2, Lk = function() {
  return !!H1;
};
Lk.hasArrayLengthDefineBug = function() {
  if (!H1)
    return null;
  try {
    return H1([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var p2 = Lk, O6 = l2, I6 = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", B6 = Object.prototype.toString, M6 = Array.prototype.concat, Ew = h2, N6 = function(t) {
  return typeof t == "function" && B6.call(t) === "[object Function]";
}, zk = p2(), P6 = function(t, e, n, r) {
  if (e in t) {
    if (r === !0) {
      if (t[e] === n)
        return;
    } else if (!N6(r) || !r())
      return;
  }
  zk ? Ew(t, e, n, !0) : Ew(t, e, n);
}, $k = function(t, e) {
  var n = arguments.length > 2 ? arguments[2] : {}, r = O6(e);
  I6 && (r = M6.call(r, Object.getOwnPropertySymbols(e)));
  for (var i = 0; i < r.length; i += 1)
    P6(t, r[i], e[r[i]], n[r[i]]);
};
$k.supportsDescriptors = !!zk;
var xl = $k, jk = { exports: {} }, W6 = Qi, _w = h2, L6 = p2(), kw = d2, Aw = is, z6 = W6("%Math.floor%"), $6 = function(e, n) {
  if (typeof e != "function")
    throw new Aw("`fn` is not a function");
  if (typeof n != "number" || n < 0 || n > 4294967295 || z6(n) !== n)
    throw new Aw("`length` must be a positive 32-bit integer");
  var r = arguments.length > 2 && !!arguments[2], i = !0, o = !0;
  if ("length" in e && kw) {
    var a = kw(e, "length");
    a && !a.configurable && (i = !1), a && !a.writable && (o = !1);
  }
  return (i || o || !r) && (L6 ? _w(
    /** @type {Parameters<define>[0]} */
    e,
    "length",
    n,
    !0,
    !0
  ) : _w(
    /** @type {Parameters<define>[0]} */
    e,
    "length",
    n
  )), e;
};
(function(t) {
  var e = u2, n = Qi, r = $6, i = is, o = n("%Function.prototype.apply%"), a = n("%Function.prototype.call%"), s = n("%Reflect.apply%", !0) || e.call(a, o), l = f2, u = n("%Math.max%");
  t.exports = function(p) {
    if (typeof p != "function")
      throw new i("a function is required");
    var y = s(e, a, arguments);
    return r(
      y,
      1 + u(0, p.length - (arguments.length - 1)),
      !0
    );
  };
  var f = function() {
    return s(e, o, arguments);
  };
  l ? l(t.exports, "apply", { value: f }) : t.exports.apply = f;
})(jk);
var wu = jk.exports, Hk = Qi, Vk = wu, j6 = Vk(Hk("String.prototype.indexOf")), Kr = function(e, n) {
  var r = Hk(e, !!n);
  return typeof r == "function" && j6(e, ".prototype.") > -1 ? Vk(r) : r;
}, H6 = l2, qk = ym(), Xk = Kr, Uw = Object, V6 = Xk("Array.prototype.push"), Fw = Xk("Object.prototype.propertyIsEnumerable"), q6 = qk ? Object.getOwnPropertySymbols : null, Gk = function(e, n) {
  if (e == null)
    throw new TypeError("target must be an object");
  var r = Uw(e);
  if (arguments.length === 1)
    return r;
  for (var i = 1; i < arguments.length; ++i) {
    var o = Uw(arguments[i]), a = H6(o), s = qk && (Object.getOwnPropertySymbols || q6);
    if (s)
      for (var l = s(o), u = 0; u < l.length; ++u) {
        var f = l[u];
        Fw(o, f) && V6(a, f);
      }
    for (var h = 0; h < a.length; ++h) {
      var p = a[h];
      if (Fw(o, p)) {
        var y = o[p];
        r[p] = y;
      }
    }
  }
  return r;
}, Ib = Gk, X6 = function() {
  if (!Object.assign)
    return !1;
  for (var t = "abcdefghijklmnopqrst", e = t.split(""), n = {}, r = 0; r < e.length; ++r)
    n[e[r]] = e[r];
  var i = Object.assign({}, n), o = "";
  for (var a in i)
    o += a;
  return t !== o;
}, G6 = function() {
  if (!Object.assign || !Object.preventExtensions)
    return !1;
  var t = Object.preventExtensions({ 1: 2 });
  try {
    Object.assign(t, "xy");
  } catch {
    return t[1] === "y";
  }
  return !1;
}, Jk = function() {
  return !Object.assign || X6() || G6() ? Ib : Object.assign;
}, J6 = xl, Y6 = Jk, Z6 = function() {
  var e = Y6();
  return J6(
    Object,
    { assign: e },
    { assign: function() {
      return Object.assign !== e;
    } }
  ), e;
}, K6 = xl, Q6 = wu, e4 = Gk, Yk = Jk, t4 = Z6, n4 = Q6.apply(Yk()), Zk = function(e, n) {
  return n4(Object, arguments);
};
K6(Zk, {
  getPolyfill: Yk,
  implementation: e4,
  shim: t4
});
var r4 = Zk, hd = function() {
  return typeof (function() {
  }).name == "string";
}, Yf = Object.getOwnPropertyDescriptor;
if (Yf)
  try {
    Yf([], "length");
  } catch {
    Yf = null;
  }
hd.functionsHaveConfigurableNames = function() {
  if (!hd() || !Yf)
    return !1;
  var e = Yf(function() {
  }, "name");
  return !!e && !!e.configurable;
};
var i4 = Function.prototype.bind;
hd.boundFunctionsHaveNames = function() {
  return hd() && typeof i4 == "function" && (function() {
  }).bind().name !== "";
};
var o4 = hd, Rw = h2, a4 = p2(), s4 = o4.functionsHaveConfigurableNames(), l4 = is, c4 = function(e, n) {
  if (typeof e != "function")
    throw new l4("`fn` is not a function");
  var r = arguments.length > 2 && !!arguments[2];
  return (!r || s4) && (a4 ? Rw(
    /** @type {Parameters<define>[0]} */
    e,
    "name",
    n,
    !0,
    !0
  ) : Rw(
    /** @type {Parameters<define>[0]} */
    e,
    "name",
    n
  )), e;
}, u4 = c4, f4 = is, d4 = Object, Kk = u4(function() {
  if (this == null || this !== d4(this))
    throw new f4("RegExp.prototype.flags getter called on non-object");
  var e = "";
  return this.hasIndices && (e += "d"), this.global && (e += "g"), this.ignoreCase && (e += "i"), this.multiline && (e += "m"), this.dotAll && (e += "s"), this.unicode && (e += "u"), this.unicodeSets && (e += "v"), this.sticky && (e += "y"), e;
}, "get flags", !0), h4 = Kk, p4 = xl.supportsDescriptors, g4 = Object.getOwnPropertyDescriptor, Qk = function() {
  if (p4 && /a/mig.flags === "gim") {
    var e = g4(RegExp.prototype, "flags");
    if (e && typeof e.get == "function" && typeof RegExp.prototype.dotAll == "boolean" && typeof RegExp.prototype.hasIndices == "boolean") {
      var n = "", r = {};
      if (Object.defineProperty(r, "hasIndices", {
        get: function() {
          n += "d";
        }
      }), Object.defineProperty(r, "sticky", {
        get: function() {
          n += "y";
        }
      }), n === "dy")
        return e.get;
    }
  }
  return h4;
}, m4 = xl.supportsDescriptors, y4 = Qk, b4 = Object.getOwnPropertyDescriptor, v4 = Object.defineProperty, x4 = TypeError, Ow = Object.getPrototypeOf, D4 = /a/, w4 = function() {
  if (!m4 || !Ow)
    throw new x4("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  var e = y4(), n = Ow(D4), r = b4(n, "flags");
  return (!r || r.get !== e) && v4(n, "flags", {
    configurable: !0,
    enumerable: !1,
    get: e
  }), e;
}, S4 = xl, T4 = wu, C4 = Kk, eA = Qk, E4 = w4, tA = T4(eA());
S4(tA, {
  getPolyfill: eA,
  implementation: C4,
  shim: E4
});
var _4 = tA, Sp = { exports: {} }, k4 = ym, Dl = function() {
  return k4() && !!Symbol.toStringTag;
}, A4 = Dl(), U4 = Kr, V1 = U4("Object.prototype.toString"), bm = function(e) {
  return A4 && e && typeof e == "object" && Symbol.toStringTag in e ? !1 : V1(e) === "[object Arguments]";
}, nA = function(e) {
  return bm(e) ? !0 : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && V1(e) !== "[object Array]" && V1(e.callee) === "[object Function]";
}, F4 = function() {
  return bm(arguments);
}();
bm.isLegacyArguments = nA;
var rA = F4 ? bm : nA;
const R4 = {}, O4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: R4
}, Symbol.toStringTag, { value: "Module" })), I4 = /* @__PURE__ */ Bk(O4);
var g2 = typeof Map == "function" && Map.prototype, Bb = Object.getOwnPropertyDescriptor && g2 ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, eg = g2 && Bb && typeof Bb.get == "function" ? Bb.get : null, Iw = g2 && Map.prototype.forEach, m2 = typeof Set == "function" && Set.prototype, Mb = Object.getOwnPropertyDescriptor && m2 ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, tg = m2 && Mb && typeof Mb.get == "function" ? Mb.get : null, Bw = m2 && Set.prototype.forEach, B4 = typeof WeakMap == "function" && WeakMap.prototype, Zf = B4 ? WeakMap.prototype.has : null, M4 = typeof WeakSet == "function" && WeakSet.prototype, Kf = M4 ? WeakSet.prototype.has : null, N4 = typeof WeakRef == "function" && WeakRef.prototype, Mw = N4 ? WeakRef.prototype.deref : null, P4 = Boolean.prototype.valueOf, W4 = Object.prototype.toString, L4 = Function.prototype.toString, z4 = String.prototype.match, y2 = String.prototype.slice, Ha = String.prototype.replace, $4 = String.prototype.toUpperCase, Nw = String.prototype.toLowerCase, iA = RegExp.prototype.test, Pw = Array.prototype.concat, zi = Array.prototype.join, j4 = Array.prototype.slice, Ww = Math.floor, q1 = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, Nb = Object.getOwnPropertySymbols, X1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, iu = typeof Symbol == "function" && typeof Symbol.iterator == "object", An = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === iu || !0) ? Symbol.toStringTag : null, oA = Object.prototype.propertyIsEnumerable, Lw = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
  return t.__proto__;
} : null);
function zw(t, e) {
  if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || iA.call(/e/, e))
    return e;
  var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof t == "number") {
    var r = t < 0 ? -Ww(-t) : Ww(t);
    if (r !== t) {
      var i = String(r), o = y2.call(e, i.length + 1);
      return Ha.call(i, n, "$&_") + "." + Ha.call(Ha.call(o, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return Ha.call(e, n, "$&_");
}
var G1 = I4, $w = G1.custom, jw = sA($w) ? $w : null, H4 = function t(e, n, r, i) {
  var o = n || {};
  if (Ra(o, "quoteStyle") && o.quoteStyle !== "single" && o.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if (Ra(o, "maxStringLength") && (typeof o.maxStringLength == "number" ? o.maxStringLength < 0 && o.maxStringLength !== 1 / 0 : o.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var a = Ra(o, "customInspect") ? o.customInspect : !0;
  if (typeof a != "boolean" && a !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if (Ra(o, "indent") && o.indent !== null && o.indent !== "	" && !(parseInt(o.indent, 10) === o.indent && o.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if (Ra(o, "numericSeparator") && typeof o.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var s = o.numericSeparator;
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  if (typeof e == "boolean")
    return e ? "true" : "false";
  if (typeof e == "string")
    return cA(e, o);
  if (typeof e == "number") {
    if (e === 0)
      return 1 / 0 / e > 0 ? "0" : "-0";
    var l = String(e);
    return s ? zw(e, l) : l;
  }
  if (typeof e == "bigint") {
    var u = String(e) + "n";
    return s ? zw(e, u) : u;
  }
  var f = typeof o.depth > "u" ? 5 : o.depth;
  if (typeof r > "u" && (r = 0), r >= f && f > 0 && typeof e == "object")
    return J1(e) ? "[Array]" : "[Object]";
  var h = lB(o, r);
  if (typeof i > "u")
    i = [];
  else if (lA(i, e) >= 0)
    return "[Circular]";
  function p(ee, A, oe) {
    if (A && (i = j4.call(i), i.push(A)), oe) {
      var j = {
        depth: o.depth
      };
      return Ra(o, "quoteStyle") && (j.quoteStyle = o.quoteStyle), t(ee, j, r + 1, i);
    }
    return t(ee, o, r + 1, i);
  }
  if (typeof e == "function" && !Hw(e)) {
    var y = Q4(e), b = Vh(e, p);
    return "[Function" + (y ? ": " + y : " (anonymous)") + "]" + (b.length > 0 ? " { " + zi.call(b, ", ") + " }" : "");
  }
  if (sA(e)) {
    var x = iu ? Ha.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : X1.call(e);
    return typeof e == "object" && !iu ? Ff(x) : x;
  }
  if (oB(e)) {
    for (var v = "<" + Nw.call(String(e.nodeName)), D = e.attributes || [], S = 0; S < D.length; S++)
      v += " " + D[S].name + "=" + aA(V4(D[S].value), "double", o);
    return v += ">", e.childNodes && e.childNodes.length && (v += "..."), v += "</" + Nw.call(String(e.nodeName)) + ">", v;
  }
  if (J1(e)) {
    if (e.length === 0)
      return "[]";
    var E = Vh(e, p);
    return h && !sB(E) ? "[" + Y1(E, h) + "]" : "[ " + zi.call(E, ", ") + " ]";
  }
  if (X4(e)) {
    var I = Vh(e, p);
    return !("cause" in Error.prototype) && "cause" in e && !oA.call(e, "cause") ? "{ [" + String(e) + "] " + zi.call(Pw.call("[cause]: " + p(e.cause), I), ", ") + " }" : I.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + zi.call(I, ", ") + " }";
  }
  if (typeof e == "object" && a) {
    if (jw && typeof e[jw] == "function" && G1)
      return G1(e, { depth: f - r });
    if (a !== "symbol" && typeof e.inspect == "function")
      return e.inspect();
  }
  if (eB(e)) {
    var R = [];
    return Iw && Iw.call(e, function(ee, A) {
      R.push(p(A, e, !0) + " => " + p(ee, e));
    }), Vw("Map", eg.call(e), R, h);
  }
  if (rB(e)) {
    var O = [];
    return Bw && Bw.call(e, function(ee) {
      O.push(p(ee, e));
    }), Vw("Set", tg.call(e), O, h);
  }
  if (tB(e))
    return Pb("WeakMap");
  if (iB(e))
    return Pb("WeakSet");
  if (nB(e))
    return Pb("WeakRef");
  if (J4(e))
    return Ff(p(Number(e)));
  if (Z4(e))
    return Ff(p(q1.call(e)));
  if (Y4(e))
    return Ff(P4.call(e));
  if (G4(e))
    return Ff(p(String(e)));
  if (typeof window < "u" && e === window)
    return "{ [object Window] }";
  if (typeof globalThis < "u" && e === globalThis || typeof it < "u" && e === it)
    return "{ [object globalThis] }";
  if (!q4(e) && !Hw(e)) {
    var N = Vh(e, p), q = Lw ? Lw(e) === Object.prototype : e instanceof Object || e.constructor === Object, $ = e instanceof Object ? "" : "null prototype", le = !q && An && Object(e) === e && An in e ? y2.call(as(e), 8, -1) : $ ? "Object" : "", ve = q || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "", M = ve + (le || $ ? "[" + zi.call(Pw.call([], le || [], $ || []), ": ") + "] " : "");
    return N.length === 0 ? M + "{}" : h ? M + "{" + Y1(N, h) + "}" : M + "{ " + zi.call(N, ", ") + " }";
  }
  return String(e);
};
function aA(t, e, n) {
  var r = (n.quoteStyle || e) === "double" ? '"' : "'";
  return r + t + r;
}
function V4(t) {
  return Ha.call(String(t), /"/g, "&quot;");
}
function J1(t) {
  return as(t) === "[object Array]" && (!An || !(typeof t == "object" && An in t));
}
function q4(t) {
  return as(t) === "[object Date]" && (!An || !(typeof t == "object" && An in t));
}
function Hw(t) {
  return as(t) === "[object RegExp]" && (!An || !(typeof t == "object" && An in t));
}
function X4(t) {
  return as(t) === "[object Error]" && (!An || !(typeof t == "object" && An in t));
}
function G4(t) {
  return as(t) === "[object String]" && (!An || !(typeof t == "object" && An in t));
}
function J4(t) {
  return as(t) === "[object Number]" && (!An || !(typeof t == "object" && An in t));
}
function Y4(t) {
  return as(t) === "[object Boolean]" && (!An || !(typeof t == "object" && An in t));
}
function sA(t) {
  if (iu)
    return t && typeof t == "object" && t instanceof Symbol;
  if (typeof t == "symbol")
    return !0;
  if (!t || typeof t != "object" || !X1)
    return !1;
  try {
    return X1.call(t), !0;
  } catch {
  }
  return !1;
}
function Z4(t) {
  if (!t || typeof t != "object" || !q1)
    return !1;
  try {
    return q1.call(t), !0;
  } catch {
  }
  return !1;
}
var K4 = Object.prototype.hasOwnProperty || function(t) {
  return t in this;
};
function Ra(t, e) {
  return K4.call(t, e);
}
function as(t) {
  return W4.call(t);
}
function Q4(t) {
  if (t.name)
    return t.name;
  var e = z4.call(L4.call(t), /^function\s*([\w$]+)/);
  return e ? e[1] : null;
}
function lA(t, e) {
  if (t.indexOf)
    return t.indexOf(e);
  for (var n = 0, r = t.length; n < r; n++)
    if (t[n] === e)
      return n;
  return -1;
}
function eB(t) {
  if (!eg || !t || typeof t != "object")
    return !1;
  try {
    eg.call(t);
    try {
      tg.call(t);
    } catch {
      return !0;
    }
    return t instanceof Map;
  } catch {
  }
  return !1;
}
function tB(t) {
  if (!Zf || !t || typeof t != "object")
    return !1;
  try {
    Zf.call(t, Zf);
    try {
      Kf.call(t, Kf);
    } catch {
      return !0;
    }
    return t instanceof WeakMap;
  } catch {
  }
  return !1;
}
function nB(t) {
  if (!Mw || !t || typeof t != "object")
    return !1;
  try {
    return Mw.call(t), !0;
  } catch {
  }
  return !1;
}
function rB(t) {
  if (!tg || !t || typeof t != "object")
    return !1;
  try {
    tg.call(t);
    try {
      eg.call(t);
    } catch {
      return !0;
    }
    return t instanceof Set;
  } catch {
  }
  return !1;
}
function iB(t) {
  if (!Kf || !t || typeof t != "object")
    return !1;
  try {
    Kf.call(t, Kf);
    try {
      Zf.call(t, Zf);
    } catch {
      return !0;
    }
    return t instanceof WeakSet;
  } catch {
  }
  return !1;
}
function oB(t) {
  return !t || typeof t != "object" ? !1 : typeof HTMLElement < "u" && t instanceof HTMLElement ? !0 : typeof t.nodeName == "string" && typeof t.getAttribute == "function";
}
function cA(t, e) {
  if (t.length > e.maxStringLength) {
    var n = t.length - e.maxStringLength, r = "... " + n + " more character" + (n > 1 ? "s" : "");
    return cA(y2.call(t, 0, e.maxStringLength), e) + r;
  }
  var i = Ha.call(Ha.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, aB);
  return aA(i, "single", e);
}
function aB(t) {
  var e = t.charCodeAt(0), n = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[e];
  return n ? "\\" + n : "\\x" + (e < 16 ? "0" : "") + $4.call(e.toString(16));
}
function Ff(t) {
  return "Object(" + t + ")";
}
function Pb(t) {
  return t + " { ? }";
}
function Vw(t, e, n, r) {
  var i = r ? Y1(n, r) : zi.call(n, ", ");
  return t + " (" + e + ") {" + i + "}";
}
function sB(t) {
  for (var e = 0; e < t.length; e++)
    if (lA(t[e], `
`) >= 0)
      return !1;
  return !0;
}
function lB(t, e) {
  var n;
  if (t.indent === "	")
    n = "	";
  else if (typeof t.indent == "number" && t.indent > 0)
    n = zi.call(Array(t.indent + 1), " ");
  else
    return null;
  return {
    base: n,
    prev: zi.call(Array(e + 1), n)
  };
}
function Y1(t, e) {
  if (t.length === 0)
    return "";
  var n = `
` + e.prev + e.base;
  return n + zi.call(t, "," + n) + `
` + e.prev;
}
function Vh(t, e) {
  var n = J1(t), r = [];
  if (n) {
    r.length = t.length;
    for (var i = 0; i < t.length; i++)
      r[i] = Ra(t, i) ? e(t[i], t) : "";
  }
  var o = typeof Nb == "function" ? Nb(t) : [], a;
  if (iu) {
    a = {};
    for (var s = 0; s < o.length; s++)
      a["$" + o[s]] = o[s];
  }
  for (var l in t)
    Ra(t, l) && (n && String(Number(l)) === l && l < t.length || iu && a["$" + l] instanceof Symbol || (iA.call(/[^\w$]/, l) ? r.push(e(l, t) + ": " + e(t[l], t)) : r.push(l + ": " + e(t[l], t))));
  if (typeof Nb == "function")
    for (var u = 0; u < o.length; u++)
      oA.call(t, o[u]) && r.push("[" + e(o[u]) + "]: " + e(t[o[u]], t));
  return r;
}
var uA = Qi, Su = Kr, cB = H4, uB = is, qh = uA("%WeakMap%", !0), Xh = uA("%Map%", !0), fB = Su("WeakMap.prototype.get", !0), dB = Su("WeakMap.prototype.set", !0), hB = Su("WeakMap.prototype.has", !0), pB = Su("Map.prototype.get", !0), gB = Su("Map.prototype.set", !0), mB = Su("Map.prototype.has", !0), b2 = function(t, e) {
  for (var n = t, r; (r = n.next) !== null; n = r)
    if (r.key === e)
      return n.next = r.next, r.next = /** @type {NonNullable<typeof list.next>} */
      t.next, t.next = r, r;
}, yB = function(t, e) {
  var n = b2(t, e);
  return n && n.value;
}, bB = function(t, e, n) {
  var r = b2(t, e);
  r ? r.value = n : t.next = /** @type {import('.').ListNode<typeof value>} */
  {
    // eslint-disable-line no-param-reassign, no-extra-parens
    key: e,
    next: t.next,
    value: n
  };
}, vB = function(t, e) {
  return !!b2(t, e);
}, fA = function() {
  var e, n, r, i = {
    assert: function(o) {
      if (!i.has(o))
        throw new uB("Side channel does not contain " + cB(o));
    },
    get: function(o) {
      if (qh && o && (typeof o == "object" || typeof o == "function")) {
        if (e)
          return fB(e, o);
      } else if (Xh) {
        if (n)
          return pB(n, o);
      } else if (r)
        return yB(r, o);
    },
    has: function(o) {
      if (qh && o && (typeof o == "object" || typeof o == "function")) {
        if (e)
          return hB(e, o);
      } else if (Xh) {
        if (n)
          return mB(n, o);
      } else if (r)
        return vB(r, o);
      return !1;
    },
    set: function(o, a) {
      qh && o && (typeof o == "object" || typeof o == "function") ? (e || (e = new qh()), dB(e, o, a)) : Xh ? (n || (n = new Xh()), gB(n, o, a)) : (r || (r = { key: {}, next: null }), bB(r, o, a));
    }
  };
  return i;
}, xB = Pk, Rf = fA(), _o = is, v2 = {
  assert: function(t, e) {
    if (!t || typeof t != "object" && typeof t != "function")
      throw new _o("`O` is not an object");
    if (typeof e != "string")
      throw new _o("`slot` must be a string");
    if (Rf.assert(t), !v2.has(t, e))
      throw new _o("`" + e + "` is not present on `O`");
  },
  get: function(t, e) {
    if (!t || typeof t != "object" && typeof t != "function")
      throw new _o("`O` is not an object");
    if (typeof e != "string")
      throw new _o("`slot` must be a string");
    var n = Rf.get(t);
    return n && n["$" + e];
  },
  has: function(t, e) {
    if (!t || typeof t != "object" && typeof t != "function")
      throw new _o("`O` is not an object");
    if (typeof e != "string")
      throw new _o("`slot` must be a string");
    var n = Rf.get(t);
    return !!n && xB(n, "$" + e);
  },
  set: function(t, e, n) {
    if (!t || typeof t != "object" && typeof t != "function")
      throw new _o("`O` is not an object");
    if (typeof e != "string")
      throw new _o("`slot` must be a string");
    var r = Rf.get(t);
    r || (r = {}, Rf.set(t, r)), r["$" + e] = n;
  }
};
Object.freeze && Object.freeze(v2);
var DB = v2, Of = DB, wB = SyntaxError, qw = typeof StopIteration == "object" ? StopIteration : null, SB = function(e) {
  if (!qw)
    throw new wB("this environment lacks StopIteration");
  Of.set(e, "[[Done]]", !1);
  var n = {
    next: function() {
      var i = Of.get(this, "[[Iterator]]"), o = Of.get(i, "[[Done]]");
      try {
        return {
          done: o,
          value: o ? void 0 : i.next()
        };
      } catch (a) {
        if (Of.set(i, "[[Done]]", !0), a !== qw)
          throw a;
        return {
          done: !0,
          value: void 0
        };
      }
    }
  };
  return Of.set(n, "[[Iterator]]", e), n;
}, TB = {}.toString, dA = Array.isArray || function(t) {
  return TB.call(t) == "[object Array]";
}, CB = String.prototype.valueOf, EB = function(e) {
  try {
    return CB.call(e), !0;
  } catch {
    return !1;
  }
}, _B = Object.prototype.toString, kB = "[object String]", AB = Dl(), hA = function(e) {
  return typeof e == "string" ? !0 : typeof e != "object" ? !1 : AB ? EB(e) : _B.call(e) === kB;
}, x2 = typeof Map == "function" && Map.prototype ? Map : null, UB = typeof Set == "function" && Set.prototype ? Set : null, ng;
x2 || (ng = function(e) {
  return !1;
});
var pA = x2 ? Map.prototype.has : null, Xw = UB ? Set.prototype.has : null;
!ng && !pA && (ng = function(e) {
  return !1;
});
var gA = ng || function(e) {
  if (!e || typeof e != "object")
    return !1;
  try {
    if (pA.call(e), Xw)
      try {
        Xw.call(e);
      } catch {
        return !0;
      }
    return e instanceof x2;
  } catch {
  }
  return !1;
}, FB = typeof Map == "function" && Map.prototype ? Map : null, D2 = typeof Set == "function" && Set.prototype ? Set : null, rg;
D2 || (rg = function(e) {
  return !1;
});
var Gw = FB ? Map.prototype.has : null, mA = D2 ? Set.prototype.has : null;
!rg && !mA && (rg = function(e) {
  return !1;
});
var yA = rg || function(e) {
  if (!e || typeof e != "object")
    return !1;
  try {
    if (mA.call(e), Gw)
      try {
        Gw.call(e);
      } catch {
        return !0;
      }
    return e instanceof D2;
  } catch {
  }
  return !1;
}, Jw = rA, Yw = SB;
if (c2() || ym()) {
  var Wb = Symbol.iterator;
  Sp.exports = function(e) {
    if (e != null && typeof e[Wb] < "u")
      return e[Wb]();
    if (Jw(e))
      return Array.prototype[Wb].call(e);
  };
} else {
  var RB = dA, OB = hA, Zw = Qi, IB = Zw("%Map%", !0), BB = Zw("%Set%", !0), ui = Kr, Kw = ui("Array.prototype.push"), Qw = ui("String.prototype.charCodeAt"), MB = ui("String.prototype.slice"), NB = function(e, n) {
    var r = e.length;
    if (n + 1 >= r)
      return n + 1;
    var i = Qw(e, n);
    if (i < 55296 || i > 56319)
      return n + 1;
    var o = Qw(e, n + 1);
    return o < 56320 || o > 57343 ? n + 1 : n + 2;
  }, Lb = function(e) {
    var n = 0;
    return {
      next: function() {
        var i = n >= e.length, o;
        return i || (o = e[n], n += 1), {
          done: i,
          value: o
        };
      }
    };
  }, eS = function(e, n) {
    if (RB(e) || Jw(e))
      return Lb(e);
    if (OB(e)) {
      var r = 0;
      return {
        next: function() {
          var o = NB(e, r), a = MB(e, r, o);
          return r = o, {
            done: o > e.length,
            value: a
          };
        }
      };
    }
    if (n && typeof e["_es6-shim iterator_"] < "u")
      return e["_es6-shim iterator_"]();
  };
  if (!IB && !BB)
    Sp.exports = function(e) {
      if (e != null)
        return eS(e, !0);
    };
  else {
    var PB = gA, WB = yA, tS = ui("Map.prototype.forEach", !0), nS = ui("Set.prototype.forEach", !0);
    if (typeof process > "u" || !process.versions || !process.versions.node)
      var rS = ui("Map.prototype.iterator", !0), iS = ui("Set.prototype.iterator", !0);
    var oS = ui("Map.prototype.@@iterator", !0) || ui("Map.prototype._es6-shim iterator_", !0), aS = ui("Set.prototype.@@iterator", !0) || ui("Set.prototype._es6-shim iterator_", !0), LB = function(e) {
      if (PB(e)) {
        if (rS)
          return Yw(rS(e));
        if (oS)
          return oS(e);
        if (tS) {
          var n = [];
          return tS(e, function(i, o) {
            Kw(n, [o, i]);
          }), Lb(n);
        }
      }
      if (WB(e)) {
        if (iS)
          return Yw(iS(e));
        if (aS)
          return aS(e);
        if (nS) {
          var r = [];
          return nS(e, function(i) {
            Kw(r, i);
          }), Lb(r);
        }
      }
    };
    Sp.exports = function(e) {
      return LB(e) || eS(e);
    };
  }
}
var zB = Sp.exports, sS = function(t) {
  return t !== t;
}, bA = function(e, n) {
  return e === 0 && n === 0 ? 1 / e === 1 / n : !!(e === n || sS(e) && sS(n));
}, $B = bA, vA = function() {
  return typeof Object.is == "function" ? Object.is : $B;
}, jB = vA, HB = xl, VB = function() {
  var e = jB();
  return HB(Object, { is: e }, {
    is: function() {
      return Object.is !== e;
    }
  }), e;
}, qB = xl, XB = wu, GB = bA, xA = vA, JB = VB, DA = XB(xA(), Object);
qB(DA, {
  getPolyfill: xA,
  implementation: GB,
  shim: JB
});
var YB = DA, ZB = wu, wA = Kr, KB = Qi, Z1 = KB("%ArrayBuffer%", !0), Tp = wA("ArrayBuffer.prototype.byteLength", !0), QB = wA("Object.prototype.toString"), lS = !!Z1 && !Tp && new Z1(0).slice, cS = !!lS && ZB(lS), SA = Tp || cS ? function(e) {
  if (!e || typeof e != "object")
    return !1;
  try {
    return Tp ? Tp(e) : cS(e, 0), !0;
  } catch {
    return !1;
  }
} : Z1 ? function(e) {
  return QB(e) === "[object ArrayBuffer]";
} : function(e) {
  return !1;
}, e9 = Date.prototype.getDay, t9 = function(e) {
  try {
    return e9.call(e), !0;
  } catch {
    return !1;
  }
}, n9 = Object.prototype.toString, r9 = "[object Date]", i9 = Dl(), o9 = function(e) {
  return typeof e != "object" || e === null ? !1 : i9 ? t9(e) : n9.call(e) === r9;
}, K1 = Kr, TA = Dl(), CA, EA, Q1, e0;
if (TA) {
  CA = K1("Object.prototype.hasOwnProperty"), EA = K1("RegExp.prototype.exec"), Q1 = {};
  var zb = function() {
    throw Q1;
  };
  e0 = {
    toString: zb,
    valueOf: zb
  }, typeof Symbol.toPrimitive == "symbol" && (e0[Symbol.toPrimitive] = zb);
}
var a9 = K1("Object.prototype.toString"), s9 = Object.getOwnPropertyDescriptor, l9 = "[object RegExp]", c9 = TA ? function(e) {
  if (!e || typeof e != "object")
    return !1;
  var n = s9(e, "lastIndex"), r = n && CA(n, "value");
  if (!r)
    return !1;
  try {
    EA(e, e0);
  } catch (i) {
    return i === Q1;
  }
} : function(e) {
  return !e || typeof e != "object" && typeof e != "function" ? !1 : a9(e) === l9;
}, u9 = Kr, uS = u9("SharedArrayBuffer.prototype.byteLength", !0), f9 = uS ? function(e) {
  if (!e || typeof e != "object")
    return !1;
  try {
    return uS(e), !0;
  } catch {
    return !1;
  }
} : function(e) {
  return !1;
}, d9 = Number.prototype.toString, h9 = function(e) {
  try {
    return d9.call(e), !0;
  } catch {
    return !1;
  }
}, p9 = Object.prototype.toString, g9 = "[object Number]", m9 = Dl(), y9 = function(e) {
  return typeof e == "number" ? !0 : typeof e != "object" ? !1 : m9 ? h9(e) : p9.call(e) === g9;
}, _A = Kr, b9 = _A("Boolean.prototype.toString"), v9 = _A("Object.prototype.toString"), x9 = function(e) {
  try {
    return b9(e), !0;
  } catch {
    return !1;
  }
}, D9 = "[object Boolean]", w9 = Dl(), S9 = function(e) {
  return typeof e == "boolean" ? !0 : e === null || typeof e != "object" ? !1 : w9 && Symbol.toStringTag in e ? x9(e) : v9(e) === D9;
}, t0 = { exports: {} }, T9 = Object.prototype.toString, C9 = c2();
if (C9) {
  var E9 = Symbol.prototype.toString, _9 = /^Symbol\(.*\)$/, k9 = function(e) {
    return typeof e.valueOf() != "symbol" ? !1 : _9.test(E9.call(e));
  };
  t0.exports = function(e) {
    if (typeof e == "symbol")
      return !0;
    if (T9.call(e) !== "[object Symbol]")
      return !1;
    try {
      return k9(e);
    } catch {
      return !1;
    }
  };
} else
  t0.exports = function(e) {
    return !1;
  };
var A9 = t0.exports, n0 = { exports: {} }, fS = typeof BigInt < "u" && BigInt, U9 = function() {
  return typeof fS == "function" && typeof BigInt == "function" && typeof fS(42) == "bigint" && typeof BigInt(42) == "bigint";
}, F9 = U9();
if (F9) {
  var R9 = BigInt.prototype.valueOf, O9 = function(e) {
    try {
      return R9.call(e), !0;
    } catch {
    }
    return !1;
  };
  n0.exports = function(e) {
    return e === null || typeof e > "u" || typeof e == "boolean" || typeof e == "string" || typeof e == "number" || typeof e == "symbol" || typeof e == "function" ? !1 : typeof e == "bigint" ? !0 : O9(e);
  };
} else
  n0.exports = function(e) {
    return !1;
  };
var I9 = n0.exports, B9 = hA, M9 = y9, N9 = S9, P9 = A9, W9 = I9, L9 = function(e) {
  if (e == null || typeof e != "object" && typeof e != "function")
    return null;
  if (B9(e))
    return "String";
  if (M9(e))
    return "Number";
  if (N9(e))
    return "Boolean";
  if (P9(e))
    return "Symbol";
  if (W9(e))
    return "BigInt";
}, ig = typeof WeakMap == "function" && WeakMap.prototype ? WeakMap : null, dS = typeof WeakSet == "function" && WeakSet.prototype ? WeakSet : null, og;
ig || (og = function(e) {
  return !1;
});
var r0 = ig ? ig.prototype.has : null, $b = dS ? dS.prototype.has : null;
!og && !r0 && (og = function(e) {
  return !1;
});
var z9 = og || function(e) {
  if (!e || typeof e != "object")
    return !1;
  try {
    if (r0.call(e, r0), $b)
      try {
        $b.call(e, $b);
      } catch {
        return !0;
      }
    return e instanceof ig;
  } catch {
  }
  return !1;
}, i0 = { exports: {} }, $9 = Qi, kA = Kr, j9 = $9("%WeakSet%", !0), jb = kA("WeakSet.prototype.has", !0);
if (jb) {
  var Hb = kA("WeakMap.prototype.has", !0);
  i0.exports = function(e) {
    if (!e || typeof e != "object")
      return !1;
    try {
      if (jb(e, jb), Hb)
        try {
          Hb(e, Hb);
        } catch {
          return !0;
        }
      return e instanceof j9;
    } catch {
    }
    return !1;
  };
} else
  i0.exports = function(e) {
    return !1;
  };
var H9 = i0.exports, V9 = gA, q9 = yA, X9 = z9, G9 = H9, J9 = function(e) {
  if (e && typeof e == "object") {
    if (V9(e))
      return "Map";
    if (q9(e))
      return "Set";
    if (X9(e))
      return "WeakMap";
    if (G9(e))
      return "WeakSet";
  }
  return !1;
}, AA = Function.prototype.toString, Lc = typeof Reflect == "object" && Reflect !== null && Reflect.apply, o0, Cp;
if (typeof Lc == "function" && typeof Object.defineProperty == "function")
  try {
    o0 = Object.defineProperty({}, "length", {
      get: function() {
        throw Cp;
      }
    }), Cp = {}, Lc(function() {
      throw 42;
    }, null, o0);
  } catch (t) {
    t !== Cp && (Lc = null);
  }
else
  Lc = null;
var Y9 = /^\s*class\b/, a0 = function(e) {
  try {
    var n = AA.call(e);
    return Y9.test(n);
  } catch {
    return !1;
  }
}, Vb = function(e) {
  try {
    return a0(e) ? !1 : (AA.call(e), !0);
  } catch {
    return !1;
  }
}, Ep = Object.prototype.toString, Z9 = "[object Object]", K9 = "[object Function]", Q9 = "[object GeneratorFunction]", eM = "[object HTMLAllCollection]", tM = "[object HTML document.all class]", nM = "[object HTMLCollection]", rM = typeof Symbol == "function" && !!Symbol.toStringTag, iM = !(0 in [,]), s0 = function() {
  return !1;
};
if (typeof document == "object") {
  var oM = document.all;
  Ep.call(oM) === Ep.call(document.all) && (s0 = function(e) {
    if ((iM || !e) && (typeof e > "u" || typeof e == "object"))
      try {
        var n = Ep.call(e);
        return (n === eM || n === tM || n === nM || n === Z9) && e("") == null;
      } catch {
      }
    return !1;
  });
}
var aM = Lc ? function(e) {
  if (s0(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  try {
    Lc(e, null, o0);
  } catch (n) {
    if (n !== Cp)
      return !1;
  }
  return !a0(e) && Vb(e);
} : function(e) {
  if (s0(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  if (rM)
    return Vb(e);
  if (a0(e))
    return !1;
  var n = Ep.call(e);
  return n !== K9 && n !== Q9 && !/^\[object HTML/.test(n) ? !1 : Vb(e);
}, sM = aM, lM = Object.prototype.toString, UA = Object.prototype.hasOwnProperty, cM = function(e, n, r) {
  for (var i = 0, o = e.length; i < o; i++)
    UA.call(e, i) && (r == null ? n(e[i], i, e) : n.call(r, e[i], i, e));
}, uM = function(e, n, r) {
  for (var i = 0, o = e.length; i < o; i++)
    r == null ? n(e.charAt(i), i, e) : n.call(r, e.charAt(i), i, e);
}, fM = function(e, n, r) {
  for (var i in e)
    UA.call(e, i) && (r == null ? n(e[i], i, e) : n.call(r, e[i], i, e));
}, dM = function(e, n, r) {
  if (!sM(n))
    throw new TypeError("iterator must be a function");
  var i;
  arguments.length >= 3 && (i = r), lM.call(e) === "[object Array]" ? cM(e, n, i) : typeof e == "string" ? uM(e, n, i) : fM(e, n, i);
}, hM = dM, pM = [
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], qb = pM, gM = typeof globalThis > "u" ? it : globalThis, mM = function() {
  for (var e = [], n = 0; n < qb.length; n++)
    typeof gM[qb[n]] == "function" && (e[e.length] = qb[n]);
  return e;
}, ag = hM, yM = mM, hS = wu, w2 = Kr, _p = d2, bM = w2("Object.prototype.toString"), FA = Dl(), pS = typeof globalThis > "u" ? it : globalThis, l0 = yM(), S2 = w2("String.prototype.slice"), Xb = Object.getPrototypeOf, vM = w2("Array.prototype.indexOf", !0) || function(e, n) {
  for (var r = 0; r < e.length; r += 1)
    if (e[r] === n)
      return r;
  return -1;
}, sg = { __proto__: null };
FA && _p && Xb ? ag(l0, function(t) {
  var e = new pS[t]();
  if (Symbol.toStringTag in e) {
    var n = Xb(e), r = _p(n, Symbol.toStringTag);
    if (!r) {
      var i = Xb(n);
      r = _p(i, Symbol.toStringTag);
    }
    sg["$" + t] = hS(r.get);
  }
}) : ag(l0, function(t) {
  var e = new pS[t](), n = e.slice || e.set;
  n && (sg["$" + t] = hS(n));
});
var xM = function(e) {
  var n = !1;
  return ag(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    sg,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(r, i) {
      if (!n)
        try {
          "$" + r(e) === i && (n = S2(i, 1));
        } catch {
        }
    }
  ), n;
}, DM = function(e) {
  var n = !1;
  return ag(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    sg,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(r, i) {
      if (!n)
        try {
          r(e), n = S2(i, 1);
        } catch {
        }
    }
  ), n;
}, wM = function(e) {
  if (!e || typeof e != "object")
    return !1;
  if (!FA) {
    var n = S2(bM(e), 8, -1);
    return vM(l0, n) > -1 ? n : n !== "Object" ? !1 : DM(e);
  }
  return _p ? xM(e) : null;
}, SM = Kr, gS = SM("ArrayBuffer.prototype.byteLength", !0), TM = SA, CM = function(e) {
  return TM(e) ? gS ? gS(e) : e.byteLength : NaN;
}, RA = r4, eo = Kr, mS = _4, EM = Qi, ou = zB, _M = fA, yS = YB, bS = rA, vS = dA, xS = SA, DS = o9, wS = c9, SS = f9, TS = l2, CS = L9, ES = J9, _S = wM, kS = CM, AS = eo("SharedArrayBuffer.prototype.byteLength", !0), US = eo("Date.prototype.getTime"), Gb = Object.getPrototypeOf, FS = eo("Object.prototype.toString"), lg = EM("%Set%", !0), c0 = eo("Map.prototype.has", !0), cg = eo("Map.prototype.get", !0), RS = eo("Map.prototype.size", !0), ug = eo("Set.prototype.add", !0), OA = eo("Set.prototype.delete", !0), fg = eo("Set.prototype.has", !0), kp = eo("Set.prototype.size", !0);
function OS(t, e, n, r) {
  for (var i = ou(t), o; (o = i.next()) && !o.done; )
    if (hi(e, o.value, n, r))
      return OA(t, o.value), !0;
  return !1;
}
function IA(t) {
  if (typeof t > "u")
    return null;
  if (typeof t != "object")
    return typeof t == "symbol" ? !1 : typeof t == "string" || typeof t == "number" ? +t == +t : !0;
}
function kM(t, e, n, r, i, o) {
  var a = IA(n);
  if (a != null)
    return a;
  var s = cg(e, a), l = RA({}, i, { strict: !1 });
  return typeof s > "u" && !c0(e, a) || !hi(r, s, l, o) ? !1 : !c0(t, a) && hi(r, s, l, o);
}
function AM(t, e, n) {
  var r = IA(n);
  return r ?? (fg(e, r) && !fg(t, r));
}
function IS(t, e, n, r, i, o) {
  for (var a = ou(t), s, l; (s = a.next()) && !s.done; )
    if (l = s.value, // eslint-disable-next-line no-use-before-define
    hi(n, l, i, o) && hi(r, cg(e, l), i, o))
      return OA(t, l), !0;
  return !1;
}
function hi(t, e, n, r) {
  var i = n || {};
  if (i.strict ? yS(t, e) : t === e)
    return !0;
  var o = CS(t), a = CS(e);
  if (o !== a)
    return !1;
  if (!t || !e || typeof t != "object" && typeof e != "object")
    return i.strict ? yS(t, e) : t == e;
  var s = r.has(t), l = r.has(e), u;
  if (s && l) {
    if (r.get(t) === r.get(e))
      return !0;
  } else
    u = {};
  return s || r.set(t, u), l || r.set(e, u), RM(t, e, i, r);
}
function BS(t) {
  return !t || typeof t != "object" || typeof t.length != "number" || typeof t.copy != "function" || typeof t.slice != "function" || t.length > 0 && typeof t[0] != "number" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t));
}
function UM(t, e, n, r) {
  if (kp(t) !== kp(e))
    return !1;
  for (var i = ou(t), o = ou(e), a, s, l; (a = i.next()) && !a.done; )
    if (a.value && typeof a.value == "object")
      l || (l = new lg()), ug(l, a.value);
    else if (!fg(e, a.value)) {
      if (n.strict || !AM(t, e, a.value))
        return !1;
      l || (l = new lg()), ug(l, a.value);
    }
  if (l) {
    for (; (s = o.next()) && !s.done; )
      if (s.value && typeof s.value == "object") {
        if (!OS(l, s.value, n.strict, r))
          return !1;
      } else if (!n.strict && !fg(t, s.value) && !OS(l, s.value, n.strict, r))
        return !1;
    return kp(l) === 0;
  }
  return !0;
}
function FM(t, e, n, r) {
  if (RS(t) !== RS(e))
    return !1;
  for (var i = ou(t), o = ou(e), a, s, l, u, f, h; (a = i.next()) && !a.done; )
    if (u = a.value[0], f = a.value[1], u && typeof u == "object")
      l || (l = new lg()), ug(l, u);
    else if (h = cg(e, u), typeof h > "u" && !c0(e, u) || !hi(f, h, n, r)) {
      if (n.strict || !kM(t, e, u, f, n, r))
        return !1;
      l || (l = new lg()), ug(l, u);
    }
  if (l) {
    for (; (s = o.next()) && !s.done; )
      if (u = s.value[0], h = s.value[1], u && typeof u == "object") {
        if (!IS(l, t, u, h, n, r))
          return !1;
      } else if (!n.strict && (!t.has(u) || !hi(cg(t, u), h, n, r)) && !IS(l, t, u, h, RA({}, n, { strict: !1 }), r))
        return !1;
    return kp(l) === 0;
  }
  return !0;
}
function RM(t, e, n, r) {
  var i, o;
  if (typeof t != typeof e || t == null || e == null || FS(t) !== FS(e) || bS(t) !== bS(e))
    return !1;
  var a = vS(t), s = vS(e);
  if (a !== s)
    return !1;
  var l = t instanceof Error, u = e instanceof Error;
  if (l !== u || (l || u) && (t.name !== e.name || t.message !== e.message))
    return !1;
  var f = wS(t), h = wS(e);
  if (f !== h || (f || h) && (t.source !== e.source || mS(t) !== mS(e)))
    return !1;
  var p = DS(t), y = DS(e);
  if (p !== y || (p || y) && US(t) !== US(e) || n.strict && Gb && Gb(t) !== Gb(e))
    return !1;
  var b = _S(t), x = _S(e);
  if (b !== x)
    return !1;
  if (b || x) {
    if (t.length !== e.length)
      return !1;
    for (i = 0; i < t.length; i++)
      if (t[i] !== e[i])
        return !1;
    return !0;
  }
  var v = BS(t), D = BS(e);
  if (v !== D)
    return !1;
  if (v || D) {
    if (t.length !== e.length)
      return !1;
    for (i = 0; i < t.length; i++)
      if (t[i] !== e[i])
        return !1;
    return !0;
  }
  var S = xS(t), E = xS(e);
  if (S !== E)
    return !1;
  if (S || E)
    return kS(t) !== kS(e) ? !1 : typeof Uint8Array == "function" && hi(new Uint8Array(t), new Uint8Array(e), n, r);
  var I = SS(t), R = SS(e);
  if (I !== R)
    return !1;
  if (I || R)
    return AS(t) !== AS(e) ? !1 : typeof Uint8Array == "function" && hi(new Uint8Array(t), new Uint8Array(e), n, r);
  if (typeof t != typeof e)
    return !1;
  var O = TS(t), N = TS(e);
  if (O.length !== N.length)
    return !1;
  for (O.sort(), N.sort(), i = O.length - 1; i >= 0; i--)
    if (O[i] != N[i])
      return !1;
  for (i = O.length - 1; i >= 0; i--)
    if (o = O[i], !hi(t[o], e[o], n, r))
      return !1;
  var q = ES(t), $ = ES(e);
  return q !== $ ? !1 : q === "Set" || $ === "Set" ? UM(t, e, n, r) : q === "Map" ? FM(t, e, n, r) : !0;
}
var OM = function(e, n, r) {
  return hi(e, n, r, _M());
};
const bJ = /* @__PURE__ */ HI(OM), MS = (t) => typeof t == "boolean" ? `${t}` : t === 0 ? "0" : t, NS = dI, vJ = (t, e) => (n) => {
  var r;
  if ((e == null ? void 0 : e.variants) == null) return NS(t, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
  const { variants: i, defaultVariants: o } = e, a = Object.keys(i).map((u) => {
    const f = n == null ? void 0 : n[u], h = o == null ? void 0 : o[u];
    if (f === null) return null;
    const p = MS(f) || MS(h);
    return i[u][p];
  }), s = n && Object.entries(n).reduce((u, f) => {
    let [h, p] = f;
    return p === void 0 || (u[h] = p), u;
  }, {}), l = e == null || (r = e.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((u, f) => {
    let { class: h, className: p, ...y } = f;
    return Object.entries(y).every((b) => {
      let [x, v] = b;
      return Array.isArray(v) ? v.includes({
        ...o,
        ...s
      }[x]) : {
        ...o,
        ...s
      }[x] === v;
    }) ? [
      ...u,
      h,
      p
    ] : u;
  }, []);
  return NS(t, a, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
};
var Hf, Ap, Qf;
function IM() {
  for (; Hf !== void 0; ) {
    const t = Hf, e = t.nextNotify;
    e !== void 0 ? (t.nextNotify = void 0, Hf = e) : (Hf = void 0, Ap = void 0), t.notify();
  }
}
function BA(t, e) {
  const n = e.depsTail, r = n !== void 0 ? n.nextDep : e.deps;
  return r !== void 0 && r.dep === t ? (e.depsTail = r, r) : BM(t, e, r, n);
}
function BM(t, e, n, r) {
  let i;
  if (Qf !== void 0 ? (i = Qf, Qf = i.nextDep, i.nextDep = n, i.dep = t, i.sub = e) : i = {
    dep: t,
    sub: e,
    nextDep: n,
    prevSub: void 0,
    nextSub: void 0
  }, r === void 0 ? e.deps = i : r.nextDep = i, t.subs === void 0)
    t.subs = i;
  else {
    const o = t.subsTail;
    i.prevSub = o, o.nextSub = i;
  }
  return e.depsTail = i, t.subsTail = i, i;
}
function MM(t) {
  let e = 16, n = t, r = 0, i;
  e: do {
    const o = n.sub, a = o.flags;
    if (a & 1) {
      if (NM(n, o))
        if (a & 28)
          a & e || (o.flags = a | e);
        else {
          o.flags = a | e | 2;
          const s = o.subs;
          if (s !== void 0) {
            s.nextSub !== void 0 ? (s.prevSub = t, n = t = s, e = 8, ++r) : (n = s, e = "notify" in o ? 4 : 8);
            continue;
          }
        }
    } else if (!(a & 28) && (o.flags = a | e, !0) || a & 2 && (o.flags = a & -3 | e, !0)) {
      const s = o.subs;
      if (s !== void 0) {
        s.nextSub !== void 0 ? (s.prevSub = t, n = t = s, e = 8, ++r) : (n = s, e = "notify" in o ? 4 : 8);
        continue;
      }
      "notify" in o && (Ap !== void 0 ? Ap.nextNotify = o : Hf = o, Ap = o);
    } else a & e || (o.flags = a | e);
    if ((i = t.nextSub) === void 0) {
      if (r) {
        let s = t.dep;
        do {
          --r;
          const l = s.subs, u = l.prevSub;
          if (l.prevSub = void 0, n = t = u.nextSub, t !== void 0) {
            e = r ? 8 : 16;
            continue e;
          }
          s = u.dep;
        } while (r);
      }
      break;
    }
    n !== t && (e = r ? 8 : 16), n = t = i;
  } while (!0);
  IM();
}
function PS(t) {
  do {
    const e = t.sub, n = e.flags;
    (n & 24) === 8 && (e.flags = n | 16), t = t.nextSub;
  } while (t !== void 0);
}
function NM(t, e) {
  const n = e.depsTail;
  if (n !== void 0) {
    let r = e.deps;
    do {
      if (r === t)
        return !0;
      if (r === n)
        break;
      r = r.nextDep;
    } while (r !== void 0);
  }
  return !1;
}
function PM(t) {
  let e = 0, n, r;
  e: do {
    n = !1;
    const i = t.dep;
    if ("update" in i) {
      const o = i.flags;
      if (o & 16) {
        if (i.update()) {
          const a = i.subs;
          a.nextSub !== void 0 && PS(a), n = !0;
        }
      } else if (o & 8) {
        const a = i.subs;
        a.nextSub !== void 0 && (a.prevSub = t), t = i.deps, ++e;
        continue;
      }
    }
    if (n || (r = t.nextDep) === void 0) {
      if (e) {
        let o = t.sub;
        do {
          --e;
          const a = o.subs;
          let s = a.prevSub;
          if (s !== void 0)
            if (a.prevSub = void 0, n) {
              if (o.update()) {
                PS(o.subs), o = s.sub;
                continue;
              }
            } else
              o.flags &= -9;
          else {
            if (n) {
              if (o.update()) {
                o = a.sub;
                continue;
              }
            } else
              o.flags &= -9;
            s = a;
          }
          if (t = s.nextDep, t !== void 0)
            continue e;
          o = s.sub, n = !1;
        } while (e);
      }
      return n;
    }
    t = r;
  } while (!0);
}
function WS(t) {
  t.depsTail = void 0, t.flags = 1;
}
function LS(t) {
  const e = t.depsTail;
  e !== void 0 ? e.nextDep !== void 0 && (zS(e.nextDep), e.nextDep = void 0) : t.deps !== void 0 && (zS(t.deps), t.deps = void 0), t.flags &= -2;
}
function zS(t) {
  do {
    const e = t.dep, n = t.nextDep, r = t.nextSub, i = t.prevSub;
    if (r !== void 0 ? (r.prevSub = i, t.nextSub = void 0) : (e.subsTail = i, "lastTrackedId" in e && (e.lastTrackedId = 0)), i !== void 0 ? (i.nextSub = r, t.prevSub = void 0) : e.subs = r, t.dep = void 0, t.sub = void 0, t.nextDep = Qf, Qf = t, e.subs === void 0 && "deps" in e) {
      if ("notify" in e)
        e.flags = 0;
      else {
        const a = e.flags;
        a & 16 || (e.flags = a | 16);
      }
      const o = e.deps;
      if (o !== void 0) {
        t = o, e.depsTail.nextDep = n, e.deps = void 0, e.depsTail = void 0;
        continue;
      }
    }
    t = n;
  } while (t !== void 0);
}
var dg, Gc = 0, WM = 0;
function $S(t, e) {
  dg = t, Gc = e;
}
function LM() {
  return ++WM;
}
function MA(t) {
  const e = new zM(t);
  return e.run(), e;
}
var zM = class {
  constructor(t) {
    this.fn = t, this.nextNotify = void 0, this.subs = void 0, this.subsTail = void 0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, Gc && BA(this, dg);
  }
  notify() {
    let t = this.flags;
    if (t & 16) {
      this.run();
      return;
    }
    if (t & 8)
      if (PM(this.deps)) {
        this.run();
        return;
      } else
        this.flags = t &= -9;
    if (t & 4) {
      this.flags = t & -5;
      let e = this.deps;
      do {
        const n = e.dep;
        "notify" in n && n.notify(), e = e.nextDep;
      } while (e !== void 0);
    }
  }
  run() {
    const t = dg, e = Gc;
    $S(this, LM()), WS(this);
    try {
      return this.fn();
    } finally {
      $S(t, e), LS(this);
    }
  }
  stop() {
    WS(this), LS(this);
  }
};
function $M(t) {
  return new jM(t);
}
var jM = class {
  constructor(t) {
    this.currentValue = t, this.subs = void 0, this.subsTail = void 0, this.lastTrackedId = 0;
  }
  get() {
    return Gc && this.lastTrackedId !== Gc && (this.lastTrackedId = Gc, BA(this, dg)), this.currentValue;
  }
  set(t) {
    if (this.currentValue !== (this.currentValue = t)) {
      const e = this.subs;
      e !== void 0 && MM(e);
    }
  }
};
function xJ(t) {
  return $M(t);
}
function DJ(t) {
  return [r_((e) => {
    let n = MA(() => {
      t.get(), e();
    });
    return () => n.stop();
  }, () => t.get(), () => t.get()), (e) => {
    typeof e == "function" ? t.set(e(t.get())) : t.set(e);
  }];
}
function wJ(t) {
  return r_((e) => {
    let n = MA(() => {
      t.get(), e();
    });
    return () => n.stop();
  }, () => t.get(), () => t.get());
}
var NA = typeof global == "object" && global && global.Object === Object && global, HM = typeof self == "object" && self && self.Object === Object && self, to = NA || HM || Function("return this")(), Yi = to.Symbol, PA = Object.prototype, VM = PA.hasOwnProperty, qM = PA.toString, If = Yi ? Yi.toStringTag : void 0;
function XM(t) {
  var e = VM.call(t, If), n = t[If];
  try {
    t[If] = void 0;
    var r = !0;
  } catch {
  }
  var i = qM.call(t);
  return r && (e ? t[If] = n : delete t[If]), i;
}
var GM = Object.prototype, JM = GM.toString;
function YM(t) {
  return JM.call(t);
}
var ZM = "[object Null]", KM = "[object Undefined]", jS = Yi ? Yi.toStringTag : void 0;
function ss(t) {
  return t == null ? t === void 0 ? KM : ZM : jS && jS in Object(t) ? XM(t) : YM(t);
}
function Lo(t) {
  return t != null && typeof t == "object";
}
var QM = "[object Symbol]";
function vm(t) {
  return typeof t == "symbol" || Lo(t) && ss(t) == QM;
}
function WA(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length, i = Array(r); ++n < r; )
    i[n] = e(t[n], n, t);
  return i;
}
var Zi = Array.isArray, eN = 1 / 0, HS = Yi ? Yi.prototype : void 0, VS = HS ? HS.toString : void 0;
function hg(t) {
  if (typeof t == "string")
    return t;
  if (Zi(t))
    return WA(t, hg) + "";
  if (vm(t))
    return VS ? VS.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -eN ? "-0" : e;
}
var tN = /\s/;
function nN(t) {
  for (var e = t.length; e-- && tN.test(t.charAt(e)); )
    ;
  return e;
}
var rN = /^\s+/;
function iN(t) {
  return t && t.slice(0, nN(t) + 1).replace(rN, "");
}
function Za(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var qS = NaN, oN = /^[-+]0x[0-9a-f]+$/i, aN = /^0b[01]+$/i, sN = /^0o[0-7]+$/i, lN = parseInt;
function Jc(t) {
  if (typeof t == "number")
    return t;
  if (vm(t))
    return qS;
  if (Za(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Za(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = iN(t);
  var n = aN.test(t);
  return n || sN.test(t) ? lN(t.slice(2), n ? 2 : 8) : oN.test(t) ? qS : +t;
}
var XS = 1 / 0, cN = 17976931348623157e292;
function uN(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = Jc(t), t === XS || t === -XS) {
    var e = t < 0 ? -1 : 1;
    return e * cN;
  }
  return t === t ? t : 0;
}
function fN(t) {
  var e = uN(t), n = e % 1;
  return e === e ? n ? e - n : e : 0;
}
function T2(t) {
  return t;
}
var dN = "[object AsyncFunction]", hN = "[object Function]", pN = "[object GeneratorFunction]", gN = "[object Proxy]";
function LA(t) {
  if (!Za(t))
    return !1;
  var e = ss(t);
  return e == hN || e == pN || e == dN || e == gN;
}
var Jb = to["__core-js_shared__"], GS = function() {
  var t = /[^.]+$/.exec(Jb && Jb.keys && Jb.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function mN(t) {
  return !!GS && GS in t;
}
var yN = Function.prototype, bN = yN.toString;
function wl(t) {
  if (t != null) {
    try {
      return bN.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var vN = /[\\^$.*+?()[\]{}|]/g, xN = /^\[object .+?Constructor\]$/, DN = Function.prototype, wN = Object.prototype, SN = DN.toString, TN = wN.hasOwnProperty, CN = RegExp(
  "^" + SN.call(TN).replace(vN, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function EN(t) {
  if (!Za(t) || mN(t))
    return !1;
  var e = LA(t) ? CN : xN;
  return e.test(wl(t));
}
function _N(t, e) {
  return t == null ? void 0 : t[e];
}
function Sl(t, e) {
  var n = _N(t, e);
  return EN(n) ? n : void 0;
}
var u0 = Sl(to, "WeakMap");
function kN(t, e, n) {
  switch (n.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, n[0]);
    case 2:
      return t.call(e, n[0], n[1]);
    case 3:
      return t.call(e, n[0], n[1], n[2]);
  }
  return t.apply(e, n);
}
var AN = 800, UN = 16, FN = Date.now;
function RN(t) {
  var e = 0, n = 0;
  return function() {
    var r = FN(), i = UN - (r - n);
    if (n = r, i > 0) {
      if (++e >= AN)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
function ON(t) {
  return function() {
    return t;
  };
}
var JS = function() {
  try {
    var t = Sl(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}(), IN = JS ? function(t, e) {
  return JS(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: ON(e),
    writable: !0
  });
} : T2, BN = RN(IN);
function MN(t, e, n, r) {
  for (var i = t.length, o = n + -1; ++o < i; )
    if (e(t[o], o, t))
      return o;
  return -1;
}
function NN(t) {
  return t !== t;
}
function PN(t, e, n) {
  for (var r = n - 1, i = t.length; ++r < i; )
    if (t[r] === e)
      return r;
  return -1;
}
function WN(t, e, n) {
  return e === e ? PN(t, e, n) : MN(t, NN, n);
}
function LN(t, e) {
  var n = t == null ? 0 : t.length;
  return !!n && WN(t, e, 0) > -1;
}
var zN = 9007199254740991, $N = /^(?:0|[1-9]\d*)$/;
function zA(t, e) {
  var n = typeof t;
  return e = e ?? zN, !!e && (n == "number" || n != "symbol" && $N.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function $A(t, e) {
  return t === e || t !== t && e !== e;
}
var YS = Math.max;
function jN(t, e, n) {
  return e = YS(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var r = arguments, i = -1, o = YS(r.length - e, 0), a = Array(o); ++i < o; )
      a[i] = r[e + i];
    i = -1;
    for (var s = Array(e + 1); ++i < e; )
      s[i] = r[i];
    return s[e] = n(a), kN(t, this, s);
  };
}
function HN(t, e) {
  return BN(jN(t, e, T2), t + "");
}
var VN = 9007199254740991;
function C2(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= VN;
}
function jA(t) {
  return t != null && C2(t.length) && !LA(t);
}
var qN = Object.prototype;
function XN(t) {
  var e = t && t.constructor, n = typeof e == "function" && e.prototype || qN;
  return t === n;
}
function GN(t, e) {
  for (var n = -1, r = Array(t); ++n < t; )
    r[n] = e(n);
  return r;
}
var JN = "[object Arguments]";
function ZS(t) {
  return Lo(t) && ss(t) == JN;
}
var HA = Object.prototype, YN = HA.hasOwnProperty, ZN = HA.propertyIsEnumerable, E2 = ZS(/* @__PURE__ */ function() {
  return arguments;
}()) ? ZS : function(t) {
  return Lo(t) && YN.call(t, "callee") && !ZN.call(t, "callee");
};
function KN() {
  return !1;
}
var VA = typeof exports == "object" && exports && !exports.nodeType && exports, KS = VA && typeof module == "object" && module && !module.nodeType && module, QN = KS && KS.exports === VA, QS = QN ? to.Buffer : void 0, e7 = QS ? QS.isBuffer : void 0, f0 = e7 || KN, t7 = "[object Arguments]", n7 = "[object Array]", r7 = "[object Boolean]", i7 = "[object Date]", o7 = "[object Error]", a7 = "[object Function]", s7 = "[object Map]", l7 = "[object Number]", c7 = "[object Object]", u7 = "[object RegExp]", f7 = "[object Set]", d7 = "[object String]", h7 = "[object WeakMap]", p7 = "[object ArrayBuffer]", g7 = "[object DataView]", m7 = "[object Float32Array]", y7 = "[object Float64Array]", b7 = "[object Int8Array]", v7 = "[object Int16Array]", x7 = "[object Int32Array]", D7 = "[object Uint8Array]", w7 = "[object Uint8ClampedArray]", S7 = "[object Uint16Array]", T7 = "[object Uint32Array]", Et = {};
Et[m7] = Et[y7] = Et[b7] = Et[v7] = Et[x7] = Et[D7] = Et[w7] = Et[S7] = Et[T7] = !0;
Et[t7] = Et[n7] = Et[p7] = Et[r7] = Et[g7] = Et[i7] = Et[o7] = Et[a7] = Et[s7] = Et[l7] = Et[c7] = Et[u7] = Et[f7] = Et[d7] = Et[h7] = !1;
function C7(t) {
  return Lo(t) && C2(t.length) && !!Et[ss(t)];
}
function _2(t) {
  return function(e) {
    return t(e);
  };
}
var qA = typeof exports == "object" && exports && !exports.nodeType && exports, ed = qA && typeof module == "object" && module && !module.nodeType && module, E7 = ed && ed.exports === qA, Yb = E7 && NA.process, pg = function() {
  try {
    var t = ed && ed.require && ed.require("util").types;
    return t || Yb && Yb.binding && Yb.binding("util");
  } catch {
  }
}(), eT = pg && pg.isTypedArray, XA = eT ? _2(eT) : C7, _7 = Object.prototype, k7 = _7.hasOwnProperty;
function A7(t, e) {
  var n = Zi(t), r = !n && E2(t), i = !n && !r && f0(t), o = !n && !r && !i && XA(t), a = n || r || i || o, s = a ? GN(t.length, String) : [], l = s.length;
  for (var u in t)
    k7.call(t, u) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    o && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    zA(u, l))) && s.push(u);
  return s;
}
function U7(t, e) {
  return function(n) {
    return t(e(n));
  };
}
var F7 = U7(Object.keys, Object), R7 = Object.prototype, O7 = R7.hasOwnProperty;
function I7(t) {
  if (!XN(t))
    return F7(t);
  var e = [];
  for (var n in Object(t))
    O7.call(t, n) && n != "constructor" && e.push(n);
  return e;
}
function GA(t) {
  return jA(t) ? A7(t) : I7(t);
}
var B7 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, M7 = /^\w*$/;
function k2(t, e) {
  if (Zi(t))
    return !1;
  var n = typeof t;
  return n == "number" || n == "symbol" || n == "boolean" || t == null || vm(t) ? !0 : M7.test(t) || !B7.test(t) || e != null && t in Object(e);
}
var pd = Sl(Object, "create");
function N7() {
  this.__data__ = pd ? pd(null) : {}, this.size = 0;
}
function P7(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var W7 = "__lodash_hash_undefined__", L7 = Object.prototype, z7 = L7.hasOwnProperty;
function $7(t) {
  var e = this.__data__;
  if (pd) {
    var n = e[t];
    return n === W7 ? void 0 : n;
  }
  return z7.call(e, t) ? e[t] : void 0;
}
var j7 = Object.prototype, H7 = j7.hasOwnProperty;
function V7(t) {
  var e = this.__data__;
  return pd ? e[t] !== void 0 : H7.call(e, t);
}
var q7 = "__lodash_hash_undefined__";
function X7(t, e) {
  var n = this.__data__;
  return this.size += this.has(t) ? 0 : 1, n[t] = pd && e === void 0 ? q7 : e, this;
}
function dl(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
dl.prototype.clear = N7;
dl.prototype.delete = P7;
dl.prototype.get = $7;
dl.prototype.has = V7;
dl.prototype.set = X7;
function G7() {
  this.__data__ = [], this.size = 0;
}
function xm(t, e) {
  for (var n = t.length; n--; )
    if ($A(t[n][0], e))
      return n;
  return -1;
}
var J7 = Array.prototype, Y7 = J7.splice;
function Z7(t) {
  var e = this.__data__, n = xm(e, t);
  if (n < 0)
    return !1;
  var r = e.length - 1;
  return n == r ? e.pop() : Y7.call(e, n, 1), --this.size, !0;
}
function K7(t) {
  var e = this.__data__, n = xm(e, t);
  return n < 0 ? void 0 : e[n][1];
}
function Q7(t) {
  return xm(this.__data__, t) > -1;
}
function eP(t, e) {
  var n = this.__data__, r = xm(n, t);
  return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this;
}
function qo(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
qo.prototype.clear = G7;
qo.prototype.delete = Z7;
qo.prototype.get = K7;
qo.prototype.has = Q7;
qo.prototype.set = eP;
var gd = Sl(to, "Map");
function tP() {
  this.size = 0, this.__data__ = {
    hash: new dl(),
    map: new (gd || qo)(),
    string: new dl()
  };
}
function nP(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function Dm(t, e) {
  var n = t.__data__;
  return nP(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
}
function rP(t) {
  var e = Dm(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function iP(t) {
  return Dm(this, t).get(t);
}
function oP(t) {
  return Dm(this, t).has(t);
}
function aP(t, e) {
  var n = Dm(this, t), r = n.size;
  return n.set(t, e), this.size += n.size == r ? 0 : 1, this;
}
function Xo(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
Xo.prototype.clear = tP;
Xo.prototype.delete = rP;
Xo.prototype.get = iP;
Xo.prototype.has = oP;
Xo.prototype.set = aP;
var sP = "Expected a function";
function A2(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(sP);
  var n = function() {
    var r = arguments, i = e ? e.apply(this, r) : r[0], o = n.cache;
    if (o.has(i))
      return o.get(i);
    var a = t.apply(this, r);
    return n.cache = o.set(i, a) || o, a;
  };
  return n.cache = new (A2.Cache || Xo)(), n;
}
A2.Cache = Xo;
var lP = 500;
function cP(t) {
  var e = A2(t, function(r) {
    return n.size === lP && n.clear(), r;
  }), n = e.cache;
  return e;
}
var uP = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, fP = /\\(\\)?/g, dP = cP(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(uP, function(n, r, i, o) {
    e.push(i ? o.replace(fP, "$1") : r || n);
  }), e;
});
function d0(t) {
  return t == null ? "" : hg(t);
}
function JA(t, e) {
  return Zi(t) ? t : k2(t, e) ? [t] : dP(d0(t));
}
var hP = 1 / 0;
function wm(t) {
  if (typeof t == "string" || vm(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -hP ? "-0" : e;
}
function YA(t, e) {
  e = JA(e, t);
  for (var n = 0, r = e.length; t != null && n < r; )
    t = t[wm(e[n++])];
  return n && n == r ? t : void 0;
}
function pP(t, e, n) {
  var r = t == null ? void 0 : YA(t, e);
  return r === void 0 ? n : r;
}
function ZA(t, e) {
  for (var n = -1, r = e.length, i = t.length; ++n < r; )
    t[i + n] = e[n];
  return t;
}
var tT = Yi ? Yi.isConcatSpreadable : void 0;
function gP(t) {
  return Zi(t) || E2(t) || !!(tT && t && t[tT]);
}
function mP(t, e, n, r, i) {
  var o = -1, a = t.length;
  for (n || (n = gP), i || (i = []); ++o < a; ) {
    var s = t[o];
    n(s) && ZA(i, s);
  }
  return i;
}
function yP(t, e, n) {
  var r = -1, i = t.length;
  e < 0 && (e = -e > i ? 0 : i + e), n = n > i ? i : n, n < 0 && (n += i), i = e > n ? 0 : n - e >>> 0, e >>>= 0;
  for (var o = Array(i); ++r < i; )
    o[r] = t[r + e];
  return o;
}
function bP(t, e, n) {
  var r = t.length;
  return n = n === void 0 ? r : n, !e && n >= r ? t : yP(t, e, n);
}
var vP = "\\ud800-\\udfff", xP = "\\u0300-\\u036f", DP = "\\ufe20-\\ufe2f", wP = "\\u20d0-\\u20ff", SP = xP + DP + wP, TP = "\\ufe0e\\ufe0f", CP = "\\u200d", EP = RegExp("[" + CP + vP + SP + TP + "]");
function U2(t) {
  return EP.test(t);
}
function _P(t) {
  return t.split("");
}
var KA = "\\ud800-\\udfff", kP = "\\u0300-\\u036f", AP = "\\ufe20-\\ufe2f", UP = "\\u20d0-\\u20ff", FP = kP + AP + UP, RP = "\\ufe0e\\ufe0f", OP = "[" + KA + "]", h0 = "[" + FP + "]", p0 = "\\ud83c[\\udffb-\\udfff]", IP = "(?:" + h0 + "|" + p0 + ")", QA = "[^" + KA + "]", e3 = "(?:\\ud83c[\\udde6-\\uddff]){2}", t3 = "[\\ud800-\\udbff][\\udc00-\\udfff]", BP = "\\u200d", n3 = IP + "?", r3 = "[" + RP + "]?", MP = "(?:" + BP + "(?:" + [QA, e3, t3].join("|") + ")" + r3 + n3 + ")*", NP = r3 + n3 + MP, PP = "(?:" + [QA + h0 + "?", h0, e3, t3, OP].join("|") + ")", WP = RegExp(p0 + "(?=" + p0 + ")|" + PP + NP, "g");
function LP(t) {
  return t.match(WP) || [];
}
function zP(t) {
  return U2(t) ? LP(t) : _P(t);
}
function $P(t, e, n) {
  return t === t && (n !== void 0 && (t = t <= n ? t : n), e !== void 0 && (t = t >= e ? t : e)), t;
}
function SJ(t, e, n) {
  return n === void 0 && (n = e, e = void 0), n !== void 0 && (n = Jc(n), n = n === n ? n : 0), e !== void 0 && (e = Jc(e), e = e === e ? e : 0), $P(Jc(t), e, n);
}
function jP() {
  this.__data__ = new qo(), this.size = 0;
}
function HP(t) {
  var e = this.__data__, n = e.delete(t);
  return this.size = e.size, n;
}
function VP(t) {
  return this.__data__.get(t);
}
function qP(t) {
  return this.__data__.has(t);
}
var XP = 200;
function GP(t, e) {
  var n = this.__data__;
  if (n instanceof qo) {
    var r = n.__data__;
    if (!gd || r.length < XP - 1)
      return r.push([t, e]), this.size = ++n.size, this;
    n = this.__data__ = new Xo(r);
  }
  return n.set(t, e), this.size = n.size, this;
}
function Po(t) {
  var e = this.__data__ = new qo(t);
  this.size = e.size;
}
Po.prototype.clear = jP;
Po.prototype.delete = HP;
Po.prototype.get = VP;
Po.prototype.has = qP;
Po.prototype.set = GP;
function JP(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length, i = 0, o = []; ++n < r; ) {
    var a = t[n];
    e(a, n, t) && (o[i++] = a);
  }
  return o;
}
function YP() {
  return [];
}
var ZP = Object.prototype, KP = ZP.propertyIsEnumerable, nT = Object.getOwnPropertySymbols, QP = nT ? function(t) {
  return t == null ? [] : (t = Object(t), JP(nT(t), function(e) {
    return KP.call(t, e);
  }));
} : YP;
function eW(t, e, n) {
  var r = e(t);
  return Zi(t) ? r : ZA(r, n(t));
}
function rT(t) {
  return eW(t, GA, QP);
}
var g0 = Sl(to, "DataView"), m0 = Sl(to, "Promise"), y0 = Sl(to, "Set"), iT = "[object Map]", tW = "[object Object]", oT = "[object Promise]", aT = "[object Set]", sT = "[object WeakMap]", lT = "[object DataView]", nW = wl(g0), rW = wl(gd), iW = wl(m0), oW = wl(y0), aW = wl(u0), Oa = ss;
(g0 && Oa(new g0(new ArrayBuffer(1))) != lT || gd && Oa(new gd()) != iT || m0 && Oa(m0.resolve()) != oT || y0 && Oa(new y0()) != aT || u0 && Oa(new u0()) != sT) && (Oa = function(t) {
  var e = ss(t), n = e == tW ? t.constructor : void 0, r = n ? wl(n) : "";
  if (r)
    switch (r) {
      case nW:
        return lT;
      case rW:
        return iT;
      case iW:
        return oT;
      case oW:
        return aT;
      case aW:
        return sT;
    }
  return e;
});
var cT = to.Uint8Array, sW = "__lodash_hash_undefined__";
function lW(t) {
  return this.__data__.set(t, sW), this;
}
function cW(t) {
  return this.__data__.has(t);
}
function md(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.__data__ = new Xo(); ++e < n; )
    this.add(t[e]);
}
md.prototype.add = md.prototype.push = lW;
md.prototype.has = cW;
function uW(t, e) {
  for (var n = -1, r = t == null ? 0 : t.length; ++n < r; )
    if (e(t[n], n, t))
      return !0;
  return !1;
}
function i3(t, e) {
  return t.has(e);
}
var fW = 1, dW = 2;
function o3(t, e, n, r, i, o) {
  var a = n & fW, s = t.length, l = e.length;
  if (s != l && !(a && l > s))
    return !1;
  var u = o.get(t), f = o.get(e);
  if (u && f)
    return u == e && f == t;
  var h = -1, p = !0, y = n & dW ? new md() : void 0;
  for (o.set(t, e), o.set(e, t); ++h < s; ) {
    var b = t[h], x = e[h];
    if (r)
      var v = a ? r(x, b, h, e, t, o) : r(b, x, h, t, e, o);
    if (v !== void 0) {
      if (v)
        continue;
      p = !1;
      break;
    }
    if (y) {
      if (!uW(e, function(D, S) {
        if (!i3(y, S) && (b === D || i(b, D, n, r, o)))
          return y.push(S);
      })) {
        p = !1;
        break;
      }
    } else if (!(b === x || i(b, x, n, r, o))) {
      p = !1;
      break;
    }
  }
  return o.delete(t), o.delete(e), p;
}
function hW(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r, i) {
    n[++e] = [i, r];
  }), n;
}
function pW(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r) {
    n[++e] = r;
  }), n;
}
var gW = 1, mW = 2, yW = "[object Boolean]", bW = "[object Date]", vW = "[object Error]", xW = "[object Map]", DW = "[object Number]", wW = "[object RegExp]", SW = "[object Set]", TW = "[object String]", CW = "[object Symbol]", EW = "[object ArrayBuffer]", _W = "[object DataView]", uT = Yi ? Yi.prototype : void 0, Zb = uT ? uT.valueOf : void 0;
function kW(t, e, n, r, i, o, a) {
  switch (n) {
    case _W:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case EW:
      return !(t.byteLength != e.byteLength || !o(new cT(t), new cT(e)));
    case yW:
    case bW:
    case DW:
      return $A(+t, +e);
    case vW:
      return t.name == e.name && t.message == e.message;
    case wW:
    case TW:
      return t == e + "";
    case xW:
      var s = hW;
    case SW:
      var l = r & gW;
      if (s || (s = pW), t.size != e.size && !l)
        return !1;
      var u = a.get(t);
      if (u)
        return u == e;
      r |= mW, a.set(t, e);
      var f = o3(s(t), s(e), r, i, o, a);
      return a.delete(t), f;
    case CW:
      if (Zb)
        return Zb.call(t) == Zb.call(e);
  }
  return !1;
}
var AW = 1, UW = Object.prototype, FW = UW.hasOwnProperty;
function RW(t, e, n, r, i, o) {
  var a = n & AW, s = rT(t), l = s.length, u = rT(e), f = u.length;
  if (l != f && !a)
    return !1;
  for (var h = l; h--; ) {
    var p = s[h];
    if (!(a ? p in e : FW.call(e, p)))
      return !1;
  }
  var y = o.get(t), b = o.get(e);
  if (y && b)
    return y == e && b == t;
  var x = !0;
  o.set(t, e), o.set(e, t);
  for (var v = a; ++h < l; ) {
    p = s[h];
    var D = t[p], S = e[p];
    if (r)
      var E = a ? r(S, D, p, e, t, o) : r(D, S, p, t, e, o);
    if (!(E === void 0 ? D === S || i(D, S, n, r, o) : E)) {
      x = !1;
      break;
    }
    v || (v = p == "constructor");
  }
  if (x && !v) {
    var I = t.constructor, R = e.constructor;
    I != R && "constructor" in t && "constructor" in e && !(typeof I == "function" && I instanceof I && typeof R == "function" && R instanceof R) && (x = !1);
  }
  return o.delete(t), o.delete(e), x;
}
var OW = 1, fT = "[object Arguments]", dT = "[object Array]", Gh = "[object Object]", IW = Object.prototype, hT = IW.hasOwnProperty;
function BW(t, e, n, r, i, o) {
  var a = Zi(t), s = Zi(e), l = a ? dT : Oa(t), u = s ? dT : Oa(e);
  l = l == fT ? Gh : l, u = u == fT ? Gh : u;
  var f = l == Gh, h = u == Gh, p = l == u;
  if (p && f0(t)) {
    if (!f0(e))
      return !1;
    a = !0, f = !1;
  }
  if (p && !f)
    return o || (o = new Po()), a || XA(t) ? o3(t, e, n, r, i, o) : kW(t, e, l, n, r, i, o);
  if (!(n & OW)) {
    var y = f && hT.call(t, "__wrapped__"), b = h && hT.call(e, "__wrapped__");
    if (y || b) {
      var x = y ? t.value() : t, v = b ? e.value() : e;
      return o || (o = new Po()), i(x, v, n, r, o);
    }
  }
  return p ? (o || (o = new Po()), RW(t, e, n, r, i, o)) : !1;
}
function F2(t, e, n, r, i) {
  return t === e ? !0 : t == null || e == null || !Lo(t) && !Lo(e) ? t !== t && e !== e : BW(t, e, n, r, F2, i);
}
var MW = 1, NW = 2;
function PW(t, e, n, r) {
  var i = n.length, o = i;
  if (t == null)
    return !o;
  for (t = Object(t); i--; ) {
    var a = n[i];
    if (a[2] ? a[1] !== t[a[0]] : !(a[0] in t))
      return !1;
  }
  for (; ++i < o; ) {
    a = n[i];
    var s = a[0], l = t[s], u = a[1];
    if (a[2]) {
      if (l === void 0 && !(s in t))
        return !1;
    } else {
      var f = new Po(), h;
      if (!(h === void 0 ? F2(u, l, MW | NW, r, f) : h))
        return !1;
    }
  }
  return !0;
}
function a3(t) {
  return t === t && !Za(t);
}
function WW(t) {
  for (var e = GA(t), n = e.length; n--; ) {
    var r = e[n], i = t[r];
    e[n] = [r, i, a3(i)];
  }
  return e;
}
function s3(t, e) {
  return function(n) {
    return n == null ? !1 : n[t] === e && (e !== void 0 || t in Object(n));
  };
}
function LW(t) {
  var e = WW(t);
  return e.length == 1 && e[0][2] ? s3(e[0][0], e[0][1]) : function(n) {
    return n === t || PW(n, t, e);
  };
}
function zW(t, e) {
  return t != null && e in Object(t);
}
function $W(t, e, n) {
  e = JA(e, t);
  for (var r = -1, i = e.length, o = !1; ++r < i; ) {
    var a = wm(e[r]);
    if (!(o = t != null && n(t, a)))
      break;
    t = t[a];
  }
  return o || ++r != i ? o : (i = t == null ? 0 : t.length, !!i && C2(i) && zA(a, i) && (Zi(t) || E2(t)));
}
function jW(t, e) {
  return t != null && $W(t, e, zW);
}
var HW = 1, VW = 2;
function qW(t, e) {
  return k2(t) && a3(e) ? s3(wm(t), e) : function(n) {
    var r = pP(n, t);
    return r === void 0 && r === e ? jW(n, t) : F2(e, r, HW | VW);
  };
}
function l3(t) {
  return function(e) {
    return e == null ? void 0 : e[t];
  };
}
function XW(t) {
  return function(e) {
    return YA(e, t);
  };
}
function GW(t) {
  return k2(t) ? l3(wm(t)) : XW(t);
}
function JW(t) {
  return typeof t == "function" ? t : t == null ? T2 : typeof t == "object" ? Zi(t) ? qW(t[0], t[1]) : LW(t) : GW(t);
}
var Kb = function() {
  return to.Date.now();
}, YW = "Expected a function", ZW = Math.max, KW = Math.min;
function QW(t, e, n) {
  var r, i, o, a, s, l, u = 0, f = !1, h = !1, p = !0;
  if (typeof t != "function")
    throw new TypeError(YW);
  e = Jc(e) || 0, Za(n) && (f = !!n.leading, h = "maxWait" in n, o = h ? ZW(Jc(n.maxWait) || 0, e) : o, p = "trailing" in n ? !!n.trailing : p);
  function y(O) {
    var N = r, q = i;
    return r = i = void 0, u = O, a = t.apply(q, N), a;
  }
  function b(O) {
    return u = O, s = setTimeout(D, e), f ? y(O) : a;
  }
  function x(O) {
    var N = O - l, q = O - u, $ = e - N;
    return h ? KW($, o - q) : $;
  }
  function v(O) {
    var N = O - l, q = O - u;
    return l === void 0 || N >= e || N < 0 || h && q >= o;
  }
  function D() {
    var O = Kb();
    if (v(O))
      return S(O);
    s = setTimeout(D, x(O));
  }
  function S(O) {
    return s = void 0, p && r ? y(O) : (r = i = void 0, a);
  }
  function E() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = i = s = void 0;
  }
  function I() {
    return s === void 0 ? a : S(Kb());
  }
  function R() {
    var O = Kb(), N = v(O);
    if (r = arguments, i = this, l = O, N) {
      if (s === void 0)
        return b(l);
      if (h)
        return clearTimeout(s), s = setTimeout(D, e), y(l);
    }
    return s === void 0 && (s = setTimeout(D, e)), a;
  }
  return R.cancel = E, R.flush = I, R;
}
function Qb(t) {
  return Lo(t) && jA(t);
}
var eL = 200;
function tL(t, e, n, r) {
  var i = -1, o = LN, a = !0, s = t.length, l = [], u = e.length;
  if (!s)
    return l;
  n && (e = WA(e, _2(n))), e.length >= eL && (o = i3, a = !1, e = new md(e));
  e:
    for (; ++i < s; ) {
      var f = t[i], h = n == null ? f : n(f);
      if (f = f !== 0 ? f : 0, a && h === h) {
        for (var p = u; p--; )
          if (e[p] === h)
            continue e;
        l.push(f);
      } else o(e, h, r) || l.push(f);
    }
  return l;
}
function nL(t) {
  var e = t == null ? 0 : t.length;
  return e ? t[e - 1] : void 0;
}
var TJ = HN(function(t, e) {
  var n = nL(e);
  return Qb(n) && (n = void 0), Qb(t) ? tL(t, mP(e, 1, Qb), JW(n)) : [];
}), rL = "[object Number]";
function CJ(t) {
  return typeof t == "number" || Lo(t) && ss(t) == rL;
}
var iL = "[object RegExp]";
function oL(t) {
  return Lo(t) && ss(t) == iL;
}
var pT = pg && pg.isRegExp, aL = pT ? _2(pT) : oL, sL = l3("length"), c3 = "\\ud800-\\udfff", lL = "\\u0300-\\u036f", cL = "\\ufe20-\\ufe2f", uL = "\\u20d0-\\u20ff", fL = lL + cL + uL, dL = "\\ufe0e\\ufe0f", hL = "[" + c3 + "]", b0 = "[" + fL + "]", v0 = "\\ud83c[\\udffb-\\udfff]", pL = "(?:" + b0 + "|" + v0 + ")", u3 = "[^" + c3 + "]", f3 = "(?:\\ud83c[\\udde6-\\uddff]){2}", d3 = "[\\ud800-\\udbff][\\udc00-\\udfff]", gL = "\\u200d", h3 = pL + "?", p3 = "[" + dL + "]?", mL = "(?:" + gL + "(?:" + [u3, f3, d3].join("|") + ")" + p3 + h3 + ")*", yL = p3 + h3 + mL, bL = "(?:" + [u3 + b0 + "?", b0, f3, d3, hL].join("|") + ")", gT = RegExp(v0 + "(?=" + v0 + ")|" + bL + yL, "g");
function vL(t) {
  for (var e = gT.lastIndex = 0; gT.test(t); )
    ++e;
  return e;
}
function xL(t) {
  return U2(t) ? vL(t) : sL(t);
}
var DL = "Expected a function";
function EJ(t, e, n) {
  var r = !0, i = !0;
  if (typeof t != "function")
    throw new TypeError(DL);
  return Za(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), QW(t, e, {
    leading: r,
    maxWait: e,
    trailing: i
  });
}
var wL = 30, SL = "...", TL = /\w*$/;
function _J(t, e) {
  var n = wL, r = SL;
  if (Za(e)) {
    var i = "separator" in e ? e.separator : i;
    n = "length" in e ? fN(e.length) : n, r = "omission" in e ? hg(e.omission) : r;
  }
  t = d0(t);
  var o = t.length;
  if (U2(t)) {
    var a = zP(t);
    o = a.length;
  }
  if (n >= o)
    return t;
  var s = n - xL(r);
  if (s < 1)
    return r;
  var l = a ? bP(a, 0, s).join("") : t.slice(0, s);
  if (i === void 0)
    return l + r;
  if (a && (s += l.length - s), aL(i)) {
    if (t.slice(s).search(i)) {
      var u, f = l;
      for (i.global || (i = RegExp(i.source, d0(TL.exec(i)) + "g")), i.lastIndex = 0; u = i.exec(f); )
        var h = u.index;
      l = l.slice(0, h === void 0 ? s : h);
    }
  } else if (t.indexOf(hg(i), s) != s) {
    var p = l.lastIndexOf(i);
    p > -1 && (l = l.slice(0, p));
  }
  return l + r;
}
const Hi = () => /* @__PURE__ */ new Map(), x0 = (t) => {
  const e = Hi();
  return t.forEach((n, r) => {
    e.set(r, n);
  }), e;
}, Tu = (t, e, n) => {
  let r = t.get(e);
  return r === void 0 && t.set(e, r = n()), r;
}, CL = (t, e) => {
  const n = [];
  for (const [r, i] of t)
    n.push(e(i, r));
  return n;
}, EL = (t, e) => {
  for (const [n, r] of t)
    if (e(r, n))
      return !0;
  return !1;
}, au = () => /* @__PURE__ */ new Set(), ev = (t) => t[t.length - 1], su = Array.from, _L = Array.isArray;
class kL {
  constructor() {
    this._observers = Hi();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(e, n) {
    return Tu(
      this._observers,
      /** @type {string} */
      e,
      au
    ).add(n), n;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(e, n) {
    const r = (...i) => {
      this.off(
        e,
        /** @type {any} */
        r
      ), n(...i);
    };
    this.on(
      e,
      /** @type {any} */
      r
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(e, n) {
    const r = this._observers.get(e);
    r !== void 0 && (r.delete(n), r.size === 0 && this._observers.delete(e));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(e, n) {
    return su((this._observers.get(e) || Hi()).values()).forEach((r) => r(...n));
  }
  destroy() {
    this._observers = Hi();
  }
}
const hl = Math.floor, Up = Math.abs, g3 = (t, e) => t < e ? t : e, Cu = (t, e) => t > e ? t : e, AL = (t) => t !== 0 ? t < 0 : 1 / t < 0, mT = 1, yT = 2, tv = 4, nv = 8, UL = 32, m3 = 64, gg = 128, FL = 31, bT = 63, td = 127, RL = 2147483647, OL = Number.isInteger || ((t) => typeof t == "number" && isFinite(t) && hl(t) === t), IL = (t) => t.toLowerCase(), BL = /^\s*/g, ML = (t) => t.replace(BL, ""), NL = /([A-Z])/g, vT = (t, e) => ML(t.replace(NL, (n) => `${e}${IL(n)}`)), PL = (t) => {
  const e = unescape(encodeURIComponent(t)), n = e.length, r = new Uint8Array(n);
  for (let i = 0; i < n; i++)
    r[i] = /** @type {number} */
    e.codePointAt(i);
  return r;
}, yd = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), WL = (t) => yd.encode(t), LL = yd ? WL : PL;
let rv = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
rv && rv.decode(new Uint8Array()).length === 1 && (rv = null);
class qd {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
}
const R2 = () => new qd(), zL = (t) => {
  let e = t.cpos;
  for (let n = 0; n < t.bufs.length; n++)
    e += t.bufs[n].length;
  return e;
}, Mo = (t) => {
  const e = new Uint8Array(zL(t));
  let n = 0;
  for (let r = 0; r < t.bufs.length; r++) {
    const i = t.bufs[r];
    e.set(i, n), n += i.length;
  }
  return e.set(new Uint8Array(t.cbuf.buffer, 0, t.cpos), n), e;
}, $L = (t, e) => {
  const n = t.cbuf.length;
  n - t.cpos < e && (t.bufs.push(new Uint8Array(t.cbuf.buffer, 0, t.cpos)), t.cbuf = new Uint8Array(Cu(n, e) * 2), t.cpos = 0);
}, Qt = (t, e) => {
  const n = t.cbuf.length;
  t.cpos === n && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(n * 2), t.cpos = 0), t.cbuf[t.cpos++] = e;
}, D0 = Qt, wt = (t, e) => {
  for (; e > td; )
    Qt(t, gg | td & e), e = hl(e / 128);
  Qt(t, td & e);
}, O2 = (t, e) => {
  const n = AL(e);
  for (n && (e = -e), Qt(t, (e > bT ? gg : 0) | (n ? m3 : 0) | bT & e), e = hl(e / 64); e > 0; )
    Qt(t, (e > td ? gg : 0) | td & e), e = hl(e / 128);
}, w0 = new Uint8Array(3e4), jL = w0.length / 3, HL = (t, e) => {
  if (e.length < jL) {
    const n = yd.encodeInto(e, w0).written || 0;
    wt(t, n);
    for (let r = 0; r < n; r++)
      Qt(t, w0[r]);
  } else
    Tr(t, LL(e));
}, VL = (t, e) => {
  const n = unescape(encodeURIComponent(e)), r = n.length;
  wt(t, r);
  for (let i = 0; i < r; i++)
    Qt(
      t,
      /** @type {number} */
      n.codePointAt(i)
    );
}, Yc = yd && /** @type {any} */
yd.encodeInto ? HL : VL, I2 = (t, e) => {
  const n = t.cbuf.length, r = t.cpos, i = g3(n - r, e.length), o = e.length - i;
  t.cbuf.set(e.subarray(0, i), r), t.cpos += i, o > 0 && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(Cu(n * 2, o)), t.cbuf.set(e.subarray(i)), t.cpos = o);
}, Tr = (t, e) => {
  wt(t, e.byteLength), I2(t, e);
}, B2 = (t, e) => {
  $L(t, e);
  const n = new DataView(t.cbuf.buffer, t.cpos, e);
  return t.cpos += e, n;
}, qL = (t, e) => B2(t, 4).setFloat32(0, e, !1), XL = (t, e) => B2(t, 8).setFloat64(0, e, !1), GL = (t, e) => (
  /** @type {any} */
  B2(t, 8).setBigInt64(0, e, !1)
), xT = new DataView(new ArrayBuffer(4)), JL = (t) => (xT.setFloat32(0, t), xT.getFloat32(0) === t), bd = (t, e) => {
  switch (typeof e) {
    case "string":
      Qt(t, 119), Yc(t, e);
      break;
    case "number":
      OL(e) && Up(e) <= RL ? (Qt(t, 125), O2(t, e)) : JL(e) ? (Qt(t, 124), qL(t, e)) : (Qt(t, 123), XL(t, e));
      break;
    case "bigint":
      Qt(t, 122), GL(t, e);
      break;
    case "object":
      if (e === null)
        Qt(t, 126);
      else if (_L(e)) {
        Qt(t, 117), wt(t, e.length);
        for (let n = 0; n < e.length; n++)
          bd(t, e[n]);
      } else if (e instanceof Uint8Array)
        Qt(t, 116), Tr(t, e);
      else {
        Qt(t, 118);
        const n = Object.keys(e);
        wt(t, n.length);
        for (let r = 0; r < n.length; r++) {
          const i = n[r];
          Yc(t, i), bd(t, e[i]);
        }
      }
      break;
    case "boolean":
      Qt(t, e ? 120 : 121);
      break;
    default:
      Qt(t, 127);
  }
};
class DT extends qd {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(e) {
    super(), this.w = e, this.s = null, this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(e) {
    this.s === e ? this.count++ : (this.count > 0 && wt(this, this.count - 1), this.count = 1, this.w(this, e), this.s = e);
  }
}
const wT = (t) => {
  t.count > 0 && (O2(t.encoder, t.count === 1 ? t.s : -t.s), t.count > 1 && wt(t.encoder, t.count - 2));
};
class Fp {
  constructor() {
    this.encoder = new qd(), this.s = 0, this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.s === e ? this.count++ : (wT(this), this.count = 1, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return wT(this), Mo(this.encoder);
  }
}
const ST = (t) => {
  if (t.count > 0) {
    const e = t.diff * 2 + (t.count === 1 ? 0 : 1);
    O2(t.encoder, e), t.count > 1 && wt(t.encoder, t.count - 2);
  }
};
class iv {
  constructor() {
    this.encoder = new qd(), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.diff === e - this.s ? (this.s = e, this.count++) : (ST(this), this.count = 1, this.diff = e - this.s, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return ST(this), Mo(this.encoder);
  }
}
class YL {
  constructor() {
    this.sarr = [], this.s = "", this.lensE = new Fp();
  }
  /**
   * @param {string} string
   */
  write(e) {
    this.s += e, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(e.length);
  }
  toUint8Array() {
    const e = new qd();
    return this.sarr.push(this.s), this.s = "", Yc(e, this.sarr.join("")), I2(e, this.lensE.toUint8Array()), Mo(e);
  }
}
const lu = (t) => new Error(t), Vi = () => {
  throw lu("Method unimplemented");
}, Ka = () => {
  throw lu("Unexpected case");
}, ZL = crypto.getRandomValues.bind(crypto), y3 = () => ZL(new Uint32Array(1))[0], KL = "10000000-1000-4000-8000" + -1e11, QL = () => KL.replace(
  /[018]/g,
  /** @param {number} c */
  (t) => (t ^ y3() & 15 >> t / 4).toString(16)
), TT = (t) => (
  /** @type {Promise<T>} */
  new Promise(t)
);
Promise.all.bind(Promise);
const CT = (t) => t === void 0 ? null : t;
class ez {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(e, n) {
    this.map.set(e, n);
  }
  /**
   * @param {string} key
   */
  getItem(e) {
    return this.map.get(e);
  }
}
let b3 = new ez(), tz = !0;
try {
  typeof localStorage < "u" && localStorage && (b3 = localStorage, tz = !1);
} catch {
}
const nz = b3, rz = Object.assign, iz = Object.keys, oz = (t, e) => {
  for (const n in t)
    e(t[n], n);
}, ET = (t) => iz(t).length, az = (t) => {
  for (const e in t)
    return !1;
  return !0;
}, sz = (t, e) => {
  for (const n in t)
    if (!e(t[n], n))
      return !1;
  return !0;
}, lz = (t, e) => Object.prototype.hasOwnProperty.call(t, e), cz = (t, e) => t === e || ET(t) === ET(e) && sz(t, (n, r) => (n !== void 0 || lz(e, r)) && e[r] === n), uz = Object.freeze, v3 = (t) => {
  for (const e in t) {
    const n = t[e];
    (typeof n == "object" || typeof n == "function") && v3(t[e]);
  }
  return uz(t);
}, M2 = (t, e, n = 0) => {
  try {
    for (; n < t.length; n++)
      t[n](...e);
  } finally {
    n < t.length && M2(t, e, n + 1);
  }
}, fz = (t, e) => e.includes(t), vd = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
let Mi;
const dz = () => {
  if (Mi === void 0)
    if (vd) {
      Mi = Hi();
      const t = process.argv;
      let e = null;
      for (let n = 0; n < t.length; n++) {
        const r = t[n];
        r[0] === "-" ? (e !== null && Mi.set(e, ""), e = r) : e !== null && (Mi.set(e, r), e = null);
      }
      e !== null && Mi.set(e, "");
    } else typeof location == "object" ? (Mi = Hi(), (location.search || "?").slice(1).split("&").forEach((t) => {
      if (t.length !== 0) {
        const [e, n] = t.split("=");
        Mi.set(`--${vT(e, "-")}`, n), Mi.set(`-${vT(e, "-")}`, n);
      }
    })) : Mi = Hi();
  return Mi;
}, S0 = (t) => dz().has(t), mg = (t) => CT(vd ? process.env[t.toUpperCase().replaceAll("-", "_")] : nz.getItem(t)), x3 = (t) => S0("--" + t) || mg(t) !== null;
x3("production");
const hz = vd && fz(process.env.FORCE_COLOR, ["true", "1", "2"]), pz = hz || !S0("--no-colors") && // @todo deprecate --no-colors
!x3("no-color") && (!vd || process.stdout.isTTY) && (!vd || S0("--color") || mg("COLORTERM") !== null || (mg("TERM") || "").includes("color"));
class gz {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(e, n) {
    this.left = e, this.right = n;
  }
}
const ko = (t, e) => new gz(t, e);
typeof DOMParser < "u" && new DOMParser();
const mz = (t) => CL(t, (e, n) => `${n}:${e};`).join(""), Go = Symbol, D3 = Go(), w3 = Go(), yz = Go(), bz = Go(), vz = Go(), S3 = Go(), xz = Go(), N2 = Go(), Dz = Go(), wz = (t) => {
  var i;
  t.length === 1 && ((i = t[0]) == null ? void 0 : i.constructor) === Function && (t = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  t[0]());
  const e = [], n = [];
  let r = 0;
  for (; r < t.length; r++) {
    const o = t[r];
    if (o === void 0)
      break;
    if (o.constructor === String || o.constructor === Number)
      e.push(o);
    else if (o.constructor === Object)
      break;
  }
  for (r > 0 && n.push(e.join("")); r < t.length; r++) {
    const o = t[r];
    o instanceof Symbol || n.push(o);
  }
  return n;
}, Sz = {
  [D3]: ko("font-weight", "bold"),
  [w3]: ko("font-weight", "normal"),
  [yz]: ko("color", "blue"),
  [vz]: ko("color", "green"),
  [bz]: ko("color", "grey"),
  [S3]: ko("color", "red"),
  [xz]: ko("color", "purple"),
  [N2]: ko("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [Dz]: ko("color", "black")
}, Tz = (t) => {
  var a;
  t.length === 1 && ((a = t[0]) == null ? void 0 : a.constructor) === Function && (t = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  t[0]());
  const e = [], n = [], r = Hi();
  let i = [], o = 0;
  for (; o < t.length; o++) {
    const s = t[o], l = Sz[s];
    if (l !== void 0)
      r.set(l.left, l.right);
    else {
      if (s === void 0)
        break;
      if (s.constructor === String || s.constructor === Number) {
        const u = mz(r);
        o > 0 || u.length > 0 ? (e.push("%c" + s), n.push(u)) : e.push(s);
      } else
        break;
    }
  }
  for (o > 0 && (i = n, i.unshift(e.join(""))); o < t.length; o++) {
    const s = t[o];
    s instanceof Symbol || i.push(s);
  }
  return i;
}, T3 = pz ? Tz : wz, Cz = (...t) => {
  console.log(...T3(t)), C3.forEach((e) => e.print(t));
}, Ez = (...t) => {
  console.warn(...T3(t)), t.unshift(N2), C3.forEach((e) => e.print(t));
}, C3 = au(), E3 = (t) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next: t
}), _z = (t, e) => E3(() => {
  let n;
  do
    n = t.next();
  while (!n.done && !e(n.value));
  return n;
}), ov = (t, e) => E3(() => {
  const { done: n, value: r } = t.next();
  return { done: n, value: n ? void 0 : e(r) };
});
class kz {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(e, n) {
    this.clock = e, this.len = n;
  }
}
class Az {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const _3 = (t, e, n) => e.clients.forEach((r, i) => {
  const o = (
    /** @type {Array<GC|Item>} */
    t.doc.store.clients.get(i)
  );
  for (let a = 0; a < r.length; a++) {
    const s = r[a];
    I3(t, o, s.clock, s.len, n);
  }
}), Uz = (t, e) => {
  let n = 0, r = t.length - 1;
  for (; n <= r; ) {
    const i = hl((n + r) / 2), o = t[i], a = o.clock;
    if (a <= e) {
      if (e < a + o.len)
        return i;
      n = i + 1;
    } else
      r = i - 1;
  }
  return null;
}, k3 = (t, e) => {
  const n = t.clients.get(e.client);
  return n !== void 0 && Uz(n, e.clock) !== null;
}, A3 = (t) => {
  t.clients.forEach((e) => {
    e.sort((i, o) => i.clock - o.clock);
    let n, r;
    for (n = 1, r = 1; n < e.length; n++) {
      const i = e[r - 1], o = e[n];
      i.clock + i.len >= o.clock ? i.len = Cu(i.len, o.clock + o.len - i.clock) : (r < n && (e[r] = o), r++);
    }
    e.length = r;
  });
}, U3 = (t, e, n, r) => {
  Tu(t.clients, e, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new kz(n, r));
}, Fz = (t, e) => {
  wt(t.restEncoder, e.clients.size), su(e.clients.entries()).sort((n, r) => r[0] - n[0]).forEach(([n, r]) => {
    t.resetDsCurVal(), wt(t.restEncoder, n);
    const i = r.length;
    wt(t.restEncoder, i);
    for (let o = 0; o < i; o++) {
      const a = r[o];
      t.writeDsClock(a.clock), t.writeDsLen(a.len);
    }
  });
}, F3 = y3;
class Xd extends kL {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid: e = QL(), collectionid: n = null, gc: r = !0, gcFilter: i = () => !0, meta: o = null, autoLoad: a = !1, shouldLoad: s = !0 } = {}) {
    super(), this.gc = r, this.gcFilter = i, this.clientID = F3(), this.guid = e, this.collectionid = n, this.share = /* @__PURE__ */ new Map(), this.store = new Lz(), this._transaction = null, this._transactionCleanups = [], this.subdocs = /* @__PURE__ */ new Set(), this._item = null, this.shouldLoad = s, this.autoLoad = a, this.meta = o, this.isLoaded = !1, this.isSynced = !1, this.isDestroyed = !1, this.whenLoaded = TT((u) => {
      this.on("load", () => {
        this.isLoaded = !0, u(this);
      });
    });
    const l = () => TT((u) => {
      const f = (h) => {
        (h === void 0 || h === !0) && (this.off("sync", f), u());
      };
      this.on("sync", f);
    });
    this.on("sync", (u) => {
      u === !1 && this.isSynced && (this.whenSynced = l()), this.isSynced = u === void 0 || u === !0, this.isSynced && !this.isLoaded && this.emit("load", [this]);
    }), this.whenSynced = l();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const e = this._item;
    e !== null && !this.shouldLoad && _t(
      /** @type {any} */
      e.parent.doc,
      (n) => {
        n.subdocsLoaded.add(this);
      },
      null,
      !0
    ), this.shouldLoad = !0;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(su(this.subdocs).map((e) => e.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(e, n = null) {
    return _t(this, e, n);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(e, n = (
    /** @type {any} */
    yn
  )) {
    const r = Tu(this.share, e, () => {
      const o = new n();
      return o._integrate(this, null), o;
    }), i = r.constructor;
    if (n !== yn && i !== n)
      if (i === yn) {
        const o = new n();
        o._map = r._map, r._map.forEach(
          /** @param {Item?} n */
          (a) => {
            for (; a !== null; a = a.left)
              a.parent = o;
          }
        ), o._start = r._start;
        for (let a = o._start; a !== null; a = a.right)
          a.parent = o;
        return o._length = r._length, this.share.set(e, o), o._integrate(this, null), /** @type {InstanceType<Type>} */
        o;
      } else
        throw new Error(`Type with the name ${e} has already been defined with a different constructor`);
    return (
      /** @type {InstanceType<Type>} */
      r
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(e = "") {
    return (
      /** @type {YArray<T>} */
      this.get(e, nd)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(e = "") {
    return this.get(e, Sd);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(e = "") {
    return (
      /** @type {YMap<T>} */
      this.get(e, xg)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(e = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(e, Td)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(e = "") {
    return this.get(e, cu);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const e = {};
    return this.share.forEach((n, r) => {
      e[r] = n.toJSON();
    }), e;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    this.isDestroyed = !0, su(this.subdocs).forEach((n) => n.destroy());
    const e = this._item;
    if (e !== null) {
      this._item = null;
      const n = (
        /** @type {ContentDoc} */
        e.content
      );
      n.doc = new Xd({ guid: this.guid, ...n.opts, shouldLoad: !1 }), n.doc._item = e, _t(
        /** @type {any} */
        e.parent.doc,
        (r) => {
          const i = n.doc;
          e.deleted || r.subdocsAdded.add(i), r.subdocsRemoved.add(this);
        },
        null,
        !0
      );
    }
    this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy();
  }
}
class Rz {
  constructor() {
    this.restEncoder = R2();
  }
  toUint8Array() {
    return Mo(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    wt(this.restEncoder, e);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    wt(this.restEncoder, e);
  }
}
class Oz extends Rz {
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    wt(this.restEncoder, e.client), wt(this.restEncoder, e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    wt(this.restEncoder, e.client), wt(this.restEncoder, e.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(e) {
    wt(this.restEncoder, e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    D0(this.restEncoder, e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    Yc(this.restEncoder, e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    wt(this.restEncoder, e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    wt(this.restEncoder, e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    wt(this.restEncoder, e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    bd(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    Tr(this.restEncoder, e);
  }
  /**
   * @param {any} embed
   */
  writeJSON(e) {
    Yc(this.restEncoder, JSON.stringify(e));
  }
  /**
   * @param {string} key
   */
  writeKey(e) {
    Yc(this.restEncoder, e);
  }
}
class Iz {
  constructor() {
    this.restEncoder = R2(), this.dsCurrVal = 0;
  }
  toUint8Array() {
    return Mo(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    const n = e - this.dsCurrVal;
    this.dsCurrVal = e, wt(this.restEncoder, n);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    e === 0 && Ka(), wt(this.restEncoder, e - 1), this.dsCurrVal += e;
  }
}
class Bz extends Iz {
  constructor() {
    super(), this.keyMap = /* @__PURE__ */ new Map(), this.keyClock = 0, this.keyClockEncoder = new iv(), this.clientEncoder = new Fp(), this.leftClockEncoder = new iv(), this.rightClockEncoder = new iv(), this.infoEncoder = new DT(D0), this.stringEncoder = new YL(), this.parentInfoEncoder = new DT(D0), this.typeRefEncoder = new Fp(), this.lenEncoder = new Fp();
  }
  toUint8Array() {
    const e = R2();
    return wt(e, 0), Tr(e, this.keyClockEncoder.toUint8Array()), Tr(e, this.clientEncoder.toUint8Array()), Tr(e, this.leftClockEncoder.toUint8Array()), Tr(e, this.rightClockEncoder.toUint8Array()), Tr(e, Mo(this.infoEncoder)), Tr(e, this.stringEncoder.toUint8Array()), Tr(e, Mo(this.parentInfoEncoder)), Tr(e, this.typeRefEncoder.toUint8Array()), Tr(e, this.lenEncoder.toUint8Array()), I2(e, Mo(this.restEncoder)), Mo(e);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    this.clientEncoder.write(e.client), this.leftClockEncoder.write(e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    this.clientEncoder.write(e.client), this.rightClockEncoder.write(e.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(e) {
    this.clientEncoder.write(e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    this.infoEncoder.write(e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    this.stringEncoder.write(e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    this.parentInfoEncoder.write(e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    this.typeRefEncoder.write(e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    this.lenEncoder.write(e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    bd(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    Tr(this.restEncoder, e);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(e) {
    bd(this.restEncoder, e);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(e) {
    const n = this.keyMap.get(e);
    n === void 0 ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(e)) : this.keyClockEncoder.write(n);
  }
}
const Mz = (t, e, n, r) => {
  r = Cu(r, e[0].id.clock);
  const i = zo(e, r);
  wt(t.restEncoder, e.length - i), t.writeClient(n), wt(t.restEncoder, r);
  const o = e[i];
  o.write(t, r - o.id.clock);
  for (let a = i + 1; a < e.length; a++)
    e[a].write(t, 0);
}, Nz = (t, e, n) => {
  const r = /* @__PURE__ */ new Map();
  n.forEach((i, o) => {
    ur(e, o) > i && r.set(o, i);
  }), P2(e).forEach((i, o) => {
    n.has(o) || r.set(o, 0);
  }), wt(t.restEncoder, r.size), su(r.entries()).sort((i, o) => o[0] - i[0]).forEach(([i, o]) => {
    Mz(
      t,
      /** @type {Array<GC|Item>} */
      e.clients.get(i),
      i,
      o
    );
  });
}, Pz = (t, e) => Nz(t, e.doc.store, e.beforeState);
class Wz {
  constructor() {
    this.l = [];
  }
}
const _T = () => new Wz(), kT = (t, e) => t.l.push(e), AT = (t, e) => {
  const n = t.l, r = n.length;
  t.l = n.filter((i) => e !== i), r === t.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.");
}, R3 = (t, e, n) => M2(t.l, [e, n]);
class Rp {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(e, n) {
    this.client = e, this.clock = n;
  }
}
const Jh = (t, e) => t === e || t !== null && e !== null && t.client === e.client && t.clock === e.clock, kt = (t, e) => new Rp(t, e), xd = (t) => {
  for (const [e, n] of t.doc.share.entries())
    if (n === t)
      return e;
  throw Ka();
};
class yg {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(e, n, r, i = 0) {
    this.type = e, this.tname = n, this.item = r, this.assoc = i;
  }
}
const Yh = (t, e, n) => {
  let r = null, i = null;
  return t._item === null ? i = xd(t) : r = kt(t._item.id.client, t._item.id.clock), new yg(r, i, e, n);
}, av = (t, e, n = 0) => {
  let r = t._start;
  if (n < 0) {
    if (e === 0)
      return Yh(t, null, n);
    e--;
  }
  for (; r !== null; ) {
    if (!r.deleted && r.countable) {
      if (r.length > e)
        return Yh(t, kt(r.id.client, r.id.clock + e), n);
      e -= r.length;
    }
    if (r.right === null && n < 0)
      return Yh(t, r.lastId, n);
    r = r.right;
  }
  return Yh(t, null, n);
}, Pc = (t, e) => e === void 0 ? !t.deleted : e.sv.has(t.id.client) && (e.sv.get(t.id.client) || 0) > t.id.clock && !k3(e.ds, t.id), T0 = (t, e) => {
  const n = Tu(t.meta, T0, au), r = t.doc.store;
  n.has(e) || (e.sv.forEach((i, o) => {
    i < ur(r, o) && Qa(t, kt(o, i));
  }), _3(t, e.ds, (i) => {
  }), n.add(e));
};
class Lz {
  constructor() {
    this.clients = /* @__PURE__ */ new Map(), this.pendingStructs = null, this.pendingDs = null;
  }
}
const P2 = (t) => {
  const e = /* @__PURE__ */ new Map();
  return t.clients.forEach((n, r) => {
    const i = n[n.length - 1];
    e.set(r, i.id.clock + i.length);
  }), e;
}, ur = (t, e) => {
  const n = t.clients.get(e);
  if (n === void 0)
    return 0;
  const r = n[n.length - 1];
  return r.id.clock + r.length;
}, O3 = (t, e) => {
  let n = t.clients.get(e.id.client);
  if (n === void 0)
    n = [], t.clients.set(e.id.client, n);
  else {
    const r = n[n.length - 1];
    if (r.id.clock + r.length !== e.id.clock)
      throw Ka();
  }
  n.push(e);
}, zo = (t, e) => {
  let n = 0, r = t.length - 1, i = t[r], o = i.id.clock;
  if (o === e)
    return r;
  let a = hl(e / (o + i.length - 1) * r);
  for (; n <= r; ) {
    if (i = t[a], o = i.id.clock, o <= e) {
      if (e < o + i.length)
        return a;
      n = a + 1;
    } else
      r = a - 1;
    a = hl((n + r) / 2);
  }
  throw Ka();
}, zz = (t, e) => {
  const n = t.clients.get(e.client);
  return n[zo(n, e.clock)];
}, sv = (
  /** @type {function(StructStore,ID):Item} */
  zz
), C0 = (t, e, n) => {
  const r = zo(e, n), i = e[r];
  return i.id.clock < n && i instanceof _r ? (e.splice(r + 1, 0, K3(t, i, n - i.id.clock)), r + 1) : r;
}, Qa = (t, e) => {
  const n = (
    /** @type {Array<Item>} */
    t.doc.store.clients.get(e.client)
  );
  return n[C0(t, n, e.clock)];
}, UT = (t, e, n) => {
  const r = e.clients.get(n.client), i = zo(r, n.clock), o = r[i];
  return n.clock !== o.id.clock + o.length - 1 && o.constructor !== Pa && r.splice(i + 1, 0, K3(t, o, n.clock - o.id.clock + 1)), o;
}, $z = (t, e, n) => {
  const r = (
    /** @type {Array<GC|Item>} */
    t.clients.get(e.id.client)
  );
  r[zo(r, e.id.clock)] = n;
}, I3 = (t, e, n, r, i) => {
  if (r === 0)
    return;
  const o = n + r;
  let a = C0(t, e, n), s;
  do
    s = e[a++], o < s.id.clock + s.length && C0(t, e, o), i(s);
  while (a < e.length && e[a].id.clock < o);
};
class jz {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(e, n, r) {
    this.doc = e, this.deleteSet = new Az(), this.beforeState = P2(e.store), this.afterState = /* @__PURE__ */ new Map(), this.changed = /* @__PURE__ */ new Map(), this.changedParentTypes = /* @__PURE__ */ new Map(), this._mergeStructs = [], this.origin = n, this.meta = /* @__PURE__ */ new Map(), this.local = r, this.subdocsAdded = /* @__PURE__ */ new Set(), this.subdocsRemoved = /* @__PURE__ */ new Set(), this.subdocsLoaded = /* @__PURE__ */ new Set(), this._needFormattingCleanup = !1;
  }
}
const FT = (t, e) => e.deleteSet.clients.size === 0 && !EL(e.afterState, (n, r) => e.beforeState.get(r) !== n) ? !1 : (A3(e.deleteSet), Pz(t, e), Fz(t, e.deleteSet), !0), RT = (t, e, n) => {
  const r = e._item;
  (r === null || r.id.clock < (t.beforeState.get(r.id.client) || 0) && !r.deleted) && Tu(t.changed, e, au).add(n);
}, Op = (t, e) => {
  let n = t[e], r = t[e - 1], i = e;
  for (; i > 0; n = r, r = t[--i - 1]) {
    if (r.deleted === n.deleted && r.constructor === n.constructor && r.mergeWith(n)) {
      n instanceof _r && n.parentSub !== null && /** @type {AbstractType<any>} */
      n.parent._map.get(n.parentSub) === n && n.parent._map.set(
        n.parentSub,
        /** @type {Item} */
        r
      );
      continue;
    }
    break;
  }
  const o = e - i;
  return o && t.splice(e + 1 - o, o), o;
}, Hz = (t, e, n) => {
  for (const [r, i] of t.clients.entries()) {
    const o = (
      /** @type {Array<GC|Item>} */
      e.clients.get(r)
    );
    for (let a = i.length - 1; a >= 0; a--) {
      const s = i[a], l = s.clock + s.len;
      for (let u = zo(o, s.clock), f = o[u]; u < o.length && f.id.clock < l; f = o[++u]) {
        const h = o[u];
        if (s.clock + s.len <= h.id.clock)
          break;
        h instanceof _r && h.deleted && !h.keep && n(h) && h.gc(e, !1);
      }
    }
  }
}, Vz = (t, e) => {
  t.clients.forEach((n, r) => {
    const i = (
      /** @type {Array<GC|Item>} */
      e.clients.get(r)
    );
    for (let o = n.length - 1; o >= 0; o--) {
      const a = n[o], s = g3(i.length - 1, 1 + zo(i, a.clock + a.len - 1));
      for (let l = s, u = i[l]; l > 0 && u.id.clock >= a.clock; u = i[l])
        l -= 1 + Op(i, l);
    }
  });
}, B3 = (t, e) => {
  if (e < t.length) {
    const n = t[e], r = n.doc, i = r.store, o = n.deleteSet, a = n._mergeStructs;
    try {
      A3(o), n.afterState = P2(n.doc.store), r.emit("beforeObserverCalls", [n, r]);
      const s = [];
      n.changed.forEach(
        (l, u) => s.push(() => {
          (u._item === null || !u._item.deleted) && u._callObserver(n, l);
        })
      ), s.push(() => {
        n.changedParentTypes.forEach((l, u) => {
          u._dEH.l.length > 0 && (u._item === null || !u._item.deleted) && (l = l.filter(
            (f) => f.target._item === null || !f.target._item.deleted
          ), l.forEach((f) => {
            f.currentTarget = u, f._path = null;
          }), l.sort((f, h) => f.path.length - h.path.length), R3(u._dEH, l, n));
        });
      }), s.push(() => r.emit("afterTransaction", [n, r])), M2(s, []), n._needFormattingCleanup && r$(n);
    } finally {
      r.gc && Hz(o, i, r.gcFilter), Vz(o, i), n.afterState.forEach((f, h) => {
        const p = n.beforeState.get(h) || 0;
        if (p !== f) {
          const y = (
            /** @type {Array<GC|Item>} */
            i.clients.get(h)
          ), b = Cu(zo(y, p), 1);
          for (let x = y.length - 1; x >= b; )
            x -= 1 + Op(y, x);
        }
      });
      for (let f = a.length - 1; f >= 0; f--) {
        const { client: h, clock: p } = a[f].id, y = (
          /** @type {Array<GC|Item>} */
          i.clients.get(h)
        ), b = zo(y, p);
        b + 1 < y.length && Op(y, b + 1) > 1 || b > 0 && Op(y, b);
      }
      if (!n.local && n.afterState.get(r.clientID) !== n.beforeState.get(r.clientID) && (Cz(N2, D3, "[yjs] ", w3, S3, "Changed the client-id because another client seems to be using it."), r.clientID = F3()), r.emit("afterTransactionCleanup", [n, r]), r._observers.has("update")) {
        const f = new Oz();
        FT(f, n) && r.emit("update", [f.toUint8Array(), n.origin, r, n]);
      }
      if (r._observers.has("updateV2")) {
        const f = new Bz();
        FT(f, n) && r.emit("updateV2", [f.toUint8Array(), n.origin, r, n]);
      }
      const { subdocsAdded: s, subdocsLoaded: l, subdocsRemoved: u } = n;
      (s.size > 0 || u.size > 0 || l.size > 0) && (s.forEach((f) => {
        f.clientID = r.clientID, f.collectionid == null && (f.collectionid = r.collectionid), r.subdocs.add(f);
      }), u.forEach((f) => r.subdocs.delete(f)), r.emit("subdocs", [{ loaded: l, added: s, removed: u }, r, n]), u.forEach((f) => f.destroy())), t.length <= e + 1 ? (r._transactionCleanups = [], r.emit("afterAllTransactions", [r, t])) : B3(t, e + 1);
    }
  }
}, _t = (t, e, n = null, r = !0) => {
  const i = t._transactionCleanups;
  let o = !1, a = null;
  t._transaction === null && (o = !0, t._transaction = new jz(t, n, r), i.push(t._transaction), i.length === 1 && t.emit("beforeAllTransactions", [t]), t.emit("beforeTransaction", [t._transaction, t]));
  try {
    a = e(t._transaction);
  } finally {
    if (o) {
      const s = t._transaction === i[0];
      t._transaction = null, s && B3(i, 0);
    }
  }
  return a;
}, OT = "You must not compute changes after the event-handler fired.";
class Sm {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(e, n) {
    this.target = e, this.currentTarget = e, this.transaction = n, this._changes = null, this._keys = null, this._delta = null, this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = qz(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(e) {
    return k3(this.transaction.deleteSet, e.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw lu(OT);
      const e = /* @__PURE__ */ new Map(), n = this.target;
      /** @type Set<string|null> */
      this.transaction.changed.get(n).forEach((i) => {
        if (i !== null) {
          const o = (
            /** @type {Item} */
            n._map.get(i)
          );
          let a, s;
          if (this.adds(o)) {
            let l = o.left;
            for (; l !== null && this.adds(l); )
              l = l.left;
            if (this.deletes(o))
              if (l !== null && this.deletes(l))
                a = "delete", s = ev(l.content.getContent());
              else
                return;
            else
              l !== null && this.deletes(l) ? (a = "update", s = ev(l.content.getContent())) : (a = "add", s = void 0);
          } else if (this.deletes(o))
            a = "delete", s = ev(
              /** @type {Item} */
              o.content.getContent()
            );
          else
            return;
          e.set(i, { action: a, oldValue: s });
        }
      }), this._keys = e;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(e) {
    return e.id.clock >= (this.transaction.beforeState.get(e.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let e = this._changes;
    if (e === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw lu(OT);
      const n = this.target, r = au(), i = au(), o = [];
      if (e = {
        added: r,
        deleted: i,
        delta: o,
        keys: this.keys
      }, /** @type Set<string|null> */
      this.transaction.changed.get(n).has(null)) {
        let s = null;
        const l = () => {
          s && o.push(s);
        };
        for (let u = n._start; u !== null; u = u.right)
          u.deleted ? this.deletes(u) && !this.adds(u) && ((s === null || s.delete === void 0) && (l(), s = { delete: 0 }), s.delete += u.length, i.add(u)) : this.adds(u) ? ((s === null || s.insert === void 0) && (l(), s = { insert: [] }), s.insert = s.insert.concat(u.content.getContent()), r.add(u)) : ((s === null || s.retain === void 0) && (l(), s = { retain: 0 }), s.retain += u.length);
        s !== null && s.retain === void 0 && l();
      }
      this._changes = e;
    }
    return (
      /** @type {any} */
      e
    );
  }
}
const qz = (t, e) => {
  const n = [];
  for (; e._item !== null && e !== t; ) {
    if (e._item.parentSub !== null)
      n.unshift(e._item.parentSub);
    else {
      let r = 0, i = (
        /** @type {AbstractType<any>} */
        e._item.parent._start
      );
      for (; i !== e._item && i !== null; )
        !i.deleted && i.countable && (r += i.length), i = i.right;
      n.unshift(r);
    }
    e = /** @type {AbstractType<any>} */
    e._item.parent;
  }
  return n;
}, kn = () => {
  Ez("Invalid access: Add Yjs type to a document before reading data.");
}, M3 = 80;
let W2 = 0;
class Xz {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(e, n) {
    e.marker = !0, this.p = e, this.index = n, this.timestamp = W2++;
  }
}
const Gz = (t) => {
  t.timestamp = W2++;
}, N3 = (t, e, n) => {
  t.p.marker = !1, t.p = e, e.marker = !0, t.index = n, t.timestamp = W2++;
}, Jz = (t, e, n) => {
  if (t.length >= M3) {
    const r = t.reduce((i, o) => i.timestamp < o.timestamp ? i : o);
    return N3(r, e, n), r;
  } else {
    const r = new Xz(e, n);
    return t.push(r), r;
  }
}, Tm = (t, e) => {
  if (t._start === null || e === 0 || t._searchMarker === null)
    return null;
  const n = t._searchMarker.length === 0 ? null : t._searchMarker.reduce((o, a) => Up(e - o.index) < Up(e - a.index) ? o : a);
  let r = t._start, i = 0;
  for (n !== null && (r = n.p, i = n.index, Gz(n)); r.right !== null && i < e; ) {
    if (!r.deleted && r.countable) {
      if (e < i + r.length)
        break;
      i += r.length;
    }
    r = r.right;
  }
  for (; r.left !== null && i > e; )
    r = r.left, !r.deleted && r.countable && (i -= r.length);
  for (; r.left !== null && r.left.id.client === r.id.client && r.left.id.clock + r.left.length === r.id.clock; )
    r = r.left, !r.deleted && r.countable && (i -= r.length);
  return n !== null && Up(n.index - i) < /** @type {YText|YArray<any>} */
  r.parent.length / M3 ? (N3(n, r, i), n) : Jz(t._searchMarker, r, i);
}, Dd = (t, e, n) => {
  for (let r = t.length - 1; r >= 0; r--) {
    const i = t[r];
    if (n > 0) {
      let o = i.p;
      for (o.marker = !1; o && (o.deleted || !o.countable); )
        o = o.left, o && !o.deleted && o.countable && (i.index -= o.length);
      if (o === null || o.marker === !0) {
        t.splice(r, 1);
        continue;
      }
      i.p = o, o.marker = !0;
    }
    (e < i.index || n > 0 && e === i.index) && (i.index = Cu(e, i.index + n));
  }
}, Cm = (t, e, n) => {
  const r = t, i = e.changedParentTypes;
  for (; Tu(i, t, () => []).push(n), t._item !== null; )
    t = /** @type {AbstractType<any>} */
    t._item.parent;
  R3(r._eH, n, e);
};
class yn {
  constructor() {
    this._item = null, this._map = /* @__PURE__ */ new Map(), this._start = null, this.doc = null, this._length = 0, this._eH = _T(), this._dEH = _T(), this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(e, n) {
    this.doc = e, this._item = n;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw Vi();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw Vi();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(e) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let e = this._start;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    !e.local && this._searchMarker && (this._searchMarker.length = 0);
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(e) {
    kT(this._eH, e);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(e) {
    kT(this._dEH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(e) {
    AT(this._eH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(e) {
    AT(this._dEH, e);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
}
const P3 = (t, e, n) => {
  t.doc ?? kn(), e < 0 && (e = t._length + e), n < 0 && (n = t._length + n);
  let r = n - e;
  const i = [];
  let o = t._start;
  for (; o !== null && r > 0; ) {
    if (o.countable && !o.deleted) {
      const a = o.content.getContent();
      if (a.length <= e)
        e -= a.length;
      else {
        for (let s = e; s < a.length && r > 0; s++)
          i.push(a[s]), r--;
        e = 0;
      }
    }
    o = o.right;
  }
  return i;
}, W3 = (t) => {
  t.doc ?? kn();
  const e = [];
  let n = t._start;
  for (; n !== null; ) {
    if (n.countable && !n.deleted) {
      const r = n.content.getContent();
      for (let i = 0; i < r.length; i++)
        e.push(r[i]);
    }
    n = n.right;
  }
  return e;
}, wd = (t, e) => {
  let n = 0, r = t._start;
  for (t.doc ?? kn(); r !== null; ) {
    if (r.countable && !r.deleted) {
      const i = r.content.getContent();
      for (let o = 0; o < i.length; o++)
        e(i[o], n++, t);
    }
    r = r.right;
  }
}, L3 = (t, e) => {
  const n = [];
  return wd(t, (r, i) => {
    n.push(e(r, i, t));
  }), n;
}, Yz = (t) => {
  let e = t._start, n = null, r = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (n === null) {
        for (; e !== null && e.deleted; )
          e = e.right;
        if (e === null)
          return {
            done: !0,
            value: void 0
          };
        n = e.content.getContent(), r = 0, e = e.right;
      }
      const i = n[r++];
      return n.length <= r && (n = null), {
        done: !1,
        value: i
      };
    }
  };
}, z3 = (t, e) => {
  t.doc ?? kn();
  const n = Tm(t, e);
  let r = t._start;
  for (n !== null && (r = n.p, e -= n.index); r !== null; r = r.right)
    if (!r.deleted && r.countable) {
      if (e < r.length)
        return r.content.getContent()[e];
      e -= r.length;
    }
}, bg = (t, e, n, r) => {
  let i = n;
  const o = t.doc, a = o.clientID, s = o.store, l = n === null ? e._start : n.right;
  let u = [];
  const f = () => {
    u.length > 0 && (i = new _r(kt(a, ur(s, a)), i, i && i.lastId, l, l && l.id, e, null, new uu(u)), i.integrate(t, 0), u = []);
  };
  r.forEach((h) => {
    if (h === null)
      u.push(h);
    else
      switch (h.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          u.push(h);
          break;
        default:
          switch (f(), h.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              i = new _r(kt(a, ur(s, a)), i, i && i.lastId, l, l && l.id, e, null, new Em(new Uint8Array(
                /** @type {Uint8Array} */
                h
              ))), i.integrate(t, 0);
              break;
            case Xd:
              i = new _r(kt(a, ur(s, a)), i, i && i.lastId, l, l && l.id, e, null, new _m(
                /** @type {Doc} */
                h
              )), i.integrate(t, 0);
              break;
            default:
              if (h instanceof yn)
                i = new _r(kt(a, ur(s, a)), i, i && i.lastId, l, l && l.id, e, null, new ls(h)), i.integrate(t, 0);
              else
                throw new Error("Unexpected content type in insert operation");
          }
      }
  }), f();
}, $3 = () => lu("Length exceeded!"), j3 = (t, e, n, r) => {
  if (n > e._length)
    throw $3();
  if (n === 0)
    return e._searchMarker && Dd(e._searchMarker, n, r.length), bg(t, e, null, r);
  const i = n, o = Tm(e, n);
  let a = e._start;
  for (o !== null && (a = o.p, n -= o.index, n === 0 && (a = a.prev, n += a && a.countable && !a.deleted ? a.length : 0)); a !== null; a = a.right)
    if (!a.deleted && a.countable) {
      if (n <= a.length) {
        n < a.length && Qa(t, kt(a.id.client, a.id.clock + n));
        break;
      }
      n -= a.length;
    }
  return e._searchMarker && Dd(e._searchMarker, i, r.length), bg(t, e, a, r);
}, Zz = (t, e, n) => {
  let i = (e._searchMarker || []).reduce((o, a) => a.index > o.index ? a : o, { index: 0, p: e._start }).p;
  if (i)
    for (; i.right; )
      i = i.right;
  return bg(t, e, i, n);
}, H3 = (t, e, n, r) => {
  if (r === 0)
    return;
  const i = n, o = r, a = Tm(e, n);
  let s = e._start;
  for (a !== null && (s = a.p, n -= a.index); s !== null && n > 0; s = s.right)
    !s.deleted && s.countable && (n < s.length && Qa(t, kt(s.id.client, s.id.clock + n)), n -= s.length);
  for (; r > 0 && s !== null; )
    s.deleted || (r < s.length && Qa(t, kt(s.id.client, s.id.clock + r)), s.delete(t), r -= s.length), s = s.right;
  if (r > 0)
    throw $3();
  e._searchMarker && Dd(
    e._searchMarker,
    i,
    -o + r
    /* in case we remove the above exception */
  );
}, vg = (t, e, n) => {
  const r = e._map.get(n);
  r !== void 0 && r.delete(t);
}, L2 = (t, e, n, r) => {
  const i = e._map.get(n) || null, o = t.doc, a = o.clientID;
  let s;
  if (r == null)
    s = new uu([r]);
  else
    switch (r.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        s = new uu([r]);
        break;
      case Uint8Array:
        s = new Em(
          /** @type {Uint8Array} */
          r
        );
        break;
      case Xd:
        s = new _m(
          /** @type {Doc} */
          r
        );
        break;
      default:
        if (r instanceof yn)
          s = new ls(r);
        else
          throw new Error("Unexpected content type");
    }
  new _r(kt(a, ur(o.store, a)), i, i && i.lastId, null, null, e, n, s).integrate(t, 0);
}, z2 = (t, e) => {
  t.doc ?? kn();
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted ? n.content.getContent()[n.length - 1] : void 0;
}, V3 = (t) => {
  const e = {};
  return t.doc ?? kn(), t._map.forEach((n, r) => {
    n.deleted || (e[r] = n.content.getContent()[n.length - 1]);
  }), e;
}, q3 = (t, e) => {
  t.doc ?? kn();
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted;
}, Kz = (t, e) => {
  const n = {};
  return t._map.forEach((r, i) => {
    let o = r;
    for (; o !== null && (!e.sv.has(o.id.client) || o.id.clock >= (e.sv.get(o.id.client) || 0)); )
      o = o.left;
    o !== null && Pc(o, e) && (n[i] = o.content.getContent()[o.length - 1]);
  }), n;
}, Zh = (t) => (t.doc ?? kn(), _z(
  t._map.entries(),
  /** @param {any} entry */
  (e) => !e[1].deleted
));
class Qz extends Sm {
}
class nd extends yn {
  constructor() {
    super(), this._prelimContent = [], this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(e) {
    const n = new nd();
    return n.push(e), n;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new nd();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const e = new nd();
    return e.insert(0, this.toArray().map(
      (n) => n instanceof yn ? (
        /** @type {typeof el} */
        n.clone()
      ) : n
    )), e;
  }
  get length() {
    return this.doc ?? kn(), this._length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    super._callObserver(e, n), Cm(this, e, new Qz(this, e));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(e, n) {
    this.doc !== null ? _t(this.doc, (r) => {
      j3(
        r,
        this,
        e,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(e) {
    this.doc !== null ? _t(this.doc, (n) => {
      Zz(
        n,
        this,
        /** @type {any} */
        e
      );
    }) : this._prelimContent.push(...e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(e, n = 1) {
    this.doc !== null ? _t(this.doc, (r) => {
      H3(r, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(e) {
    return z3(this, e);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return W3(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(e = 0, n = this.length) {
    return P3(this, e, n);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((e) => e instanceof yn ? e.toJSON() : e);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(e) {
    return L3(
      this,
      /** @type {any} */
      e
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    wd(this, e);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return Yz(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(c$);
  }
}
class e$ extends Sm {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(e, n, r) {
    super(e, n), this.keysChanged = r;
  }
}
class xg extends yn {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(e) {
    super(), this._prelimContent = null, e === void 0 ? this._prelimContent = /* @__PURE__ */ new Map() : this._prelimContent = new Map(e);
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this._prelimContent.forEach((r, i) => {
      this.set(i, r);
    }), this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new xg();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const e = new xg();
    return this.forEach((n, r) => {
      e.set(r, n instanceof yn ? (
        /** @type {typeof value} */
        n.clone()
      ) : n);
    }), e;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    Cm(this, e, new e$(this, e, n));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    this.doc ?? kn();
    const e = {};
    return this._map.forEach((n, r) => {
      if (!n.deleted) {
        const i = n.content.getContent()[n.length - 1];
        e[r] = i instanceof yn ? i.toJSON() : i;
      }
    }), e;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...Zh(this)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return ov(
      Zh(this),
      /** @param {any} v */
      (e) => e[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return ov(
      Zh(this),
      /** @param {any} v */
      (e) => e[1].content.getContent()[e[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return ov(
      Zh(this),
      /** @param {any} v */
      (e) => (
        /** @type {any} */
        [e[0], e[1].content.getContent()[e[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    this.doc ?? kn(), this._map.forEach((n, r) => {
      n.deleted || e(n.content.getContent()[n.length - 1], r, this);
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(e) {
    this.doc !== null ? _t(this.doc, (n) => {
      vg(n, this, e);
    }) : this._prelimContent.delete(e);
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(e, n) {
    return this.doc !== null ? _t(this.doc, (r) => {
      L2(
        r,
        this,
        e,
        /** @type {any} */
        n
      );
    }) : this._prelimContent.set(e, n), n;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(e) {
    return (
      /** @type {any} */
      z2(this, e)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(e) {
    return q3(this, e);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    this.doc !== null ? _t(this.doc, (e) => {
      this.forEach(function(n, r, i) {
        vg(e, i, r);
      });
    }) : this._prelimContent.clear();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(u$);
  }
}
const Va = (t, e) => t === e || typeof t == "object" && typeof e == "object" && t && e && cz(t, e);
class E0 {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(e, n, r, i) {
    this.left = e, this.right = n, this.index = r, this.currentAttributes = i;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    switch (this.right === null && Ka(), this.right.content.constructor) {
      case tn:
        this.right.deleted || Eu(
          this.currentAttributes,
          /** @type {ContentFormat} */
          this.right.content
        );
        break;
      default:
        this.right.deleted || (this.index += this.right.length);
        break;
    }
    this.left = this.right, this.right = this.right.right;
  }
}
const IT = (t, e, n) => {
  for (; e.right !== null && n > 0; ) {
    switch (e.right.content.constructor) {
      case tn:
        e.right.deleted || Eu(
          e.currentAttributes,
          /** @type {ContentFormat} */
          e.right.content
        );
        break;
      default:
        e.right.deleted || (n < e.right.length && Qa(t, kt(e.right.id.client, e.right.id.clock + n)), e.index += e.right.length, n -= e.right.length);
        break;
    }
    e.left = e.right, e.right = e.right.right;
  }
  return e;
}, Kh = (t, e, n, r) => {
  const i = /* @__PURE__ */ new Map(), o = r ? Tm(e, n) : null;
  if (o) {
    const a = new E0(o.p.left, o.p, o.index, i);
    return IT(t, a, n - o.index);
  } else {
    const a = new E0(null, e._start, 0, i);
    return IT(t, a, n);
  }
}, X3 = (t, e, n, r) => {
  for (; n.right !== null && (n.right.deleted === !0 || n.right.content.constructor === tn && Va(
    r.get(
      /** @type {ContentFormat} */
      n.right.content.key
    ),
    /** @type {ContentFormat} */
    n.right.content.value
  )); )
    n.right.deleted || r.delete(
      /** @type {ContentFormat} */
      n.right.content.key
    ), n.forward();
  const i = t.doc, o = i.clientID;
  r.forEach((a, s) => {
    const l = n.left, u = n.right, f = new _r(kt(o, ur(i.store, o)), l, l && l.lastId, u, u && u.id, e, null, new tn(s, a));
    f.integrate(t, 0), n.right = f, n.forward();
  });
}, Eu = (t, e) => {
  const { key: n, value: r } = e;
  r === null ? t.delete(n) : t.set(n, r);
}, G3 = (t, e) => {
  for (; t.right !== null; ) {
    if (!(t.right.deleted || t.right.content.constructor === tn && Va(
      e[
        /** @type {ContentFormat} */
        t.right.content.key
      ] ?? null,
      /** @type {ContentFormat} */
      t.right.content.value
    ))) break;
    t.forward();
  }
}, J3 = (t, e, n, r) => {
  const i = t.doc, o = i.clientID, a = /* @__PURE__ */ new Map();
  for (const s in r) {
    const l = r[s], u = n.currentAttributes.get(s) ?? null;
    if (!Va(u, l)) {
      a.set(s, u);
      const { left: f, right: h } = n;
      n.right = new _r(kt(o, ur(i.store, o)), f, f && f.lastId, h, h && h.id, e, null, new tn(s, l)), n.right.integrate(t, 0), n.forward();
    }
  }
  return a;
}, lv = (t, e, n, r, i) => {
  n.currentAttributes.forEach((p, y) => {
    i[y] === void 0 && (i[y] = null);
  });
  const o = t.doc, a = o.clientID;
  G3(n, i);
  const s = J3(t, e, n, i), l = r.constructor === String ? new $o(
    /** @type {string} */
    r
  ) : r instanceof yn ? new ls(r) : new _u(r);
  let { left: u, right: f, index: h } = n;
  e._searchMarker && Dd(e._searchMarker, n.index, l.getLength()), f = new _r(kt(a, ur(o.store, a)), u, u && u.lastId, f, f && f.id, e, null, l), f.integrate(t, 0), n.right = f, n.index = h, n.forward(), X3(t, e, n, s);
}, BT = (t, e, n, r, i) => {
  const o = t.doc, a = o.clientID;
  G3(n, i);
  const s = J3(t, e, n, i);
  e: for (; n.right !== null && (r > 0 || s.size > 0 && (n.right.deleted || n.right.content.constructor === tn)); ) {
    if (!n.right.deleted)
      switch (n.right.content.constructor) {
        case tn: {
          const { key: l, value: u } = (
            /** @type {ContentFormat} */
            n.right.content
          ), f = i[l];
          if (f !== void 0) {
            if (Va(f, u))
              s.delete(l);
            else {
              if (r === 0)
                break e;
              s.set(l, u);
            }
            n.right.delete(t);
          } else
            n.currentAttributes.set(l, u);
          break;
        }
        default:
          r < n.right.length && Qa(t, kt(n.right.id.client, n.right.id.clock + r)), r -= n.right.length;
          break;
      }
    n.forward();
  }
  if (r > 0) {
    let l = "";
    for (; r > 0; r--)
      l += `
`;
    n.right = new _r(kt(a, ur(o.store, a)), n.left, n.left && n.left.lastId, n.right, n.right && n.right.id, e, null, new $o(l)), n.right.integrate(t, 0), n.forward();
  }
  X3(t, e, n, s);
}, Y3 = (t, e, n, r, i) => {
  let o = e;
  const a = Hi();
  for (; o && (!o.countable || o.deleted); ) {
    if (!o.deleted && o.content.constructor === tn) {
      const u = (
        /** @type {ContentFormat} */
        o.content
      );
      a.set(u.key, u);
    }
    o = o.right;
  }
  let s = 0, l = !1;
  for (; e !== o; ) {
    if (n === e && (l = !0), !e.deleted) {
      const u = e.content;
      switch (u.constructor) {
        case tn: {
          const { key: f, value: h } = (
            /** @type {ContentFormat} */
            u
          ), p = r.get(f) ?? null;
          (a.get(f) !== u || p === h) && (e.delete(t), s++, !l && (i.get(f) ?? null) === h && p !== h && (p === null ? i.delete(f) : i.set(f, p))), !l && !e.deleted && Eu(
            i,
            /** @type {ContentFormat} */
            u
          );
          break;
        }
      }
    }
    e = /** @type {Item} */
    e.right;
  }
  return s;
}, t$ = (t, e) => {
  for (; e && e.right && (e.right.deleted || !e.right.countable); )
    e = e.right;
  const n = /* @__PURE__ */ new Set();
  for (; e && (e.deleted || !e.countable); ) {
    if (!e.deleted && e.content.constructor === tn) {
      const r = (
        /** @type {ContentFormat} */
        e.content.key
      );
      n.has(r) ? e.delete(t) : n.add(r);
    }
    e = e.left;
  }
}, n$ = (t) => {
  let e = 0;
  return _t(
    /** @type {Doc} */
    t.doc,
    (n) => {
      let r = (
        /** @type {Item} */
        t._start
      ), i = t._start, o = Hi();
      const a = x0(o);
      for (; i; ) {
        if (i.deleted === !1)
          switch (i.content.constructor) {
            case tn:
              Eu(
                a,
                /** @type {ContentFormat} */
                i.content
              );
              break;
            default:
              e += Y3(n, r, i, o, a), o = x0(a), r = i;
              break;
          }
        i = i.right;
      }
    }
  ), e;
}, r$ = (t) => {
  const e = /* @__PURE__ */ new Set(), n = t.doc;
  for (const [r, i] of t.afterState.entries()) {
    const o = t.beforeState.get(r) || 0;
    i !== o && I3(
      t,
      /** @type {Array<Item|GC>} */
      n.store.clients.get(r),
      o,
      i,
      (a) => {
        !a.deleted && /** @type {Item} */
        a.content.constructor === tn && a.constructor !== Pa && e.add(
          /** @type {any} */
          a.parent
        );
      }
    );
  }
  _t(n, (r) => {
    _3(t, t.deleteSet, (i) => {
      if (i instanceof Pa || !/** @type {YText} */
      i.parent._hasFormatting || e.has(
        /** @type {YText} */
        i.parent
      ))
        return;
      const o = (
        /** @type {YText} */
        i.parent
      );
      i.content.constructor === tn ? e.add(o) : t$(r, i);
    });
    for (const i of e)
      n$(i);
  });
}, MT = (t, e, n) => {
  const r = n, i = x0(e.currentAttributes), o = e.right;
  for (; n > 0 && e.right !== null; ) {
    if (e.right.deleted === !1)
      switch (e.right.content.constructor) {
        case ls:
        case _u:
        case $o:
          n < e.right.length && Qa(t, kt(e.right.id.client, e.right.id.clock + n)), n -= e.right.length, e.right.delete(t);
          break;
      }
    e.forward();
  }
  o && Y3(t, o, e.right, i, e.currentAttributes);
  const a = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (e.left || e.right).parent
  );
  return a._searchMarker && Dd(a._searchMarker, e.index, -r + n), e;
};
class i$ extends Sm {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(e, n, r) {
    super(e, n), this.childListChanged = !1, this.keysChanged = /* @__PURE__ */ new Set(), r.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.keysChanged.add(i);
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const e = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = e;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const e = (
        /** @type {Doc} */
        this.target.doc
      ), n = [];
      _t(e, (r) => {
        const i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
        let a = this.target._start, s = null;
        const l = {};
        let u = "", f = 0, h = 0;
        const p = () => {
          if (s !== null) {
            let y = null;
            switch (s) {
              case "delete":
                h > 0 && (y = { delete: h }), h = 0;
                break;
              case "insert":
                (typeof u == "object" || u.length > 0) && (y = { insert: u }, i.size > 0 && (y.attributes = {}, i.forEach((b, x) => {
                  b !== null && (y.attributes[x] = b);
                }))), u = "";
                break;
              case "retain":
                f > 0 && (y = { retain: f }, az(l) || (y.attributes = rz({}, l))), f = 0;
                break;
            }
            y && n.push(y), s = null;
          }
        };
        for (; a !== null; ) {
          switch (a.content.constructor) {
            case ls:
            case _u:
              this.adds(a) ? this.deletes(a) || (p(), s = "insert", u = a.content.getContent()[0], p()) : this.deletes(a) ? (s !== "delete" && (p(), s = "delete"), h += 1) : a.deleted || (s !== "retain" && (p(), s = "retain"), f += 1);
              break;
            case $o:
              this.adds(a) ? this.deletes(a) || (s !== "insert" && (p(), s = "insert"), u += /** @type {ContentString} */
              a.content.str) : this.deletes(a) ? (s !== "delete" && (p(), s = "delete"), h += a.length) : a.deleted || (s !== "retain" && (p(), s = "retain"), f += a.length);
              break;
            case tn: {
              const { key: y, value: b } = (
                /** @type {ContentFormat} */
                a.content
              );
              if (this.adds(a)) {
                if (!this.deletes(a)) {
                  const x = i.get(y) ?? null;
                  Va(x, b) ? b !== null && a.delete(r) : (s === "retain" && p(), Va(b, o.get(y) ?? null) ? delete l[y] : l[y] = b);
                }
              } else if (this.deletes(a)) {
                o.set(y, b);
                const x = i.get(y) ?? null;
                Va(x, b) || (s === "retain" && p(), l[y] = x);
              } else if (!a.deleted) {
                o.set(y, b);
                const x = l[y];
                x !== void 0 && (Va(x, b) ? x !== null && a.delete(r) : (s === "retain" && p(), b === null ? delete l[y] : l[y] = b));
              }
              a.deleted || (s === "insert" && p(), Eu(
                i,
                /** @type {ContentFormat} */
                a.content
              ));
              break;
            }
          }
          a = a.right;
        }
        for (p(); n.length > 0; ) {
          const y = n[n.length - 1];
          if (y.retain !== void 0 && y.attributes === void 0)
            n.pop();
          else
            break;
        }
      }), this._delta = n;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
}
class Sd extends yn {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(e) {
    super(), this._pending = e !== void 0 ? [() => this.insert(0, e)] : [], this._searchMarker = [], this._hasFormatting = !1;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this.doc ?? kn(), this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n);
    try {
      this._pending.forEach((r) => r());
    } catch (r) {
      console.error(r);
    }
    this._pending = null;
  }
  _copy() {
    return new Sd();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const e = new Sd();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    super._callObserver(e, n);
    const r = new i$(this, e, n);
    Cm(this, e, r), !e.local && this._hasFormatting && (e._needFormattingCleanup = !0);
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    this.doc ?? kn();
    let e = "", n = this._start;
    for (; n !== null; )
      !n.deleted && n.countable && n.content.constructor === $o && (e += /** @type {ContentString} */
      n.content.str), n = n.right;
    return e;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(e, { sanitize: n = !0 } = {}) {
    this.doc !== null ? _t(this.doc, (r) => {
      const i = new E0(null, this._start, 0, /* @__PURE__ */ new Map());
      for (let o = 0; o < e.length; o++) {
        const a = e[o];
        if (a.insert !== void 0) {
          const s = !n && typeof a.insert == "string" && o === e.length - 1 && i.right === null && a.insert.slice(-1) === `
` ? a.insert.slice(0, -1) : a.insert;
          (typeof s != "string" || s.length > 0) && lv(r, this, i, s, a.attributes || {});
        } else a.retain !== void 0 ? BT(r, this, i, a.retain, a.attributes || {}) : a.delete !== void 0 && MT(r, i, a.delete);
      }
    }) : this._pending.push(() => this.applyDelta(e));
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(e, n, r) {
    this.doc ?? kn();
    const i = [], o = /* @__PURE__ */ new Map(), a = (
      /** @type {Doc} */
      this.doc
    );
    let s = "", l = this._start;
    function u() {
      if (s.length > 0) {
        const h = {};
        let p = !1;
        o.forEach((b, x) => {
          p = !0, h[x] = b;
        });
        const y = { insert: s };
        p && (y.attributes = h), i.push(y), s = "";
      }
    }
    const f = () => {
      for (; l !== null; ) {
        if (Pc(l, e) || n !== void 0 && Pc(l, n))
          switch (l.content.constructor) {
            case $o: {
              const h = o.get("ychange");
              e !== void 0 && !Pc(l, e) ? (h === void 0 || h.user !== l.id.client || h.type !== "removed") && (u(), o.set("ychange", r ? r("removed", l.id) : { type: "removed" })) : n !== void 0 && !Pc(l, n) ? (h === void 0 || h.user !== l.id.client || h.type !== "added") && (u(), o.set("ychange", r ? r("added", l.id) : { type: "added" })) : h !== void 0 && (u(), o.delete("ychange")), s += /** @type {ContentString} */
              l.content.str;
              break;
            }
            case ls:
            case _u: {
              u();
              const h = {
                insert: l.content.getContent()[0]
              };
              if (o.size > 0) {
                const p = (
                  /** @type {Object<string,any>} */
                  {}
                );
                h.attributes = p, o.forEach((y, b) => {
                  p[b] = y;
                });
              }
              i.push(h);
              break;
            }
            case tn:
              Pc(l, e) && (u(), Eu(
                o,
                /** @type {ContentFormat} */
                l.content
              ));
              break;
          }
        l = l.right;
      }
      u();
    };
    return e || n ? _t(a, (h) => {
      e && T0(h, e), n && T0(h, n), f();
    }, "cleanup") : f(), i;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(e, n, r) {
    if (n.length <= 0)
      return;
    const i = this.doc;
    i !== null ? _t(i, (o) => {
      const a = Kh(o, this, e, !r);
      r || (r = {}, a.currentAttributes.forEach((s, l) => {
        r[l] = s;
      })), lv(o, this, a, n, r);
    }) : this._pending.push(() => this.insert(e, n, r));
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(e, n, r) {
    const i = this.doc;
    i !== null ? _t(i, (o) => {
      const a = Kh(o, this, e, !r);
      lv(o, this, a, n, r || {});
    }) : this._pending.push(() => this.insertEmbed(e, n, r || {}));
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(e, n) {
    if (n === 0)
      return;
    const r = this.doc;
    r !== null ? _t(r, (i) => {
      MT(i, Kh(i, this, e, !0), n);
    }) : this._pending.push(() => this.delete(e, n));
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(e, n, r) {
    if (n === 0)
      return;
    const i = this.doc;
    i !== null ? _t(i, (o) => {
      const a = Kh(o, this, e, !1);
      a.right !== null && BT(o, this, a, n, r);
    }) : this._pending.push(() => this.format(e, n, r));
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? _t(this.doc, (n) => {
      vg(n, this, e);
    }) : this._pending.push(() => this.removeAttribute(e));
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, n) {
    this.doc !== null ? _t(this.doc, (r) => {
      L2(r, this, e, n);
    }) : this._pending.push(() => this.setAttribute(e, n));
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      z2(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return V3(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(f$);
  }
}
class cv {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(e, n = () => !0) {
    this._filter = n, this._root = e, this._currentNode = /** @type {Item} */
    e._start, this._firstCall = !0, e.doc ?? kn();
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let e = this._currentNode, n = e && e.content && /** @type {any} */
    e.content.type;
    if (e !== null && (!this._firstCall || e.deleted || !this._filter(n)))
      do
        if (n = /** @type {any} */
        e.content.type, !e.deleted && (n.constructor === Td || n.constructor === cu) && n._start !== null)
          e = n._start;
        else
          for (; e !== null; )
            if (e.right !== null) {
              e = e.right;
              break;
            } else e.parent === this._root ? e = null : e = /** @type {AbstractType<any>} */
            e.parent._item;
      while (e !== null && (e.deleted || !this._filter(
        /** @type {ContentType} */
        e.content.type
      )));
    return this._firstCall = !1, e === null ? { value: void 0, done: !0 } : (this._currentNode = e, { value: (
      /** @type {any} */
      e.content.type
    ), done: !1 });
  }
}
class cu extends yn {
  constructor() {
    super(), this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const e = this._first;
    return e ? e.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  _copy() {
    return new cu();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const e = new cu();
    return e.insert(0, this.toArray().map((n) => n instanceof yn ? n.clone() : n)), e;
  }
  get length() {
    return this.doc ?? kn(), this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(e) {
    return new cv(this, e);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(e) {
    e = e.toUpperCase();
    const r = new cv(this, (i) => i.nodeName && i.nodeName.toUpperCase() === e).next();
    return r.done ? null : r.value;
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(e) {
    return e = e.toUpperCase(), su(new cv(this, (n) => n.nodeName && n.nodeName.toUpperCase() === e));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, n) {
    Cm(this, e, new o$(this, n, e));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return L3(this, (e) => e.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n = {}, r) {
    const i = e.createDocumentFragment();
    return r !== void 0 && r._createAssociation(i, this), wd(this, (o) => {
      i.insertBefore(o.toDOM(e, n, r), null);
    }), i;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(e, n) {
    this.doc !== null ? _t(this.doc, (r) => {
      j3(r, this, e, n);
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(e, n) {
    if (this.doc !== null)
      _t(this.doc, (r) => {
        const i = e && e instanceof yn ? e._item : e;
        bg(r, this, i, n);
      });
    else {
      const r = (
        /** @type {Array<any>} */
        this._prelimContent
      ), i = e === null ? 0 : r.findIndex((o) => o === e) + 1;
      if (i === 0 && e !== null)
        throw lu("Reference item not found");
      r.splice(i, 0, ...n);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(e, n = 1) {
    this.doc !== null ? _t(this.doc, (r) => {
      H3(r, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return W3(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(e) {
    this.insert(this.length, e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(e) {
    return z3(this, e);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(e = 0, n = this.length) {
    return P3(this, e, n);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    wd(this, e);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(h$);
  }
}
class Td extends cu {
  constructor(e = "UNDEFINED") {
    super(), this.nodeName = e, this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, n) {
    super._integrate(e, n), /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((r, i) => {
      this.setAttribute(i, r);
    }), this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new Td(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const e = new Td(this.nodeName), n = this.getAttributes();
    return oz(n, (r, i) => {
      typeof r == "string" && e.setAttribute(i, r);
    }), e.insert(0, this.toArray().map((r) => r instanceof yn ? r.clone() : r)), e;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const e = this.getAttributes(), n = [], r = [];
    for (const s in e)
      r.push(s);
    r.sort();
    const i = r.length;
    for (let s = 0; s < i; s++) {
      const l = r[s];
      n.push(l + '="' + e[l] + '"');
    }
    const o = this.nodeName.toLocaleLowerCase(), a = n.length > 0 ? " " + n.join(" ") : "";
    return `<${o}${a}>${super.toString()}</${o}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? _t(this.doc, (n) => {
      vg(n, this, e);
    }) : this._prelimAttrs.delete(e);
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, n) {
    this.doc !== null ? _t(this.doc, (r) => {
      L2(r, this, e, n);
    }) : this._prelimAttrs.set(e, n);
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      z2(this, e)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(e) {
    return (
      /** @type {any} */
      q3(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(e) {
    return (
      /** @type {any} */
      e ? Kz(this, e) : V3(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n = {}, r) {
    const i = e.createElement(this.nodeName), o = this.getAttributes();
    for (const a in o) {
      const s = o[a];
      typeof s == "string" && i.setAttribute(a, s);
    }
    return wd(this, (a) => {
      i.appendChild(a.toDOM(e, n, r));
    }), r !== void 0 && r._createAssociation(i, this), i;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(d$), e.writeKey(this.nodeName);
  }
}
class o$ extends Sm {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(e, n, r) {
    super(e, r), this.childListChanged = !1, this.attributesChanged = /* @__PURE__ */ new Set(), n.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.attributesChanged.add(i);
    });
  }
}
class Cd extends Sd {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  _copy() {
    return new Cd();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */
  clone() {
    const e = new Cd();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, n, r) {
    const i = e.createTextNode(this.toString());
    return r !== void 0 && r._createAssociation(i, this), i;
  }
  toString() {
    return this.toDelta().map((e) => {
      const n = [];
      for (const i in e.attributes) {
        const o = [];
        for (const a in e.attributes[i])
          o.push({ key: a, value: e.attributes[i][a] });
        o.sort((a, s) => a.key < s.key ? -1 : 1), n.push({ nodeName: i, attrs: o });
      }
      n.sort((i, o) => i.nodeName < o.nodeName ? -1 : 1);
      let r = "";
      for (let i = 0; i < n.length; i++) {
        const o = n[i];
        r += `<${o.nodeName}`;
        for (let a = 0; a < o.attrs.length; a++) {
          const s = o.attrs[a];
          r += ` ${s.key}="${s.value}"`;
        }
        r += ">";
      }
      r += e.insert;
      for (let i = n.length - 1; i >= 0; i--)
        r += `</${n[i].nodeName}>`;
      return r;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(p$);
  }
}
class Z3 {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(e, n) {
    this.id = e, this.length = n;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw Vi();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(e, n, r) {
    throw Vi();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    throw Vi();
  }
}
const a$ = 0;
class Pa extends Z3 {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    n > 0 && (this.id.clock += n, this.length -= n), O3(e.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeInfo(a$), e.writeLen(this.length - n);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, n) {
    return null;
  }
}
class Em {
  /**
   * @param {Uint8Array} content
   */
  constructor(e) {
    this.content = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new Em(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(e) {
    throw Vi();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
}
class Dg {
  /**
   * @param {number} len
   */
  constructor(e) {
    this.len = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new Dg(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(e) {
    const n = new Dg(this.len - e);
    return this.len = e, n;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.len += e.len, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    U3(e.deleteSet, n.id.client, n.id.clock, this.len), n.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeLen(this.len - n);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
}
const s$ = (t, e) => new Xd({ guid: t, ...e, shouldLoad: e.shouldLoad || e.autoLoad || !1 });
class _m {
  /**
   * @param {Doc} doc
   */
  constructor(e) {
    e._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = e;
    const n = {};
    this.opts = n, e.gc || (n.gc = !1), e.autoLoad && (n.autoLoad = !0), e.meta !== null && (n.meta = e.meta);
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new _m(s$(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(e) {
    throw Vi();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    this.doc._item = n, e.subdocsAdded.add(this.doc), this.doc.shouldLoad && e.subdocsLoaded.add(this.doc);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    e.subdocsAdded.has(this.doc) ? e.subdocsAdded.delete(this.doc) : e.subdocsRemoved.add(this.doc);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeString(this.doc.guid), e.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
}
class _u {
  /**
   * @param {Object} embed
   */
  constructor(e) {
    this.embed = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new _u(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(e) {
    throw Vi();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
}
class tn {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(e, n) {
    this.key = e, this.value = n;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new tn(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(e) {
    throw Vi();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(e, n) {
    const r = (
      /** @type {YText} */
      n.parent
    );
    r._searchMarker = null, r._hasFormatting = !0;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeKey(this.key), e.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
}
const l$ = mg("node_env") === "development";
class uu {
  /**
   * @param {Array<any>} arr
   */
  constructor(e) {
    this.arr = e, l$ && v3(e);
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new uu(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(e) {
    const n = new uu(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), n;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    const r = this.arr.length;
    e.writeLen(r - n);
    for (let i = n; i < r; i++) {
      const o = this.arr[i];
      e.writeAny(o);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
}
class $o {
  /**
   * @param {string} str
   */
  constructor(e) {
    this.str = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new $o(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(e) {
    const n = new $o(this.str.slice(e));
    this.str = this.str.slice(0, e);
    const r = this.str.charCodeAt(e - 1);
    return r >= 55296 && r <= 56319 && (this.str = this.str.slice(0, e - 1) + "�", n.str = "�" + n.str.slice(1)), n;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.str += e.str, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    e.writeString(n === 0 ? this.str : this.str.slice(n));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
}
const c$ = 0, u$ = 1, f$ = 2, d$ = 3, h$ = 4, p$ = 6;
class ls {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(e) {
    this.type = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new ls(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(e) {
    throw Vi();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, n) {
    this.type._integrate(e.doc, n);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.deleted ? n.id.clock < (e.beforeState.get(n.id.client) || 0) && e._mergeStructs.push(n) : n.delete(e), n = n.right;
    this.type._map.forEach((r) => {
      r.deleted ? r.id.clock < (e.beforeState.get(r.id.client) || 0) && e._mergeStructs.push(r) : r.delete(e);
    }), e.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.gc(e, !0), n = n.right;
    this.type._start = null, this.type._map.forEach(
      /** @param {Item | null} item */
      (r) => {
        for (; r !== null; )
          r.gc(e, !0), r = r.left;
      }
    ), this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, n) {
    this.type._write(e);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
}
const K3 = (t, e, n) => {
  const { client: r, clock: i } = e.id, o = new _r(
    kt(r, i + n),
    e,
    kt(r, i + n - 1),
    e.right,
    e.rightOrigin,
    e.parent,
    e.parentSub,
    e.content.splice(n)
  );
  return e.deleted && o.markDeleted(), e.keep && (o.keep = !0), e.redone !== null && (o.redone = kt(e.redone.client, e.redone.clock + n)), e.right = o, o.right !== null && (o.right.left = o), t._mergeStructs.push(o), o.parentSub !== null && o.right === null && o.parent._map.set(o.parentSub, o), e.length = n, o;
};
let _r = class _0 extends Z3 {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(e, n, r, i, o, a, s, l) {
    super(e, l.getLength()), this.origin = r, this.left = n, this.right = i, this.rightOrigin = o, this.parent = a, this.parentSub = s, this.redone = null, this.content = l, this.info = this.content.isCountable() ? yT : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(e) {
    (this.info & nv) > 0 !== e && (this.info ^= nv);
  }
  get marker() {
    return (this.info & nv) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & mT) > 0;
  }
  set keep(e) {
    this.keep !== e && (this.info ^= mT);
  }
  get countable() {
    return (this.info & yT) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & tv) > 0;
  }
  set deleted(e) {
    this.deleted !== e && (this.info ^= tv);
  }
  markDeleted() {
    this.info |= tv;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, n) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= ur(n, this.origin.client))
      return this.origin.client;
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= ur(n, this.rightOrigin.client))
      return this.rightOrigin.client;
    if (this.parent && this.parent.constructor === Rp && this.id.client !== this.parent.client && this.parent.clock >= ur(n, this.parent.client))
      return this.parent.client;
    if (this.origin && (this.left = UT(e, n, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = Qa(e, this.rightOrigin), this.rightOrigin = this.right.id), this.left && this.left.constructor === Pa || this.right && this.right.constructor === Pa)
      this.parent = null;
    else if (!this.parent)
      this.left && this.left.constructor === _0 && (this.parent = this.left.parent, this.parentSub = this.left.parentSub), this.right && this.right.constructor === _0 && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
    else if (this.parent.constructor === Rp) {
      const r = sv(n, this.parent);
      r.constructor === Pa ? this.parent = null : this.parent = /** @type {ContentType} */
      r.content.type;
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, n) {
    if (n > 0 && (this.id.clock += n, this.left = UT(e, e.doc.store, kt(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(n), this.length -= n), this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let r = this.left, i;
        if (r !== null)
          i = r.right;
        else if (this.parentSub !== null)
          for (i = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; i !== null && i.left !== null; )
            i = i.left;
        else
          i = /** @type {AbstractType<any>} */
          this.parent._start;
        const o = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set();
        for (; i !== null && i !== this.right; ) {
          if (a.add(i), o.add(i), Jh(this.origin, i.origin)) {
            if (i.id.client < this.id.client)
              r = i, o.clear();
            else if (Jh(this.rightOrigin, i.rightOrigin))
              break;
          } else if (i.origin !== null && a.has(sv(e.doc.store, i.origin)))
            o.has(sv(e.doc.store, i.origin)) || (r = i, o.clear());
          else
            break;
          i = i.right;
        }
        this.left = r;
      }
      if (this.left !== null) {
        const r = this.left.right;
        this.right = r, this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null)
          for (r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; r !== null && r.left !== null; )
            r = r.left;
        else
          r = /** @type {AbstractType<any>} */
          this.parent._start, this.parent._start = this;
        this.right = r;
      }
      this.right !== null ? this.right.left = this : this.parentSub !== null && (this.parent._map.set(this.parentSub, this), this.left !== null && this.left.delete(e)), this.parentSub === null && this.countable && !this.deleted && (this.parent._length += this.length), O3(e.doc.store, this), this.content.integrate(e, this), RT(
        e,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      ), /** @type {AbstractType<any>} */
      (this.parent._item !== null && /** @type {AbstractType<any>} */
      this.parent._item.deleted || this.parentSub !== null && this.right !== null) && this.delete(e);
    } else
      new Pa(this.id, this.length).integrate(e, 0);
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let e = this.right;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let e = this.left;
    for (; e !== null && e.deleted; )
      e = e.left;
    return e;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : kt(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(e) {
    if (this.constructor === e.constructor && Jh(e.origin, this.lastId) && this.right === e && Jh(this.rightOrigin, e.rightOrigin) && this.id.client === e.id.client && this.id.clock + this.length === e.id.clock && this.deleted === e.deleted && this.redone === null && e.redone === null && this.content.constructor === e.content.constructor && this.content.mergeWith(e.content)) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      return n && n.forEach((r) => {
        r.p === e && (r.p = this, !this.deleted && this.countable && (r.index -= this.length));
      }), e.keep && (this.keep = !0), this.right = e.right, this.right !== null && (this.right.left = this), this.length += e.length, !0;
    }
    return !1;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(e) {
    if (!this.deleted) {
      const n = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      this.countable && this.parentSub === null && (n._length -= this.length), this.markDeleted(), U3(e.deleteSet, this.id.client, this.id.clock, this.length), RT(e, n, this.parentSub), this.content.delete(e);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(e, n) {
    if (!this.deleted)
      throw Ka();
    this.content.gc(e), n ? $z(e, this, new Pa(this.id, this.length)) : this.content = new Dg(this.length);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(e, n) {
    const r = n > 0 ? kt(this.id.client, this.id.clock + n - 1) : this.origin, i = this.rightOrigin, o = this.parentSub, a = this.content.getRef() & FL | (r === null ? 0 : gg) | // origin is defined
    (i === null ? 0 : m3) | // right origin is defined
    (o === null ? 0 : UL);
    if (e.writeInfo(a), r !== null && e.writeLeftID(r), i !== null && e.writeRightID(i), r === null && i === null) {
      const s = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (s._item !== void 0) {
        const l = s._item;
        if (l === null) {
          const u = xd(s);
          e.writeParentInfo(!0), e.writeString(u);
        } else
          e.writeParentInfo(!1), e.writeLeftID(l.id);
      } else s.constructor === String ? (e.writeParentInfo(!0), e.writeString(s)) : s.constructor === Rp ? (e.writeParentInfo(!1), e.writeLeftID(s)) : Ka();
      o !== null && e.writeString(o);
    }
    this.content.write(e, n);
  }
};
const Q3 = (
  /** @type {any} */
  typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}
), eU = "__ $YJS$ __";
Q3[eU] === !0 && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
Q3[eU] = !0;
const kJ = new ns("y-sync");
new ns("y-undo");
new ns("yjs-cursor");
const AJ = (t, e, n) => {
  if (t === 0)
    return av(e, 0, -1);
  let r = e._first === null ? null : (
    /** @type {Y.ContentType} */
    e._first.content.type
  );
  for (; r !== null && e !== r; ) {
    if (r instanceof Cd) {
      if (r._length >= t)
        return av(r, t, -1);
      if (t -= r._length, r._item !== null && r._item.next !== null)
        r = /** @type {Y.ContentType} */
        r._item.next.content.type;
      else {
        do
          r = r._item === null ? null : r._item.parent, t--;
        while (r !== e && r !== null && r._item !== null && r._item.next === null);
        r !== null && r !== e && (r = r._item === null ? null : (
          /** @type {Y.ContentType} */
          /** @type Y.Item */
          r._item.next.content.type
        ));
      }
    } else {
      const i = (
        /** @type {any} */
        (n.get(r) || { nodeSize: 0 }).nodeSize
      );
      if (r._first !== null && t < i)
        r = /** @type {Y.ContentType} */
        r._first.content.type, t--;
      else {
        if (t === 1 && r._length === 0 && i > 1)
          return new yg(r._item === null ? null : r._item.id, r._item === null ? xd(r) : null, null);
        if (t -= i, r._item !== null && r._item.next !== null)
          r = /** @type {Y.ContentType} */
          r._item.next.content.type;
        else {
          if (t === 0)
            return r = r._item === null ? r : r._item.parent, new yg(r._item === null ? null : r._item.id, r._item === null ? xd(r) : null, null);
          do
            r = /** @type {Y.Item} */
            r._item.parent, t--;
          while (r !== e && /** @type {Y.Item} */
          r._item.next === null);
          r !== e && (r = /** @type {Y.ContentType} */
          /** @type {Y.Item} */
          /** @type {Y.Item} */
          r._item.next.content.type);
        }
      }
    }
    if (r === null)
      throw Ka();
    if (t === 0 && r.constructor !== Cd && r !== e)
      return g$(r._item.parent, r._item);
  }
  return av(e, e._length, -1);
}, g$ = (t, e) => {
  let n = null, r = null;
  return t._item === null ? r = xd(t) : n = kt(t._item.id.client, t._item.id.clock), new yg(n, r, e.id);
}, m$ = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", y$ = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", fu = (t, e) => {
  for (const n in e)
    t[n] = e[n];
  return t;
}, k0 = "numeric", A0 = "ascii", U0 = "alpha", Ip = "asciinumeric", Qh = "alphanumeric", F0 = "domain", tU = "emoji", b$ = "scheme", v$ = "slashscheme", NT = "whitespace";
function x$(t, e) {
  return t in e || (e[t] = []), e[t];
}
function Qs(t, e, n) {
  e[k0] && (e[Ip] = !0, e[Qh] = !0), e[A0] && (e[Ip] = !0, e[U0] = !0), e[Ip] && (e[Qh] = !0), e[U0] && (e[Qh] = !0), e[Qh] && (e[F0] = !0), e[tU] && (e[F0] = !0);
  for (const r in e) {
    const i = x$(r, n);
    i.indexOf(t) < 0 && i.push(t);
  }
}
function D$(t, e) {
  const n = {};
  for (const r in e)
    e[r].indexOf(t) >= 0 && (n[r] = !0);
  return n;
}
function lr(t) {
  t === void 0 && (t = null), this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
lr.groups = {};
lr.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this, n = e.j[t];
    if (n)
      return n;
    for (let r = 0; r < e.jr.length; r++) {
      const i = e.jr[r][0], o = e.jr[r][1];
      if (o && i.test(t))
        return o;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e) {
    return e === void 0 && (e = !1), e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, n, r) {
    for (let i = 0; i < t.length; i++)
      this.tt(t[i], e, n, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, n, r) {
    r = r || lr.groups;
    let i;
    return e && e.j ? i = e : (i = new lr(e), n && r && Qs(e, n, r)), this.jr.push([t, i]), i;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, n, r) {
    let i = this;
    const o = t.length;
    if (!o)
      return i;
    for (let a = 0; a < o - 1; a++)
      i = i.tt(t[a]);
    return i.tt(t[o - 1], e, n, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, n, r) {
    r = r || lr.groups;
    const i = this;
    if (e && e.j)
      return i.j[t] = e, e;
    const o = e;
    let a, s = i.go(t);
    if (s ? (a = new lr(), fu(a.j, s.j), a.jr.push.apply(a.jr, s.jr), a.jd = s.jd, a.t = s.t) : a = new lr(), o) {
      if (r)
        if (a.t && typeof a.t == "string") {
          const l = fu(D$(a.t, r), n);
          Qs(o, l, r);
        } else n && Qs(o, n, r);
      a.t = o;
    }
    return i.j[t] = a, a;
  }
};
const ot = (t, e, n, r, i) => t.ta(e, n, r, i), jr = (t, e, n, r, i) => t.tr(e, n, r, i), PT = (t, e, n, r, i) => t.ts(e, n, r, i), Ne = (t, e, n, r, i) => t.tt(e, n, r, i), Ro = "WORD", R0 = "UWORD", Ed = "LOCALHOST", O0 = "TLD", I0 = "UTLD", Bp = "SCHEME", Wc = "SLASH_SCHEME", $2 = "NUM", nU = "WS", j2 = "NL", rd = "OPENBRACE", id = "CLOSEBRACE", wg = "OPENBRACKET", Sg = "CLOSEBRACKET", Tg = "OPENPAREN", Cg = "CLOSEPAREN", Eg = "OPENANGLEBRACKET", _g = "CLOSEANGLEBRACKET", kg = "FULLWIDTHLEFTPAREN", Ag = "FULLWIDTHRIGHTPAREN", Ug = "LEFTCORNERBRACKET", Fg = "RIGHTCORNERBRACKET", Rg = "LEFTWHITECORNERBRACKET", Og = "RIGHTWHITECORNERBRACKET", Ig = "FULLWIDTHLESSTHAN", Bg = "FULLWIDTHGREATERTHAN", Mg = "AMPERSAND", Ng = "APOSTROPHE", Pg = "ASTERISK", Ia = "AT", Wg = "BACKSLASH", Lg = "BACKTICK", zg = "CARET", Wa = "COLON", H2 = "COMMA", $g = "DOLLAR", Ni = "DOT", jg = "EQUALS", V2 = "EXCLAMATION", Pi = "HYPHEN", Hg = "PERCENT", Vg = "PIPE", qg = "PLUS", Xg = "POUND", Gg = "QUERY", q2 = "QUOTE", X2 = "SEMI", Wi = "SLASH", od = "TILDE", Jg = "UNDERSCORE", rU = "EMOJI", Yg = "SYM";
var iU = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD: Ro,
  UWORD: R0,
  LOCALHOST: Ed,
  TLD: O0,
  UTLD: I0,
  SCHEME: Bp,
  SLASH_SCHEME: Wc,
  NUM: $2,
  WS: nU,
  NL: j2,
  OPENBRACE: rd,
  CLOSEBRACE: id,
  OPENBRACKET: wg,
  CLOSEBRACKET: Sg,
  OPENPAREN: Tg,
  CLOSEPAREN: Cg,
  OPENANGLEBRACKET: Eg,
  CLOSEANGLEBRACKET: _g,
  FULLWIDTHLEFTPAREN: kg,
  FULLWIDTHRIGHTPAREN: Ag,
  LEFTCORNERBRACKET: Ug,
  RIGHTCORNERBRACKET: Fg,
  LEFTWHITECORNERBRACKET: Rg,
  RIGHTWHITECORNERBRACKET: Og,
  FULLWIDTHLESSTHAN: Ig,
  FULLWIDTHGREATERTHAN: Bg,
  AMPERSAND: Mg,
  APOSTROPHE: Ng,
  ASTERISK: Pg,
  AT: Ia,
  BACKSLASH: Wg,
  BACKTICK: Lg,
  CARET: zg,
  COLON: Wa,
  COMMA: H2,
  DOLLAR: $g,
  DOT: Ni,
  EQUALS: jg,
  EXCLAMATION: V2,
  HYPHEN: Pi,
  PERCENT: Hg,
  PIPE: Vg,
  PLUS: qg,
  POUND: Xg,
  QUERY: Gg,
  QUOTE: q2,
  SEMI: X2,
  SLASH: Wi,
  TILDE: od,
  UNDERSCORE: Jg,
  EMOJI: rU,
  SYM: Yg
});
const Ac = /[a-z]/, uv = new RegExp("\\p{L}", "u"), fv = new RegExp("\\p{Emoji}", "u"), dv = /\d/, WT = /\s/, LT = `
`, w$ = "️", S$ = "‍";
let ep = null, tp = null;
function T$(t) {
  t === void 0 && (t = []);
  const e = {};
  lr.groups = e;
  const n = new lr();
  ep == null && (ep = zT(m$)), tp == null && (tp = zT(y$)), Ne(n, "'", Ng), Ne(n, "{", rd), Ne(n, "}", id), Ne(n, "[", wg), Ne(n, "]", Sg), Ne(n, "(", Tg), Ne(n, ")", Cg), Ne(n, "<", Eg), Ne(n, ">", _g), Ne(n, "（", kg), Ne(n, "）", Ag), Ne(n, "「", Ug), Ne(n, "」", Fg), Ne(n, "『", Rg), Ne(n, "』", Og), Ne(n, "＜", Ig), Ne(n, "＞", Bg), Ne(n, "&", Mg), Ne(n, "*", Pg), Ne(n, "@", Ia), Ne(n, "`", Lg), Ne(n, "^", zg), Ne(n, ":", Wa), Ne(n, ",", H2), Ne(n, "$", $g), Ne(n, ".", Ni), Ne(n, "=", jg), Ne(n, "!", V2), Ne(n, "-", Pi), Ne(n, "%", Hg), Ne(n, "|", Vg), Ne(n, "+", qg), Ne(n, "#", Xg), Ne(n, "?", Gg), Ne(n, '"', q2), Ne(n, "/", Wi), Ne(n, ";", X2), Ne(n, "~", od), Ne(n, "_", Jg), Ne(n, "\\", Wg);
  const r = jr(n, dv, $2, {
    [k0]: !0
  });
  jr(r, dv, r);
  const i = jr(n, Ac, Ro, {
    [A0]: !0
  });
  jr(i, Ac, i);
  const o = jr(n, uv, R0, {
    [U0]: !0
  });
  jr(o, Ac), jr(o, uv, o);
  const a = jr(n, WT, nU, {
    [NT]: !0
  });
  Ne(n, LT, j2, {
    [NT]: !0
  }), Ne(a, LT), jr(a, WT, a);
  const s = jr(n, fv, rU, {
    [tU]: !0
  });
  jr(s, fv, s), Ne(s, w$, s);
  const l = Ne(s, S$);
  jr(l, fv, s);
  const u = [[Ac, i]], f = [[Ac, null], [uv, o]];
  for (let h = 0; h < ep.length; h++)
    _a(n, ep[h], O0, Ro, u);
  for (let h = 0; h < tp.length; h++)
    _a(n, tp[h], I0, R0, f);
  Qs(O0, {
    tld: !0,
    ascii: !0
  }, e), Qs(I0, {
    utld: !0,
    alpha: !0
  }, e), _a(n, "file", Bp, Ro, u), _a(n, "mailto", Bp, Ro, u), _a(n, "http", Wc, Ro, u), _a(n, "https", Wc, Ro, u), _a(n, "ftp", Wc, Ro, u), _a(n, "ftps", Wc, Ro, u), Qs(Bp, {
    scheme: !0,
    ascii: !0
  }, e), Qs(Wc, {
    slashscheme: !0,
    ascii: !0
  }, e), t = t.sort((h, p) => h[0] > p[0] ? 1 : -1);
  for (let h = 0; h < t.length; h++) {
    const p = t[h][0], b = t[h][1] ? {
      [b$]: !0
    } : {
      [v$]: !0
    };
    p.indexOf("-") >= 0 ? b[F0] = !0 : Ac.test(p) ? dv.test(p) ? b[Ip] = !0 : b[A0] = !0 : b[k0] = !0, PT(n, p, p, b);
  }
  return PT(n, "localhost", Ed, {
    ascii: !0
  }), n.jd = new lr(Yg), {
    start: n,
    tokens: fu({
      groups: e
    }, iU)
  };
}
function C$(t, e) {
  const n = E$(e.replace(/[A-Z]/g, (s) => s.toLowerCase())), r = n.length, i = [];
  let o = 0, a = 0;
  for (; a < r; ) {
    let s = t, l = null, u = 0, f = null, h = -1, p = -1;
    for (; a < r && (l = s.go(n[a])); )
      s = l, s.accepts() ? (h = 0, p = 0, f = s) : h >= 0 && (h += n[a].length, p++), u += n[a].length, o += n[a].length, a++;
    o -= h, a -= p, u -= h, i.push({
      t: f.t,
      // token type/name
      v: e.slice(o - u, o),
      // string value
      s: o - u,
      // start index
      e: o
      // end index (excluding)
    });
  }
  return i;
}
function E$(t) {
  const e = [], n = t.length;
  let r = 0;
  for (; r < n; ) {
    let i = t.charCodeAt(r), o, a = i < 55296 || i > 56319 || r + 1 === n || (o = t.charCodeAt(r + 1)) < 56320 || o > 57343 ? t[r] : t.slice(r, r + 2);
    e.push(a), r += a.length;
  }
  return e;
}
function _a(t, e, n, r, i) {
  let o;
  const a = e.length;
  for (let s = 0; s < a - 1; s++) {
    const l = e[s];
    t.j[l] ? o = t.j[l] : (o = new lr(r), o.jr = i.slice(), t.j[l] = o), t = o;
  }
  return o = new lr(n), o.jr = i.slice(), t.j[e[a - 1]] = o, o;
}
function zT(t) {
  const e = [], n = [];
  let r = 0, i = "0123456789";
  for (; r < t.length; ) {
    let o = 0;
    for (; i.indexOf(t[r + o]) >= 0; )
      o++;
    if (o > 0) {
      e.push(n.join(""));
      for (let a = parseInt(t.substring(r, r + o), 10); a > 0; a--)
        n.pop();
      r += o;
    } else
      n.push(t[r]), r++;
  }
  return e;
}
const _d = {
  defaultProtocol: "http",
  events: null,
  format: $T,
  formatHref: $T,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function G2(t, e) {
  e === void 0 && (e = null);
  let n = fu({}, _d);
  t && (n = fu(n, t instanceof G2 ? t.o : t));
  const r = n.ignoreTags, i = [];
  for (let o = 0; o < r.length; o++)
    i.push(r[o].toUpperCase());
  this.o = n, e && (this.defaultRender = e), this.ignoreTags = i;
}
G2.prototype = {
  o: _d,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, n) {
    const r = e != null;
    let i = this.o[t];
    return i && (typeof i == "object" ? (i = n.t in i ? i[n.t] : _d[t], typeof i == "function" && r && (i = i(e, n))) : typeof i == "function" && r && (i = i(e, n.t, n)), i);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, n) {
    let r = this.o[t];
    return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  }
};
function $T(t) {
  return t;
}
function oU(t, e) {
  this.t = "token", this.v = t, this.tk = e;
}
oU.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
  */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(), n = t.get("truncate", e, this), r = t.get("format", e, this);
    return n && r.length > n ? r.substring(0, n) + "…" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t) {
    return t === void 0 && (t = _d.defaultProtocol), {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this, n = this.toHref(t.get("defaultProtocol")), r = t.get("formatHref", n, this), i = t.get("tagName", n, e), o = this.toFormattedString(t), a = {}, s = t.get("className", n, e), l = t.get("target", n, e), u = t.get("rel", n, e), f = t.getObj("attributes", n, e), h = t.getObj("events", n, e);
    return a.href = r, s && (a.class = s), l && (a.target = l), u && (a.rel = u), f && fu(a, f), {
      tagName: i,
      attributes: a,
      content: o,
      eventListeners: h
    };
  }
};
function km(t, e) {
  class n extends oU {
    constructor(i, o) {
      super(i, o), this.t = t;
    }
  }
  for (const r in e)
    n.prototype[r] = e[r];
  return n.t = t, n;
}
const jT = km("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), HT = km("text"), _$ = km("nl"), np = km("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t) {
    return t === void 0 && (t = _d.defaultProtocol), this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== Ed && t[1].t === Wa;
  }
}), Hr = (t) => new lr(t);
function k$(t) {
  let {
    groups: e
  } = t;
  const n = e.domain.concat([Mg, Pg, Ia, Wg, Lg, zg, $g, jg, Pi, $2, Hg, Vg, qg, Xg, Wi, Yg, od, Jg]), r = [Ng, Wa, H2, Ni, V2, Gg, q2, X2, Eg, _g, rd, id, Sg, wg, Tg, Cg, kg, Ag, Ug, Fg, Rg, Og, Ig, Bg], i = [Mg, Ng, Pg, Wg, Lg, zg, $g, jg, Pi, rd, id, Hg, Vg, qg, Xg, Gg, Wi, Yg, od, Jg], o = Hr(), a = Ne(o, od);
  ot(a, i, a), ot(a, e.domain, a);
  const s = Hr(), l = Hr(), u = Hr();
  ot(o, e.domain, s), ot(o, e.scheme, l), ot(o, e.slashscheme, u), ot(s, i, a), ot(s, e.domain, s);
  const f = Ne(s, Ia);
  Ne(a, Ia, f), Ne(l, Ia, f), Ne(u, Ia, f);
  const h = Ne(a, Ni);
  ot(h, i, a), ot(h, e.domain, a);
  const p = Hr();
  ot(f, e.domain, p), ot(p, e.domain, p);
  const y = Ne(p, Ni);
  ot(y, e.domain, p);
  const b = Hr(jT);
  ot(y, e.tld, b), ot(y, e.utld, b), Ne(f, Ed, b);
  const x = Ne(p, Pi);
  ot(x, e.domain, p), ot(b, e.domain, p), Ne(b, Ni, y), Ne(b, Pi, x);
  const v = Ne(b, Wa);
  ot(v, e.numeric, jT);
  const D = Ne(s, Pi), S = Ne(s, Ni);
  ot(D, e.domain, s), ot(S, i, a), ot(S, e.domain, s);
  const E = Hr(np);
  ot(S, e.tld, E), ot(S, e.utld, E), ot(E, e.domain, s), ot(E, i, a), Ne(E, Ni, S), Ne(E, Pi, D), Ne(E, Ia, f);
  const I = Ne(E, Wa), R = Hr(np);
  ot(I, e.numeric, R);
  const O = Hr(np), N = Hr();
  ot(O, n, O), ot(O, r, N), ot(N, n, O), ot(N, r, N), Ne(E, Wi, O), Ne(R, Wi, O);
  const q = Ne(l, Wa), $ = Ne(u, Wa), le = Ne($, Wi), ve = Ne(le, Wi);
  ot(l, e.domain, s), Ne(l, Ni, S), Ne(l, Pi, D), ot(u, e.domain, s), Ne(u, Ni, S), Ne(u, Pi, D), ot(q, e.domain, O), Ne(q, Wi, O), ot(ve, e.domain, O), ot(ve, n, O), Ne(ve, Wi, O);
  const M = [
    [rd, id],
    // {}
    [wg, Sg],
    // []
    [Tg, Cg],
    // ()
    [Eg, _g],
    // <>
    [kg, Ag],
    // （）
    [Ug, Fg],
    // 「」
    [Rg, Og],
    // 『』
    [Ig, Bg]
    // ＜＞
  ];
  for (let ee = 0; ee < M.length; ee++) {
    const [A, oe] = M[ee], j = Ne(O, A);
    Ne(N, A, j), Ne(j, oe, O);
    const Q = Hr(np);
    ot(j, n, Q);
    const G = Hr();
    ot(j, r), ot(Q, n, Q), ot(Q, r, G), ot(G, n, Q), ot(G, r, G), Ne(Q, oe, O), Ne(G, oe, O);
  }
  return Ne(o, Ed, E), Ne(o, j2, _$), {
    start: o,
    tokens: iU
  };
}
function A$(t, e, n) {
  let r = n.length, i = 0, o = [], a = [];
  for (; i < r; ) {
    let s = t, l = null, u = null, f = 0, h = null, p = -1;
    for (; i < r && !(l = s.go(n[i].t)); )
      a.push(n[i++]);
    for (; i < r && (u = l || s.go(n[i].t)); )
      l = null, s = u, s.accepts() ? (p = 0, h = s) : p >= 0 && p++, i++, f++;
    if (p < 0)
      i -= f, i < r && (a.push(n[i]), i++);
    else {
      a.length > 0 && (o.push(hv(HT, e, a)), a = []), i -= p, f -= p;
      const y = h.t, b = n.slice(i - f, i);
      o.push(hv(y, e, b));
    }
  }
  return a.length > 0 && o.push(hv(HT, e, a)), o;
}
function hv(t, e, n) {
  const r = n[0].s, i = n[n.length - 1].e, o = e.slice(r, i);
  return new t(o, n);
}
const U$ = typeof console < "u" && console && console.warn || (() => {
}), F$ = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", It = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function UJ() {
  lr.groups = {}, It.scanner = null, It.parser = null, It.tokenQueue = [], It.pluginQueue = [], It.customSchemes = [], It.initialized = !1;
}
function FJ(t, e) {
  if (e === void 0 && (e = !1), It.initialized && U$(`linkifyjs: already initialized - will not register custom scheme "${t}" ${F$}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  It.customSchemes.push([t, e]);
}
function R$() {
  It.scanner = T$(It.customSchemes);
  for (let t = 0; t < It.tokenQueue.length; t++)
    It.tokenQueue[t][1]({
      scanner: It.scanner
    });
  It.parser = k$(It.scanner.tokens);
  for (let t = 0; t < It.pluginQueue.length; t++)
    It.pluginQueue[t][1]({
      scanner: It.scanner,
      parser: It.parser
    });
  It.initialized = !0;
}
function O$(t) {
  return It.initialized || R$(), A$(It.parser.start, t, C$(It.scanner.start, t));
}
function RJ(t, e, n) {
  if (e === void 0 && (e = null), n === void 0 && (n = null), e && typeof e == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    n = e, e = null;
  }
  const r = new G2(n), i = O$(t), o = [];
  for (let a = 0; a < i.length; a++) {
    const s = i[a];
    s.isLink && (!e || s.t === e) && r.check(s) && o.push(s.toFormattedObject(r));
  }
  return o;
}
var Zg = 200, en = function() {
};
en.prototype.append = function(e) {
  return e.length ? (e = en.from(e), !this.length && e || e.length < Zg && this.leafAppend(e) || this.length < Zg && e.leafPrepend(this) || this.appendInner(e)) : this;
};
en.prototype.prepend = function(e) {
  return e.length ? en.from(e).append(this) : this;
};
en.prototype.appendInner = function(e) {
  return new I$(this, e);
};
en.prototype.slice = function(e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? en.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
};
en.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
en.prototype.forEach = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0);
};
en.prototype.map = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(o, a) {
    return i.push(e(o, a));
  }, n, r), i;
};
en.from = function(e) {
  return e instanceof en ? e : e && e.length ? new aU(e) : en.empty;
};
var aU = /* @__PURE__ */ function(t) {
  function e(r) {
    t.call(this), this.values = r;
  }
  t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(i, o) {
    return i == 0 && o == this.length ? this : new e(this.values.slice(i, o));
  }, e.prototype.getInner = function(i) {
    return this.values[i];
  }, e.prototype.forEachInner = function(i, o, a, s) {
    for (var l = o; l < a; l++)
      if (i(this.values[l], s + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(i, o, a, s) {
    for (var l = o - 1; l >= a; l--)
      if (i(this.values[l], s + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(i) {
    if (this.length + i.length <= Zg)
      return new e(this.values.concat(i.flatten()));
  }, e.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= Zg)
      return new e(i.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, n), e;
}(en);
en.empty = new aU([]);
var I$ = /* @__PURE__ */ function(t) {
  function e(n, r) {
    t.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1;
  }
  return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, i, o, a) {
    var s = this.left.length;
    if (i < s && this.left.forEachInner(r, i, Math.min(o, s), a) === !1 || o > s && this.right.forEachInner(r, Math.max(i - s, 0), Math.min(this.length, o) - s, a + s) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, o, a) {
    var s = this.left.length;
    if (i > s && this.right.forEachInvertedInner(r, i - s, Math.max(o, s) - s, a + s) === !1 || o < s && this.left.forEachInvertedInner(r, Math.min(i, s), o, a) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var o = this.left.length;
    return i <= o ? this.left.slice(r, i) : r >= o ? this.right.slice(r - o, i - o) : this.left.slice(r, o).append(this.right.slice(0, i - o));
  }, e.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new e(this.left, i);
  }, e.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new e(i, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
}(en);
const B$ = 500;
class fi {
  constructor(e, n) {
    this.items = e, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, n) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, o;
    n && (i = this.remapping(r, this.items.length), o = i.maps.length);
    let a = e.tr, s, l, u = [], f = [];
    return this.items.forEach((h, p) => {
      if (!h.step) {
        i || (i = this.remapping(r, p + 1), o = i.maps.length), o--, f.push(h);
        return;
      }
      if (i) {
        f.push(new Li(h.map));
        let y = h.step.map(i.slice(o)), b;
        y && a.maybeStep(y).doc && (b = a.mapping.maps[a.mapping.maps.length - 1], u.push(new Li(b, void 0, void 0, u.length + f.length))), o--, b && i.appendMap(b, o);
      } else
        a.maybeStep(h.step);
      if (h.selection)
        return s = i ? h.selection.map(i.slice(o)) : h.selection, l = new fi(this.items.slice(0, r).append(f.reverse().concat(u)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: a, selection: s };
  }
  // Create a new branch with the given transform added.
  addTransform(e, n, r, i) {
    let o = [], a = this.eventCount, s = this.items, l = !i && s.length ? s.get(s.length - 1) : null;
    for (let f = 0; f < e.steps.length; f++) {
      let h = e.steps[f].invert(e.docs[f]), p = new Li(e.mapping.maps[f], h, n), y;
      (y = l && l.merge(p)) && (p = y, f ? o.pop() : s = s.slice(0, s.length - 1)), o.push(p), n && (a++, n = void 0), i || (l = p);
    }
    let u = a - r.depth;
    return u > N$ && (s = M$(s, u), a -= u), new fi(s.append(o), a);
  }
  remapping(e, n) {
    let r = new jc();
    return this.items.forEach((i, o) => {
      let a = i.mirrorOffset != null && o - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, a);
    }, e, n), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new fi(this.items.append(e.map((n) => new Li(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, n) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - n), o = e.mapping, a = e.steps.length, s = this.eventCount;
    this.items.forEach((p) => {
      p.selection && s--;
    }, i);
    let l = n;
    this.items.forEach((p) => {
      let y = o.getMirror(--l);
      if (y == null)
        return;
      a = Math.min(a, y);
      let b = o.maps[y];
      if (p.step) {
        let x = e.steps[y].invert(e.docs[y]), v = p.selection && p.selection.map(o.slice(l + 1, y));
        v && s++, r.push(new Li(b, x, v));
      } else
        r.push(new Li(b));
    }, i);
    let u = [];
    for (let p = n; p < a; p++)
      u.push(new Li(o.maps[p]));
    let f = this.items.slice(0, i).append(u).append(r), h = new fi(f, s);
    return h.emptyItemCount() > B$ && (h = h.compress(this.items.length - r.length)), h;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((n) => {
      n.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let n = this.remapping(0, e), r = n.maps.length, i = [], o = 0;
    return this.items.forEach((a, s) => {
      if (s >= e)
        i.push(a), a.selection && o++;
      else if (a.step) {
        let l = a.step.map(n.slice(r)), u = l && l.getMap();
        if (r--, u && n.appendMap(u, r), l) {
          let f = a.selection && a.selection.map(n.slice(r));
          f && o++;
          let h = new Li(u.invert(), l, f), p, y = i.length - 1;
          (p = i.length && i[y].merge(h)) ? i[y] = p : i.push(h);
        }
      } else a.map && r--;
    }, this.items.length, 0), new fi(en.from(i.reverse()), o);
  }
}
fi.empty = new fi(en.empty, 0);
function M$(t, e) {
  let n;
  return t.forEach((r, i) => {
    if (r.selection && e-- == 0)
      return n = i, !1;
  }), t.slice(n);
}
class Li {
  constructor(e, n, r, i) {
    this.map = e, this.step = n, this.selection = r, this.mirrorOffset = i;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n)
        return new Li(n.getMap().invert(), n, this.selection);
    }
  }
}
class Ba {
  constructor(e, n, r, i, o) {
    this.done = e, this.undone = n, this.prevRanges = r, this.prevTime = i, this.prevComposition = o;
  }
}
const N$ = 20;
function P$(t, e, n, r) {
  let i = n.getMeta(sl), o;
  if (i)
    return i.historyState;
  n.getMeta(z$) && (t = new Ba(t.done, t.undone, null, 0, -1));
  let a = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return t;
  if (a && a.getMeta(sl))
    return a.getMeta(sl).redo ? new Ba(t.done.addTransform(n, void 0, r, Mp(e)), t.undone, VT(n.mapping.maps), t.prevTime, t.prevComposition) : new Ba(t.done, t.undone.addTransform(n, void 0, r, Mp(e)), null, t.prevTime, t.prevComposition);
  if (n.getMeta("addToHistory") !== !1 && !(a && a.getMeta("addToHistory") === !1)) {
    let s = n.getMeta("composition"), l = t.prevTime == 0 || !a && t.prevComposition != s && (t.prevTime < (n.time || 0) - r.newGroupDelay || !W$(n, t.prevRanges)), u = a ? pv(t.prevRanges, n.mapping) : VT(n.mapping.maps);
    return new Ba(t.done.addTransform(n, l ? e.selection.getBookmark() : void 0, r, Mp(e)), fi.empty, u, n.time, s ?? t.prevComposition);
  } else return (o = n.getMeta("rebased")) ? new Ba(t.done.rebased(n, o), t.undone.rebased(n, o), pv(t.prevRanges, n.mapping), t.prevTime, t.prevComposition) : new Ba(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), pv(t.prevRanges, n.mapping), t.prevTime, t.prevComposition);
}
function W$(t, e) {
  if (!e)
    return !1;
  if (!t.docChanged)
    return !0;
  let n = !1;
  return t.mapping.maps[0].forEach((r, i) => {
    for (let o = 0; o < e.length; o += 2)
      r <= e[o + 1] && i >= e[o] && (n = !0);
  }), n;
}
function VT(t) {
  let e = [];
  for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
    t[n].forEach((r, i, o, a) => e.push(o, a));
  return e;
}
function pv(t, e) {
  if (!t)
    return null;
  let n = [];
  for (let r = 0; r < t.length; r += 2) {
    let i = e.map(t[r], 1), o = e.map(t[r + 1], -1);
    i <= o && n.push(i, o);
  }
  return n;
}
function L$(t, e, n) {
  let r = Mp(e), i = sl.get(e).spec.config, o = (n ? t.undone : t.done).popEvent(e, r);
  if (!o)
    return null;
  let a = o.selection.resolve(o.transform.doc), s = (n ? t.done : t.undone).addTransform(o.transform, e.selection.getBookmark(), i, r), l = new Ba(n ? s : o.remaining, n ? o.remaining : s, null, 0, -1);
  return o.transform.setSelection(a).setMeta(sl, { redo: n, historyState: l });
}
let gv = !1, qT = null;
function Mp(t) {
  let e = t.plugins;
  if (qT != e) {
    gv = !1, qT = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        gv = !0;
        break;
      }
  }
  return gv;
}
const sl = new ns("history"), z$ = new ns("closeHistory");
function OJ(t = {}) {
  return t = {
    depth: t.depth || 100,
    newGroupDelay: t.newGroupDelay || 500
  }, new xu({
    key: sl,
    state: {
      init() {
        return new Ba(fi.empty, fi.empty, null, 0, -1);
      },
      apply(e, n, r) {
        return P$(n, r, e, t);
      }
    },
    config: t,
    props: {
      handleDOMEvents: {
        beforeinput(e, n) {
          let r = n.inputType, i = r == "historyUndo" ? $$ : r == "historyRedo" ? j$ : null;
          return i ? (n.preventDefault(), i(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function sU(t, e) {
  return (n, r) => {
    let i = sl.getState(n);
    if (!i || (t ? i.undone : i.done).eventCount == 0)
      return !1;
    if (r) {
      let o = L$(i, n, t);
      o && r(e ? o.scrollIntoView() : o);
    }
    return !0;
  };
}
const $$ = sU(!1, !0), j$ = sU(!0, !0);
function IJ(t = {}) {
  return new xu({
    view(e) {
      return new H$(e, t);
    }
  });
}
class H$ {
  constructor(e, n) {
    var r;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = n.width) !== null && r !== void 0 ? r : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((i) => {
      let o = (a) => {
        this[i](a);
      };
      return e.dom.addEventListener(i, o), { name: i, handler: o };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
  }
  update(e, n) {
    this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, r;
    if (n) {
      let s = e.nodeBefore, l = e.nodeAfter;
      if (s || l) {
        let u = this.editorView.nodeDOM(this.cursorPos - (s ? s.nodeSize : 0));
        if (u) {
          let f = u.getBoundingClientRect(), h = s ? f.bottom : f.top;
          s && l && (h = (h + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), r = { left: f.left, right: f.right, top: h - this.width / 2, bottom: h + this.width / 2 };
        }
      }
    }
    if (!r) {
      let s = this.editorView.coordsAtPos(this.cursorPos);
      r = { left: s.left - this.width / 2, right: s.left + this.width / 2, top: s.top, bottom: s.bottom };
    }
    let i = this.editorView.dom.offsetParent;
    this.element || (this.element = i.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let o, a;
    if (!i || i == document.body && getComputedStyle(i).position == "static")
      o = -pageXOffset, a = -pageYOffset;
    else {
      let s = i.getBoundingClientRect();
      o = s.left - i.scrollLeft, a = s.top - i.scrollTop;
    }
    this.element.style.left = r.left - o + "px", this.element.style.top = r.top - a + "px", this.element.style.width = r.right - r.left + "px", this.element.style.height = r.bottom - r.top + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), i = r && r.type.spec.disableDropCursor, o = typeof i == "function" ? i(this.editorView, n, e) : i;
    if (n && !o) {
      let a = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let s = O_(this.editorView.state.doc, a, this.editorView.dragging.slice);
        s != null && (a = s);
      }
      this.setCursor(a), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
  }
}
class Pt extends et {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    return Pt.valid(r) ? new Pt(r) : et.near(r);
  }
  content() {
    return We.empty;
  }
  eq(e) {
    return e instanceof Pt && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new Pt(e.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new J2(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !V$(e) || !q$(e))
      return !1;
    let r = n.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = n.contentMatchAt(e.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, n, r = !1) {
    e: for (; ; ) {
      if (!r && Pt.valid(e))
        return e;
      let i = e.pos, o = null;
      for (let a = e.depth; ; a--) {
        let s = e.node(a);
        if (n > 0 ? e.indexAfter(a) < s.childCount : e.index(a) > 0) {
          o = s.child(n > 0 ? e.indexAfter(a) : e.index(a) - 1);
          break;
        } else if (a == 0)
          return null;
        i += n;
        let l = e.doc.resolve(i);
        if (Pt.valid(l))
          return l;
      }
      for (; ; ) {
        let a = n > 0 ? o.firstChild : o.lastChild;
        if (!a) {
          if (o.isAtom && !o.isText && !Ye.isSelectable(o)) {
            e = e.doc.resolve(i + o.nodeSize * n), r = !1;
            continue e;
          }
          break;
        }
        o = a, i += n;
        let s = e.doc.resolve(i);
        if (Pt.valid(s))
          return s;
      }
      return null;
    }
  }
}
Pt.prototype.visible = !1;
Pt.findFrom = Pt.findGapCursorFrom;
et.jsonID("gapcursor", Pt);
class J2 {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new J2(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return Pt.valid(n) ? new Pt(n) : et.near(n);
  }
}
function V$(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e), r = t.node(e);
    if (n == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function q$(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e), r = t.node(e);
    if (n == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(n); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function BJ() {
  return new xu({
    props: {
      decorations: Y$,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && Pt.valid(n) ? new Pt(n) : null;
      },
      handleClick: G$,
      handleKeyDown: X$,
      handleDOMEvents: { beforeinput: J$ }
    }
  });
}
const X$ = i2({
  ArrowLeft: rp("horiz", -1),
  ArrowRight: rp("horiz", 1),
  ArrowUp: rp("vert", -1),
  ArrowDown: rp("vert", 1)
});
function rp(t, e) {
  const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, i, o) {
    let a = r.selection, s = e > 0 ? a.$to : a.$from, l = a.empty;
    if (a instanceof st) {
      if (!o.endOfTextblock(n) || s.depth == 0)
        return !1;
      l = !1, s = r.doc.resolve(e > 0 ? s.after() : s.before());
    }
    let u = Pt.findGapCursorFrom(s, e, l);
    return u ? (i && i(r.tr.setSelection(new Pt(u))), !0) : !1;
  };
}
function G$(t, e, n) {
  if (!t || !t.editable)
    return !1;
  let r = t.state.doc.resolve(e);
  if (!Pt.valid(r))
    return !1;
  let i = t.posAtCoords({ left: n.clientX, top: n.clientY });
  return i && i.inside > -1 && Ye.isSelectable(t.state.doc.nodeAt(i.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new Pt(r))), !0);
}
function J$(t, e) {
  if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof Pt))
    return !1;
  let { $from: n } = t.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = Fe.empty;
  for (let a = r.length - 1; a >= 0; a--)
    i = Fe.from(r[a].createAndFill(null, i));
  let o = t.state.tr.replace(n.pos, n.pos, new We(i, 0, 0));
  return o.setSelection(st.near(o.doc.resolve(n.pos + 1))), t.dispatch(o), !1;
}
function Y$(t) {
  if (!(t.selection instanceof Pt))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Nt.create(t.doc, [qn.widget(t.selection.head, e, { key: "gapcursor" })]);
}
var B0, M0;
if (typeof WeakMap < "u") {
  let t = /* @__PURE__ */ new WeakMap();
  B0 = (e) => t.get(e), M0 = (e, n) => (t.set(e, n), n);
} else {
  const t = [];
  let n = 0;
  B0 = (r) => {
    for (let i = 0; i < t.length; i += 2)
      if (t[i] == r)
        return t[i + 1];
  }, M0 = (r, i) => (n == 10 && (n = 0), t[n++] = r, t[n++] = i);
}
var Wt = class {
  constructor(t, e, n, r) {
    this.width = t, this.height = e, this.map = n, this.problems = r;
  }
  // Find the dimensions of the cell at the given position.
  findCell(t) {
    for (let e = 0; e < this.map.length; e++) {
      const n = this.map[e];
      if (n != t)
        continue;
      const r = e % this.width, i = e / this.width | 0;
      let o = r + 1, a = i + 1;
      for (let s = 1; o < this.width && this.map[e + s] == n; s++)
        o++;
      for (let s = 1; a < this.height && this.map[e + this.width * s] == n; s++)
        a++;
      return { left: r, top: i, right: o, bottom: a };
    }
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(t) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == t)
        return e % this.width;
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(t, e, n) {
    const { left: r, right: i, top: o, bottom: a } = this.findCell(t);
    return e == "horiz" ? (n < 0 ? r == 0 : i == this.width) ? null : this.map[o * this.width + (n < 0 ? r - 1 : i)] : (n < 0 ? o == 0 : a == this.height) ? null : this.map[r + this.width * (n < 0 ? o - 1 : a)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(t, e) {
    const {
      left: n,
      right: r,
      top: i,
      bottom: o
    } = this.findCell(t), {
      left: a,
      right: s,
      top: l,
      bottom: u
    } = this.findCell(e);
    return {
      left: Math.min(n, a),
      top: Math.min(i, l),
      right: Math.max(r, s),
      bottom: Math.max(o, u)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(t) {
    const e = [], n = {};
    for (let r = t.top; r < t.bottom; r++)
      for (let i = t.left; i < t.right; i++) {
        const o = r * this.width + i, a = this.map[o];
        n[a] || (n[a] = !0, !(i == t.left && i && this.map[o - 1] == a || r == t.top && r && this.map[o - this.width] == a) && e.push(a));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(t, e, n) {
    for (let r = 0, i = 0; ; r++) {
      const o = i + n.child(r).nodeSize;
      if (r == t) {
        let a = e + t * this.width;
        const s = (t + 1) * this.width;
        for (; a < s && this.map[a] < i; )
          a++;
        return a == s ? o - 1 : this.map[a];
      }
      i = o;
    }
  }
  // Find the table map for the given table node.
  static get(t) {
    return B0(t) || M0(t, Z$(t));
  }
};
function Z$(t) {
  if (t.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + t.type.name);
  const e = K$(t), n = t.childCount, r = [];
  let i = 0, o = null;
  const a = [];
  for (let u = 0, f = e * n; u < f; u++)
    r[u] = 0;
  for (let u = 0, f = 0; u < n; u++) {
    const h = t.child(u);
    f++;
    for (let b = 0; ; b++) {
      for (; i < r.length && r[i] != 0; )
        i++;
      if (b == h.childCount)
        break;
      const x = h.child(b), { colspan: v, rowspan: D, colwidth: S } = x.attrs;
      for (let E = 0; E < D; E++) {
        if (E + u >= n) {
          (o || (o = [])).push({
            type: "overlong_rowspan",
            pos: f,
            n: D - E
          });
          break;
        }
        const I = i + E * e;
        for (let R = 0; R < v; R++) {
          r[I + R] == 0 ? r[I + R] = f : (o || (o = [])).push({
            type: "collision",
            row: u,
            pos: f,
            n: v - R
          });
          const O = S && S[R];
          if (O) {
            const N = (I + R) % e * 2, q = a[N];
            q == null || q != O && a[N + 1] == 1 ? (a[N] = O, a[N + 1] = 1) : q == O && a[N + 1]++;
          }
        }
      }
      i += v, f += x.nodeSize;
    }
    const p = (u + 1) * e;
    let y = 0;
    for (; i < p; )
      r[i++] == 0 && y++;
    y && (o || (o = [])).push({ type: "missing", row: u, n: y }), f++;
  }
  const s = new Wt(e, n, r, o);
  let l = !1;
  for (let u = 0; !l && u < a.length; u += 2)
    a[u] != null && a[u + 1] < n && (l = !0);
  return l && Q$(s, a, t), s;
}
function K$(t) {
  let e = -1, n = !1;
  for (let r = 0; r < t.childCount; r++) {
    const i = t.child(r);
    let o = 0;
    if (n)
      for (let a = 0; a < r; a++) {
        const s = t.child(a);
        for (let l = 0; l < s.childCount; l++) {
          const u = s.child(l);
          a + u.attrs.rowspan > r && (o += u.attrs.colspan);
        }
      }
    for (let a = 0; a < i.childCount; a++) {
      const s = i.child(a);
      o += s.attrs.colspan, s.attrs.rowspan > 1 && (n = !0);
    }
    e == -1 ? e = o : e != o && (e = Math.max(e, o));
  }
  return e;
}
function Q$(t, e, n) {
  t.problems || (t.problems = []);
  const r = {};
  for (let i = 0; i < t.map.length; i++) {
    const o = t.map[i];
    if (r[o])
      continue;
    r[o] = !0;
    const a = n.nodeAt(o);
    if (!a)
      throw new RangeError(`No cell with offset ${o} found`);
    let s = null;
    const l = a.attrs;
    for (let u = 0; u < l.colspan; u++) {
      const f = (i + u) % t.width, h = e[f * 2];
      h != null && (!l.colwidth || l.colwidth[u] != h) && ((s || (s = ej(l)))[u] = h);
    }
    s && t.problems.unshift({
      type: "colwidth mismatch",
      pos: o,
      colwidth: s
    });
  }
}
function ej(t) {
  if (t.colwidth)
    return t.colwidth.slice();
  const e = [];
  for (let n = 0; n < t.colspan; n++)
    e.push(0);
  return e;
}
function Un(t) {
  let e = t.cached.tableNodeTypes;
  if (!e) {
    e = t.cached.tableNodeTypes = {};
    for (const n in t.nodes) {
      const r = t.nodes[n], i = r.spec.tableRole;
      i && (e[i] = r);
    }
  }
  return e;
}
var La = new ns("selectingCells");
function ku(t) {
  for (let e = t.depth - 1; e > 0; e--)
    if (t.node(e).type.spec.tableRole == "row")
      return t.node(0).resolve(t.before(e + 1));
  return null;
}
function tj(t) {
  for (let e = t.depth; e > 0; e--) {
    const n = t.node(e).type.spec.tableRole;
    if (n === "cell" || n === "header_cell")
      return t.node(e);
  }
  return null;
}
function yi(t) {
  const e = t.selection.$head;
  for (let n = e.depth; n > 0; n--)
    if (e.node(n).type.spec.tableRole == "row")
      return !0;
  return !1;
}
function Am(t) {
  const e = t.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const n = ku(e.$head) || nj(e.$head);
  if (n)
    return n;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function nj(t) {
  for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return t.doc.resolve(n);
  }
  for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return t.doc.resolve(n - e.nodeSize);
  }
}
function N0(t) {
  return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function rj(t) {
  return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
}
function Y2(t, e) {
  return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function lU(t, e, n) {
  const r = t.node(-1), i = Wt.get(r), o = t.start(-1), a = i.nextCell(t.pos - o, e, n);
  return a == null ? null : t.node(0).resolve(o + a);
}
function pl(t, e, n = 1) {
  const r = { ...t, colspan: t.colspan - n };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, n), r.colwidth.some((i) => i > 0) || (r.colwidth = null)), r;
}
function cU(t, e, n = 1) {
  const r = { ...t, colspan: t.colspan + n };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let i = 0; i < n; i++)
      r.colwidth.splice(e, 0, 0);
  }
  return r;
}
function ij(t, e, n) {
  const r = Un(e.type.schema).header_cell;
  for (let i = 0; i < t.height; i++)
    if (e.nodeAt(t.map[n + i * t.width]).type != r)
      return !1;
  return !0;
}
var Rt = class Oo extends et {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, n = e) {
    const r = e.node(-1), i = Wt.get(r), o = e.start(-1), a = i.rectBetween(
      e.pos - o,
      n.pos - o
    ), s = e.node(0), l = i.cellsInRect(a).filter((f) => f != n.pos - o);
    l.unshift(n.pos - o);
    const u = l.map((f) => {
      const h = r.nodeAt(f);
      if (!h)
        throw RangeError(`No cell with offset ${f} found`);
      const p = o + f + 1;
      return new W_(
        s.resolve(p),
        s.resolve(p + h.content.size)
      );
    });
    super(u[0].$from, u[0].$to, u), this.$anchorCell = e, this.$headCell = n;
  }
  map(e, n) {
    const r = e.resolve(n.map(this.$anchorCell.pos)), i = e.resolve(n.map(this.$headCell.pos));
    if (N0(r) && N0(i) && Y2(r, i)) {
      const o = this.$anchorCell.node(-1) != r.node(-1);
      return o && this.isRowSelection() ? Oo.rowSelection(r, i) : o && this.isColSelection() ? Oo.colSelection(r, i) : new Oo(r, i);
    }
    return st.between(r, i);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), n = Wt.get(e), r = this.$anchorCell.start(-1), i = n.rectBetween(
      this.$anchorCell.pos - r,
      this.$headCell.pos - r
    ), o = {}, a = [];
    for (let l = i.top; l < i.bottom; l++) {
      const u = [];
      for (let f = l * n.width + i.left, h = i.left; h < i.right; h++, f++) {
        const p = n.map[f];
        if (o[p])
          continue;
        o[p] = !0;
        const y = n.findCell(p);
        let b = e.nodeAt(p);
        if (!b)
          throw RangeError(`No cell with offset ${p} found`);
        const x = i.left - y.left, v = y.right - i.right;
        if (x > 0 || v > 0) {
          let D = b.attrs;
          if (x > 0 && (D = pl(D, 0, x)), v > 0 && (D = pl(
            D,
            D.colspan - v,
            v
          )), y.left < i.left) {
            if (b = b.type.createAndFill(D), !b)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(D)}`
              );
          } else
            b = b.type.create(D, b.content);
        }
        if (y.top < i.top || y.bottom > i.bottom) {
          const D = {
            ...b.attrs,
            rowspan: Math.min(y.bottom, i.bottom) - Math.max(y.top, i.top)
          };
          y.top < i.top ? b = b.type.createAndFill(D) : b = b.type.create(D, b.content);
        }
        u.push(b);
      }
      a.push(e.child(l).copy(Fe.from(u)));
    }
    const s = this.isColSelection() && this.isRowSelection() ? e : a;
    return new We(Fe.from(s), 1, 1);
  }
  replace(e, n = We.empty) {
    const r = e.steps.length, i = this.ranges;
    for (let a = 0; a < i.length; a++) {
      const { $from: s, $to: l } = i[a], u = e.mapping.slice(r);
      e.replace(
        u.map(s.pos),
        u.map(l.pos),
        a ? We.empty : n
      );
    }
    const o = et.findFrom(
      e.doc.resolve(e.mapping.slice(r).map(this.to)),
      -1
    );
    o && e.setSelection(o);
  }
  replaceWith(e, n) {
    this.replace(e, new We(Fe.from(n), 0, 0));
  }
  forEachCell(e) {
    const n = this.$anchorCell.node(-1), r = Wt.get(n), i = this.$anchorCell.start(-1), o = r.cellsInRect(
      r.rectBetween(
        this.$anchorCell.pos - i,
        this.$headCell.pos - i
      )
    );
    for (let a = 0; a < o.length; a++)
      e(n.nodeAt(o[a]), i + o[a]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), n = this.$headCell.index(-1);
    if (Math.min(e, n) > 0)
      return !1;
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, i = n + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, i) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, n = e) {
    const r = e.node(-1), i = Wt.get(r), o = e.start(-1), a = i.findCell(e.pos - o), s = i.findCell(n.pos - o), l = e.node(0);
    return a.top <= s.top ? (a.top > 0 && (e = l.resolve(o + i.map[a.left])), s.bottom < i.height && (n = l.resolve(
      o + i.map[i.width * (i.height - 1) + s.right - 1]
    ))) : (s.top > 0 && (n = l.resolve(o + i.map[s.left])), a.bottom < i.height && (e = l.resolve(
      o + i.map[i.width * (i.height - 1) + a.right - 1]
    ))), new Oo(e, n);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), n = Wt.get(e), r = this.$anchorCell.start(-1), i = n.colCount(this.$anchorCell.pos - r), o = n.colCount(this.$headCell.pos - r);
    if (Math.min(i, o) > 0)
      return !1;
    const a = i + this.$anchorCell.nodeAfter.attrs.colspan, s = o + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(a, s) == n.width;
  }
  eq(e) {
    return e instanceof Oo && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, n = e) {
    const r = e.node(-1), i = Wt.get(r), o = e.start(-1), a = i.findCell(e.pos - o), s = i.findCell(n.pos - o), l = e.node(0);
    return a.left <= s.left ? (a.left > 0 && (e = l.resolve(
      o + i.map[a.top * i.width]
    )), s.right < i.width && (n = l.resolve(
      o + i.map[i.width * (s.top + 1) - 1]
    ))) : (s.left > 0 && (n = l.resolve(o + i.map[s.top * i.width])), a.right < i.width && (e = l.resolve(
      o + i.map[i.width * (a.top + 1) - 1]
    ))), new Oo(e, n);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, n) {
    return new Oo(e.resolve(n.anchor), e.resolve(n.head));
  }
  static create(e, n, r = n) {
    return new Oo(e.resolve(n), e.resolve(r));
  }
  getBookmark() {
    return new oj(this.$anchorCell.pos, this.$headCell.pos);
  }
};
Rt.prototype.visible = !1;
et.jsonID("cell", Rt);
var oj = class uU {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new uU(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const n = e.resolve(this.anchor), r = e.resolve(this.head);
    return n.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && r.index() < r.parent.childCount && Y2(n, r) ? new Rt(n, r) : et.near(r, 1);
  }
};
function aj(t) {
  if (!(t.selection instanceof Rt))
    return null;
  const e = [];
  return t.selection.forEachCell((n, r) => {
    e.push(
      qn.node(r, r + n.nodeSize, { class: "selectedCell" })
    );
  }), Nt.create(t.doc, e);
}
function sj({ $from: t, $to: e }) {
  if (t.pos == e.pos || t.pos < e.pos - 6)
    return !1;
  let n = t.pos, r = e.pos, i = t.depth;
  for (; i >= 0 && !(t.after(i + 1) < t.end(i)); i--, n++)
    ;
  for (let o = e.depth; o >= 0 && !(e.before(o + 1) > e.start(o)); o--, r--)
    ;
  return n == r && /row|table/.test(t.node(i).type.spec.tableRole);
}
function lj({ $from: t, $to: e }) {
  let n, r;
  for (let i = t.depth; i > 0; i--) {
    const o = t.node(i);
    if (o.type.spec.tableRole === "cell" || o.type.spec.tableRole === "header_cell") {
      n = o;
      break;
    }
  }
  for (let i = e.depth; i > 0; i--) {
    const o = e.node(i);
    if (o.type.spec.tableRole === "cell" || o.type.spec.tableRole === "header_cell") {
      r = o;
      break;
    }
  }
  return n !== r && e.parentOffset === 0;
}
function cj(t, e, n) {
  const r = (e || t).selection, i = (e || t).doc;
  let o, a;
  if (r instanceof Ye && (a = r.node.type.spec.tableRole)) {
    if (a == "cell" || a == "header_cell")
      o = Rt.create(i, r.from);
    else if (a == "row") {
      const s = i.resolve(r.from + 1);
      o = Rt.rowSelection(s, s);
    } else if (!n) {
      const s = Wt.get(r.node), l = r.from + 1, u = l + s.map[s.width * s.height - 1];
      o = Rt.create(i, l + 1, u);
    }
  } else r instanceof st && sj(r) ? o = st.create(i, r.from) : r instanceof st && lj(r) && (o = st.create(i, r.$from.start(), r.$from.end()));
  return o && (e || (e = t.tr)).setSelection(o), e;
}
var uj = new ns("fix-tables");
function fU(t, e, n, r) {
  const i = t.childCount, o = e.childCount;
  e:
    for (let a = 0, s = 0; a < o; a++) {
      const l = e.child(a);
      for (let u = s, f = Math.min(i, a + 3); u < f; u++)
        if (t.child(u) == l) {
          s = u + 1, n += l.nodeSize;
          continue e;
        }
      r(l, n), s < i && t.child(s).sameMarkup(l) ? fU(t.child(s), l, n + 1, r) : l.nodesBetween(0, l.content.size, r, n + 1), n += l.nodeSize;
    }
}
function fj(t, e) {
  let n;
  const r = (i, o) => {
    i.type.spec.tableRole == "table" && (n = dj(t, i, o, n));
  };
  return e ? e.doc != t.doc && fU(e.doc, t.doc, 0, r) : t.doc.descendants(r), n;
}
function dj(t, e, n, r) {
  const i = Wt.get(e);
  if (!i.problems)
    return r;
  r || (r = t.tr);
  const o = [];
  for (let l = 0; l < i.height; l++)
    o.push(0);
  for (let l = 0; l < i.problems.length; l++) {
    const u = i.problems[l];
    if (u.type == "collision") {
      const f = e.nodeAt(u.pos);
      if (!f)
        continue;
      const h = f.attrs;
      for (let p = 0; p < h.rowspan; p++)
        o[u.row + p] += u.n;
      r.setNodeMarkup(
        r.mapping.map(n + 1 + u.pos),
        null,
        pl(h, h.colspan - u.n, u.n)
      );
    } else if (u.type == "missing")
      o[u.row] += u.n;
    else if (u.type == "overlong_rowspan") {
      const f = e.nodeAt(u.pos);
      if (!f)
        continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + u.pos), null, {
        ...f.attrs,
        rowspan: f.attrs.rowspan - u.n
      });
    } else if (u.type == "colwidth mismatch") {
      const f = e.nodeAt(u.pos);
      if (!f)
        continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + u.pos), null, {
        ...f.attrs,
        colwidth: u.colwidth
      });
    }
  }
  let a, s;
  for (let l = 0; l < o.length; l++)
    o[l] && (a == null && (a = l), s = l);
  for (let l = 0, u = n + 1; l < i.height; l++) {
    const f = e.child(l), h = u + f.nodeSize, p = o[l];
    if (p > 0) {
      let y = "cell";
      f.firstChild && (y = f.firstChild.type.spec.tableRole);
      const b = [];
      for (let v = 0; v < p; v++) {
        const D = Un(t.schema)[y].createAndFill();
        D && b.push(D);
      }
      const x = (l == 0 || a == l - 1) && s == l ? u + 1 : h - 1;
      r.insert(r.mapping.map(x), b);
    }
    u = h;
  }
  return r.setMeta(uj, { fixTables: !0 });
}
function no(t) {
  const e = t.selection, n = Am(t), r = n.node(-1), i = n.start(-1), o = Wt.get(r);
  return { ...e instanceof Rt ? o.rectBetween(
    e.$anchorCell.pos - i,
    e.$headCell.pos - i
  ) : o.findCell(n.pos - i), tableStart: i, map: o, table: r };
}
function dU(t, { map: e, tableStart: n, table: r }, i) {
  let o = i > 0 ? -1 : 0;
  ij(e, r, i + o) && (o = i == 0 || i == e.width ? null : 0);
  for (let a = 0; a < e.height; a++) {
    const s = a * e.width + i;
    if (i > 0 && i < e.width && e.map[s - 1] == e.map[s]) {
      const l = e.map[s], u = r.nodeAt(l);
      t.setNodeMarkup(
        t.mapping.map(n + l),
        null,
        cU(u.attrs, i - e.colCount(l))
      ), a += u.attrs.rowspan - 1;
    } else {
      const l = o == null ? Un(r.type.schema).cell : r.nodeAt(e.map[s + o]).type, u = e.positionAt(a, i, r);
      t.insert(t.mapping.map(n + u), l.createAndFill());
    }
  }
  return t;
}
function MJ(t, e) {
  if (!yi(t))
    return !1;
  if (e) {
    const n = no(t);
    e(dU(t.tr, n, n.left));
  }
  return !0;
}
function NJ(t, e) {
  if (!yi(t))
    return !1;
  if (e) {
    const n = no(t);
    e(dU(t.tr, n, n.right));
  }
  return !0;
}
function hj(t, { map: e, table: n, tableStart: r }, i) {
  const o = t.mapping.maps.length;
  for (let a = 0; a < e.height; ) {
    const s = a * e.width + i, l = e.map[s], u = n.nodeAt(l), f = u.attrs;
    if (i > 0 && e.map[s - 1] == l || i < e.width - 1 && e.map[s + 1] == l)
      t.setNodeMarkup(
        t.mapping.slice(o).map(r + l),
        null,
        pl(f, i - e.colCount(l))
      );
    else {
      const h = t.mapping.slice(o).map(r + l);
      t.delete(h, h + u.nodeSize);
    }
    a += f.rowspan;
  }
}
function PJ(t, e) {
  if (!yi(t))
    return !1;
  if (e) {
    const n = no(t), r = t.tr;
    if (n.left == 0 && n.right == n.map.width)
      return !1;
    for (let i = n.right - 1; hj(r, n, i), i != n.left; i--) {
      const o = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!o)
        throw RangeError("No table found");
      n.table = o, n.map = Wt.get(o);
    }
    e(r);
  }
  return !0;
}
function pj(t, e, n) {
  var r;
  const i = Un(e.type.schema).header_cell;
  for (let o = 0; o < t.width; o++)
    if (((r = e.nodeAt(t.map[o + n * t.width])) == null ? void 0 : r.type) != i)
      return !1;
  return !0;
}
function hU(t, { map: e, tableStart: n, table: r }, i) {
  var o;
  let a = n;
  for (let u = 0; u < i; u++)
    a += r.child(u).nodeSize;
  const s = [];
  let l = i > 0 ? -1 : 0;
  pj(e, r, i + l) && (l = i == 0 || i == e.height ? null : 0);
  for (let u = 0, f = e.width * i; u < e.width; u++, f++)
    if (i > 0 && i < e.height && e.map[f] == e.map[f - e.width]) {
      const h = e.map[f], p = r.nodeAt(h).attrs;
      t.setNodeMarkup(n + h, null, {
        ...p,
        rowspan: p.rowspan + 1
      }), u += p.colspan - 1;
    } else {
      const h = l == null ? Un(r.type.schema).cell : (o = r.nodeAt(e.map[f + l * e.width])) == null ? void 0 : o.type, p = h == null ? void 0 : h.createAndFill();
      p && s.push(p);
    }
  return t.insert(a, Un(r.type.schema).row.create(null, s)), t;
}
function WJ(t, e) {
  if (!yi(t))
    return !1;
  if (e) {
    const n = no(t);
    e(hU(t.tr, n, n.top));
  }
  return !0;
}
function LJ(t, e) {
  if (!yi(t))
    return !1;
  if (e) {
    const n = no(t);
    e(hU(t.tr, n, n.bottom));
  }
  return !0;
}
function gj(t, { map: e, table: n, tableStart: r }, i) {
  let o = 0;
  for (let u = 0; u < i; u++)
    o += n.child(u).nodeSize;
  const a = o + n.child(i).nodeSize, s = t.mapping.maps.length;
  t.delete(o + r, a + r);
  const l = /* @__PURE__ */ new Set();
  for (let u = 0, f = i * e.width; u < e.width; u++, f++) {
    const h = e.map[f];
    if (!l.has(h)) {
      if (l.add(h), i > 0 && h == e.map[f - e.width]) {
        const p = n.nodeAt(h).attrs;
        t.setNodeMarkup(t.mapping.slice(s).map(h + r), null, {
          ...p,
          rowspan: p.rowspan - 1
        }), u += p.colspan - 1;
      } else if (i < e.height && h == e.map[f + e.width]) {
        const p = n.nodeAt(h), y = p.attrs, b = p.type.create(
          { ...y, rowspan: p.attrs.rowspan - 1 },
          p.content
        ), x = e.positionAt(i + 1, u, n);
        t.insert(t.mapping.slice(s).map(r + x), b), u += y.colspan - 1;
      }
    }
  }
}
function zJ(t, e) {
  if (!yi(t))
    return !1;
  if (e) {
    const n = no(t), r = t.tr;
    if (n.top == 0 && n.bottom == n.map.height)
      return !1;
    for (let i = n.bottom - 1; gj(r, n, i), i != n.top; i--) {
      const o = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!o)
        throw RangeError("No table found");
      n.table = o, n.map = Wt.get(n.table);
    }
    e(r);
  }
  return !0;
}
function XT(t) {
  const e = t.content;
  return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function mj({ width: t, height: e, map: n }, r) {
  let i = r.top * t + r.left, o = i, a = (r.bottom - 1) * t + r.left, s = i + (r.right - r.left - 1);
  for (let l = r.top; l < r.bottom; l++) {
    if (r.left > 0 && n[o] == n[o - 1] || r.right < t && n[s] == n[s + 1])
      return !0;
    o += t, s += t;
  }
  for (let l = r.left; l < r.right; l++) {
    if (r.top > 0 && n[i] == n[i - t] || r.bottom < e && n[a] == n[a + t])
      return !0;
    i++, a++;
  }
  return !1;
}
function $J(t, e) {
  const n = t.selection;
  if (!(n instanceof Rt) || n.$anchorCell.pos == n.$headCell.pos)
    return !1;
  const r = no(t), { map: i } = r;
  if (mj(i, r))
    return !1;
  if (e) {
    const o = t.tr, a = {};
    let s = Fe.empty, l, u;
    for (let f = r.top; f < r.bottom; f++)
      for (let h = r.left; h < r.right; h++) {
        const p = i.map[f * i.width + h], y = r.table.nodeAt(p);
        if (!(a[p] || !y))
          if (a[p] = !0, l == null)
            l = p, u = y;
          else {
            XT(y) || (s = s.append(y.content));
            const b = o.mapping.map(p + r.tableStart);
            o.delete(b, b + y.nodeSize);
          }
      }
    if (l == null || u == null)
      return !0;
    if (o.setNodeMarkup(l + r.tableStart, null, {
      ...cU(
        u.attrs,
        u.attrs.colspan,
        r.right - r.left - u.attrs.colspan
      ),
      rowspan: r.bottom - r.top
    }), s.size) {
      const f = l + 1 + u.content.size, h = XT(u) ? l + 1 : f;
      o.replaceWith(h + r.tableStart, f + r.tableStart, s);
    }
    o.setSelection(
      new Rt(o.doc.resolve(l + r.tableStart))
    ), e(o);
  }
  return !0;
}
function jJ(t, e) {
  const n = Un(t.schema);
  return yj(({ node: r }) => n[r.type.spec.tableRole])(t, e);
}
function yj(t) {
  return (e, n) => {
    var r;
    const i = e.selection;
    let o, a;
    if (i instanceof Rt) {
      if (i.$anchorCell.pos != i.$headCell.pos)
        return !1;
      o = i.$anchorCell.nodeAfter, a = i.$anchorCell.pos;
    } else {
      if (o = tj(i.$from), !o)
        return !1;
      a = (r = ku(i.$from)) == null ? void 0 : r.pos;
    }
    if (o == null || a == null || o.attrs.colspan == 1 && o.attrs.rowspan == 1)
      return !1;
    if (n) {
      let s = o.attrs;
      const l = [], u = s.colwidth;
      s.rowspan > 1 && (s = { ...s, rowspan: 1 }), s.colspan > 1 && (s = { ...s, colspan: 1 });
      const f = no(e), h = e.tr;
      for (let y = 0; y < f.right - f.left; y++)
        l.push(
          u ? {
            ...s,
            colwidth: u && u[y] ? [u[y]] : null
          } : s
        );
      let p;
      for (let y = f.top; y < f.bottom; y++) {
        let b = f.map.positionAt(y, f.left, f.table);
        y == f.top && (b += o.nodeSize);
        for (let x = f.left, v = 0; x < f.right; x++, v++)
          x == f.left && y == f.top || h.insert(
            p = h.mapping.map(b + f.tableStart, 1),
            t({ node: o, row: y, col: x }).createAndFill(l[v])
          );
      }
      h.setNodeMarkup(
        a,
        t({ node: o, row: f.top, col: f.left }),
        l[0]
      ), i instanceof Rt && h.setSelection(
        new Rt(
          h.doc.resolve(i.$anchorCell.pos),
          p ? h.doc.resolve(p) : void 0
        )
      ), n(h);
    }
    return !0;
  };
}
function HJ(t, e) {
  return function(n, r) {
    if (!yi(n))
      return !1;
    const i = Am(n);
    if (i.nodeAfter.attrs[t] === e)
      return !1;
    if (r) {
      const o = n.tr;
      n.selection instanceof Rt ? n.selection.forEachCell((a, s) => {
        a.attrs[t] !== e && o.setNodeMarkup(s, null, {
          ...a.attrs,
          [t]: e
        });
      }) : o.setNodeMarkup(i.pos, null, {
        ...i.nodeAfter.attrs,
        [t]: e
      }), r(o);
    }
    return !0;
  };
}
function bj(t) {
  return function(e, n) {
    if (!yi(e))
      return !1;
    if (n) {
      const r = Un(e.schema), i = no(e), o = e.tr, a = i.map.cellsInRect(
        t == "column" ? {
          left: i.left,
          top: 0,
          right: i.right,
          bottom: i.map.height
        } : t == "row" ? {
          left: 0,
          top: i.top,
          right: i.map.width,
          bottom: i.bottom
        } : i
      ), s = a.map((l) => i.table.nodeAt(l));
      for (let l = 0; l < a.length; l++)
        s[l].type == r.header_cell && o.setNodeMarkup(
          i.tableStart + a[l],
          r.cell,
          s[l].attrs
        );
      if (o.steps.length == 0)
        for (let l = 0; l < a.length; l++)
          o.setNodeMarkup(
            i.tableStart + a[l],
            r.header_cell,
            s[l].attrs
          );
      n(o);
    }
    return !0;
  };
}
function GT(t, e, n) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: t == "row" ? e.map.width : 1,
    bottom: t == "column" ? e.map.height : 1
  });
  for (let i = 0; i < r.length; i++) {
    const o = e.table.nodeAt(r[i]);
    if (o && o.type !== n.header_cell)
      return !1;
  }
  return !0;
}
function Z2(t, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? bj(t) : function(n, r) {
    if (!yi(n))
      return !1;
    if (r) {
      const i = Un(n.schema), o = no(n), a = n.tr, s = GT("row", o, i), l = GT(
        "column",
        o,
        i
      ), f = (t === "column" ? s : t === "row" ? l : !1) ? 1 : 0, h = t == "column" ? {
        left: 0,
        top: f,
        right: 1,
        bottom: o.map.height
      } : t == "row" ? {
        left: f,
        top: 0,
        right: o.map.width,
        bottom: 1
      } : o, p = t == "column" ? l ? i.cell : i.header_cell : t == "row" ? s ? i.cell : i.header_cell : i.cell;
      o.map.cellsInRect(h).forEach((y) => {
        const b = y + o.tableStart, x = a.doc.nodeAt(b);
        x && a.setNodeMarkup(b, p, x.attrs);
      }), r(a);
    }
    return !0;
  };
}
Z2("row", {
  useDeprecatedLogic: !0
});
Z2("column", {
  useDeprecatedLogic: !0
});
var VJ = Z2("cell", {
  useDeprecatedLogic: !0
});
function vj(t, e) {
  if (e < 0) {
    const n = t.nodeBefore;
    if (n)
      return t.pos - n.nodeSize;
    for (let r = t.index(-1) - 1, i = t.before(); r >= 0; r--) {
      const o = t.node(-1).child(r), a = o.lastChild;
      if (a)
        return i - 1 - a.nodeSize;
      i -= o.nodeSize;
    }
  } else {
    if (t.index() < t.parent.childCount - 1)
      return t.pos + t.nodeAfter.nodeSize;
    const n = t.node(-1);
    for (let r = t.indexAfter(-1), i = t.after(); r < n.childCount; r++) {
      const o = n.child(r);
      if (o.childCount)
        return i + 1;
      i += o.nodeSize;
    }
  }
  return null;
}
function qJ(t) {
  return function(e, n) {
    if (!yi(e))
      return !1;
    const r = vj(Am(e), t);
    if (r == null)
      return !1;
    if (n) {
      const i = e.doc.resolve(r);
      n(
        e.tr.setSelection(st.between(i, rj(i))).scrollIntoView()
      );
    }
    return !0;
  };
}
function XJ(t, e) {
  const n = t.selection.$anchor;
  for (let r = n.depth; r > 0; r--)
    if (n.node(r).type.spec.tableRole == "table")
      return e && e(
        t.tr.delete(n.before(r), n.after(r)).scrollIntoView()
      ), !0;
  return !1;
}
function ip(t, e) {
  const n = t.selection;
  if (!(n instanceof Rt))
    return !1;
  if (e) {
    const r = t.tr, i = Un(t.schema).cell.createAndFill().content;
    n.forEachCell((o, a) => {
      o.content.eq(i) || r.replace(
        r.mapping.map(a + 1),
        r.mapping.map(a + o.nodeSize - 1),
        new We(i, 0, 0)
      );
    }), r.docChanged && e(r);
  }
  return !0;
}
function xj(t) {
  if (!t.size)
    return null;
  let { content: e, openStart: n, openEnd: r } = t;
  for (; e.childCount == 1 && (n > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
    n--, r--, e = e.child(0).content;
  const i = e.child(0), o = i.type.spec.tableRole, a = i.type.schema, s = [];
  if (o == "row")
    for (let l = 0; l < e.childCount; l++) {
      let u = e.child(l).content;
      const f = l ? 0 : Math.max(0, n - 1), h = l < e.childCount - 1 ? 0 : Math.max(0, r - 1);
      (f || h) && (u = P0(
        Un(a).row,
        new We(u, f, h)
      ).content), s.push(u);
    }
  else if (o == "cell" || o == "header_cell")
    s.push(
      n || r ? P0(
        Un(a).row,
        new We(e, n, r)
      ).content : e
    );
  else
    return null;
  return Dj(a, s);
}
function Dj(t, e) {
  const n = [];
  for (let i = 0; i < e.length; i++) {
    const o = e[i];
    for (let a = o.childCount - 1; a >= 0; a--) {
      const { rowspan: s, colspan: l } = o.child(a).attrs;
      for (let u = i; u < i + s; u++)
        n[u] = (n[u] || 0) + l;
    }
  }
  let r = 0;
  for (let i = 0; i < n.length; i++)
    r = Math.max(r, n[i]);
  for (let i = 0; i < n.length; i++)
    if (i >= e.length && e.push(Fe.empty), n[i] < r) {
      const o = Un(t).cell.createAndFill(), a = [];
      for (let s = n[i]; s < r; s++)
        a.push(o);
      e[i] = e[i].append(Fe.from(a));
    }
  return { height: e.length, width: r, rows: e };
}
function P0(t, e) {
  const n = t.createAndFill();
  return new P_(n).replace(0, n.content.size, e).doc;
}
function wj({ width: t, height: e, rows: n }, r, i) {
  if (t != r) {
    const o = [], a = [];
    for (let s = 0; s < n.length; s++) {
      const l = n[s], u = [];
      for (let f = o[s] || 0, h = 0; f < r; h++) {
        let p = l.child(h % l.childCount);
        f + p.attrs.colspan > r && (p = p.type.createChecked(
          pl(
            p.attrs,
            p.attrs.colspan,
            f + p.attrs.colspan - r
          ),
          p.content
        )), u.push(p), f += p.attrs.colspan;
        for (let y = 1; y < p.attrs.rowspan; y++)
          o[s + y] = (o[s + y] || 0) + p.attrs.colspan;
      }
      a.push(Fe.from(u));
    }
    n = a, t = r;
  }
  if (e != i) {
    const o = [];
    for (let a = 0, s = 0; a < i; a++, s++) {
      const l = [], u = n[s % e];
      for (let f = 0; f < u.childCount; f++) {
        let h = u.child(f);
        a + h.attrs.rowspan > i && (h = h.type.create(
          {
            ...h.attrs,
            rowspan: Math.max(1, i - h.attrs.rowspan)
          },
          h.content
        )), l.push(h);
      }
      o.push(Fe.from(l));
    }
    n = o, e = i;
  }
  return { width: t, height: e, rows: n };
}
function Sj(t, e, n, r, i, o, a) {
  const s = t.doc.type.schema, l = Un(s);
  let u, f;
  if (i > e.width)
    for (let h = 0, p = 0; h < e.height; h++) {
      const y = n.child(h);
      p += y.nodeSize;
      const b = [];
      let x;
      y.lastChild == null || y.lastChild.type == l.cell ? x = u || (u = l.cell.createAndFill()) : x = f || (f = l.header_cell.createAndFill());
      for (let v = e.width; v < i; v++)
        b.push(x);
      t.insert(t.mapping.slice(a).map(p - 1 + r), b);
    }
  if (o > e.height) {
    const h = [];
    for (let b = 0, x = (e.height - 1) * e.width; b < Math.max(e.width, i); b++) {
      const v = b >= e.width ? !1 : n.nodeAt(e.map[x + b]).type == l.header_cell;
      h.push(
        v ? f || (f = l.header_cell.createAndFill()) : u || (u = l.cell.createAndFill())
      );
    }
    const p = l.row.create(null, Fe.from(h)), y = [];
    for (let b = e.height; b < o; b++)
      y.push(p);
    t.insert(t.mapping.slice(a).map(r + n.nodeSize - 2), y);
  }
  return !!(u || f);
}
function JT(t, e, n, r, i, o, a, s) {
  if (a == 0 || a == e.height)
    return !1;
  let l = !1;
  for (let u = i; u < o; u++) {
    const f = a * e.width + u, h = e.map[f];
    if (e.map[f - e.width] == h) {
      l = !0;
      const p = n.nodeAt(h), { top: y, left: b } = e.findCell(h);
      t.setNodeMarkup(t.mapping.slice(s).map(h + r), null, {
        ...p.attrs,
        rowspan: a - y
      }), t.insert(
        t.mapping.slice(s).map(e.positionAt(a, b, n)),
        p.type.createAndFill({
          ...p.attrs,
          rowspan: y + p.attrs.rowspan - a
        })
      ), u += p.attrs.colspan - 1;
    }
  }
  return l;
}
function YT(t, e, n, r, i, o, a, s) {
  if (a == 0 || a == e.width)
    return !1;
  let l = !1;
  for (let u = i; u < o; u++) {
    const f = u * e.width + a, h = e.map[f];
    if (e.map[f - 1] == h) {
      l = !0;
      const p = n.nodeAt(h), y = e.colCount(h), b = t.mapping.slice(s).map(h + r);
      t.setNodeMarkup(
        b,
        null,
        pl(
          p.attrs,
          a - y,
          p.attrs.colspan - (a - y)
        )
      ), t.insert(
        b + p.nodeSize,
        p.type.createAndFill(
          pl(p.attrs, 0, a - y)
        )
      ), u += p.attrs.rowspan - 1;
    }
  }
  return l;
}
function ZT(t, e, n, r, i) {
  let o = n ? t.doc.nodeAt(n - 1) : t.doc;
  if (!o)
    throw new Error("No table found");
  let a = Wt.get(o);
  const { top: s, left: l } = r, u = l + i.width, f = s + i.height, h = t.tr;
  let p = 0;
  function y() {
    if (o = n ? h.doc.nodeAt(n - 1) : h.doc, !o)
      throw new Error("No table found");
    a = Wt.get(o), p = h.mapping.maps.length;
  }
  Sj(h, a, o, n, u, f, p) && y(), JT(h, a, o, n, l, u, s, p) && y(), JT(h, a, o, n, l, u, f, p) && y(), YT(h, a, o, n, s, f, l, p) && y(), YT(h, a, o, n, s, f, u, p) && y();
  for (let b = s; b < f; b++) {
    const x = a.positionAt(b, l, o), v = a.positionAt(b, u, o);
    h.replace(
      h.mapping.slice(p).map(x + n),
      h.mapping.slice(p).map(v + n),
      new We(i.rows[b - s], 0, 0)
    );
  }
  y(), h.setSelection(
    new Rt(
      h.doc.resolve(n + a.positionAt(s, l, o)),
      h.doc.resolve(n + a.positionAt(f - 1, u - 1, o))
    )
  ), e(h);
}
var Tj = i2({
  ArrowLeft: op("horiz", -1),
  ArrowRight: op("horiz", 1),
  ArrowUp: op("vert", -1),
  ArrowDown: op("vert", 1),
  "Shift-ArrowLeft": ap("horiz", -1),
  "Shift-ArrowRight": ap("horiz", 1),
  "Shift-ArrowUp": ap("vert", -1),
  "Shift-ArrowDown": ap("vert", 1),
  Backspace: ip,
  "Mod-Backspace": ip,
  Delete: ip,
  "Mod-Delete": ip
});
function Np(t, e, n) {
  return n.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function op(t, e) {
  return (n, r, i) => {
    if (!i)
      return !1;
    const o = n.selection;
    if (o instanceof Rt)
      return Np(
        n,
        r,
        et.near(o.$headCell, e)
      );
    if (t != "horiz" && !o.empty)
      return !1;
    const a = pU(i, t, e);
    if (a == null)
      return !1;
    if (t == "horiz")
      return Np(
        n,
        r,
        et.near(n.doc.resolve(o.head + e), e)
      );
    {
      const s = n.doc.resolve(a), l = lU(s, t, e);
      let u;
      return l ? u = et.near(l, 1) : e < 0 ? u = et.near(n.doc.resolve(s.before(-1)), -1) : u = et.near(n.doc.resolve(s.after(-1)), 1), Np(n, r, u);
    }
  };
}
function ap(t, e) {
  return (n, r, i) => {
    if (!i)
      return !1;
    const o = n.selection;
    let a;
    if (o instanceof Rt)
      a = o;
    else {
      const l = pU(i, t, e);
      if (l == null)
        return !1;
      a = new Rt(n.doc.resolve(l));
    }
    const s = lU(a.$headCell, t, e);
    return s ? Np(
      n,
      r,
      new Rt(a.$anchorCell, s)
    ) : !1;
  };
}
function Cj(t, e) {
  const n = t.state.doc, r = ku(n.resolve(e));
  return r ? (t.dispatch(t.state.tr.setSelection(new Rt(r))), !0) : !1;
}
function Ej(t, e, n) {
  if (!yi(t.state))
    return !1;
  let r = xj(n);
  const i = t.state.selection;
  if (i instanceof Rt) {
    r || (r = {
      width: 1,
      height: 1,
      rows: [
        Fe.from(
          P0(Un(t.state.schema).cell, n)
        )
      ]
    });
    const o = i.$anchorCell.node(-1), a = i.$anchorCell.start(-1), s = Wt.get(o).rectBetween(
      i.$anchorCell.pos - a,
      i.$headCell.pos - a
    );
    return r = wj(r, s.right - s.left, s.bottom - s.top), ZT(t.state, t.dispatch, a, s, r), !0;
  } else if (r) {
    const o = Am(t.state), a = o.start(-1);
    return ZT(
      t.state,
      t.dispatch,
      a,
      Wt.get(o.node(-1)).findCell(o.pos - a),
      r
    ), !0;
  } else
    return !1;
}
function _j(t, e) {
  var n;
  if (e.ctrlKey || e.metaKey)
    return;
  const r = KT(t, e.target);
  let i;
  if (e.shiftKey && t.state.selection instanceof Rt)
    o(t.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && r && (i = ku(t.state.selection.$anchor)) != null && ((n = mv(t, e)) == null ? void 0 : n.pos) != i.pos)
    o(i, e), e.preventDefault();
  else if (!r)
    return;
  function o(l, u) {
    let f = mv(t, u);
    const h = La.getState(t.state) == null;
    if (!f || !Y2(l, f))
      if (h)
        f = l;
      else
        return;
    const p = new Rt(l, f);
    if (h || !t.state.selection.eq(p)) {
      const y = t.state.tr.setSelection(p);
      h && y.setMeta(La, l.pos), t.dispatch(y);
    }
  }
  function a() {
    t.root.removeEventListener("mouseup", a), t.root.removeEventListener("dragstart", a), t.root.removeEventListener("mousemove", s), La.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(La, -1));
  }
  function s(l) {
    const u = l, f = La.getState(t.state);
    let h;
    if (f != null)
      h = t.state.doc.resolve(f);
    else if (KT(t, u.target) != r && (h = mv(t, e), !h))
      return a();
    h && o(h, u);
  }
  t.root.addEventListener("mouseup", a), t.root.addEventListener("dragstart", a), t.root.addEventListener("mousemove", s);
}
function pU(t, e, n) {
  if (!(t.state.selection instanceof st))
    return null;
  const { $head: r } = t.state.selection;
  for (let i = r.depth - 1; i >= 0; i--) {
    const o = r.node(i);
    if ((n < 0 ? r.index(i) : r.indexAfter(i)) != (n < 0 ? 0 : o.childCount))
      return null;
    if (o.type.spec.tableRole == "cell" || o.type.spec.tableRole == "header_cell") {
      const s = r.before(i), l = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
      return t.endOfTextblock(l) ? s : null;
    }
  }
  return null;
}
function KT(t, e) {
  for (; e && e != t.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function mv(t, e) {
  const n = t.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return n && n ? ku(t.state.doc.resolve(n.pos)) : null;
}
var kj = class {
  constructor(t, e) {
    this.node = t, this.defaultCellMinWidth = e, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
      "--default-cell-min-width",
      `${e}px`
    ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), W0(t, this.colgroup, this.table, e), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(t) {
    return t.type != this.node.type ? !1 : (this.node = t, W0(
      t,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    ), !0);
  }
  ignoreMutation(t) {
    return t.type == "attributes" && (t.target == this.table || this.colgroup.contains(t.target));
  }
};
function W0(t, e, n, r, i, o) {
  var a;
  let s = 0, l = !0, u = e.firstChild;
  const f = t.firstChild;
  if (f) {
    for (let h = 0, p = 0; h < f.childCount; h++) {
      const { colspan: y, colwidth: b } = f.child(h).attrs;
      for (let x = 0; x < y; x++, p++) {
        const v = i == p ? o : b && b[x], D = v ? v + "px" : "";
        if (s += v || r, v || (l = !1), u)
          u.style.width != D && (u.style.width = D), u = u.nextSibling;
        else {
          const S = document.createElement("col");
          S.style.width = D, e.appendChild(S);
        }
      }
    }
    for (; u; ) {
      const h = u.nextSibling;
      (a = u.parentNode) == null || a.removeChild(u), u = h;
    }
    l ? (n.style.width = s + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = s + "px");
  }
}
var Er = new ns(
  "tableColumnResizing"
);
function GJ({
  handleWidth: t = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: n = 100,
  View: r = kj,
  lastColumnResizable: i = !0
} = {}) {
  const o = new xu({
    key: Er,
    state: {
      init(a, s) {
        var l, u;
        const f = (u = (l = o.spec) == null ? void 0 : l.props) == null ? void 0 : u.nodeViews, h = Un(s.schema).table.name;
        return r && f && (f[h] = (p, y) => new r(p, n, y)), new Aj(-1, !1);
      },
      apply(a, s) {
        return s.apply(a);
      }
    },
    props: {
      attributes: (a) => {
        const s = Er.getState(a);
        return s && s.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (a, s) => {
          Uj(a, s, t, i);
        },
        mouseleave: (a) => {
          Fj(a);
        },
        mousedown: (a, s) => {
          Rj(a, s, e, n);
        }
      },
      decorations: (a) => {
        const s = Er.getState(a);
        if (s && s.activeHandle > -1)
          return Nj(a, s.activeHandle);
      },
      nodeViews: {}
    }
  });
  return o;
}
var Aj = class Pp {
  constructor(e, n) {
    this.activeHandle = e, this.dragging = n;
  }
  apply(e) {
    const n = this, r = e.getMeta(Er);
    if (r && r.setHandle != null)
      return new Pp(r.setHandle, !1);
    if (r && r.setDragging !== void 0)
      return new Pp(n.activeHandle, r.setDragging);
    if (n.activeHandle > -1 && e.docChanged) {
      let i = e.mapping.map(n.activeHandle, -1);
      return N0(e.doc.resolve(i)) || (i = -1), new Pp(i, n.dragging);
    }
    return n;
  }
};
function Uj(t, e, n, r) {
  const i = Er.getState(t.state);
  if (i && !i.dragging) {
    const o = Ij(e.target);
    let a = -1;
    if (o) {
      const { left: s, right: l } = o.getBoundingClientRect();
      e.clientX - s <= n ? a = QT(t, e, "left", n) : l - e.clientX <= n && (a = QT(t, e, "right", n));
    }
    if (a != i.activeHandle) {
      if (!r && a !== -1) {
        const s = t.state.doc.resolve(a), l = s.node(-1), u = Wt.get(l), f = s.start(-1);
        if (u.colCount(s.pos - f) + s.nodeAfter.attrs.colspan - 1 == u.width - 1)
          return;
      }
      gU(t, a);
    }
  }
}
function Fj(t) {
  const e = Er.getState(t.state);
  e && e.activeHandle > -1 && !e.dragging && gU(t, -1);
}
function Rj(t, e, n, r) {
  var i;
  const o = (i = t.dom.ownerDocument.defaultView) != null ? i : window, a = Er.getState(t.state);
  if (!a || a.activeHandle == -1 || a.dragging)
    return !1;
  const s = t.state.doc.nodeAt(a.activeHandle), l = Oj(t, a.activeHandle, s.attrs);
  t.dispatch(
    t.state.tr.setMeta(Er, {
      setDragging: { startX: e.clientX, startWidth: l }
    })
  );
  function u(h) {
    o.removeEventListener("mouseup", u), o.removeEventListener("mousemove", f);
    const p = Er.getState(t.state);
    p != null && p.dragging && (Bj(
      t,
      p.activeHandle,
      eC(p.dragging, h, n)
    ), t.dispatch(
      t.state.tr.setMeta(Er, { setDragging: null })
    ));
  }
  function f(h) {
    if (!h.which)
      return u(h);
    const p = Er.getState(t.state);
    if (p && p.dragging) {
      const y = eC(p.dragging, h, n);
      tC(
        t,
        p.activeHandle,
        y,
        r
      );
    }
  }
  return tC(
    t,
    a.activeHandle,
    l,
    r
  ), o.addEventListener("mouseup", u), o.addEventListener("mousemove", f), e.preventDefault(), !0;
}
function Oj(t, e, { colspan: n, colwidth: r }) {
  const i = r && r[r.length - 1];
  if (i)
    return i;
  const o = t.domAtPos(e);
  let s = o.node.childNodes[o.offset].offsetWidth, l = n;
  if (r)
    for (let u = 0; u < n; u++)
      r[u] && (s -= r[u], l--);
  return s / l;
}
function Ij(t) {
  for (; t && t.nodeName != "TD" && t.nodeName != "TH"; )
    t = t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode;
  return t;
}
function QT(t, e, n, r) {
  const i = n == "right" ? -r : r, o = t.posAtCoords({
    left: e.clientX + i,
    top: e.clientY
  });
  if (!o)
    return -1;
  const { pos: a } = o, s = ku(t.state.doc.resolve(a));
  if (!s)
    return -1;
  if (n == "right")
    return s.pos;
  const l = Wt.get(s.node(-1)), u = s.start(-1), f = l.map.indexOf(s.pos - u);
  return f % l.width == 0 ? -1 : u + l.map[f - 1];
}
function eC(t, e, n) {
  const r = e.clientX - t.startX;
  return Math.max(n, t.startWidth + r);
}
function gU(t, e) {
  t.dispatch(
    t.state.tr.setMeta(Er, { setHandle: e })
  );
}
function Bj(t, e, n) {
  const r = t.state.doc.resolve(e), i = r.node(-1), o = Wt.get(i), a = r.start(-1), s = o.colCount(r.pos - a) + r.nodeAfter.attrs.colspan - 1, l = t.state.tr;
  for (let u = 0; u < o.height; u++) {
    const f = u * o.width + s;
    if (u && o.map[f] == o.map[f - o.width])
      continue;
    const h = o.map[f], p = i.nodeAt(h).attrs, y = p.colspan == 1 ? 0 : s - o.colCount(h);
    if (p.colwidth && p.colwidth[y] == n)
      continue;
    const b = p.colwidth ? p.colwidth.slice() : Mj(p.colspan);
    b[y] = n, l.setNodeMarkup(a + h, null, { ...p, colwidth: b });
  }
  l.docChanged && t.dispatch(l);
}
function tC(t, e, n, r) {
  const i = t.state.doc.resolve(e), o = i.node(-1), a = i.start(-1), s = Wt.get(o).colCount(i.pos - a) + i.nodeAfter.attrs.colspan - 1;
  let l = t.domAtPos(i.start(-1)).node;
  for (; l && l.nodeName != "TABLE"; )
    l = l.parentNode;
  l && W0(
    o,
    l.firstChild,
    l,
    r,
    s,
    n
  );
}
function Mj(t) {
  return Array(t).fill(0);
}
function Nj(t, e) {
  var n;
  const r = [], i = t.doc.resolve(e), o = i.node(-1);
  if (!o)
    return Nt.empty;
  const a = Wt.get(o), s = i.start(-1), l = a.colCount(i.pos - s) + i.nodeAfter.attrs.colspan - 1;
  for (let u = 0; u < a.height; u++) {
    const f = l + u * a.width;
    if ((l == a.width - 1 || a.map[f] != a.map[f + 1]) && (u == 0 || a.map[f] != a.map[f - a.width])) {
      const h = a.map[f], p = s + h + o.nodeAt(h).nodeSize - 1, y = document.createElement("div");
      y.className = "column-resize-handle", (n = Er.getState(t)) != null && n.dragging && r.push(
        qn.node(
          s + h,
          s + h + o.nodeAt(h).nodeSize,
          {
            class: "column-resize-dragging"
          }
        )
      ), r.push(qn.widget(p, y));
    }
  }
  return Nt.create(t.doc, r);
}
function JJ({
  allowTableNodeSelection: t = !1
} = {}) {
  return new xu({
    key: La,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, n) {
        const r = e.getMeta(La);
        if (r != null)
          return r == -1 ? null : r;
        if (n == null || !e.docChanged)
          return n;
        const { deleted: i, pos: o } = e.mapping.mapResult(n);
        return i ? null : o;
      }
    },
    props: {
      decorations: aj,
      handleDOMEvents: {
        mousedown: _j
      },
      createSelectionBetween(e) {
        return La.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: Cj,
      handleKeyDown: Tj,
      handlePaste: Ej
    },
    appendTransaction(e, n, r) {
      return cj(
        r,
        fj(r, n),
        t
      );
    }
  });
}
var ro = {}, K2 = "1.13.7", nC = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {}, Um = Array.prototype, Q2 = Object.prototype, rC = typeof Symbol < "u" ? Symbol.prototype : null, Pj = Um.push, Gd = Um.slice, kd = Q2.toString, Wj = Q2.hasOwnProperty, mU = typeof ArrayBuffer < "u", Lj = typeof DataView < "u", zj = Array.isArray, iC = Object.keys, oC = Object.create, aC = mU && ArrayBuffer.isView, $j = isNaN, jj = isFinite, yU = !{ toString: null }.propertyIsEnumerable("toString"), sC = [
  "valueOf",
  "isPrototypeOf",
  "toString",
  "propertyIsEnumerable",
  "hasOwnProperty",
  "toLocaleString"
], Hj = Math.pow(2, 53) - 1;
function Yn(t, e) {
  return e = e == null ? t.length - 1 : +e, function() {
    for (var n = Math.max(arguments.length - e, 0), r = Array(n), i = 0; i < n; i++)
      r[i] = arguments[i + e];
    switch (e) {
      case 0:
        return t.call(this, r);
      case 1:
        return t.call(this, arguments[0], r);
      case 2:
        return t.call(this, arguments[0], arguments[1], r);
    }
    var o = Array(e + 1);
    for (i = 0; i < e; i++)
      o[i] = arguments[i];
    return o[e] = r, t.apply(this, o);
  };
}
function cs(t) {
  var e = typeof t;
  return e === "function" || e === "object" && !!t;
}
function bU(t) {
  return t === null;
}
function ex(t) {
  return t === void 0;
}
function tx(t) {
  return t === !0 || t === !1 || kd.call(t) === "[object Boolean]";
}
function vU(t) {
  return !!(t && t.nodeType === 1);
}
function On(t) {
  var e = "[object " + t + "]";
  return function(n) {
    return kd.call(n) === e;
  };
}
const Fm = On("String"), nx = On("Number"), xU = On("Date"), DU = On("RegExp"), wU = On("Error"), rx = On("Symbol"), ix = On("ArrayBuffer");
var SU = On("Function"), Vj = nC.document && nC.document.childNodes;
typeof /./ != "function" && typeof Int8Array != "object" && typeof Vj != "function" && (SU = function(t) {
  return typeof t == "function" || !1;
});
const Fn = SU, TU = On("Object");
var CU = Lj && (!/\[native code\]/.test(String(DataView)) || TU(new DataView(new ArrayBuffer(8)))), ox = typeof Map < "u" && TU(/* @__PURE__ */ new Map()), qj = On("DataView");
function Xj(t) {
  return t != null && Fn(t.getInt8) && ix(t.buffer);
}
const Ad = CU ? Xj : qj, us = zj || On("Array");
function fs(t, e) {
  return t != null && Wj.call(t, e);
}
var L0 = On("Arguments");
(function() {
  L0(arguments) || (L0 = function(t) {
    return fs(t, "callee");
  });
})();
const Rm = L0;
function EU(t) {
  return !rx(t) && jj(t) && !isNaN(parseFloat(t));
}
function ax(t) {
  return nx(t) && $j(t);
}
function sx(t) {
  return function() {
    return t;
  };
}
function _U(t) {
  return function(e) {
    var n = t(e);
    return typeof n == "number" && n >= 0 && n <= Hj;
  };
}
function kU(t) {
  return function(e) {
    return e == null ? void 0 : e[t];
  };
}
const Kg = kU("byteLength"), Gj = _U(Kg);
var Jj = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function Yj(t) {
  return aC ? aC(t) && !Ad(t) : Gj(t) && Jj.test(kd.call(t));
}
const lx = mU ? Yj : sx(!1), dr = kU("length");
function Zj(t) {
  for (var e = {}, n = t.length, r = 0; r < n; ++r) e[t[r]] = !0;
  return {
    contains: function(i) {
      return e[i] === !0;
    },
    push: function(i) {
      return e[i] = !0, t.push(i);
    }
  };
}
function AU(t, e) {
  e = Zj(e);
  var n = sC.length, r = t.constructor, i = Fn(r) && r.prototype || Q2, o = "constructor";
  for (fs(t, o) && !e.contains(o) && e.push(o); n--; )
    o = sC[n], o in t && t[o] !== i[o] && !e.contains(o) && e.push(o);
}
function qt(t) {
  if (!cs(t)) return [];
  if (iC) return iC(t);
  var e = [];
  for (var n in t) fs(t, n) && e.push(n);
  return yU && AU(t, e), e;
}
function UU(t) {
  if (t == null) return !0;
  var e = dr(t);
  return typeof e == "number" && (us(t) || Fm(t) || Rm(t)) ? e === 0 : dr(qt(t)) === 0;
}
function cx(t, e) {
  var n = qt(e), r = n.length;
  if (t == null) return !r;
  for (var i = Object(t), o = 0; o < r; o++) {
    var a = n[o];
    if (e[a] !== i[a] || !(a in i)) return !1;
  }
  return !0;
}
function yt(t) {
  if (t instanceof yt) return t;
  if (!(this instanceof yt)) return new yt(t);
  this._wrapped = t;
}
yt.VERSION = K2;
yt.prototype.value = function() {
  return this._wrapped;
};
yt.prototype.valueOf = yt.prototype.toJSON = yt.prototype.value;
yt.prototype.toString = function() {
  return String(this._wrapped);
};
function lC(t) {
  return new Uint8Array(
    t.buffer || t,
    t.byteOffset || 0,
    Kg(t)
  );
}
var cC = "[object DataView]";
function z0(t, e, n, r) {
  if (t === e) return t !== 0 || 1 / t === 1 / e;
  if (t == null || e == null) return !1;
  if (t !== t) return e !== e;
  var i = typeof t;
  return i !== "function" && i !== "object" && typeof e != "object" ? !1 : FU(t, e, n, r);
}
function FU(t, e, n, r) {
  t instanceof yt && (t = t._wrapped), e instanceof yt && (e = e._wrapped);
  var i = kd.call(t);
  if (i !== kd.call(e)) return !1;
  if (CU && i == "[object Object]" && Ad(t)) {
    if (!Ad(e)) return !1;
    i = cC;
  }
  switch (i) {
    case "[object RegExp]":
    case "[object String]":
      return "" + t == "" + e;
    case "[object Number]":
      return +t != +t ? +e != +e : +t == 0 ? 1 / +t === 1 / e : +t == +e;
    case "[object Date]":
    case "[object Boolean]":
      return +t == +e;
    case "[object Symbol]":
      return rC.valueOf.call(t) === rC.valueOf.call(e);
    case "[object ArrayBuffer]":
    case cC:
      return FU(lC(t), lC(e), n, r);
  }
  var o = i === "[object Array]";
  if (!o && lx(t)) {
    var a = Kg(t);
    if (a !== Kg(e)) return !1;
    if (t.buffer === e.buffer && t.byteOffset === e.byteOffset) return !0;
    o = !0;
  }
  if (!o) {
    if (typeof t != "object" || typeof e != "object") return !1;
    var s = t.constructor, l = e.constructor;
    if (s !== l && !(Fn(s) && s instanceof s && Fn(l) && l instanceof l) && "constructor" in t && "constructor" in e)
      return !1;
  }
  n = n || [], r = r || [];
  for (var u = n.length; u--; )
    if (n[u] === t) return r[u] === e;
  if (n.push(t), r.push(e), o) {
    if (u = t.length, u !== e.length) return !1;
    for (; u--; )
      if (!z0(t[u], e[u], n, r)) return !1;
  } else {
    var f = qt(t), h;
    if (u = f.length, qt(e).length !== u) return !1;
    for (; u--; )
      if (h = f[u], !(fs(e, h) && z0(t[h], e[h], n, r))) return !1;
  }
  return n.pop(), r.pop(), !0;
}
function RU(t, e) {
  return z0(t, e);
}
function Au(t) {
  if (!cs(t)) return [];
  var e = [];
  for (var n in t) e.push(n);
  return yU && AU(t, e), e;
}
function ux(t) {
  var e = dr(t);
  return function(n) {
    if (n == null) return !1;
    var r = Au(n);
    if (dr(r)) return !1;
    for (var i = 0; i < e; i++)
      if (!Fn(n[t[i]])) return !1;
    return t !== BU || !Fn(n[fx]);
  };
}
var fx = "forEach", OU = "has", dx = ["clear", "delete"], IU = ["get", OU, "set"], Kj = dx.concat(fx, IU), BU = dx.concat(IU), Qj = ["add"].concat(dx, fx, OU);
const MU = ox ? ux(Kj) : On("Map"), NU = ox ? ux(BU) : On("WeakMap"), PU = ox ? ux(Qj) : On("Set"), WU = On("WeakSet");
function Tl(t) {
  for (var e = qt(t), n = e.length, r = Array(n), i = 0; i < n; i++)
    r[i] = t[e[i]];
  return r;
}
function LU(t) {
  for (var e = qt(t), n = e.length, r = Array(n), i = 0; i < n; i++)
    r[i] = [e[i], t[e[i]]];
  return r;
}
function hx(t) {
  for (var e = {}, n = qt(t), r = 0, i = n.length; r < i; r++)
    e[t[n[r]]] = n[r];
  return e;
}
function Ud(t) {
  var e = [];
  for (var n in t)
    Fn(t[n]) && e.push(n);
  return e.sort();
}
function px(t, e) {
  return function(n) {
    var r = arguments.length;
    if (e && (n = Object(n)), r < 2 || n == null) return n;
    for (var i = 1; i < r; i++)
      for (var o = arguments[i], a = t(o), s = a.length, l = 0; l < s; l++) {
        var u = a[l];
        (!e || n[u] === void 0) && (n[u] = o[u]);
      }
    return n;
  };
}
const gx = px(Au), du = px(qt), mx = px(Au, !0);
function eH() {
  return function() {
  };
}
function zU(t) {
  if (!cs(t)) return {};
  if (oC) return oC(t);
  var e = eH();
  e.prototype = t;
  var n = new e();
  return e.prototype = null, n;
}
function $U(t, e) {
  var n = zU(t);
  return e && du(n, e), n;
}
function jU(t) {
  return cs(t) ? us(t) ? t.slice() : gx({}, t) : t;
}
function HU(t, e) {
  return e(t), t;
}
function yx(t) {
  return us(t) ? t : [t];
}
yt.toPath = yx;
function Jd(t) {
  return yt.toPath(t);
}
function bx(t, e) {
  for (var n = e.length, r = 0; r < n; r++) {
    if (t == null) return;
    t = t[e[r]];
  }
  return n ? t : void 0;
}
function vx(t, e, n) {
  var r = bx(t, Jd(e));
  return ex(r) ? n : r;
}
function VU(t, e) {
  e = Jd(e);
  for (var n = e.length, r = 0; r < n; r++) {
    var i = e[r];
    if (!fs(t, i)) return !1;
    t = t[i];
  }
  return !!n;
}
function Om(t) {
  return t;
}
function gl(t) {
  return t = du({}, t), function(e) {
    return cx(e, t);
  };
}
function Im(t) {
  return t = Jd(t), function(e) {
    return bx(e, t);
  };
}
function Yd(t, e, n) {
  if (e === void 0) return t;
  switch (n ?? 3) {
    case 1:
      return function(r) {
        return t.call(e, r);
      };
    case 3:
      return function(r, i, o) {
        return t.call(e, r, i, o);
      };
    case 4:
      return function(r, i, o, a) {
        return t.call(e, r, i, o, a);
      };
  }
  return function() {
    return t.apply(e, arguments);
  };
}
function qU(t, e, n) {
  return t == null ? Om : Fn(t) ? Yd(t, e, n) : cs(t) && !us(t) ? gl(t) : Im(t);
}
function Bm(t, e) {
  return qU(t, e, 1 / 0);
}
yt.iteratee = Bm;
function pr(t, e, n) {
  return yt.iteratee !== Bm ? yt.iteratee(t, e) : qU(t, e, n);
}
function XU(t, e, n) {
  e = pr(e, n);
  for (var r = qt(t), i = r.length, o = {}, a = 0; a < i; a++) {
    var s = r[a];
    o[s] = e(t[s], s, t);
  }
  return o;
}
function xx() {
}
function GU(t) {
  return t == null ? xx : function(e) {
    return vx(t, e);
  };
}
function JU(t, e, n) {
  var r = Array(Math.max(0, t));
  e = Yd(e, n, 1);
  for (var i = 0; i < t; i++) r[i] = e(i);
  return r;
}
function Qg(t, e) {
  return e == null && (e = t, t = 0), t + Math.floor(Math.random() * (e - t + 1));
}
const hu = Date.now || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function YU(t) {
  var e = function(o) {
    return t[o];
  }, n = "(?:" + qt(t).join("|") + ")", r = RegExp(n), i = RegExp(n, "g");
  return function(o) {
    return o = o == null ? "" : "" + o, r.test(o) ? o.replace(i, e) : o;
  };
}
const ZU = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
}, KU = YU(ZU), tH = hx(ZU), QU = YU(tH), eF = yt.templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
};
var yv = /(.)^/, nH = {
  "'": "'",
  "\\": "\\",
  "\r": "r",
  "\n": "n",
  "\u2028": "u2028",
  "\u2029": "u2029"
}, rH = /\\|'|\r|\n|\u2028|\u2029/g;
function iH(t) {
  return "\\" + nH[t];
}
var oH = /^\s*(\w|\$)+\s*$/;
function tF(t, e, n) {
  !e && n && (e = n), e = mx({}, e, yt.templateSettings);
  var r = RegExp([
    (e.escape || yv).source,
    (e.interpolate || yv).source,
    (e.evaluate || yv).source
  ].join("|") + "|$", "g"), i = 0, o = "__p+='";
  t.replace(r, function(u, f, h, p, y) {
    return o += t.slice(i, y).replace(rH, iH), i = y + u.length, f ? o += `'+
((__t=(` + f + `))==null?'':_.escape(__t))+
'` : h ? o += `'+
((__t=(` + h + `))==null?'':__t)+
'` : p && (o += `';
` + p + `
__p+='`), u;
  }), o += `';
`;
  var a = e.variable;
  if (a) {
    if (!oH.test(a)) throw new Error(
      "variable is not a bare identifier: " + a
    );
  } else
    o = `with(obj||{}){
` + o + `}
`, a = "obj";
  o = `var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
` + o + `return __p;
`;
  var s;
  try {
    s = new Function(a, "_", o);
  } catch (u) {
    throw u.source = o, u;
  }
  var l = function(u) {
    return s.call(this, u, yt);
  };
  return l.source = "function(" + a + `){
` + o + "}", l;
}
function nF(t, e, n) {
  e = Jd(e);
  var r = e.length;
  if (!r)
    return Fn(n) ? n.call(t) : n;
  for (var i = 0; i < r; i++) {
    var o = t == null ? void 0 : t[e[i]];
    o === void 0 && (o = n, i = r), t = Fn(o) ? o.call(t) : o;
  }
  return t;
}
var aH = 0;
function rF(t) {
  var e = ++aH + "";
  return t ? t + e : e;
}
function iF(t) {
  var e = yt(t);
  return e._chain = !0, e;
}
function oF(t, e, n, r, i) {
  if (!(r instanceof e)) return t.apply(n, i);
  var o = zU(t.prototype), a = t.apply(o, i);
  return cs(a) ? a : o;
}
var Cl = Yn(function(t, e) {
  var n = Cl.placeholder, r = function() {
    for (var i = 0, o = e.length, a = Array(o), s = 0; s < o; s++)
      a[s] = e[s] === n ? arguments[i++] : e[s];
    for (; i < arguments.length; ) a.push(arguments[i++]);
    return oF(t, r, this, this, a);
  };
  return r;
});
Cl.placeholder = yt;
const Dx = Yn(function(t, e, n) {
  if (!Fn(t)) throw new TypeError("Bind must be called on a function");
  var r = Yn(function(i) {
    return oF(t, r, e, this, n.concat(i));
  });
  return r;
}), kr = _U(dr);
function El(t, e, n, r) {
  if (r = r || [], !e && e !== 0)
    e = 1 / 0;
  else if (e <= 0)
    return r.concat(t);
  for (var i = r.length, o = 0, a = dr(t); o < a; o++) {
    var s = t[o];
    if (kr(s) && (us(s) || Rm(s)))
      if (e > 1)
        El(s, e - 1, n, r), i = r.length;
      else
        for (var l = 0, u = s.length; l < u; ) r[i++] = s[l++];
    else n || (r[i++] = s);
  }
  return r;
}
const aF = Yn(function(t, e) {
  e = El(e, !1, !1);
  var n = e.length;
  if (n < 1) throw new Error("bindAll must be passed function names");
  for (; n--; ) {
    var r = e[n];
    t[r] = Dx(t[r], t);
  }
  return t;
});
function sF(t, e) {
  var n = function(r) {
    var i = n.cache, o = "" + (e ? e.apply(this, arguments) : r);
    return fs(i, o) || (i[o] = t.apply(this, arguments)), i[o];
  };
  return n.cache = {}, n;
}
const wx = Yn(function(t, e, n) {
  return setTimeout(function() {
    return t.apply(null, n);
  }, e);
}), lF = Cl(wx, yt, 1);
function cF(t, e, n) {
  var r, i, o, a, s = 0;
  n || (n = {});
  var l = function() {
    s = n.leading === !1 ? 0 : hu(), r = null, a = t.apply(i, o), r || (i = o = null);
  }, u = function() {
    var f = hu();
    !s && n.leading === !1 && (s = f);
    var h = e - (f - s);
    return i = this, o = arguments, h <= 0 || h > e ? (r && (clearTimeout(r), r = null), s = f, a = t.apply(i, o), r || (i = o = null)) : !r && n.trailing !== !1 && (r = setTimeout(l, h)), a;
  };
  return u.cancel = function() {
    clearTimeout(r), s = 0, r = i = o = null;
  }, u;
}
function uF(t, e, n) {
  var r, i, o, a, s, l = function() {
    var f = hu() - i;
    e > f ? r = setTimeout(l, e - f) : (r = null, n || (a = t.apply(s, o)), r || (o = s = null));
  }, u = Yn(function(f) {
    return s = this, o = f, i = hu(), r || (r = setTimeout(l, e), n && (a = t.apply(s, o))), a;
  });
  return u.cancel = function() {
    clearTimeout(r), r = o = s = null;
  }, u;
}
function fF(t, e) {
  return Cl(e, t);
}
function Mm(t) {
  return function() {
    return !t.apply(this, arguments);
  };
}
function dF() {
  var t = arguments, e = t.length - 1;
  return function() {
    for (var n = e, r = t[e].apply(this, arguments); n--; ) r = t[n].call(this, r);
    return r;
  };
}
function hF(t, e) {
  return function() {
    if (--t < 1)
      return e.apply(this, arguments);
  };
}
function Sx(t, e) {
  var n;
  return function() {
    return --t > 0 && (n = e.apply(this, arguments)), t <= 1 && (e = null), n;
  };
}
const pF = Cl(Sx, 2);
function Tx(t, e, n) {
  e = pr(e, n);
  for (var r = qt(t), i, o = 0, a = r.length; o < a; o++)
    if (i = r[o], e(t[i], i, t)) return i;
}
function gF(t) {
  return function(e, n, r) {
    n = pr(n, r);
    for (var i = dr(e), o = t > 0 ? 0 : i - 1; o >= 0 && o < i; o += t)
      if (n(e[o], o, e)) return o;
    return -1;
  };
}
const Nm = gF(1), Cx = gF(-1);
function Ex(t, e, n, r) {
  n = pr(n, r, 1);
  for (var i = n(e), o = 0, a = dr(t); o < a; ) {
    var s = Math.floor((o + a) / 2);
    n(t[s]) < i ? o = s + 1 : a = s;
  }
  return o;
}
function mF(t, e, n) {
  return function(r, i, o) {
    var a = 0, s = dr(r);
    if (typeof o == "number")
      t > 0 ? a = o >= 0 ? o : Math.max(o + s, a) : s = o >= 0 ? Math.min(o + 1, s) : o + s + 1;
    else if (n && o && s)
      return o = n(r, i), r[o] === i ? o : -1;
    if (i !== i)
      return o = e(Gd.call(r, a, s), ax), o >= 0 ? o + a : -1;
    for (o = t > 0 ? a : s - 1; o >= 0 && o < s; o += t)
      if (r[o] === i) return o;
    return -1;
  };
}
const _x = mF(1, Nm, Ex), yF = mF(-1, Cx);
function Fd(t, e, n) {
  var r = kr(t) ? Nm : Tx, i = r(t, e, n);
  if (i !== void 0 && i !== -1) return t[i];
}
function bF(t, e) {
  return Fd(t, gl(e));
}
function mi(t, e, n) {
  e = Yd(e, n);
  var r, i;
  if (kr(t))
    for (r = 0, i = t.length; r < i; r++)
      e(t[r], r, t);
  else {
    var o = qt(t);
    for (r = 0, i = o.length; r < i; r++)
      e(t[o[r]], o[r], t);
  }
  return t;
}
function jo(t, e, n) {
  e = pr(e, n);
  for (var r = !kr(t) && qt(t), i = (r || t).length, o = Array(i), a = 0; a < i; a++) {
    var s = r ? r[a] : a;
    o[a] = e(t[s], s, t);
  }
  return o;
}
function vF(t) {
  var e = function(n, r, i, o) {
    var a = !kr(n) && qt(n), s = (a || n).length, l = t > 0 ? 0 : s - 1;
    for (o || (i = n[a ? a[l] : l], l += t); l >= 0 && l < s; l += t) {
      var u = a ? a[l] : l;
      i = r(i, n[u], u, n);
    }
    return i;
  };
  return function(n, r, i, o) {
    var a = arguments.length >= 3;
    return e(n, Yd(r, o, 4), i, a);
  };
}
const Zc = vF(1), em = vF(-1);
function es(t, e, n) {
  var r = [];
  return e = pr(e, n), mi(t, function(i, o, a) {
    e(i, o, a) && r.push(i);
  }), r;
}
function xF(t, e, n) {
  return es(t, Mm(pr(e)), n);
}
function tm(t, e, n) {
  e = pr(e, n);
  for (var r = !kr(t) && qt(t), i = (r || t).length, o = 0; o < i; o++) {
    var a = r ? r[o] : o;
    if (!e(t[a], a, t)) return !1;
  }
  return !0;
}
function nm(t, e, n) {
  e = pr(e, n);
  for (var r = !kr(t) && qt(t), i = (r || t).length, o = 0; o < i; o++) {
    var a = r ? r[o] : o;
    if (e(t[a], a, t)) return !0;
  }
  return !1;
}
function Zr(t, e, n, r) {
  return kr(t) || (t = Tl(t)), (typeof n != "number" || r) && (n = 0), _x(t, e, n) >= 0;
}
const DF = Yn(function(t, e, n) {
  var r, i;
  return Fn(e) ? i = e : (e = Jd(e), r = e.slice(0, -1), e = e[e.length - 1]), jo(t, function(o) {
    var a = i;
    if (!a) {
      if (r && r.length && (o = bx(o, r)), o == null) return;
      a = o[e];
    }
    return a == null ? a : a.apply(o, n);
  });
});
function Pm(t, e) {
  return jo(t, Im(e));
}
function wF(t, e) {
  return es(t, gl(e));
}
function kx(t, e, n) {
  var r = -1 / 0, i = -1 / 0, o, a;
  if (e == null || typeof e == "number" && typeof t[0] != "object" && t != null) {
    t = kr(t) ? t : Tl(t);
    for (var s = 0, l = t.length; s < l; s++)
      o = t[s], o != null && o > r && (r = o);
  } else
    e = pr(e, n), mi(t, function(u, f, h) {
      a = e(u, f, h), (a > i || a === -1 / 0 && r === -1 / 0) && (r = u, i = a);
    });
  return r;
}
function SF(t, e, n) {
  var r = 1 / 0, i = 1 / 0, o, a;
  if (e == null || typeof e == "number" && typeof t[0] != "object" && t != null) {
    t = kr(t) ? t : Tl(t);
    for (var s = 0, l = t.length; s < l; s++)
      o = t[s], o != null && o < r && (r = o);
  } else
    e = pr(e, n), mi(t, function(u, f, h) {
      a = e(u, f, h), (a < i || a === 1 / 0 && r === 1 / 0) && (r = u, i = a);
    });
  return r;
}
var sH = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function Ax(t) {
  return t ? us(t) ? Gd.call(t) : Fm(t) ? t.match(sH) : kr(t) ? jo(t, Om) : Tl(t) : [];
}
function Ux(t, e, n) {
  if (e == null || n)
    return kr(t) || (t = Tl(t)), t[Qg(t.length - 1)];
  var r = Ax(t), i = dr(r);
  e = Math.max(Math.min(e, i), 0);
  for (var o = i - 1, a = 0; a < e; a++) {
    var s = Qg(a, o), l = r[a];
    r[a] = r[s], r[s] = l;
  }
  return r.slice(0, e);
}
function TF(t) {
  return Ux(t, 1 / 0);
}
function CF(t, e, n) {
  var r = 0;
  return e = pr(e, n), Pm(jo(t, function(i, o, a) {
    return {
      value: i,
      index: r++,
      criteria: e(i, o, a)
    };
  }).sort(function(i, o) {
    var a = i.criteria, s = o.criteria;
    if (a !== s) {
      if (a > s || a === void 0) return 1;
      if (a < s || s === void 0) return -1;
    }
    return i.index - o.index;
  }), "value");
}
function Wm(t, e) {
  return function(n, r, i) {
    var o = e ? [[], []] : {};
    return r = pr(r, i), mi(n, function(a, s) {
      var l = r(a, s, n);
      t(o, a, l);
    }), o;
  };
}
const EF = Wm(function(t, e, n) {
  fs(t, n) ? t[n].push(e) : t[n] = [e];
}), _F = Wm(function(t, e, n) {
  t[n] = e;
}), kF = Wm(function(t, e, n) {
  fs(t, n) ? t[n]++ : t[n] = 1;
}), AF = Wm(function(t, e, n) {
  t[n ? 0 : 1].push(e);
}, !0);
function UF(t) {
  return t == null ? 0 : kr(t) ? t.length : qt(t).length;
}
function lH(t, e, n) {
  return e in n;
}
const Fx = Yn(function(t, e) {
  var n = {}, r = e[0];
  if (t == null) return n;
  Fn(r) ? (e.length > 1 && (r = Yd(r, e[1])), e = Au(t)) : (r = lH, e = El(e, !1, !1), t = Object(t));
  for (var i = 0, o = e.length; i < o; i++) {
    var a = e[i], s = t[a];
    r(s, a, t) && (n[a] = s);
  }
  return n;
}), FF = Yn(function(t, e) {
  var n = e[0], r;
  return Fn(n) ? (n = Mm(n), e.length > 1 && (r = e[1])) : (e = jo(El(e, !1, !1), String), n = function(i, o) {
    return !Zr(e, o);
  }), Fx(t, n, r);
});
function Rx(t, e, n) {
  return Gd.call(t, 0, Math.max(0, t.length - (e == null || n ? 1 : e)));
}
function Kc(t, e, n) {
  return t == null || t.length < 1 ? e == null || n ? void 0 : [] : e == null || n ? t[0] : Rx(t, t.length - e);
}
function ll(t, e, n) {
  return Gd.call(t, e == null || n ? 1 : e);
}
function RF(t, e, n) {
  return t == null || t.length < 1 ? e == null || n ? void 0 : [] : e == null || n ? t[t.length - 1] : ll(t, Math.max(0, t.length - e));
}
function OF(t) {
  return es(t, Boolean);
}
function IF(t, e) {
  return El(t, e, !1);
}
const Ox = Yn(function(t, e) {
  return e = El(e, !0, !0), es(t, function(n) {
    return !Zr(e, n);
  });
}), BF = Yn(function(t, e) {
  return Ox(t, e);
});
function Rd(t, e, n, r) {
  tx(e) || (r = n, n = e, e = !1), n != null && (n = pr(n, r));
  for (var i = [], o = [], a = 0, s = dr(t); a < s; a++) {
    var l = t[a], u = n ? n(l, a, t) : l;
    e && !n ? ((!a || o !== u) && i.push(l), o = u) : n ? Zr(o, u) || (o.push(u), i.push(l)) : Zr(i, l) || i.push(l);
  }
  return i;
}
const MF = Yn(function(t) {
  return Rd(El(t, !0, !0));
});
function NF(t) {
  for (var e = [], n = arguments.length, r = 0, i = dr(t); r < i; r++) {
    var o = t[r];
    if (!Zr(e, o)) {
      var a;
      for (a = 1; a < n && Zr(arguments[a], o); a++)
        ;
      a === n && e.push(o);
    }
  }
  return e;
}
function Od(t) {
  for (var e = t && kx(t, dr).length || 0, n = Array(e), r = 0; r < e; r++)
    n[r] = Pm(t, r);
  return n;
}
const PF = Yn(Od);
function WF(t, e) {
  for (var n = {}, r = 0, i = dr(t); r < i; r++)
    e ? n[t[r]] = e[r] : n[t[r][0]] = t[r][1];
  return n;
}
function LF(t, e, n) {
  e == null && (e = t || 0, t = 0), n || (n = e < t ? -1 : 1);
  for (var r = Math.max(Math.ceil((e - t) / n), 0), i = Array(r), o = 0; o < r; o++, t += n)
    i[o] = t;
  return i;
}
function zF(t, e) {
  if (e == null || e < 1) return [];
  for (var n = [], r = 0, i = t.length; r < i; )
    n.push(Gd.call(t, r, r += e));
  return n;
}
function Ix(t, e) {
  return t._chain ? yt(e).chain() : e;
}
function Bx(t) {
  return mi(Ud(t), function(e) {
    var n = yt[e] = t[e];
    yt.prototype[e] = function() {
      var r = [this._wrapped];
      return Pj.apply(r, arguments), Ix(this, n.apply(yt, r));
    };
  }), yt;
}
mi(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(t) {
  var e = Um[t];
  yt.prototype[t] = function() {
    var n = this._wrapped;
    return n != null && (e.apply(n, arguments), (t === "shift" || t === "splice") && n.length === 0 && delete n[0]), Ix(this, n);
  };
});
mi(["concat", "join", "slice"], function(t) {
  var e = Um[t];
  yt.prototype[t] = function() {
    var n = this._wrapped;
    return n != null && (n = e.apply(n, arguments)), Ix(this, n);
  };
});
const cH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VERSION: K2,
  after: hF,
  all: tm,
  allKeys: Au,
  any: nm,
  assign: du,
  before: Sx,
  bind: Dx,
  bindAll: aF,
  chain: iF,
  chunk: zF,
  clone: jU,
  collect: jo,
  compact: OF,
  compose: dF,
  constant: sx,
  contains: Zr,
  countBy: kF,
  create: $U,
  debounce: uF,
  default: yt,
  defaults: mx,
  defer: lF,
  delay: wx,
  detect: Fd,
  difference: Ox,
  drop: ll,
  each: mi,
  escape: KU,
  every: tm,
  extend: gx,
  extendOwn: du,
  filter: es,
  find: Fd,
  findIndex: Nm,
  findKey: Tx,
  findLastIndex: Cx,
  findWhere: bF,
  first: Kc,
  flatten: IF,
  foldl: Zc,
  foldr: em,
  forEach: mi,
  functions: Ud,
  get: vx,
  groupBy: EF,
  has: VU,
  head: Kc,
  identity: Om,
  include: Zr,
  includes: Zr,
  indexBy: _F,
  indexOf: _x,
  initial: Rx,
  inject: Zc,
  intersection: NF,
  invert: hx,
  invoke: DF,
  isArguments: Rm,
  isArray: us,
  isArrayBuffer: ix,
  isBoolean: tx,
  isDataView: Ad,
  isDate: xU,
  isElement: vU,
  isEmpty: UU,
  isEqual: RU,
  isError: wU,
  isFinite: EU,
  isFunction: Fn,
  isMap: MU,
  isMatch: cx,
  isNaN: ax,
  isNull: bU,
  isNumber: nx,
  isObject: cs,
  isRegExp: DU,
  isSet: PU,
  isString: Fm,
  isSymbol: rx,
  isTypedArray: lx,
  isUndefined: ex,
  isWeakMap: NU,
  isWeakSet: WU,
  iteratee: Bm,
  keys: qt,
  last: RF,
  lastIndexOf: yF,
  map: jo,
  mapObject: XU,
  matcher: gl,
  matches: gl,
  max: kx,
  memoize: sF,
  methods: Ud,
  min: SF,
  mixin: Bx,
  negate: Mm,
  noop: xx,
  now: hu,
  object: WF,
  omit: FF,
  once: pF,
  pairs: LU,
  partial: Cl,
  partition: AF,
  pick: Fx,
  pluck: Pm,
  property: Im,
  propertyOf: GU,
  random: Qg,
  range: LF,
  reduce: Zc,
  reduceRight: em,
  reject: xF,
  rest: ll,
  restArguments: Yn,
  result: nF,
  sample: Ux,
  select: es,
  shuffle: TF,
  size: UF,
  some: nm,
  sortBy: CF,
  sortedIndex: Ex,
  tail: ll,
  take: Kc,
  tap: HU,
  template: tF,
  templateSettings: eF,
  throttle: cF,
  times: JU,
  toArray: Ax,
  toPath: yx,
  transpose: Od,
  unescape: QU,
  union: MF,
  uniq: Rd,
  unique: Rd,
  uniqueId: rF,
  unzip: Od,
  values: Tl,
  where: wF,
  without: BF,
  wrap: fF,
  zip: PF
}, Symbol.toStringTag, { value: "Module" }));
var $0 = Bx(cH);
$0._ = $0;
const uH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VERSION: K2,
  after: hF,
  all: tm,
  allKeys: Au,
  any: nm,
  assign: du,
  before: Sx,
  bind: Dx,
  bindAll: aF,
  chain: iF,
  chunk: zF,
  clone: jU,
  collect: jo,
  compact: OF,
  compose: dF,
  constant: sx,
  contains: Zr,
  countBy: kF,
  create: $U,
  debounce: uF,
  default: $0,
  defaults: mx,
  defer: lF,
  delay: wx,
  detect: Fd,
  difference: Ox,
  drop: ll,
  each: mi,
  escape: KU,
  every: tm,
  extend: gx,
  extendOwn: du,
  filter: es,
  find: Fd,
  findIndex: Nm,
  findKey: Tx,
  findLastIndex: Cx,
  findWhere: bF,
  first: Kc,
  flatten: IF,
  foldl: Zc,
  foldr: em,
  forEach: mi,
  functions: Ud,
  get: vx,
  groupBy: EF,
  has: VU,
  head: Kc,
  identity: Om,
  include: Zr,
  includes: Zr,
  indexBy: _F,
  indexOf: _x,
  initial: Rx,
  inject: Zc,
  intersection: NF,
  invert: hx,
  invoke: DF,
  isArguments: Rm,
  isArray: us,
  isArrayBuffer: ix,
  isBoolean: tx,
  isDataView: Ad,
  isDate: xU,
  isElement: vU,
  isEmpty: UU,
  isEqual: RU,
  isError: wU,
  isFinite: EU,
  isFunction: Fn,
  isMap: MU,
  isMatch: cx,
  isNaN: ax,
  isNull: bU,
  isNumber: nx,
  isObject: cs,
  isRegExp: DU,
  isSet: PU,
  isString: Fm,
  isSymbol: rx,
  isTypedArray: lx,
  isUndefined: ex,
  isWeakMap: NU,
  isWeakSet: WU,
  iteratee: Bm,
  keys: qt,
  last: RF,
  lastIndexOf: yF,
  map: jo,
  mapObject: XU,
  matcher: gl,
  matches: gl,
  max: kx,
  memoize: sF,
  methods: Ud,
  min: SF,
  mixin: Bx,
  negate: Mm,
  noop: xx,
  now: hu,
  object: WF,
  omit: FF,
  once: pF,
  pairs: LU,
  partial: Cl,
  partition: AF,
  pick: Fx,
  pluck: Pm,
  property: Im,
  propertyOf: GU,
  random: Qg,
  range: LF,
  reduce: Zc,
  reduceRight: em,
  reject: xF,
  rest: ll,
  restArguments: Yn,
  result: nF,
  sample: Ux,
  select: es,
  shuffle: TF,
  size: UF,
  some: nm,
  sortBy: CF,
  sortedIndex: Ex,
  tail: ll,
  take: Kc,
  tap: HU,
  template: tF,
  templateSettings: eF,
  throttle: cF,
  times: JU,
  toArray: Ax,
  toPath: yx,
  transpose: Od,
  unescape: QU,
  union: MF,
  uniq: Rd,
  unique: Rd,
  uniqueId: rF,
  unzip: Od,
  values: Tl,
  where: wF,
  without: BF,
  wrap: fF,
  zip: PF
}, Symbol.toStringTag, { value: "Module" })), $t = /* @__PURE__ */ Bk(uH);
var Mx = {}, rn = {}, $F = { exports: {} }, sp = { exports: {} }, uC;
function Uu() {
  if (uC) return sp.exports;
  uC = 1;
  var t = /* @__PURE__ */ function() {
    return this === void 0;
  }();
  if (t)
    sp.exports = {
      freeze: Object.freeze,
      defineProperty: Object.defineProperty,
      getDescriptor: Object.getOwnPropertyDescriptor,
      keys: Object.keys,
      names: Object.getOwnPropertyNames,
      getPrototypeOf: Object.getPrototypeOf,
      isArray: Array.isArray,
      isES5: t,
      propertyIsWritable: function(f, h) {
        var p = Object.getOwnPropertyDescriptor(f, h);
        return !!(!p || p.writable || p.set);
      }
    };
  else {
    var e = {}.hasOwnProperty, n = {}.toString, r = {}.constructor.prototype, i = function(f) {
      var h = [];
      for (var p in f)
        e.call(f, p) && h.push(p);
      return h;
    }, o = function(f, h) {
      return { value: f[h] };
    }, a = function(f, h, p) {
      return f[h] = p.value, f;
    }, s = function(f) {
      return f;
    }, l = function(f) {
      try {
        return Object(f).constructor.prototype;
      } catch {
        return r;
      }
    }, u = function(f) {
      try {
        return n.call(f) === "[object Array]";
      } catch {
        return !1;
      }
    };
    sp.exports = {
      isArray: u,
      keys: i,
      names: i,
      defineProperty: a,
      getDescriptor: o,
      freeze: s,
      getPrototypeOf: l,
      isES5: t,
      propertyIsWritable: function() {
        return !0;
      }
    };
  }
  return sp.exports;
}
var bv, fC;
function Tt() {
  if (fC) return bv;
  fC = 1;
  var t = Uu(), e = typeof navigator > "u", n = { e: {} }, r, i = typeof self < "u" ? self : typeof window < "u" ? window : typeof it < "u" || it !== void 0 ? it : null;
  function o() {
    try {
      var P = r;
      return r = null, P.apply(this, arguments);
    } catch (pe) {
      return n.e = pe, n;
    }
  }
  function a(P) {
    return r = P, o;
  }
  var s = function(P, pe) {
    var we = {}.hasOwnProperty;
    function be() {
      this.constructor = P, this.constructor$ = pe;
      for (var _e in pe.prototype)
        we.call(pe.prototype, _e) && _e.charAt(_e.length - 1) !== "$" && (this[_e + "$"] = pe.prototype[_e]);
    }
    return be.prototype = pe.prototype, P.prototype = new be(), P.prototype;
  };
  function l(P) {
    return P == null || P === !0 || P === !1 || typeof P == "string" || typeof P == "number";
  }
  function u(P) {
    return typeof P == "function" || typeof P == "object" && P !== null;
  }
  function f(P) {
    return l(P) ? new Error(O(P)) : P;
  }
  function h(P, pe) {
    var we = P.length, be = new Array(we + 1), _e;
    for (_e = 0; _e < we; ++_e)
      be[_e] = P[_e];
    return be[_e] = pe, be;
  }
  function p(P, pe, we) {
    if (t.isES5) {
      var be = Object.getOwnPropertyDescriptor(P, pe);
      if (be != null)
        return be.get == null && be.set == null ? be.value : we;
    } else
      return {}.hasOwnProperty.call(P, pe) ? P[pe] : void 0;
  }
  function y(P, pe, we) {
    if (l(P)) return P;
    var be = {
      value: we,
      configurable: !0,
      enumerable: !1,
      writable: !0
    };
    return t.defineProperty(P, pe, be), P;
  }
  function b(P) {
    throw P;
  }
  var x = function() {
    var P = [
      Array.prototype,
      Object.prototype,
      Function.prototype
    ], pe = function(_e) {
      for (var $e = 0; $e < P.length; ++$e)
        if (P[$e] === _e)
          return !0;
      return !1;
    };
    if (t.isES5) {
      var we = Object.getOwnPropertyNames;
      return function(_e) {
        for (var $e = [], Le = /* @__PURE__ */ Object.create(null); _e != null && !pe(_e); ) {
          var ze;
          try {
            ze = we(_e);
          } catch {
            return $e;
          }
          for (var tt = 0; tt < ze.length; ++tt) {
            var ie = ze[tt];
            if (!Le[ie]) {
              Le[ie] = !0;
              var Ee = Object.getOwnPropertyDescriptor(_e, ie);
              Ee != null && Ee.get == null && Ee.set == null && $e.push(ie);
            }
          }
          _e = t.getPrototypeOf(_e);
        }
        return $e;
      };
    } else {
      var be = {}.hasOwnProperty;
      return function(_e) {
        if (pe(_e)) return [];
        var $e = [];
        e: for (var Le in _e)
          if (be.call(_e, Le))
            $e.push(Le);
          else {
            for (var ze = 0; ze < P.length; ++ze)
              if (be.call(P[ze], Le))
                continue e;
            $e.push(Le);
          }
        return $e;
      };
    }
  }(), v = /this\s*\.\s*\S+\s*=/;
  function D(P) {
    try {
      if (typeof P == "function") {
        var pe = t.names(P.prototype), we = t.isES5 && pe.length > 1, be = pe.length > 0 && !(pe.length === 1 && pe[0] === "constructor"), _e = v.test(P + "") && t.names(P).length > 0;
        if (we || be || _e)
          return !0;
      }
      return !1;
    } catch {
      return !1;
    }
  }
  function S(P) {
    return P;
  }
  var E = /^[a-z$_][a-z$_0-9]*$/i;
  function I(P) {
    return E.test(P);
  }
  function R(P, pe, we) {
    for (var be = new Array(P), _e = 0; _e < P; ++_e)
      be[_e] = pe + _e + we;
    return be;
  }
  function O(P) {
    try {
      return P + "";
    } catch {
      return "[no string representation]";
    }
  }
  function N(P) {
    return P !== null && typeof P == "object" && typeof P.message == "string" && typeof P.name == "string";
  }
  function q(P) {
    try {
      y(P, "isOperational", !0);
    } catch {
    }
  }
  function $(P) {
    return P == null ? !1 : P instanceof Error.__BluebirdErrorTypes__.OperationalError || P.isOperational === !0;
  }
  function le(P) {
    return N(P) && t.propertyIsWritable(P, "stack");
  }
  var ve = function() {
    return "stack" in new Error() ? function(P) {
      return le(P) ? P : new Error(O(P));
    } : function(P) {
      if (le(P)) return P;
      try {
        throw new Error(O(P));
      } catch (pe) {
        return pe;
      }
    };
  }();
  function M(P) {
    return {}.toString.call(P);
  }
  function ee(P, pe, we) {
    for (var be = t.names(P), _e = 0; _e < be.length; ++_e) {
      var $e = be[_e];
      if (we($e))
        try {
          t.defineProperty(pe, $e, t.getDescriptor(P, $e));
        } catch {
        }
    }
  }
  var A = function(P) {
    return t.isArray(P) ? P : null;
  };
  if (typeof Symbol < "u" && Symbol.iterator) {
    var oe = typeof Array.from == "function" ? function(P) {
      return Array.from(P);
    } : function(P) {
      for (var pe = [], we = P[Symbol.iterator](), be; !(be = we.next()).done; )
        pe.push(be.value);
      return pe;
    };
    A = function(P) {
      return t.isArray(P) ? P : P != null && typeof P[Symbol.iterator] == "function" ? oe(P) : null;
    };
  }
  var j = typeof process < "u" && M(process).toLowerCase() === "[object process]", Q = typeof process < "u" && typeof process.env < "u";
  function G(P) {
    return Q ? process.env[P] : void 0;
  }
  function Z() {
    if (typeof Promise == "function")
      try {
        var P = new Promise(function() {
        });
        if ({}.toString.call(P) === "[object Promise]")
          return Promise;
      } catch {
      }
  }
  function re(P, pe) {
    return P.bind(pe);
  }
  var V = {
    isClass: D,
    isIdentifier: I,
    inheritedDataKeys: x,
    getDataPropertyOrDefault: p,
    thrower: b,
    isArray: t.isArray,
    asArray: A,
    notEnumerableProp: y,
    isPrimitive: l,
    isObject: u,
    isError: N,
    canEvaluate: e,
    errorObj: n,
    tryCatch: a,
    inherits: s,
    withAppended: h,
    maybeWrapAsError: f,
    toFastProperties: S,
    filledRange: R,
    toString: O,
    canAttachTrace: le,
    ensureErrorObject: ve,
    originatesFromRejection: $,
    markAsOriginatingFromRejection: q,
    classString: M,
    copyDescriptors: ee,
    hasDevTools: typeof chrome < "u" && chrome && typeof chrome.loadTimes == "function",
    isNode: j,
    hasEnvVariables: Q,
    env: G,
    global: i,
    getNativePromise: Z,
    domainBind: re
  };
  V.isRecentNode = V.isNode && function() {
    var P = process.versions.node.split(".").map(Number);
    return P[0] === 0 && P[1] > 10 || P[0] > 0;
  }(), V.isNode && V.toFastProperties(process);
  try {
    throw new Error();
  } catch (P) {
    V.lastLineError = P;
  }
  return bv = V, bv;
}
var lp = { exports: {} }, vv, dC;
function fH() {
  if (dC) return vv;
  dC = 1;
  var t = Tt(), e, n = function() {
    throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
  }, r = t.getNativePromise();
  if (t.isNode && typeof MutationObserver > "u") {
    var i = it.setImmediate, o = process.nextTick;
    e = t.isRecentNode ? function(s) {
      i.call(it, s);
    } : function(s) {
      o.call(process, s);
    };
  } else if (typeof r == "function" && typeof r.resolve == "function") {
    var a = r.resolve();
    e = function(s) {
      a.then(s);
    };
  } else typeof MutationObserver < "u" && !(typeof window < "u" && window.navigator && (window.navigator.standalone || window.cordova)) ? e = function() {
    var s = document.createElement("div"), l = { attributes: !0 }, u = !1, f = document.createElement("div"), h = new MutationObserver(function() {
      s.classList.toggle("foo"), u = !1;
    });
    h.observe(f, l);
    var p = function() {
      u || (u = !0, f.classList.toggle("foo"));
    };
    return function(b) {
      var x = new MutationObserver(function() {
        x.disconnect(), b();
      });
      x.observe(s, l), p();
    };
  }() : typeof setImmediate < "u" ? e = function(s) {
    setImmediate(s);
  } : typeof setTimeout < "u" ? e = function(s) {
    setTimeout(s, 0);
  } : e = n;
  return vv = e, vv;
}
var xv, hC;
function dH() {
  if (hC) return xv;
  hC = 1;
  function t(n, r, i, o, a) {
    for (var s = 0; s < a; ++s)
      i[s + o] = n[s + r], n[s + r] = void 0;
  }
  function e(n) {
    this._capacity = n, this._length = 0, this._front = 0;
  }
  return e.prototype._willBeOverCapacity = function(n) {
    return this._capacity < n;
  }, e.prototype._pushOne = function(n) {
    var r = this.length();
    this._checkCapacity(r + 1);
    var i = this._front + r & this._capacity - 1;
    this[i] = n, this._length = r + 1;
  }, e.prototype.push = function(n, r, i) {
    var o = this.length() + 3;
    if (this._willBeOverCapacity(o)) {
      this._pushOne(n), this._pushOne(r), this._pushOne(i);
      return;
    }
    var a = this._front + o - 3;
    this._checkCapacity(o);
    var s = this._capacity - 1;
    this[a + 0 & s] = n, this[a + 1 & s] = r, this[a + 2 & s] = i, this._length = o;
  }, e.prototype.shift = function() {
    var n = this._front, r = this[n];
    return this[n] = void 0, this._front = n + 1 & this._capacity - 1, this._length--, r;
  }, e.prototype.length = function() {
    return this._length;
  }, e.prototype._checkCapacity = function(n) {
    this._capacity < n && this._resizeTo(this._capacity << 1);
  }, e.prototype._resizeTo = function(n) {
    var r = this._capacity;
    this._capacity = n;
    var i = this._front, o = this._length, a = i + o & r - 1;
    t(this, 0, this, r, a);
  }, xv = e, xv;
}
var pC;
function hH() {
  if (pC) return lp.exports;
  pC = 1;
  var t;
  try {
    throw new Error();
  } catch (l) {
    t = l;
  }
  var e = fH(), n = dH(), r = Tt();
  function i() {
    this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new n(16), this._normalQueue = new n(16), this._haveDrainedQueues = !1, this._trampolineEnabled = !0;
    var l = this;
    this.drainQueues = function() {
      l._drainQueues();
    }, this._schedule = e;
  }
  i.prototype.setScheduler = function(l) {
    var u = this._schedule;
    return this._schedule = l, this._customScheduler = !0, u;
  }, i.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
  }, i.prototype.enableTrampoline = function() {
    this._trampolineEnabled = !0;
  }, i.prototype.disableTrampolineIfNecessary = function() {
    r.hasDevTools && (this._trampolineEnabled = !1);
  }, i.prototype.haveItemsQueued = function() {
    return this._isTickUsed || this._haveDrainedQueues;
  }, i.prototype.fatalError = function(l, u) {
    u ? (process.stderr.write("Fatal " + (l instanceof Error ? l.stack : l) + `
`), process.exit(2)) : this.throwLater(l);
  }, i.prototype.throwLater = function(l, u) {
    if (arguments.length === 1 && (u = l, l = function() {
      throw u;
    }), typeof setTimeout < "u")
      setTimeout(function() {
        l(u);
      }, 0);
    else try {
      this._schedule(function() {
        l(u);
      });
    } catch {
      throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
    }
  };
  function o(l, u, f) {
    this._lateQueue.push(l, u, f), this._queueTick();
  }
  function a(l, u, f) {
    this._normalQueue.push(l, u, f), this._queueTick();
  }
  function s(l) {
    this._normalQueue._pushOne(l), this._queueTick();
  }
  return r.hasDevTools ? (i.prototype.invokeLater = function(l, u, f) {
    this._trampolineEnabled ? o.call(this, l, u, f) : this._schedule(function() {
      setTimeout(function() {
        l.call(u, f);
      }, 100);
    });
  }, i.prototype.invoke = function(l, u, f) {
    this._trampolineEnabled ? a.call(this, l, u, f) : this._schedule(function() {
      l.call(u, f);
    });
  }, i.prototype.settlePromises = function(l) {
    this._trampolineEnabled ? s.call(this, l) : this._schedule(function() {
      l._settlePromises();
    });
  }) : (i.prototype.invokeLater = o, i.prototype.invoke = a, i.prototype.settlePromises = s), i.prototype._drainQueue = function(l) {
    for (; l.length() > 0; ) {
      var u = l.shift();
      if (typeof u != "function") {
        u._settlePromises();
        continue;
      }
      var f = l.shift(), h = l.shift();
      u.call(f, h);
    }
  }, i.prototype._drainQueues = function() {
    this._drainQueue(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, this._drainQueue(this._lateQueue);
  }, i.prototype._queueTick = function() {
    this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues));
  }, i.prototype._reset = function() {
    this._isTickUsed = !1;
  }, lp.exports = i, lp.exports.firstLineError = t, lp.exports;
}
var Dv, gC;
function ts() {
  if (gC) return Dv;
  gC = 1;
  var t = Uu(), e = t.freeze, n = Tt(), r = n.inherits, i = n.notEnumerableProp;
  function o(D, S) {
    function E(I) {
      if (!(this instanceof E)) return new E(I);
      i(
        this,
        "message",
        typeof I == "string" ? I : S
      ), i(this, "name", D), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this);
    }
    return r(E, Error), E;
  }
  var a, s, l = o("Warning", "warning"), u = o("CancellationError", "cancellation error"), f = o("TimeoutError", "timeout error"), h = o("AggregateError", "aggregate error");
  try {
    a = TypeError, s = RangeError;
  } catch {
    a = o("TypeError", "type error"), s = o("RangeError", "range error");
  }
  for (var p = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "), y = 0; y < p.length; ++y)
    typeof Array.prototype[p[y]] == "function" && (h.prototype[p[y]] = Array.prototype[p[y]]);
  t.defineProperty(h.prototype, "length", {
    value: 0,
    configurable: !1,
    writable: !0,
    enumerable: !0
  }), h.prototype.isOperational = !0;
  var b = 0;
  h.prototype.toString = function() {
    var D = Array(b * 4 + 1).join(" "), S = `
` + D + `AggregateError of:
`;
    b++, D = Array(b * 4 + 1).join(" ");
    for (var E = 0; E < this.length; ++E) {
      for (var I = this[E] === this ? "[Circular AggregateError]" : this[E] + "", R = I.split(`
`), O = 0; O < R.length; ++O)
        R[O] = D + R[O];
      I = R.join(`
`), S += I + `
`;
    }
    return b--, S;
  };
  function x(D) {
    if (!(this instanceof x))
      return new x(D);
    i(this, "name", "OperationalError"), i(this, "message", D), this.cause = D, this.isOperational = !0, D instanceof Error ? (i(this, "message", D.message), i(this, "stack", D.stack)) : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  }
  r(x, Error);
  var v = Error.__BluebirdErrorTypes__;
  return v || (v = e({
    CancellationError: u,
    TimeoutError: f,
    OperationalError: x,
    RejectionError: x,
    AggregateError: h
  }), t.defineProperty(Error, "__BluebirdErrorTypes__", {
    value: v,
    writable: !1,
    enumerable: !1,
    configurable: !1
  })), Dv = {
    Error,
    TypeError: a,
    RangeError: s,
    CancellationError: v.CancellationError,
    OperationalError: v.OperationalError,
    TimeoutError: v.TimeoutError,
    AggregateError: v.AggregateError,
    Warning: l
  }, Dv;
}
var wv, mC;
function pH() {
  return mC || (mC = 1, wv = function(t, e) {
    var n = Tt(), r = n.errorObj, i = n.isObject;
    function o(h, p) {
      if (i(h)) {
        if (h instanceof t) return h;
        var y = s(h);
        if (y === r) {
          p && p._pushContext();
          var b = t.reject(y.e);
          return p && p._popContext(), b;
        } else if (typeof y == "function") {
          if (u(h)) {
            var b = new t(e);
            return h._then(
              b._fulfill,
              b._reject,
              void 0,
              b,
              null
            ), b;
          }
          return f(h, y, p);
        }
      }
      return h;
    }
    function a(h) {
      return h.then;
    }
    function s(h) {
      try {
        return a(h);
      } catch (p) {
        return r.e = p, r;
      }
    }
    var l = {}.hasOwnProperty;
    function u(h) {
      try {
        return l.call(h, "_promise0");
      } catch {
        return !1;
      }
    }
    function f(h, p, y) {
      var b = new t(e), x = b;
      y && y._pushContext(), b._captureStackTrace(), y && y._popContext();
      var v = !0, D = n.tryCatch(p).call(h, S, E);
      v = !1, b && D === r && (b._rejectCallback(D.e, !0, !0), b = null);
      function S(I) {
        b && (b._resolveCallback(I), b = null);
      }
      function E(I) {
        b && (b._rejectCallback(I, v, !0), b = null);
      }
      return x;
    }
    return o;
  }), wv;
}
var Sv, yC;
function gH() {
  return yC || (yC = 1, Sv = function(t, e, n, r, i) {
    var o = Tt();
    o.isArray;
    function a(l) {
      switch (l) {
        case -2:
          return [];
        case -3:
          return {};
      }
    }
    function s(l) {
      var u = this._promise = new t(e);
      l instanceof t && u._propagateFrom(l, 3), u._setOnCancel(this), this._values = l, this._length = 0, this._totalResolved = 0, this._init(void 0, -2);
    }
    return o.inherits(s, i), s.prototype.length = function() {
      return this._length;
    }, s.prototype.promise = function() {
      return this._promise;
    }, s.prototype._init = function l(u, f) {
      var h = n(this._values, this._promise);
      if (h instanceof t) {
        h = h._target();
        var p = h._bitField;
        if (this._values = h, p & 50397184)
          if (p & 33554432)
            h = h._value();
          else return p & 16777216 ? this._reject(h._reason()) : this._cancel();
        else return this._promise._setAsyncGuaranteed(), h._then(
          l,
          this._reject,
          void 0,
          this,
          f
        );
      }
      if (h = o.asArray(h), h === null) {
        var y = r(
          "expecting an array or an iterable object but got " + o.classString(h)
        ).reason();
        this._promise._rejectCallback(y, !1);
        return;
      }
      if (h.length === 0) {
        f === -5 ? this._resolveEmptyArray() : this._resolve(a(f));
        return;
      }
      this._iterate(h);
    }, s.prototype._iterate = function(l) {
      var u = this.getActualLength(l.length);
      this._length = u, this._values = this.shouldCopyValues() ? new Array(u) : this._values;
      for (var f = this._promise, h = !1, p = null, y = 0; y < u; ++y) {
        var b = n(l[y], f);
        b instanceof t ? (b = b._target(), p = b._bitField) : p = null, h ? p !== null && b.suppressUnhandledRejections() : p !== null ? p & 50397184 ? p & 33554432 ? h = this._promiseFulfilled(b._value(), y) : p & 16777216 ? h = this._promiseRejected(b._reason(), y) : h = this._promiseCancelled(y) : (b._proxy(this, y), this._values[y] = b) : h = this._promiseFulfilled(b, y);
      }
      h || f._setAsyncGuaranteed();
    }, s.prototype._isResolved = function() {
      return this._values === null;
    }, s.prototype._resolve = function(l) {
      this._values = null, this._promise._fulfill(l);
    }, s.prototype._cancel = function() {
      this._isResolved() || !this._promise._isCancellable() || (this._values = null, this._promise._cancel());
    }, s.prototype._reject = function(l) {
      this._values = null, this._promise._rejectCallback(l, !1);
    }, s.prototype._promiseFulfilled = function(l, u) {
      this._values[u] = l;
      var f = ++this._totalResolved;
      return f >= this._length ? (this._resolve(this._values), !0) : !1;
    }, s.prototype._promiseCancelled = function() {
      return this._cancel(), !0;
    }, s.prototype._promiseRejected = function(l) {
      return this._totalResolved++, this._reject(l), !0;
    }, s.prototype._resultCancelled = function() {
      if (!this._isResolved()) {
        var l = this._values;
        if (this._cancel(), l instanceof t)
          l.cancel();
        else
          for (var u = 0; u < l.length; ++u)
            l[u] instanceof t && l[u].cancel();
      }
    }, s.prototype.shouldCopyValues = function() {
      return !0;
    }, s.prototype.getActualLength = function(l) {
      return l;
    }, s;
  }), Sv;
}
var Tv, bC;
function mH() {
  return bC || (bC = 1, Tv = function(t) {
    var e = !1, n = [];
    t.prototype._promiseCreated = function() {
    }, t.prototype._pushContext = function() {
    }, t.prototype._popContext = function() {
      return null;
    }, t._peekContext = t.prototype._peekContext = function() {
    };
    function r() {
      this._trace = new r.CapturedTrace(o());
    }
    r.prototype._pushContext = function() {
      this._trace !== void 0 && (this._trace._promiseCreated = null, n.push(this._trace));
    }, r.prototype._popContext = function() {
      if (this._trace !== void 0) {
        var a = n.pop(), s = a._promiseCreated;
        return a._promiseCreated = null, s;
      }
      return null;
    };
    function i() {
      if (e) return new r();
    }
    function o() {
      var a = n.length - 1;
      if (a >= 0)
        return n[a];
    }
    return r.CapturedTrace = null, r.create = i, r.deactivateLongStackTraces = function() {
    }, r.activateLongStackTraces = function() {
      var a = t.prototype._pushContext, s = t.prototype._popContext, l = t._peekContext, u = t.prototype._peekContext, f = t.prototype._promiseCreated;
      r.deactivateLongStackTraces = function() {
        t.prototype._pushContext = a, t.prototype._popContext = s, t._peekContext = l, t.prototype._peekContext = u, t.prototype._promiseCreated = f, e = !1;
      }, e = !0, t.prototype._pushContext = r.prototype._pushContext, t.prototype._popContext = r.prototype._popContext, t._peekContext = t.prototype._peekContext = o, t.prototype._promiseCreated = function() {
        var h = this._peekContext();
        h && h._promiseCreated == null && (h._promiseCreated = this);
      };
    }, r;
  }), Tv;
}
var Cv, vC;
function yH() {
  return vC || (vC = 1, Cv = function(t, e) {
    var n = t._getDomain, r = t._async, i = ts().Warning, o = Tt(), a = o.canAttachTrace, s, l, u = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/, f = /\((?:timers\.js):\d+:\d+\)/, h = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/, p = null, y = null, b = !1, x, v = !!(o.env("BLUEBIRD_DEBUG") != 0 && (o.env("BLUEBIRD_DEBUG") || o.env("NODE_ENV") === "development")), D = !!(o.env("BLUEBIRD_WARNINGS") != 0 && (v || o.env("BLUEBIRD_WARNINGS"))), S = !!(o.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (v || o.env("BLUEBIRD_LONG_STACK_TRACES"))), E = o.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (D || !!o.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    t.prototype.suppressUnhandledRejections = function() {
      var K = this._target();
      K._bitField = K._bitField & -1048577 | 524288;
    }, t.prototype._ensurePossibleRejectionHandled = function() {
      this._bitField & 524288 || (this._setRejectionIsUnhandled(), r.invokeLater(this._notifyUnhandledRejection, this, void 0));
    }, t.prototype._notifyUnhandledRejectionIsHandled = function() {
      Ee(
        "rejectionHandled",
        s,
        void 0,
        this
      );
    }, t.prototype._setReturnedNonUndefined = function() {
      this._bitField = this._bitField | 268435456;
    }, t.prototype._returnedNonUndefined = function() {
      return (this._bitField & 268435456) !== 0;
    }, t.prototype._notifyUnhandledRejection = function() {
      if (this._isRejectionUnhandled()) {
        var K = this._settledValue();
        this._setUnhandledRejectionIsNotified(), Ee(
          "unhandledRejection",
          l,
          K,
          this
        );
      }
    }, t.prototype._setUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField | 262144;
    }, t.prototype._unsetUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField & -262145;
    }, t.prototype._isUnhandledRejectionNotified = function() {
      return (this._bitField & 262144) > 0;
    }, t.prototype._setRejectionIsUnhandled = function() {
      this._bitField = this._bitField | 1048576;
    }, t.prototype._unsetRejectionIsUnhandled = function() {
      this._bitField = this._bitField & -1048577, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), this._notifyUnhandledRejectionIsHandled());
    }, t.prototype._isRejectionUnhandled = function() {
      return (this._bitField & 1048576) > 0;
    }, t.prototype._warn = function(K, ne, ce) {
      return we(K, ne, ce || this);
    }, t.onPossiblyUnhandledRejection = function(K) {
      var ne = n();
      l = typeof K == "function" ? ne === null ? K : o.domainBind(ne, K) : void 0;
    }, t.onUnhandledRejectionHandled = function(K) {
      var ne = n();
      s = typeof K == "function" ? ne === null ? K : o.domainBind(ne, K) : void 0;
    };
    var I = function() {
    };
    t.longStackTraces = function() {
      if (r.haveItemsQueued() && !se.longStackTraces)
        throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
      if (!se.longStackTraces && ge()) {
        var K = t.prototype._captureStackTrace, ne = t.prototype._attachExtraTrace;
        se.longStackTraces = !0, I = function() {
          if (r.haveItemsQueued() && !se.longStackTraces)
            throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
          t.prototype._captureStackTrace = K, t.prototype._attachExtraTrace = ne, e.deactivateLongStackTraces(), r.enableTrampoline(), se.longStackTraces = !1;
        }, t.prototype._captureStackTrace = re, t.prototype._attachExtraTrace = V, e.activateLongStackTraces(), r.disableTrampolineIfNecessary();
      }
    }, t.hasLongStackTraces = function() {
      return se.longStackTraces && ge();
    };
    var R = function() {
      try {
        if (typeof CustomEvent == "function") {
          var K = new CustomEvent("CustomEvent");
          return o.global.dispatchEvent(K), function(ne, ce) {
            var xe = new CustomEvent(ne.toLowerCase(), {
              detail: ce,
              cancelable: !0
            });
            return !o.global.dispatchEvent(xe);
          };
        } else if (typeof Event == "function") {
          var K = new Event("CustomEvent");
          return o.global.dispatchEvent(K), function(ce, xe) {
            var Be = new Event(ce.toLowerCase(), {
              cancelable: !0
            });
            return Be.detail = xe, !o.global.dispatchEvent(Be);
          };
        } else {
          var K = document.createEvent("CustomEvent");
          return K.initCustomEvent("testingtheevent", !1, !0, {}), o.global.dispatchEvent(K), function(ce, xe) {
            var Be = document.createEvent("CustomEvent");
            return Be.initCustomEvent(
              ce.toLowerCase(),
              !1,
              !0,
              xe
            ), !o.global.dispatchEvent(Be);
          };
        }
      } catch {
      }
      return function() {
        return !1;
      };
    }(), O = function() {
      return o.isNode ? function() {
        return process.emit.apply(process, arguments);
      } : o.global ? function(K) {
        var ne = "on" + K.toLowerCase(), ce = o.global[ne];
        return ce ? (ce.apply(o.global, [].slice.call(arguments, 1)), !0) : !1;
      } : function() {
        return !1;
      };
    }();
    function N(K, ne) {
      return { promise: ne };
    }
    var q = {
      promiseCreated: N,
      promiseFulfilled: N,
      promiseRejected: N,
      promiseResolved: N,
      promiseCancelled: N,
      promiseChained: function(K, ne, ce) {
        return { promise: ne, child: ce };
      },
      warning: function(K, ne) {
        return { warning: ne };
      },
      unhandledRejection: function(K, ne, ce) {
        return { reason: ne, promise: ce };
      },
      rejectionHandled: N
    }, $ = function(K) {
      var ne = !1;
      try {
        ne = O.apply(null, arguments);
      } catch (xe) {
        r.throwLater(xe), ne = !0;
      }
      var ce = !1;
      try {
        ce = R(
          K,
          q[K].apply(null, arguments)
        );
      } catch (xe) {
        r.throwLater(xe), ce = !0;
      }
      return ce || ne;
    };
    t.config = function(K) {
      if (K = Object(K), "longStackTraces" in K && (K.longStackTraces ? t.longStackTraces() : !K.longStackTraces && t.hasLongStackTraces() && I()), "warnings" in K) {
        var ne = K.warnings;
        se.warnings = !!ne, E = se.warnings, o.isObject(ne) && "wForgottenReturn" in ne && (E = !!ne.wForgottenReturn);
      }
      if ("cancellation" in K && K.cancellation && !se.cancellation) {
        if (r.haveItemsQueued())
          throw new Error(
            "cannot enable cancellation after promises are in use"
          );
        t.prototype._clearCancellationData = oe, t.prototype._propagateFrom = j, t.prototype._onCancel = ee, t.prototype._setOnCancel = A, t.prototype._attachCancellationCallback = M, t.prototype._execute = ve, G = j, se.cancellation = !0;
      }
      return "monitoring" in K && (K.monitoring && !se.monitoring ? (se.monitoring = !0, t.prototype._fireEvent = $) : !K.monitoring && se.monitoring && (se.monitoring = !1, t.prototype._fireEvent = le)), t;
    };
    function le() {
      return !1;
    }
    t.prototype._fireEvent = le, t.prototype._execute = function(K, ne, ce) {
      try {
        K(ne, ce);
      } catch (xe) {
        return xe;
      }
    }, t.prototype._onCancel = function() {
    }, t.prototype._setOnCancel = function(K) {
    }, t.prototype._attachCancellationCallback = function(K) {
    }, t.prototype._captureStackTrace = function() {
    }, t.prototype._attachExtraTrace = function() {
    }, t.prototype._clearCancellationData = function() {
    }, t.prototype._propagateFrom = function(K, ne) {
    };
    function ve(K, ne, ce) {
      var xe = this;
      try {
        K(ne, ce, function(Be) {
          if (typeof Be != "function")
            throw new TypeError("onCancel must be a function, got: " + o.toString(Be));
          xe._attachCancellationCallback(Be);
        });
      } catch (Be) {
        return Be;
      }
    }
    function M(K) {
      if (!this._isCancellable()) return this;
      var ne = this._onCancel();
      ne !== void 0 ? o.isArray(ne) ? ne.push(K) : this._setOnCancel([ne, K]) : this._setOnCancel(K);
    }
    function ee() {
      return this._onCancelField;
    }
    function A(K) {
      this._onCancelField = K;
    }
    function oe() {
      this._cancellationParent = void 0, this._onCancelField = void 0;
    }
    function j(K, ne) {
      if (ne & 1) {
        this._cancellationParent = K;
        var ce = K._branchesRemainingToCancel;
        ce === void 0 && (ce = 0), K._branchesRemainingToCancel = ce + 1;
      }
      ne & 2 && K._isBound() && this._setBoundTo(K._boundTo);
    }
    function Q(K, ne) {
      ne & 2 && K._isBound() && this._setBoundTo(K._boundTo);
    }
    var G = Q;
    function Z() {
      var K = this._boundTo;
      return K !== void 0 && K instanceof t ? K.isFulfilled() ? K.value() : void 0 : K;
    }
    function re() {
      this._trace = new Se(this._peekContext());
    }
    function V(K, ne) {
      if (a(K)) {
        var ce = this._trace;
        if (ce !== void 0 && ne && (ce = ce._parent), ce !== void 0)
          ce.attachExtraTrace(K);
        else if (!K.__stackCleaned__) {
          var xe = tt(K);
          o.notEnumerableProp(
            K,
            "stack",
            xe.message + `
` + xe.stack.join(`
`)
          ), o.notEnumerableProp(K, "__stackCleaned__", !0);
        }
      }
    }
    function P(K, ne, ce, xe, Be) {
      if (K === void 0 && ne !== null && E) {
        if (Be !== void 0 && Be._returnedNonUndefined() || !(xe._bitField & 65535)) return;
        ce && (ce = ce + " ");
        var Me = "", Je = "";
        if (ne._trace) {
          for (var He = ne._trace.stack.split(`
`), Ke = Le(He), lt = Ke.length - 1; lt >= 0; --lt) {
            var nt = Ke[lt];
            if (!f.test(nt)) {
              var Bt = nt.match(h);
              Bt && (Me = "at " + Bt[1] + ":" + Bt[2] + ":" + Bt[3] + " ");
              break;
            }
          }
          if (Ke.length > 0) {
            for (var Bn = Ke[0], lt = 0; lt < He.length; ++lt)
              if (He[lt] === Bn) {
                lt > 0 && (Je = `
` + He[lt - 1]);
                break;
              }
          }
        }
        var At = "a promise was created in a " + ce + "handler " + Me + "but was not returned from it, see http://goo.gl/rRqMUw" + Je;
        xe._warn(At, !0, ne);
      }
    }
    function pe(K, ne) {
      var ce = K + " is deprecated and will be removed in a future version.";
      return ne && (ce += " Use " + ne + " instead."), we(ce);
    }
    function we(K, ne, ce) {
      if (se.warnings) {
        var xe = new i(K), Be;
        if (ne)
          ce._attachExtraTrace(xe);
        else if (se.longStackTraces && (Be = t._peekContext()))
          Be.attachExtraTrace(xe);
        else {
          var Me = tt(xe);
          xe.stack = Me.message + `
` + Me.stack.join(`
`);
        }
        $("warning", xe) || ie(xe, "", !0);
      }
    }
    function be(K, ne) {
      for (var ce = 0; ce < ne.length - 1; ++ce)
        ne[ce].push("From previous event:"), ne[ce] = ne[ce].join(`
`);
      return ce < ne.length && (ne[ce] = ne[ce].join(`
`)), K + `
` + ne.join(`
`);
    }
    function _e(K) {
      for (var ne = 0; ne < K.length; ++ne)
        (K[ne].length === 0 || ne + 1 < K.length && K[ne][0] === K[ne + 1][0]) && (K.splice(ne, 1), ne--);
    }
    function $e(K) {
      for (var ne = K[0], ce = 1; ce < K.length; ++ce) {
        for (var xe = K[ce], Be = ne.length - 1, Me = ne[Be], Je = -1, He = xe.length - 1; He >= 0; --He)
          if (xe[He] === Me) {
            Je = He;
            break;
          }
        for (var He = Je; He >= 0; --He) {
          var Ke = xe[He];
          if (ne[Be] === Ke)
            ne.pop(), Be--;
          else
            break;
        }
        ne = xe;
      }
    }
    function Le(K) {
      for (var ne = [], ce = 0; ce < K.length; ++ce) {
        var xe = K[ce], Be = xe === "    (No stack trace)" || p.test(xe), Me = Be && ue(xe);
        Be && !Me && (b && xe.charAt(0) !== " " && (xe = "    " + xe), ne.push(xe));
      }
      return ne;
    }
    function ze(K) {
      for (var ne = K.stack.replace(/\s+$/g, "").split(`
`), ce = 0; ce < ne.length; ++ce) {
        var xe = ne[ce];
        if (xe === "    (No stack trace)" || p.test(xe))
          break;
      }
      return ce > 0 && K.name != "SyntaxError" && (ne = ne.slice(ce)), ne;
    }
    function tt(K) {
      var ne = K.stack, ce = K.toString();
      return ne = typeof ne == "string" && ne.length > 0 ? ze(K) : ["    (No stack trace)"], {
        message: ce,
        stack: K.name == "SyntaxError" ? ne : Le(ne)
      };
    }
    function ie(K, ne, ce) {
      if (typeof console < "u") {
        var xe;
        if (o.isObject(K)) {
          var Be = K.stack;
          xe = ne + y(Be, K);
        } else
          xe = ne + String(K);
        typeof x == "function" ? x(xe, ce) : (typeof console.log == "function" || typeof console.log == "object") && console.log(xe);
      }
    }
    function Ee(K, ne, ce, xe) {
      var Be = !1;
      try {
        typeof ne == "function" && (Be = !0, K === "rejectionHandled" ? ne(xe) : ne(ce, xe));
      } catch (Me) {
        r.throwLater(Me);
      }
      K === "unhandledRejection" ? !$(K, ce, xe) && !Be && ie(ce, "Unhandled rejection ") : $(K, xe);
    }
    function Re(K) {
      var ne;
      if (typeof K == "function")
        ne = "[function " + (K.name || "anonymous") + "]";
      else {
        ne = K && typeof K.toString == "function" ? K.toString() : o.toString(K);
        var ce = /\[object [a-zA-Z0-9$_]+\]/;
        if (ce.test(ne))
          try {
            var xe = JSON.stringify(K);
            ne = xe;
          } catch {
          }
        ne.length === 0 && (ne = "(empty array)");
      }
      return "(<" + k(ne) + ">, no stack trace)";
    }
    function k(K) {
      var ne = 41;
      return K.length < ne ? K : K.substr(0, ne - 3) + "...";
    }
    function ge() {
      return typeof ke == "function";
    }
    var ue = function() {
      return !1;
    }, Y = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function H(K) {
      var ne = K.match(Y);
      if (ne)
        return {
          fileName: ne[1],
          line: parseInt(ne[2], 10)
        };
    }
    function ae(K, ne) {
      if (ge()) {
        for (var ce = K.stack.split(`
`), xe = ne.stack.split(`
`), Be = -1, Me = -1, Je, He, Ke = 0; Ke < ce.length; ++Ke) {
          var lt = H(ce[Ke]);
          if (lt) {
            Je = lt.fileName, Be = lt.line;
            break;
          }
        }
        for (var Ke = 0; Ke < xe.length; ++Ke) {
          var lt = H(xe[Ke]);
          if (lt) {
            He = lt.fileName, Me = lt.line;
            break;
          }
        }
        Be < 0 || Me < 0 || !Je || !He || Je !== He || Be >= Me || (ue = function(nt) {
          if (u.test(nt)) return !0;
          var Bt = H(nt);
          return !!(Bt && Bt.fileName === Je && Be <= Bt.line && Bt.line <= Me);
        });
      }
    }
    function Se(K) {
      this._parent = K, this._promisesCreated = 0;
      var ne = this._length = 1 + (K === void 0 ? 0 : K._length);
      ke(this, Se), ne > 32 && this.uncycle();
    }
    o.inherits(Se, Error), e.CapturedTrace = Se, Se.prototype.uncycle = function() {
      var K = this._length;
      if (!(K < 2)) {
        for (var ne = [], ce = {}, xe = 0, Be = this; Be !== void 0; ++xe)
          ne.push(Be), Be = Be._parent;
        K = this._length = xe;
        for (var xe = K - 1; xe >= 0; --xe) {
          var Me = ne[xe].stack;
          ce[Me] === void 0 && (ce[Me] = xe);
        }
        for (var xe = 0; xe < K; ++xe) {
          var Je = ne[xe].stack, He = ce[Je];
          if (He !== void 0 && He !== xe) {
            He > 0 && (ne[He - 1]._parent = void 0, ne[He - 1]._length = 1), ne[xe]._parent = void 0, ne[xe]._length = 1;
            var Ke = xe > 0 ? ne[xe - 1] : this;
            He < K - 1 ? (Ke._parent = ne[He + 1], Ke._parent.uncycle(), Ke._length = Ke._parent._length + 1) : (Ke._parent = void 0, Ke._length = 1);
            for (var lt = Ke._length + 1, nt = xe - 2; nt >= 0; --nt)
              ne[nt]._length = lt, lt++;
            return;
          }
        }
      }
    }, Se.prototype.attachExtraTrace = function(K) {
      if (!K.__stackCleaned__) {
        this.uncycle();
        for (var ne = tt(K), ce = ne.message, xe = [ne.stack], Be = this; Be !== void 0; )
          xe.push(Le(Be.stack.split(`
`))), Be = Be._parent;
        $e(xe), _e(xe), o.notEnumerableProp(K, "stack", be(ce, xe)), o.notEnumerableProp(K, "__stackCleaned__", !0);
      }
    };
    var ke = function() {
      var ne = /^\s*at\s*/, ce = function(Je, He) {
        return typeof Je == "string" ? Je : He.name !== void 0 && He.message !== void 0 ? He.toString() : Re(He);
      };
      if (typeof Error.stackTraceLimit == "number" && typeof Error.captureStackTrace == "function") {
        Error.stackTraceLimit += 6, p = ne, y = ce;
        var xe = Error.captureStackTrace;
        return ue = function(Je) {
          return u.test(Je);
        }, function(Je, He) {
          Error.stackTraceLimit += 6, xe(Je, He), Error.stackTraceLimit -= 6;
        };
      }
      var Be = new Error();
      if (typeof Be.stack == "string" && Be.stack.split(`
`)[0].indexOf("stackDetection@") >= 0)
        return p = /@/, y = ce, b = !0, function(He) {
          He.stack = new Error().stack;
        };
      var Me;
      try {
        throw new Error();
      } catch (Je) {
        Me = "stack" in Je;
      }
      return !("stack" in Be) && Me && typeof Error.stackTraceLimit == "number" ? (p = ne, y = ce, function(He) {
        Error.stackTraceLimit += 6;
        try {
          throw new Error();
        } catch (Ke) {
          He.stack = Ke.stack;
        }
        Error.stackTraceLimit -= 6;
      }) : (y = function(Je, He) {
        return typeof Je == "string" ? Je : (typeof He == "object" || typeof He == "function") && He.name !== void 0 && He.message !== void 0 ? He.toString() : Re(He);
      }, null);
    }();
    typeof console < "u" && typeof console.warn < "u" && (x = function(K) {
      console.warn(K);
    }, o.isNode && process.stderr.isTTY ? x = function(K, ne) {
      var ce = ne ? "\x1B[33m" : "\x1B[31m";
      console.warn(ce + K + `\x1B[0m
`);
    } : !o.isNode && typeof new Error().stack == "string" && (x = function(K, ne) {
      console.warn(
        "%c" + K,
        ne ? "color: darkorange" : "color: red"
      );
    }));
    var se = {
      warnings: D,
      longStackTraces: !1,
      cancellation: !1,
      monitoring: !1
    };
    return S && t.longStackTraces(), {
      longStackTraces: function() {
        return se.longStackTraces;
      },
      warnings: function() {
        return se.warnings;
      },
      cancellation: function() {
        return se.cancellation;
      },
      monitoring: function() {
        return se.monitoring;
      },
      propagateFromFunction: function() {
        return G;
      },
      boundValueFunction: function() {
        return Z;
      },
      checkForgottenReturns: P,
      setBounds: ae,
      warn: we,
      deprecated: pe,
      CapturedTrace: Se,
      fireDomEvent: R,
      fireGlobalEvent: O
    };
  }), Cv;
}
var Ev, xC;
function bH() {
  return xC || (xC = 1, Ev = function(t, e) {
    var n = Tt(), r = t.CancellationError, i = n.errorObj;
    function o(h, p, y) {
      this.promise = h, this.type = p, this.handler = y, this.called = !1, this.cancelPromise = null;
    }
    o.prototype.isFinallyHandler = function() {
      return this.type === 0;
    };
    function a(h) {
      this.finallyHandler = h;
    }
    a.prototype._resultCancelled = function() {
      s(this.finallyHandler);
    };
    function s(h, p) {
      return h.cancelPromise != null ? (arguments.length > 1 ? h.cancelPromise._reject(p) : h.cancelPromise._cancel(), h.cancelPromise = null, !0) : !1;
    }
    function l() {
      return f.call(this, this.promise._target()._settledValue());
    }
    function u(h) {
      if (!s(this, h))
        return i.e = h, i;
    }
    function f(h) {
      var p = this.promise, y = this.handler;
      if (!this.called) {
        this.called = !0;
        var b = this.isFinallyHandler() ? y.call(p._boundValue()) : y.call(p._boundValue(), h);
        if (b !== void 0) {
          p._setReturnedNonUndefined();
          var x = e(b, p);
          if (x instanceof t) {
            if (this.cancelPromise != null)
              if (x._isCancelled()) {
                var v = new r("late cancellation observer");
                return p._attachExtraTrace(v), i.e = v, i;
              } else x.isPending() && x._attachCancellationCallback(
                new a(this)
              );
            return x._then(
              l,
              u,
              void 0,
              this,
              void 0
            );
          }
        }
      }
      return p.isRejected() ? (s(this), i.e = h, i) : (s(this), h);
    }
    return t.prototype._passThrough = function(h, p, y, b) {
      return typeof h != "function" ? this.then() : this._then(
        y,
        b,
        void 0,
        new o(this, p, h),
        void 0
      );
    }, t.prototype.lastly = t.prototype.finally = function(h) {
      return this._passThrough(
        h,
        0,
        f,
        f
      );
    }, t.prototype.tap = function(h) {
      return this._passThrough(h, 1, f);
    }, o;
  }), Ev;
}
var _v, DC;
function vH() {
  return DC || (DC = 1, _v = function(t) {
    var e = Tt(), n = Uu().keys, r = e.tryCatch, i = e.errorObj;
    function o(a, s, l) {
      return function(u) {
        var f = l._boundValue();
        e: for (var h = 0; h < a.length; ++h) {
          var p = a[h];
          if (p === Error || p != null && p.prototype instanceof Error) {
            if (u instanceof p)
              return r(s).call(f, u);
          } else if (typeof p == "function") {
            var y = r(p).call(f, u);
            if (y === i)
              return y;
            if (y)
              return r(s).call(f, u);
          } else if (e.isObject(u)) {
            for (var b = n(p), x = 0; x < b.length; ++x) {
              var v = b[x];
              if (p[v] != u[v])
                continue e;
            }
            return r(s).call(f, u);
          }
        }
        return t;
      };
    }
    return o;
  }), _v;
}
var kv, wC;
function jF() {
  if (wC) return kv;
  wC = 1;
  var t = Tt(), e = t.maybeWrapAsError, n = ts(), r = n.OperationalError, i = Uu();
  function o(u) {
    return u instanceof Error && i.getPrototypeOf(u) === Error.prototype;
  }
  var a = /^(?:name|message|stack|cause)$/;
  function s(u) {
    var f;
    if (o(u)) {
      f = new r(u), f.name = u.name, f.message = u.message, f.stack = u.stack;
      for (var h = i.keys(u), p = 0; p < h.length; ++p) {
        var y = h[p];
        a.test(y) || (f[y] = u[y]);
      }
      return f;
    }
    return t.markAsOriginatingFromRejection(u), u;
  }
  function l(u, f) {
    return function(h, p) {
      if (u !== null) {
        if (h) {
          var y = s(e(h));
          u._attachExtraTrace(y), u._reject(y);
        } else if (!f)
          u._fulfill(p);
        else {
          for (var b = arguments.length, x = new Array(Math.max(b - 1, 0)), v = 1; v < b; ++v)
            x[v - 1] = arguments[v];
          u._fulfill(x);
        }
        u = null;
      }
    };
  }
  return kv = l, kv;
}
var Av, SC;
function xH() {
  return SC || (SC = 1, Av = function(t, e, n, r, i) {
    var o = Tt(), a = o.tryCatch;
    t.method = function(s) {
      if (typeof s != "function")
        throw new t.TypeError("expecting a function but got " + o.classString(s));
      return function() {
        var l = new t(e);
        l._captureStackTrace(), l._pushContext();
        var u = a(s).apply(this, arguments), f = l._popContext();
        return i.checkForgottenReturns(
          u,
          f,
          "Promise.method",
          l
        ), l._resolveFromSyncValue(u), l;
      };
    }, t.attempt = t.try = function(s) {
      if (typeof s != "function")
        return r("expecting a function but got " + o.classString(s));
      var l = new t(e);
      l._captureStackTrace(), l._pushContext();
      var u;
      if (arguments.length > 1) {
        i.deprecated("calling Promise.try with more than 1 argument");
        var f = arguments[1], h = arguments[2];
        u = o.isArray(f) ? a(s).apply(h, f) : a(s).call(h, f);
      } else
        u = a(s)();
      var p = l._popContext();
      return i.checkForgottenReturns(
        u,
        p,
        "Promise.try",
        l
      ), l._resolveFromSyncValue(u), l;
    }, t.prototype._resolveFromSyncValue = function(s) {
      s === o.errorObj ? this._rejectCallback(s.e, !1) : this._resolveCallback(s, !0);
    };
  }), Av;
}
var Uv, TC;
function DH() {
  return TC || (TC = 1, Uv = function(t, e, n, r) {
    var i = !1, o = function(u, f) {
      this._reject(f);
    }, a = function(u, f) {
      f.promiseRejectionQueued = !0, f.bindingPromise._then(o, o, null, this, u);
    }, s = function(u, f) {
      this._bitField & 50397184 || this._resolveCallback(f.target);
    }, l = function(u, f) {
      f.promiseRejectionQueued || this._reject(u);
    };
    t.prototype.bind = function(u) {
      i || (i = !0, t.prototype._propagateFrom = r.propagateFromFunction(), t.prototype._boundValue = r.boundValueFunction());
      var f = n(u), h = new t(e);
      h._propagateFrom(this, 1);
      var p = this._target();
      if (h._setBoundTo(f), f instanceof t) {
        var y = {
          promiseRejectionQueued: !1,
          promise: h,
          target: p,
          bindingPromise: f
        };
        p._then(e, a, void 0, h, y), f._then(
          s,
          l,
          void 0,
          h,
          y
        ), h._setOnCancel(f);
      } else
        h._resolveCallback(p);
      return h;
    }, t.prototype._setBoundTo = function(u) {
      u !== void 0 ? (this._bitField = this._bitField | 2097152, this._boundTo = u) : this._bitField = this._bitField & -2097153;
    }, t.prototype._isBound = function() {
      return (this._bitField & 2097152) === 2097152;
    }, t.bind = function(u, f) {
      return t.resolve(f).bind(u);
    };
  }), Uv;
}
var Fv, CC;
function wH() {
  return CC || (CC = 1, Fv = function(t, e, n, r) {
    var i = Tt(), o = i.tryCatch, a = i.errorObj, s = t._async;
    t.prototype.break = t.prototype.cancel = function() {
      if (!r.cancellation()) return this._warn("cancellation is disabled");
      for (var l = this, u = l; l._isCancellable(); ) {
        if (!l._cancelBy(u)) {
          u._isFollowing() ? u._followee().cancel() : u._cancelBranched();
          break;
        }
        var f = l._cancellationParent;
        if (f == null || !f._isCancellable()) {
          l._isFollowing() ? l._followee().cancel() : l._cancelBranched();
          break;
        } else
          l._isFollowing() && l._followee().cancel(), l._setWillBeCancelled(), u = l, l = f;
      }
    }, t.prototype._branchHasCancelled = function() {
      this._branchesRemainingToCancel--;
    }, t.prototype._enoughBranchesHaveCancelled = function() {
      return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
    }, t.prototype._cancelBy = function(l) {
      return l === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), !0) : (this._branchHasCancelled(), this._enoughBranchesHaveCancelled() ? (this._invokeOnCancel(), !0) : !1);
    }, t.prototype._cancelBranched = function() {
      this._enoughBranchesHaveCancelled() && this._cancel();
    }, t.prototype._cancel = function() {
      this._isCancellable() && (this._setCancelled(), s.invoke(this._cancelPromises, this, void 0));
    }, t.prototype._cancelPromises = function() {
      this._length() > 0 && this._settlePromises();
    }, t.prototype._unsetOnCancel = function() {
      this._onCancelField = void 0;
    }, t.prototype._isCancellable = function() {
      return this.isPending() && !this._isCancelled();
    }, t.prototype.isCancellable = function() {
      return this.isPending() && !this.isCancelled();
    }, t.prototype._doInvokeOnCancel = function(l, u) {
      if (i.isArray(l))
        for (var f = 0; f < l.length; ++f)
          this._doInvokeOnCancel(l[f], u);
      else if (l !== void 0)
        if (typeof l == "function") {
          if (!u) {
            var h = o(l).call(this._boundValue());
            h === a && (this._attachExtraTrace(h.e), s.throwLater(h.e));
          }
        } else
          l._resultCancelled(this);
    }, t.prototype._invokeOnCancel = function() {
      var l = this._onCancel();
      this._unsetOnCancel(), s.invoke(this._doInvokeOnCancel, this, l);
    }, t.prototype._invokeInternalOnCancel = function() {
      this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel());
    }, t.prototype._resultCancelled = function() {
      this.cancel();
    };
  }), Fv;
}
var Rv, EC;
function SH() {
  return EC || (EC = 1, Rv = function(t) {
    function e() {
      return this.value;
    }
    function n() {
      throw this.reason;
    }
    t.prototype.return = t.prototype.thenReturn = function(r) {
      return r instanceof t && r.suppressUnhandledRejections(), this._then(
        e,
        void 0,
        void 0,
        { value: r },
        void 0
      );
    }, t.prototype.throw = t.prototype.thenThrow = function(r) {
      return this._then(
        n,
        void 0,
        void 0,
        { reason: r },
        void 0
      );
    }, t.prototype.catchThrow = function(r) {
      if (arguments.length <= 1)
        return this._then(
          void 0,
          n,
          void 0,
          { reason: r },
          void 0
        );
      var i = arguments[1], o = function() {
        throw i;
      };
      return this.caught(r, o);
    }, t.prototype.catchReturn = function(r) {
      if (arguments.length <= 1)
        return r instanceof t && r.suppressUnhandledRejections(), this._then(
          void 0,
          e,
          void 0,
          { value: r },
          void 0
        );
      var i = arguments[1];
      i instanceof t && i.suppressUnhandledRejections();
      var o = function() {
        return i;
      };
      return this.caught(r, o);
    };
  }), Rv;
}
var Ov, _C;
function TH() {
  return _C || (_C = 1, Ov = function(t) {
    function e(l) {
      l !== void 0 ? (l = l._target(), this._bitField = l._bitField, this._settledValueField = l._isFateSealed() ? l._settledValue() : void 0) : (this._bitField = 0, this._settledValueField = void 0);
    }
    e.prototype._settledValue = function() {
      return this._settledValueField;
    };
    var n = e.prototype.value = function() {
      if (!this.isFulfilled())
        throw new TypeError(`cannot get fulfillment value of a non-fulfilled promise

    See http://goo.gl/MqrFmX
`);
      return this._settledValue();
    }, r = e.prototype.error = e.prototype.reason = function() {
      if (!this.isRejected())
        throw new TypeError(`cannot get rejection reason of a non-rejected promise

    See http://goo.gl/MqrFmX
`);
      return this._settledValue();
    }, i = e.prototype.isFulfilled = function() {
      return (this._bitField & 33554432) !== 0;
    }, o = e.prototype.isRejected = function() {
      return (this._bitField & 16777216) !== 0;
    }, a = e.prototype.isPending = function() {
      return (this._bitField & 50397184) === 0;
    }, s = e.prototype.isResolved = function() {
      return (this._bitField & 50331648) !== 0;
    };
    e.prototype.isCancelled = function() {
      return (this._bitField & 8454144) !== 0;
    }, t.prototype.__isCancelled = function() {
      return (this._bitField & 65536) === 65536;
    }, t.prototype._isCancelled = function() {
      return this._target().__isCancelled();
    }, t.prototype.isCancelled = function() {
      return (this._target()._bitField & 8454144) !== 0;
    }, t.prototype.isPending = function() {
      return a.call(this._target());
    }, t.prototype.isRejected = function() {
      return o.call(this._target());
    }, t.prototype.isFulfilled = function() {
      return i.call(this._target());
    }, t.prototype.isResolved = function() {
      return s.call(this._target());
    }, t.prototype.value = function() {
      return n.call(this._target());
    }, t.prototype.reason = function() {
      var l = this._target();
      return l._unsetRejectionIsUnhandled(), r.call(l);
    }, t.prototype._value = function() {
      return this._settledValue();
    }, t.prototype._reason = function() {
      return this._unsetRejectionIsUnhandled(), this._settledValue();
    }, t.PromiseInspection = e;
  }), Ov;
}
var Iv, kC;
function CH() {
  return kC || (kC = 1, Iv = function(t, e, n, r, i, o) {
    var a = Tt(), s = a.canEvaluate, l = a.tryCatch, u = a.errorObj, f;
    if (s) {
      for (var h = function(S) {
        return new Function("value", "holder", `                             
	            'use strict';                                                    
	            holder.pIndex = value;                                           
	            holder.checkFulfillment(this);                                   
	            `.replace(/Index/g, S));
      }, p = function(S) {
        return new Function("promise", "holder", `                           
	            'use strict';                                                    
	            holder.pIndex = promise;                                         
	            `.replace(/Index/g, S));
      }, y = function(S) {
        for (var E = new Array(S), I = 0; I < E.length; ++I)
          E[I] = "this.p" + (I + 1);
        var R = E.join(" = ") + " = null;", O = `var promise;
` + E.map(function(le) {
          return `                                                         
	                promise = ` + le + `;                                      
	                if (promise instanceof Promise) {                            
	                    promise.cancel();                                        
	                }                                                            
	            `;
        }).join(`
`), N = E.join(", "), q = "Holder$" + S, $ = `return function(tryCatch, errorObj, Promise, async) {    
	            'use strict';                                                    
	            function [TheName](fn) {                                         
	                [TheProperties]                                              
	                this.fn = fn;                                                
	                this.asyncNeeded = true;                                     
	                this.now = 0;                                                
	            }                                                                
	                                                                             
	            [TheName].prototype._callFunction = function(promise) {          
	                promise._pushContext();                                      
	                var ret = tryCatch(this.fn)([ThePassedArguments]);           
	                promise._popContext();                                       
	                if (ret === errorObj) {                                      
	                    promise._rejectCallback(ret.e, false);                   
	                } else {                                                     
	                    promise._resolveCallback(ret);                           
	                }                                                            
	            };                                                               
	                                                                             
	            [TheName].prototype.checkFulfillment = function(promise) {       
	                var now = ++this.now;                                        
	                if (now === [TheTotal]) {                                    
	                    if (this.asyncNeeded) {                                  
	                        async.invoke(this._callFunction, this, promise);     
	                    } else {                                                 
	                        this._callFunction(promise);                         
	                    }                                                        
	                                                                             
	                }                                                            
	            };                                                               
	                                                                             
	            [TheName].prototype._resultCancelled = function() {              
	                [CancellationCode]                                           
	            };                                                               
	                                                                             
	            return [TheName];                                                
	        }(tryCatch, errorObj, Promise, async);                               
	        `;
        return $ = $.replace(/\[TheName\]/g, q).replace(/\[TheTotal\]/g, S).replace(/\[ThePassedArguments\]/g, N).replace(/\[TheProperties\]/g, R).replace(/\[CancellationCode\]/g, O), new Function("tryCatch", "errorObj", "Promise", "async", $)(l, u, t, i);
      }, b = [], x = [], v = [], D = 0; D < 8; ++D)
        b.push(y(D + 1)), x.push(h(D + 1)), v.push(p(D + 1));
      f = function(S) {
        this._reject(S);
      };
    }
    t.join = function() {
      var S = arguments.length - 1, E;
      if (S > 0 && typeof arguments[S] == "function" && (E = arguments[S], S <= 8 && s)) {
        var A = new t(r);
        A._captureStackTrace();
        for (var I = b[S - 1], R = new I(E), O = x, N = 0; N < S; ++N) {
          var q = n(arguments[N], A);
          if (q instanceof t) {
            q = q._target();
            var $ = q._bitField;
            $ & 50397184 ? $ & 33554432 ? O[N].call(
              A,
              q._value(),
              R
            ) : $ & 16777216 ? A._reject(q._reason()) : A._cancel() : (q._then(
              O[N],
              f,
              void 0,
              A,
              R
            ), v[N](q, R), R.asyncNeeded = !1);
          } else
            O[N].call(A, q, R);
        }
        if (!A._isFateSealed()) {
          if (R.asyncNeeded) {
            var le = o();
            le !== null && (R.fn = a.domainBind(le, R.fn));
          }
          A._setAsyncGuaranteed(), A._setOnCancel(R);
        }
        return A;
      }
      for (var ve = arguments.length, M = new Array(ve), ee = 0; ee < ve; ++ee)
        M[ee] = arguments[ee];
      E && M.pop();
      var A = new e(M).promise();
      return E !== void 0 ? A.spread(E) : A;
    };
  }), Iv;
}
var Bv, AC;
function EH() {
  return AC || (AC = 1, Bv = function(t, e, n, r, i, o) {
    var a = t._getDomain, s = Tt(), l = s.tryCatch, u = s.errorObj, f = t._async;
    function h(y, b, x, v) {
      this.constructor$(y), this._promise._captureStackTrace();
      var D = a();
      this._callback = D === null ? b : s.domainBind(D, b), this._preservedValues = v === i ? new Array(this.length()) : null, this._limit = x, this._inFlight = 0, this._queue = [], f.invoke(this._asyncInit, this, void 0);
    }
    s.inherits(h, e), h.prototype._asyncInit = function() {
      this._init$(void 0, -2);
    }, h.prototype._init = function() {
    }, h.prototype._promiseFulfilled = function(y, b) {
      var x = this._values, v = this.length(), D = this._preservedValues, S = this._limit;
      if (b < 0) {
        if (b = b * -1 - 1, x[b] = y, S >= 1 && (this._inFlight--, this._drainQueue(), this._isResolved()))
          return !0;
      } else {
        if (S >= 1 && this._inFlight >= S)
          return x[b] = y, this._queue.push(b), !1;
        D !== null && (D[b] = y);
        var E = this._promise, I = this._callback, R = E._boundValue();
        E._pushContext();
        var O = l(I).call(R, y, b, v), N = E._popContext();
        if (o.checkForgottenReturns(
          O,
          N,
          D !== null ? "Promise.filter" : "Promise.map",
          E
        ), O === u)
          return this._reject(O.e), !0;
        var q = r(O, this._promise);
        if (q instanceof t) {
          q = q._target();
          var $ = q._bitField;
          if ($ & 50397184)
            if ($ & 33554432)
              O = q._value();
            else return $ & 16777216 ? (this._reject(q._reason()), !0) : (this._cancel(), !0);
          else return S >= 1 && this._inFlight++, x[b] = q, q._proxy(this, (b + 1) * -1), !1;
        }
        x[b] = O;
      }
      var le = ++this._totalResolved;
      return le >= v ? (D !== null ? this._filter(x, D) : this._resolve(x), !0) : !1;
    }, h.prototype._drainQueue = function() {
      for (var y = this._queue, b = this._limit, x = this._values; y.length > 0 && this._inFlight < b; ) {
        if (this._isResolved()) return;
        var v = y.pop();
        this._promiseFulfilled(x[v], v);
      }
    }, h.prototype._filter = function(y, b) {
      for (var x = b.length, v = new Array(x), D = 0, S = 0; S < x; ++S)
        y[S] && (v[D++] = b[S]);
      v.length = D, this._resolve(v);
    }, h.prototype.preservedValues = function() {
      return this._preservedValues;
    };
    function p(y, b, x, v) {
      if (typeof b != "function")
        return n("expecting a function but got " + s.classString(b));
      var D = 0;
      if (x !== void 0)
        if (typeof x == "object" && x !== null) {
          if (typeof x.concurrency != "number")
            return t.reject(
              new TypeError("'concurrency' must be a number but it is " + s.classString(x.concurrency))
            );
          D = x.concurrency;
        } else
          return t.reject(new TypeError(
            "options argument must be an object but it is " + s.classString(x)
          ));
      return D = typeof D == "number" && isFinite(D) && D >= 1 ? D : 0, new h(y, b, D, v).promise();
    }
    t.prototype.map = function(y, b) {
      return p(this, y, b, null);
    }, t.map = function(y, b, x, v) {
      return p(y, b, x, v);
    };
  }), Bv;
}
var Mv, UC;
function _H() {
  if (UC) return Mv;
  UC = 1;
  var t = Object.create;
  if (t) {
    var e = t(null), n = t(null);
    e[" size"] = n[" size"] = 0;
  }
  return Mv = function(r) {
    var i = Tt(), o = i.canEvaluate, a = i.isIdentifier, s, l;
    {
      var u = function(v) {
        return new Function("ensureMethod", `                                    
	        return function(obj) {                                               
	            'use strict'                                                     
	            var len = this.length;                                           
	            ensureMethod(obj, 'methodName');                                 
	            switch(len) {                                                    
	                case 1: return obj.methodName(this[0]);                      
	                case 2: return obj.methodName(this[0], this[1]);             
	                case 3: return obj.methodName(this[0], this[1], this[2]);    
	                case 0: return obj.methodName();                             
	                default:                                                     
	                    return obj.methodName.apply(obj, this);                  
	            }                                                                
	        };                                                                   
	        `.replace(/methodName/g, v))(p);
      }, f = function(v) {
        return new Function("obj", `                                             
	        'use strict';                                                        
	        return obj.propertyName;                                             
	        `.replace("propertyName", v));
      }, h = function(v, D, S) {
        var E = S[v];
        if (typeof E != "function") {
          if (!a(v))
            return null;
          if (E = D(v), S[v] = E, S[" size"]++, S[" size"] > 512) {
            for (var I = Object.keys(S), R = 0; R < 256; ++R) delete S[I[R]];
            S[" size"] = I.length - 256;
          }
        }
        return E;
      };
      s = function(v) {
        return h(v, u, e);
      }, l = function(v) {
        return h(v, f, n);
      };
    }
    function p(v, D) {
      var S;
      if (v != null && (S = v[D]), typeof S != "function") {
        var E = "Object " + i.classString(v) + " has no method '" + i.toString(D) + "'";
        throw new r.TypeError(E);
      }
      return S;
    }
    function y(v) {
      var D = this.pop(), S = p(v, D);
      return S.apply(v, this);
    }
    r.prototype.call = function(v) {
      for (var D = arguments.length, S = new Array(Math.max(D - 1, 0)), E = 1; E < D; ++E)
        S[E - 1] = arguments[E];
      if (o) {
        var I = s(v);
        if (I !== null)
          return this._then(
            I,
            void 0,
            void 0,
            S,
            void 0
          );
      }
      return S.push(v), this._then(y, void 0, void 0, S, void 0);
    };
    function b(v) {
      return v[this];
    }
    function x(v) {
      var D = +this;
      return D < 0 && (D = Math.max(0, D + v.length)), v[D];
    }
    r.prototype.get = function(v) {
      var D = typeof v == "number", S;
      if (D)
        S = x;
      else if (o) {
        var E = l(v);
        S = E !== null ? E : b;
      } else
        S = b;
      return this._then(S, void 0, void 0, v, void 0);
    };
  }, Mv;
}
var Nv, FC;
function kH() {
  return FC || (FC = 1, Nv = function(t, e, n, r, i, o) {
    var a = Tt(), s = ts().TypeError, l = Tt().inherits, u = a.errorObj, f = a.tryCatch, h = {};
    function p(E) {
      setTimeout(function() {
        throw E;
      }, 0);
    }
    function y(E) {
      var I = n(E);
      return I !== E && typeof E._isDisposable == "function" && typeof E._getDisposer == "function" && E._isDisposable() && I._setDisposable(E._getDisposer()), I;
    }
    function b(E, I) {
      var R = 0, O = E.length, N = new t(i);
      function q() {
        if (R >= O) return N._fulfill();
        var $ = y(E[R++]);
        if ($ instanceof t && $._isDisposable()) {
          try {
            $ = n(
              $._getDisposer().tryDispose(I),
              E.promise
            );
          } catch (le) {
            return p(le);
          }
          if ($ instanceof t)
            return $._then(
              q,
              p,
              null,
              null,
              null
            );
        }
        q();
      }
      return q(), N;
    }
    function x(E, I, R) {
      this._data = E, this._promise = I, this._context = R;
    }
    x.prototype.data = function() {
      return this._data;
    }, x.prototype.promise = function() {
      return this._promise;
    }, x.prototype.resource = function() {
      return this.promise().isFulfilled() ? this.promise().value() : h;
    }, x.prototype.tryDispose = function(E) {
      var I = this.resource(), R = this._context;
      R !== void 0 && R._pushContext();
      var O = I !== h ? this.doDispose(I, E) : null;
      return R !== void 0 && R._popContext(), this._promise._unsetDisposable(), this._data = null, O;
    }, x.isDisposer = function(E) {
      return E != null && typeof E.resource == "function" && typeof E.tryDispose == "function";
    };
    function v(E, I, R) {
      this.constructor$(E, I, R);
    }
    l(v, x), v.prototype.doDispose = function(E, I) {
      var R = this.data();
      return R.call(E, E, I);
    };
    function D(E) {
      return x.isDisposer(E) ? (this.resources[this.index]._setDisposable(E), E.promise()) : E;
    }
    function S(E) {
      this.length = E, this.promise = null, this[E - 1] = null;
    }
    S.prototype._resultCancelled = function() {
      for (var E = this.length, I = 0; I < E; ++I) {
        var R = this[I];
        R instanceof t && R.cancel();
      }
    }, t.using = function() {
      var E = arguments.length;
      if (E < 2) return e(
        "you must pass at least 2 arguments to Promise.using"
      );
      var I = arguments[E - 1];
      if (typeof I != "function")
        return e("expecting a function but got " + a.classString(I));
      var R, O = !0;
      E === 2 && Array.isArray(arguments[0]) ? (R = arguments[0], E = R.length, O = !1) : (R = arguments, E--);
      for (var N = new S(E), q = 0; q < E; ++q) {
        var $ = R[q];
        if (x.isDisposer($)) {
          var le = $;
          $ = $.promise(), $._setDisposable(le);
        } else {
          var ve = n($);
          ve instanceof t && ($ = ve._then(D, null, null, {
            resources: N,
            index: q
          }, void 0));
        }
        N[q] = $;
      }
      for (var M = new Array(N.length), q = 0; q < M.length; ++q)
        M[q] = t.resolve(N[q]).reflect();
      var ee = t.all(M).then(function(oe) {
        for (var j = 0; j < oe.length; ++j) {
          var Q = oe[j];
          if (Q.isRejected())
            return u.e = Q.error(), u;
          if (!Q.isFulfilled()) {
            ee.cancel();
            return;
          }
          oe[j] = Q.value();
        }
        A._pushContext(), I = f(I);
        var G = O ? I.apply(void 0, oe) : I(oe), Z = A._popContext();
        return o.checkForgottenReturns(
          G,
          Z,
          "Promise.using",
          A
        ), G;
      }), A = ee.lastly(function() {
        var oe = new t.PromiseInspection(ee);
        return b(N, oe);
      });
      return N.promise = A, A._setOnCancel(N), A;
    }, t.prototype._setDisposable = function(E) {
      this._bitField = this._bitField | 131072, this._disposer = E;
    }, t.prototype._isDisposable = function() {
      return (this._bitField & 131072) > 0;
    }, t.prototype._getDisposer = function() {
      return this._disposer;
    }, t.prototype._unsetDisposable = function() {
      this._bitField = this._bitField & -131073, this._disposer = void 0;
    }, t.prototype.disposer = function(E) {
      if (typeof E == "function")
        return new v(E, this, r());
      throw new s();
    };
  }), Nv;
}
var Pv, RC;
function AH() {
  return RC || (RC = 1, Pv = function(t, e, n) {
    var r = Tt(), i = t.TimeoutError;
    function o(h) {
      this.handle = h;
    }
    o.prototype._resultCancelled = function() {
      clearTimeout(this.handle);
    };
    var a = function(h) {
      return s(+this).thenReturn(h);
    }, s = t.delay = function(h, p) {
      var y, b;
      return p !== void 0 ? (y = t.resolve(p)._then(a, null, null, h, void 0), n.cancellation() && p instanceof t && y._setOnCancel(p)) : (y = new t(e), b = setTimeout(function() {
        y._fulfill();
      }, +h), n.cancellation() && y._setOnCancel(new o(b)), y._captureStackTrace()), y._setAsyncGuaranteed(), y;
    };
    t.prototype.delay = function(h) {
      return s(h, this);
    };
    var l = function(h, p, y) {
      var b;
      typeof p != "string" ? p instanceof Error ? b = p : b = new i("operation timed out") : b = new i(p), r.markAsOriginatingFromRejection(b), h._attachExtraTrace(b), h._reject(b), y != null && y.cancel();
    };
    function u(h) {
      return clearTimeout(this.handle), h;
    }
    function f(h) {
      throw clearTimeout(this.handle), h;
    }
    t.prototype.timeout = function(h, p) {
      h = +h;
      var y, b, x = new o(setTimeout(function() {
        y.isPending() && l(y, p, b);
      }, h));
      return n.cancellation() ? (b = this.then(), y = b._then(
        u,
        f,
        void 0,
        x,
        void 0
      ), y._setOnCancel(x)) : y = this._then(
        u,
        f,
        void 0,
        x,
        void 0
      ), y;
    };
  }), Pv;
}
var Wv, OC;
function UH() {
  return OC || (OC = 1, Wv = function(t, e, n, r, i, o) {
    var a = ts(), s = a.TypeError, l = Tt(), u = l.errorObj, f = l.tryCatch, h = [];
    function p(b, x, v) {
      for (var D = 0; D < x.length; ++D) {
        v._pushContext();
        var S = f(x[D])(b);
        if (v._popContext(), S === u) {
          v._pushContext();
          var E = t.reject(u.e);
          return v._popContext(), E;
        }
        var I = r(S, v);
        if (I instanceof t) return I;
      }
      return null;
    }
    function y(b, x, v, D) {
      if (o.cancellation()) {
        var S = new t(n), E = this._finallyPromise = new t(n);
        this._promise = S.lastly(function() {
          return E;
        }), S._captureStackTrace(), S._setOnCancel(this);
      } else {
        var I = this._promise = new t(n);
        I._captureStackTrace();
      }
      this._stack = D, this._generatorFunction = b, this._receiver = x, this._generator = void 0, this._yieldHandlers = typeof v == "function" ? [v].concat(h) : h, this._yieldedPromise = null, this._cancellationPhase = !1;
    }
    l.inherits(y, i), y.prototype._isResolved = function() {
      return this._promise === null;
    }, y.prototype._cleanup = function() {
      this._promise = this._generator = null, o.cancellation() && this._finallyPromise !== null && (this._finallyPromise._fulfill(), this._finallyPromise = null);
    }, y.prototype._promiseCancelled = function() {
      if (!this._isResolved()) {
        var b = typeof this._generator.return < "u", x;
        if (b)
          this._promise._pushContext(), x = f(this._generator.return).call(
            this._generator,
            void 0
          ), this._promise._popContext();
        else {
          var v = new t.CancellationError(
            "generator .return() sentinel"
          );
          t.coroutine.returnSentinel = v, this._promise._attachExtraTrace(v), this._promise._pushContext(), x = f(this._generator.throw).call(
            this._generator,
            v
          ), this._promise._popContext();
        }
        this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(x);
      }
    }, y.prototype._promiseFulfilled = function(b) {
      this._yieldedPromise = null, this._promise._pushContext();
      var x = f(this._generator.next).call(this._generator, b);
      this._promise._popContext(), this._continue(x);
    }, y.prototype._promiseRejected = function(b) {
      this._yieldedPromise = null, this._promise._attachExtraTrace(b), this._promise._pushContext();
      var x = f(this._generator.throw).call(this._generator, b);
      this._promise._popContext(), this._continue(x);
    }, y.prototype._resultCancelled = function() {
      if (this._yieldedPromise instanceof t) {
        var b = this._yieldedPromise;
        this._yieldedPromise = null, b.cancel();
      }
    }, y.prototype.promise = function() {
      return this._promise;
    }, y.prototype._run = function() {
      this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, this._promiseFulfilled(void 0);
    }, y.prototype._continue = function(b) {
      var x = this._promise;
      if (b === u)
        return this._cleanup(), this._cancellationPhase ? x.cancel() : x._rejectCallback(b.e, !1);
      var v = b.value;
      if (b.done === !0)
        return this._cleanup(), this._cancellationPhase ? x.cancel() : x._resolveCallback(v);
      var D = r(v, this._promise);
      if (!(D instanceof t) && (D = p(
        D,
        this._yieldHandlers,
        this._promise
      ), D === null)) {
        this._promiseRejected(
          new s(
            `A value %s was yielded that could not be treated as a promise

    See http://goo.gl/MqrFmX

`.replace("%s", v) + `From coroutine:
` + this._stack.split(`
`).slice(1, -7).join(`
`)
          )
        );
        return;
      }
      D = D._target();
      var S = D._bitField;
      S & 50397184 ? S & 33554432 ? t._async.invoke(
        this._promiseFulfilled,
        this,
        D._value()
      ) : S & 16777216 ? t._async.invoke(
        this._promiseRejected,
        this,
        D._reason()
      ) : this._promiseCancelled() : (this._yieldedPromise = D, D._proxy(this, null));
    }, t.coroutine = function(b, x) {
      if (typeof b != "function")
        throw new s(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
      var v = Object(x).yieldHandler, D = y, S = new Error().stack;
      return function() {
        var E = b.apply(this, arguments), I = new D(
          void 0,
          void 0,
          v,
          S
        ), R = I.promise();
        return I._generator = E, I._promiseFulfilled(void 0), R;
      };
    }, t.coroutine.addYieldHandler = function(b) {
      if (typeof b != "function")
        throw new s("expecting a function but got " + l.classString(b));
      h.push(b);
    }, t.spawn = function(b) {
      if (o.deprecated("Promise.spawn()", "Promise.coroutine()"), typeof b != "function")
        return e(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
      var x = new y(b, this), v = x.promise();
      return x._run(t.spawn), v;
    };
  }), Wv;
}
var Lv, IC;
function FH() {
  return IC || (IC = 1, Lv = function(t) {
    var e = Tt(), n = t._async, r = e.tryCatch, i = e.errorObj;
    function o(l, u) {
      var f = this;
      if (!e.isArray(l)) return a.call(f, l, u);
      var h = r(u).apply(f._boundValue(), [null].concat(l));
      h === i && n.throwLater(h.e);
    }
    function a(l, u) {
      var f = this, h = f._boundValue(), p = l === void 0 ? r(u).call(h, null) : r(u).call(h, null, l);
      p === i && n.throwLater(p.e);
    }
    function s(l, u) {
      var f = this;
      if (!l) {
        var h = new Error(l + "");
        h.cause = l, l = h;
      }
      var p = r(u).call(f._boundValue(), l);
      p === i && n.throwLater(p.e);
    }
    t.prototype.asCallback = t.prototype.nodeify = function(l, u) {
      if (typeof l == "function") {
        var f = a;
        u !== void 0 && Object(u).spread && (f = o), this._then(
          f,
          s,
          void 0,
          this,
          l
        );
      }
      return this;
    };
  }), Lv;
}
var zv, BC;
function RH() {
  return BC || (BC = 1, zv = function(t, e) {
    var n = {}, r = Tt(), i = jF(), o = r.withAppended, a = r.maybeWrapAsError, s = r.canEvaluate, l = ts().TypeError, u = "Async", f = { __isPromisified__: !0 }, h = [
      "arity",
      "length",
      "name",
      "arguments",
      "caller",
      "callee",
      "prototype",
      "__isPromisified__"
    ], p = new RegExp("^(?:" + h.join("|") + ")$"), y = function(ee) {
      return r.isIdentifier(ee) && ee.charAt(0) !== "_" && ee !== "constructor";
    };
    function b(ee) {
      return !p.test(ee);
    }
    function x(ee) {
      try {
        return ee.__isPromisified__ === !0;
      } catch {
        return !1;
      }
    }
    function v(ee, A, oe) {
      var j = r.getDataPropertyOrDefault(
        ee,
        A + oe,
        f
      );
      return j ? x(j) : !1;
    }
    function D(ee, A, oe) {
      for (var j = 0; j < ee.length; j += 2) {
        var Q = ee[j];
        if (oe.test(Q)) {
          for (var G = Q.replace(oe, ""), Z = 0; Z < ee.length; Z += 2)
            if (ee[Z] === G)
              throw new l(`Cannot promisify an API that has normal methods with '%s'-suffix

    See http://goo.gl/MqrFmX
`.replace("%s", A));
        }
      }
    }
    function S(ee, A, oe, j) {
      for (var Q = r.inheritedDataKeys(ee), G = [], Z = 0; Z < Q.length; ++Z) {
        var re = Q[Z], V = ee[re], P = j === y ? !0 : y(re);
        typeof V == "function" && !x(V) && !v(ee, re, A) && j(re, V, ee, P) && G.push(re, V);
      }
      return D(G, A, oe), G;
    }
    var E = function(ee) {
      return ee.replace(/([$])/, "\\$");
    }, I;
    {
      var R = function(ee) {
        for (var A = [ee], oe = Math.max(0, ee - 1 - 3), j = ee - 1; j >= oe; --j)
          A.push(j);
        for (var j = ee + 1; j <= 3; ++j)
          A.push(j);
        return A;
      }, O = function(ee) {
        return r.filledRange(ee, "_arg", "");
      }, N = function(ee) {
        return r.filledRange(
          Math.max(ee, 3),
          "_arg",
          ""
        );
      }, q = function(ee) {
        return typeof ee.length == "number" ? Math.max(Math.min(ee.length, 1024), 0) : 0;
      };
      I = function(ee, A, oe, j, Q, G) {
        var Z = Math.max(0, q(j) - 1), re = R(Z), V = typeof ee == "string" || A === n;
        function P(_e) {
          var $e = O(_e).join(", "), Le = _e > 0 ? ", " : "", ze;
          return V ? ze = `ret = callback.call(this, {{args}}, nodeback); break;
` : ze = A === void 0 ? `ret = callback({{args}}, nodeback); break;
` : `ret = callback.call(receiver, {{args}}, nodeback); break;
`, ze.replace("{{args}}", $e).replace(", ", Le);
        }
        function pe() {
          for (var _e = "", $e = 0; $e < re.length; ++$e)
            _e += "case " + re[$e] + ":" + P(re[$e]);
          return _e += `                                                             
	        default:                                                             
	            var args = new Array(len + 1);                                   
	            var i = 0;                                                       
	            for (var i = 0; i < len; ++i) {                                  
	               args[i] = arguments[i];                                       
	            }                                                                
	            args[i] = nodeback;                                              
	            [CodeForCall]                                                    
	            break;                                                           
	        `.replace("[CodeForCall]", V ? `ret = callback.apply(this, args);
` : `ret = callback.apply(receiver, args);
`), _e;
        }
        var we = typeof ee == "string" ? "this != null ? this['" + ee + "'] : fn" : "fn", be = `'use strict';                                                
	        var ret = function (Parameters) {                                    
	            'use strict';                                                    
	            var len = arguments.length;                                      
	            var promise = new Promise(INTERNAL);                             
	            promise._captureStackTrace();                                    
	            var nodeback = nodebackForPromise(promise, ` + G + `);   
	            var ret;                                                         
	            var callback = tryCatch([GetFunctionCode]);                      
	            switch(len) {                                                    
	                [CodeForSwitchCase]                                          
	            }                                                                
	            if (ret === errorObj) {                                          
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
	            }                                                                
	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     
	            return promise;                                                  
	        };                                                                   
	        notEnumerableProp(ret, '__isPromisified__', true);                   
	        return ret;                                                          
	    `.replace("[CodeForSwitchCase]", pe()).replace("[GetFunctionCode]", we);
        return be = be.replace("Parameters", N(Z)), new Function(
          "Promise",
          "fn",
          "receiver",
          "withAppended",
          "maybeWrapAsError",
          "nodebackForPromise",
          "tryCatch",
          "errorObj",
          "notEnumerableProp",
          "INTERNAL",
          be
        )(
          t,
          j,
          A,
          o,
          a,
          i,
          r.tryCatch,
          r.errorObj,
          r.notEnumerableProp,
          e
        );
      };
    }
    function $(ee, A, oe, j, Q, G) {
      var Z = /* @__PURE__ */ function() {
        return this;
      }(), re = ee;
      typeof re == "string" && (ee = j);
      function V() {
        var P = A;
        A === n && (P = this);
        var pe = new t(e);
        pe._captureStackTrace();
        var we = typeof re == "string" && this !== Z ? this[re] : ee, be = i(pe, G);
        try {
          we.apply(P, o(arguments, be));
        } catch (_e) {
          pe._rejectCallback(a(_e), !0, !0);
        }
        return pe._isFateSealed() || pe._setAsyncGuaranteed(), pe;
      }
      return r.notEnumerableProp(V, "__isPromisified__", !0), V;
    }
    var le = s ? I : $;
    function ve(ee, A, oe, j, Q) {
      for (var G = new RegExp(E(A) + "$"), Z = S(ee, A, G, oe), re = 0, V = Z.length; re < V; re += 2) {
        var P = Z[re], pe = Z[re + 1], we = P + A;
        if (j === le)
          ee[we] = le(P, n, P, pe, A, Q);
        else {
          var be = j(pe, function() {
            return le(
              P,
              n,
              P,
              pe,
              A,
              Q
            );
          });
          r.notEnumerableProp(be, "__isPromisified__", !0), ee[we] = be;
        }
      }
      return r.toFastProperties(ee), ee;
    }
    function M(ee, A, oe) {
      return le(
        ee,
        A,
        void 0,
        ee,
        null,
        oe
      );
    }
    t.promisify = function(ee, A) {
      if (typeof ee != "function")
        throw new l("expecting a function but got " + r.classString(ee));
      if (x(ee))
        return ee;
      A = Object(A);
      var oe = A.context === void 0 ? n : A.context, j = !!A.multiArgs, Q = M(ee, oe, j);
      return r.copyDescriptors(ee, Q, b), Q;
    }, t.promisifyAll = function(ee, A) {
      if (typeof ee != "function" && typeof ee != "object")
        throw new l(`the target of promisifyAll must be an object or a function

    See http://goo.gl/MqrFmX
`);
      A = Object(A);
      var oe = !!A.multiArgs, j = A.suffix;
      typeof j != "string" && (j = u);
      var Q = A.filter;
      typeof Q != "function" && (Q = y);
      var G = A.promisifier;
      if (typeof G != "function" && (G = le), !r.isIdentifier(j))
        throw new RangeError(`suffix must be a valid identifier

    See http://goo.gl/MqrFmX
`);
      for (var Z = r.inheritedDataKeys(ee), re = 0; re < Z.length; ++re) {
        var V = ee[Z[re]];
        Z[re] !== "constructor" && r.isClass(V) && (ve(
          V.prototype,
          j,
          Q,
          G,
          oe
        ), ve(V, j, Q, G, oe));
      }
      return ve(ee, j, Q, G, oe);
    };
  }), zv;
}
var $v, MC;
function OH() {
  return MC || (MC = 1, $v = function(t, e, n, r) {
    var i = Tt(), o = i.isObject, a = Uu(), s;
    typeof Map == "function" && (s = Map);
    var l = /* @__PURE__ */ function() {
      var p = 0, y = 0;
      function b(x, v) {
        this[p] = x, this[p + y] = v, p++;
      }
      return function(v) {
        y = v.size, p = 0;
        var D = new Array(v.size * 2);
        return v.forEach(b, D), D;
      };
    }(), u = function(p) {
      for (var y = new s(), b = p.length / 2 | 0, x = 0; x < b; ++x) {
        var v = p[b + x], D = p[x];
        y.set(v, D);
      }
      return y;
    };
    function f(p) {
      var y = !1, b;
      if (s !== void 0 && p instanceof s)
        b = l(p), y = !0;
      else {
        var x = a.keys(p), v = x.length;
        b = new Array(v * 2);
        for (var D = 0; D < v; ++D) {
          var S = x[D];
          b[D] = p[S], b[D + v] = S;
        }
      }
      this.constructor$(b), this._isMap = y, this._init$(void 0, -3);
    }
    i.inherits(f, e), f.prototype._init = function() {
    }, f.prototype._promiseFulfilled = function(p, y) {
      this._values[y] = p;
      var b = ++this._totalResolved;
      if (b >= this._length) {
        var x;
        if (this._isMap)
          x = u(this._values);
        else {
          x = {};
          for (var v = this.length(), D = 0, S = this.length(); D < S; ++D)
            x[this._values[D + v]] = this._values[D];
        }
        return this._resolve(x), !0;
      }
      return !1;
    }, f.prototype.shouldCopyValues = function() {
      return !1;
    }, f.prototype.getActualLength = function(p) {
      return p >> 1;
    };
    function h(p) {
      var y, b = n(p);
      if (o(b))
        b instanceof t ? y = b._then(
          t.props,
          void 0,
          void 0,
          void 0,
          void 0
        ) : y = new f(b).promise();
      else return r(`cannot await properties of a non-object

    See http://goo.gl/MqrFmX
`);
      return b instanceof t && y._propagateFrom(b, 2), y;
    }
    t.prototype.props = function() {
      return h(this);
    }, t.props = function(p) {
      return h(p);
    };
  }), $v;
}
var jv, NC;
function IH() {
  return NC || (NC = 1, jv = function(t, e, n, r) {
    var i = Tt(), o = function(s) {
      return s.then(function(l) {
        return a(l, s);
      });
    };
    function a(s, l) {
      var u = n(s);
      if (u instanceof t)
        return o(u);
      if (s = i.asArray(s), s === null)
        return r("expecting an array or an iterable object but got " + i.classString(s));
      var f = new t(e);
      l !== void 0 && f._propagateFrom(l, 3);
      for (var h = f._fulfill, p = f._reject, y = 0, b = s.length; y < b; ++y) {
        var x = s[y];
        x === void 0 && !(y in s) || t.cast(x)._then(h, p, void 0, f, null);
      }
      return f;
    }
    t.race = function(s) {
      return a(s, void 0);
    }, t.prototype.race = function() {
      return a(this, void 0);
    };
  }), jv;
}
var Hv, PC;
function BH() {
  return PC || (PC = 1, Hv = function(t, e, n, r, i, o) {
    var a = t._getDomain, s = Tt(), l = s.tryCatch;
    function u(b, x, v, D) {
      this.constructor$(b);
      var S = a();
      this._fn = S === null ? x : s.domainBind(S, x), v !== void 0 && (v = t.resolve(v), v._attachCancellationCallback(this)), this._initialValue = v, this._currentCancellable = null, D === i ? this._eachValues = Array(this._length) : D === 0 ? this._eachValues = null : this._eachValues = void 0, this._promise._captureStackTrace(), this._init$(void 0, -5);
    }
    s.inherits(u, e), u.prototype._gotAccum = function(b) {
      this._eachValues !== void 0 && this._eachValues !== null && b !== i && this._eachValues.push(b);
    }, u.prototype._eachComplete = function(b) {
      return this._eachValues !== null && this._eachValues.push(b), this._eachValues;
    }, u.prototype._init = function() {
    }, u.prototype._resolveEmptyArray = function() {
      this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
    }, u.prototype.shouldCopyValues = function() {
      return !1;
    }, u.prototype._resolve = function(b) {
      this._promise._resolveCallback(b), this._values = null;
    }, u.prototype._resultCancelled = function(b) {
      if (b === this._initialValue) return this._cancel();
      this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof t && this._currentCancellable.cancel(), this._initialValue instanceof t && this._initialValue.cancel());
    }, u.prototype._iterate = function(b) {
      this._values = b;
      var x, v, D = b.length;
      if (this._initialValue !== void 0 ? (x = this._initialValue, v = 0) : (x = t.resolve(b[0]), v = 1), this._currentCancellable = x, !x.isRejected())
        for (; v < D; ++v) {
          var S = {
            accum: null,
            value: b[v],
            index: v,
            length: D,
            array: this
          };
          x = x._then(p, void 0, void 0, S, void 0);
        }
      this._eachValues !== void 0 && (x = x._then(this._eachComplete, void 0, void 0, this, void 0)), x._then(f, f, void 0, x, this);
    }, t.prototype.reduce = function(b, x) {
      return h(this, b, x, null);
    }, t.reduce = function(b, x, v, D) {
      return h(b, x, v, D);
    };
    function f(b, x) {
      this.isFulfilled() ? x._resolve(b) : x._reject(b);
    }
    function h(b, x, v, D) {
      if (typeof x != "function")
        return n("expecting a function but got " + s.classString(x));
      var S = new u(b, x, v, D);
      return S.promise();
    }
    function p(b) {
      this.accum = b, this.array._gotAccum(b);
      var x = r(this.value, this.array._promise);
      return x instanceof t ? (this.array._currentCancellable = x, x._then(y, void 0, void 0, this, void 0)) : y.call(this, x);
    }
    function y(b) {
      var x = this.array, v = x._promise, D = l(x._fn);
      v._pushContext();
      var S;
      x._eachValues !== void 0 ? S = D.call(v._boundValue(), b, this.index, this.length) : S = D.call(
        v._boundValue(),
        this.accum,
        b,
        this.index,
        this.length
      ), S instanceof t && (x._currentCancellable = S);
      var E = v._popContext();
      return o.checkForgottenReturns(
        S,
        E,
        x._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
        v
      ), S;
    }
  }), Hv;
}
var Vv, WC;
function MH() {
  return WC || (WC = 1, Vv = function(t, e, n) {
    var r = t.PromiseInspection, i = Tt();
    function o(a) {
      this.constructor$(a);
    }
    i.inherits(o, e), o.prototype._promiseResolved = function(a, s) {
      this._values[a] = s;
      var l = ++this._totalResolved;
      return l >= this._length ? (this._resolve(this._values), !0) : !1;
    }, o.prototype._promiseFulfilled = function(a, s) {
      var l = new r();
      return l._bitField = 33554432, l._settledValueField = a, this._promiseResolved(s, l);
    }, o.prototype._promiseRejected = function(a, s) {
      var l = new r();
      return l._bitField = 16777216, l._settledValueField = a, this._promiseResolved(s, l);
    }, t.settle = function(a) {
      return n.deprecated(".settle()", ".reflect()"), new o(a).promise();
    }, t.prototype.settle = function() {
      return t.settle(this);
    };
  }), Vv;
}
var qv, LC;
function NH() {
  return LC || (LC = 1, qv = function(t, e, n) {
    var r = Tt(), i = ts().RangeError, o = ts().AggregateError, a = r.isArray, s = {};
    function l(f) {
      this.constructor$(f), this._howMany = 0, this._unwrap = !1, this._initialized = !1;
    }
    r.inherits(l, e), l.prototype._init = function() {
      if (this._initialized) {
        if (this._howMany === 0) {
          this._resolve([]);
          return;
        }
        this._init$(void 0, -5);
        var f = a(this._values);
        !this._isResolved() && f && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()));
      }
    }, l.prototype.init = function() {
      this._initialized = !0, this._init();
    }, l.prototype.setUnwrap = function() {
      this._unwrap = !0;
    }, l.prototype.howMany = function() {
      return this._howMany;
    }, l.prototype.setHowMany = function(f) {
      this._howMany = f;
    }, l.prototype._promiseFulfilled = function(f) {
      return this._addFulfilled(f), this._fulfilled() === this.howMany() ? (this._values.length = this.howMany(), this.howMany() === 1 && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), !0) : !1;
    }, l.prototype._promiseRejected = function(f) {
      return this._addRejected(f), this._checkOutcome();
    }, l.prototype._promiseCancelled = function() {
      return this._values instanceof t || this._values == null ? this._cancel() : (this._addRejected(s), this._checkOutcome());
    }, l.prototype._checkOutcome = function() {
      if (this.howMany() > this._canPossiblyFulfill()) {
        for (var f = new o(), h = this.length(); h < this._values.length; ++h)
          this._values[h] !== s && f.push(this._values[h]);
        return f.length > 0 ? this._reject(f) : this._cancel(), !0;
      }
      return !1;
    }, l.prototype._fulfilled = function() {
      return this._totalResolved;
    }, l.prototype._rejected = function() {
      return this._values.length - this.length();
    }, l.prototype._addRejected = function(f) {
      this._values.push(f);
    }, l.prototype._addFulfilled = function(f) {
      this._values[this._totalResolved++] = f;
    }, l.prototype._canPossiblyFulfill = function() {
      return this.length() - this._rejected();
    }, l.prototype._getRangeError = function(f) {
      var h = "Input array must contain at least " + this._howMany + " items but contains only " + f + " items";
      return new i(h);
    }, l.prototype._resolveEmptyArray = function() {
      this._reject(this._getRangeError(0));
    };
    function u(f, h) {
      if ((h | 0) !== h || h < 0)
        return n(`expecting a positive integer

    See http://goo.gl/MqrFmX
`);
      var p = new l(f), y = p.promise();
      return p.setHowMany(h), p.init(), y;
    }
    t.some = function(f, h) {
      return u(f, h);
    }, t.prototype.some = function(f) {
      return u(this, f);
    }, t._SomePromiseArray = l;
  }), qv;
}
var Xv, zC;
function PH() {
  return zC || (zC = 1, Xv = function(t, e) {
    var n = t.map;
    t.prototype.filter = function(r, i) {
      return n(this, r, i, e);
    }, t.filter = function(r, i, o) {
      return n(r, i, o, e);
    };
  }), Xv;
}
var Gv, $C;
function WH() {
  return $C || ($C = 1, Gv = function(t, e) {
    var n = t.reduce, r = t.all;
    function i() {
      return r(this);
    }
    function o(a, s) {
      return n(a, s, e, e);
    }
    t.prototype.each = function(a) {
      return n(this, a, e, 0)._then(i, void 0, void 0, this, void 0);
    }, t.prototype.mapSeries = function(a) {
      return n(this, a, e, e);
    }, t.each = function(a, s) {
      return n(a, s, e, 0)._then(i, void 0, void 0, a, void 0);
    }, t.mapSeries = o;
  }), Gv;
}
var Jv, jC;
function LH() {
  return jC || (jC = 1, Jv = function(t) {
    var e = t._SomePromiseArray;
    function n(r) {
      var i = new e(r), o = i.promise();
      return i.setHowMany(1), i.setUnwrap(), i.init(), o;
    }
    t.any = function(r) {
      return n(r);
    }, t.prototype.any = function() {
      return n(this);
    };
  }), Jv;
}
(function(t) {
  t.exports = function() {
    var e = function() {
      return new p(`circular promise resolution chain

    See http://goo.gl/MqrFmX
`);
    }, n = function() {
      return new M.PromiseInspection(this._target());
    }, r = function(j) {
      return M.reject(new p(j));
    };
    function i() {
    }
    var o = {}, a = Tt(), s;
    a.isNode ? s = function() {
      var j = process.domain;
      return j === void 0 && (j = null), j;
    } : s = function() {
      return null;
    }, a.notEnumerableProp(M, "_getDomain", s);
    var l = Uu(), u = hH(), f = new u();
    l.defineProperty(M, "_async", { value: f });
    var h = ts(), p = M.TypeError = h.TypeError;
    M.RangeError = h.RangeError;
    var y = M.CancellationError = h.CancellationError;
    M.TimeoutError = h.TimeoutError, M.OperationalError = h.OperationalError, M.RejectionError = h.OperationalError, M.AggregateError = h.AggregateError;
    var b = function() {
    }, x = {}, v = {}, D = pH()(M, b), S = gH()(
      M,
      b,
      D,
      r,
      i
    ), E = mH()(M), I = E.create, R = yH()(M, E);
    R.CapturedTrace;
    var O = bH()(M, D), N = vH()(v), q = jF(), $ = a.errorObj, le = a.tryCatch;
    function ve(j, Q) {
      if (typeof Q != "function")
        throw new p("expecting a function but got " + a.classString(Q));
      if (j.constructor !== M)
        throw new p(`the promise constructor cannot be invoked directly

    See http://goo.gl/MqrFmX
`);
    }
    function M(j) {
      this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, this._promise0 = void 0, this._receiver0 = void 0, j !== b && (ve(this, j), this._resolveFromExecutor(j)), this._promiseCreated(), this._fireEvent("promiseCreated", this);
    }
    M.prototype.toString = function() {
      return "[object Promise]";
    }, M.prototype.caught = M.prototype.catch = function(j) {
      var Q = arguments.length;
      if (Q > 1) {
        var G = new Array(Q - 1), Z = 0, re;
        for (re = 0; re < Q - 1; ++re) {
          var V = arguments[re];
          if (a.isObject(V))
            G[Z++] = V;
          else
            return r("expecting an object but got A catch statement predicate " + a.classString(V));
        }
        return G.length = Z, j = arguments[re], this.then(void 0, N(G, j, this));
      }
      return this.then(void 0, j);
    }, M.prototype.reflect = function() {
      return this._then(
        n,
        n,
        void 0,
        this,
        void 0
      );
    }, M.prototype.then = function(j, Q) {
      if (R.warnings() && arguments.length > 0 && typeof j != "function" && typeof Q != "function") {
        var G = ".then() only accepts functions but was passed: " + a.classString(j);
        arguments.length > 1 && (G += ", " + a.classString(Q)), this._warn(G);
      }
      return this._then(j, Q, void 0, void 0, void 0);
    }, M.prototype.done = function(j, Q) {
      var G = this._then(j, Q, void 0, void 0, void 0);
      G._setIsFinal();
    }, M.prototype.spread = function(j) {
      return typeof j != "function" ? r("expecting a function but got " + a.classString(j)) : this.all()._then(j, void 0, void 0, x, void 0);
    }, M.prototype.toJSON = function() {
      var j = {
        isFulfilled: !1,
        isRejected: !1,
        fulfillmentValue: void 0,
        rejectionReason: void 0
      };
      return this.isFulfilled() ? (j.fulfillmentValue = this.value(), j.isFulfilled = !0) : this.isRejected() && (j.rejectionReason = this.reason(), j.isRejected = !0), j;
    }, M.prototype.all = function() {
      return arguments.length > 0 && this._warn(".all() was passed arguments but it does not take any"), new S(this).promise();
    }, M.prototype.error = function(j) {
      return this.caught(a.originatesFromRejection, j);
    }, M.getNewLibraryCopy = t.exports, M.is = function(j) {
      return j instanceof M;
    }, M.fromNode = M.fromCallback = function(j) {
      var Q = new M(b);
      Q._captureStackTrace();
      var G = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : !1, Z = le(j)(q(Q, G));
      return Z === $ && Q._rejectCallback(Z.e, !0), Q._isFateSealed() || Q._setAsyncGuaranteed(), Q;
    }, M.all = function(j) {
      return new S(j).promise();
    }, M.cast = function(j) {
      var Q = D(j);
      return Q instanceof M || (Q = new M(b), Q._captureStackTrace(), Q._setFulfilled(), Q._rejectionHandler0 = j), Q;
    }, M.resolve = M.fulfilled = M.cast, M.reject = M.rejected = function(j) {
      var Q = new M(b);
      return Q._captureStackTrace(), Q._rejectCallback(j, !0), Q;
    }, M.setScheduler = function(j) {
      if (typeof j != "function")
        throw new p("expecting a function but got " + a.classString(j));
      return f.setScheduler(j);
    }, M.prototype._then = function(j, Q, G, Z, re) {
      var V = re !== void 0, P = V ? re : new M(b), pe = this._target(), we = pe._bitField;
      V || (P._propagateFrom(this, 3), P._captureStackTrace(), Z === void 0 && this._bitField & 2097152 && (we & 50397184 ? Z = this._boundValue() : Z = pe === this ? void 0 : this._boundTo), this._fireEvent("promiseChained", this, P));
      var be = s();
      if (we & 50397184) {
        var _e, $e, Le = pe._settlePromiseCtx;
        we & 33554432 ? ($e = pe._rejectionHandler0, _e = j) : we & 16777216 ? ($e = pe._fulfillmentHandler0, _e = Q, pe._unsetRejectionIsUnhandled()) : (Le = pe._settlePromiseLateCancellationObserver, $e = new y("late cancellation observer"), pe._attachExtraTrace($e), _e = Q), f.invoke(Le, pe, {
          handler: be === null ? _e : typeof _e == "function" && a.domainBind(be, _e),
          promise: P,
          receiver: Z,
          value: $e
        });
      } else
        pe._addCallbacks(j, Q, P, Z, be);
      return P;
    }, M.prototype._length = function() {
      return this._bitField & 65535;
    }, M.prototype._isFateSealed = function() {
      return (this._bitField & 117506048) !== 0;
    }, M.prototype._isFollowing = function() {
      return (this._bitField & 67108864) === 67108864;
    }, M.prototype._setLength = function(j) {
      this._bitField = this._bitField & -65536 | j & 65535;
    }, M.prototype._setFulfilled = function() {
      this._bitField = this._bitField | 33554432, this._fireEvent("promiseFulfilled", this);
    }, M.prototype._setRejected = function() {
      this._bitField = this._bitField | 16777216, this._fireEvent("promiseRejected", this);
    }, M.prototype._setFollowing = function() {
      this._bitField = this._bitField | 67108864, this._fireEvent("promiseResolved", this);
    }, M.prototype._setIsFinal = function() {
      this._bitField = this._bitField | 4194304;
    }, M.prototype._isFinal = function() {
      return (this._bitField & 4194304) > 0;
    }, M.prototype._unsetCancelled = function() {
      this._bitField = this._bitField & -65537;
    }, M.prototype._setCancelled = function() {
      this._bitField = this._bitField | 65536, this._fireEvent("promiseCancelled", this);
    }, M.prototype._setWillBeCancelled = function() {
      this._bitField = this._bitField | 8388608;
    }, M.prototype._setAsyncGuaranteed = function() {
      f.hasCustomScheduler() || (this._bitField = this._bitField | 134217728);
    }, M.prototype._receiverAt = function(j) {
      var Q = j === 0 ? this._receiver0 : this[j * 4 - 4 + 3];
      if (Q !== o)
        return Q === void 0 && this._isBound() ? this._boundValue() : Q;
    }, M.prototype._promiseAt = function(j) {
      return this[j * 4 - 4 + 2];
    }, M.prototype._fulfillmentHandlerAt = function(j) {
      return this[j * 4 - 4 + 0];
    }, M.prototype._rejectionHandlerAt = function(j) {
      return this[j * 4 - 4 + 1];
    }, M.prototype._boundValue = function() {
    }, M.prototype._migrateCallback0 = function(j) {
      j._bitField;
      var Q = j._fulfillmentHandler0, G = j._rejectionHandler0, Z = j._promise0, re = j._receiverAt(0);
      re === void 0 && (re = o), this._addCallbacks(Q, G, Z, re, null);
    }, M.prototype._migrateCallbackAt = function(j, Q) {
      var G = j._fulfillmentHandlerAt(Q), Z = j._rejectionHandlerAt(Q), re = j._promiseAt(Q), V = j._receiverAt(Q);
      V === void 0 && (V = o), this._addCallbacks(G, Z, re, V, null);
    }, M.prototype._addCallbacks = function(j, Q, G, Z, re) {
      var V = this._length();
      if (V >= 65531 && (V = 0, this._setLength(0)), V === 0)
        this._promise0 = G, this._receiver0 = Z, typeof j == "function" && (this._fulfillmentHandler0 = re === null ? j : a.domainBind(re, j)), typeof Q == "function" && (this._rejectionHandler0 = re === null ? Q : a.domainBind(re, Q));
      else {
        var P = V * 4 - 4;
        this[P + 2] = G, this[P + 3] = Z, typeof j == "function" && (this[P + 0] = re === null ? j : a.domainBind(re, j)), typeof Q == "function" && (this[P + 1] = re === null ? Q : a.domainBind(re, Q));
      }
      return this._setLength(V + 1), V;
    }, M.prototype._proxy = function(j, Q) {
      this._addCallbacks(void 0, void 0, Q, j, null);
    }, M.prototype._resolveCallback = function(j, Q) {
      if (!(this._bitField & 117506048)) {
        if (j === this)
          return this._rejectCallback(e(), !1);
        var G = D(j, this);
        if (!(G instanceof M)) return this._fulfill(j);
        Q && this._propagateFrom(G, 2);
        var Z = G._target();
        if (Z === this) {
          this._reject(e());
          return;
        }
        var re = Z._bitField;
        if (re & 50397184)
          if (re & 33554432)
            this._fulfill(Z._value());
          else if (re & 16777216)
            this._reject(Z._reason());
          else {
            var pe = new y("late cancellation observer");
            Z._attachExtraTrace(pe), this._reject(pe);
          }
        else {
          var V = this._length();
          V > 0 && Z._migrateCallback0(this);
          for (var P = 1; P < V; ++P)
            Z._migrateCallbackAt(this, P);
          this._setFollowing(), this._setLength(0), this._setFollowee(Z);
        }
      }
    }, M.prototype._rejectCallback = function(j, Q, G) {
      var Z = a.ensureErrorObject(j), re = Z === j;
      if (!re && !G && R.warnings()) {
        var V = "a promise was rejected with a non-error: " + a.classString(j);
        this._warn(V, !0);
      }
      this._attachExtraTrace(Z, Q ? re : !1), this._reject(j);
    }, M.prototype._resolveFromExecutor = function(j) {
      var Q = this;
      this._captureStackTrace(), this._pushContext();
      var G = !0, Z = this._execute(j, function(re) {
        Q._resolveCallback(re);
      }, function(re) {
        Q._rejectCallback(re, G);
      });
      G = !1, this._popContext(), Z !== void 0 && Q._rejectCallback(Z, !0);
    }, M.prototype._settlePromiseFromHandler = function(j, Q, G, Z) {
      var re = Z._bitField;
      if (!(re & 65536)) {
        Z._pushContext();
        var V;
        Q === x ? !G || typeof G.length != "number" ? (V = $, V.e = new p("cannot .spread() a non-array: " + a.classString(G))) : V = le(j).apply(this._boundValue(), G) : V = le(j).call(Q, G);
        var P = Z._popContext();
        re = Z._bitField, !(re & 65536) && (V === v ? Z._reject(G) : V === $ ? Z._rejectCallback(V.e, !1) : (R.checkForgottenReturns(V, P, "", Z, this), Z._resolveCallback(V)));
      }
    }, M.prototype._target = function() {
      for (var j = this; j._isFollowing(); ) j = j._followee();
      return j;
    }, M.prototype._followee = function() {
      return this._rejectionHandler0;
    }, M.prototype._setFollowee = function(j) {
      this._rejectionHandler0 = j;
    }, M.prototype._settlePromise = function(j, Q, G, Z) {
      var re = j instanceof M, V = this._bitField, P = (V & 134217728) !== 0;
      V & 65536 ? (re && j._invokeInternalOnCancel(), G instanceof O && G.isFinallyHandler() ? (G.cancelPromise = j, le(Q).call(G, Z) === $ && j._reject($.e)) : Q === n ? j._fulfill(n.call(G)) : G instanceof i ? G._promiseCancelled(j) : re || j instanceof S ? j._cancel() : G.cancel()) : typeof Q == "function" ? re ? (P && j._setAsyncGuaranteed(), this._settlePromiseFromHandler(Q, G, Z, j)) : Q.call(G, Z, j) : G instanceof i ? G._isResolved() || (V & 33554432 ? G._promiseFulfilled(Z, j) : G._promiseRejected(Z, j)) : re && (P && j._setAsyncGuaranteed(), V & 33554432 ? j._fulfill(Z) : j._reject(Z));
    }, M.prototype._settlePromiseLateCancellationObserver = function(j) {
      var Q = j.handler, G = j.promise, Z = j.receiver, re = j.value;
      typeof Q == "function" ? G instanceof M ? this._settlePromiseFromHandler(Q, Z, re, G) : Q.call(Z, re, G) : G instanceof M && G._reject(re);
    }, M.prototype._settlePromiseCtx = function(j) {
      this._settlePromise(j.promise, j.handler, j.receiver, j.value);
    }, M.prototype._settlePromise0 = function(j, Q, G) {
      var Z = this._promise0, re = this._receiverAt(0);
      this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(Z, j, re, Q);
    }, M.prototype._clearCallbackDataAtIndex = function(j) {
      var Q = j * 4 - 4;
      this[Q + 2] = this[Q + 3] = this[Q + 0] = this[Q + 1] = void 0;
    }, M.prototype._fulfill = function(j) {
      var Q = this._bitField;
      if (!((Q & 117506048) >>> 16)) {
        if (j === this) {
          var G = e();
          return this._attachExtraTrace(G), this._reject(G);
        }
        this._setFulfilled(), this._rejectionHandler0 = j, (Q & 65535) > 0 && (Q & 134217728 ? this._settlePromises() : f.settlePromises(this));
      }
    }, M.prototype._reject = function(j) {
      var Q = this._bitField;
      if (!((Q & 117506048) >>> 16)) {
        if (this._setRejected(), this._fulfillmentHandler0 = j, this._isFinal())
          return f.fatalError(j, a.isNode);
        (Q & 65535) > 0 ? f.settlePromises(this) : this._ensurePossibleRejectionHandled();
      }
    }, M.prototype._fulfillPromises = function(j, Q) {
      for (var G = 1; G < j; G++) {
        var Z = this._fulfillmentHandlerAt(G), re = this._promiseAt(G), V = this._receiverAt(G);
        this._clearCallbackDataAtIndex(G), this._settlePromise(re, Z, V, Q);
      }
    }, M.prototype._rejectPromises = function(j, Q) {
      for (var G = 1; G < j; G++) {
        var Z = this._rejectionHandlerAt(G), re = this._promiseAt(G), V = this._receiverAt(G);
        this._clearCallbackDataAtIndex(G), this._settlePromise(re, Z, V, Q);
      }
    }, M.prototype._settlePromises = function() {
      var j = this._bitField, Q = j & 65535;
      if (Q > 0) {
        if (j & 16842752) {
          var G = this._fulfillmentHandler0;
          this._settlePromise0(this._rejectionHandler0, G, j), this._rejectPromises(Q, G);
        } else {
          var Z = this._rejectionHandler0;
          this._settlePromise0(this._fulfillmentHandler0, Z, j), this._fulfillPromises(Q, Z);
        }
        this._setLength(0);
      }
      this._clearCancellationData();
    }, M.prototype._settledValue = function() {
      var j = this._bitField;
      if (j & 33554432)
        return this._rejectionHandler0;
      if (j & 16777216)
        return this._fulfillmentHandler0;
    };
    function ee(j) {
      this.promise._resolveCallback(j);
    }
    function A(j) {
      this.promise._rejectCallback(j, !1);
    }
    M.defer = M.pending = function() {
      R.deprecated("Promise.defer", "new Promise");
      var j = new M(b);
      return {
        promise: j,
        resolve: ee,
        reject: A
      };
    }, a.notEnumerableProp(
      M,
      "_makeSelfResolutionError",
      e
    ), xH()(
      M,
      b,
      D,
      r,
      R
    ), DH()(M, b, D, R), wH()(M, S, r, R), SH()(M), TH()(M), CH()(
      M,
      S,
      D,
      b,
      f,
      s
    ), M.Promise = M, M.version = "3.4.7", EH()(M, S, r, D, b, R), _H()(M), kH()(M, r, D, I, b, R), AH()(M, b, R), UH()(M, r, b, D, i, R), FH()(M), RH()(M, b), OH()(M, S, D, r), IH()(M, b, D, r), BH()(M, S, r, D, b, R), MH()(M, S, R), NH()(M, S, r), PH()(M, b), WH()(M, b), LH()(M), a.toFastProperties(M), a.toFastProperties(M.prototype);
    function oe(j) {
      var Q = new M(b);
      Q._fulfillmentHandler0 = j, Q._rejectionHandler0 = j, Q._promise0 = j, Q._receiver0 = j;
    }
    return oe({ a: 1 }), oe({ b: 2 }), oe({ c: 3 }), oe(1), oe(function() {
    }), oe(void 0), oe(!1), oe(new M(b)), R.setBounds(u.firstLineError, a.lastLineError), M;
  };
})($F);
var zH = $F.exports, $H = $t, hr = zH();
rn.defer = jH;
rn.when = hr.resolve;
rn.resolve = hr.resolve;
rn.all = hr.all;
rn.props = hr.props;
rn.reject = hr.reject;
rn.promisify = hr.promisify;
rn.mapSeries = hr.mapSeries;
rn.attempt = hr.attempt;
rn.nfcall = function(t) {
  var e = Array.prototype.slice.call(arguments, 1), n = hr.promisify(t);
  return n.apply(null, e);
};
hr.prototype.fail = hr.prototype.caught;
hr.prototype.also = function(t) {
  return this.then(function(e) {
    var n = $H.extend({}, e, t(e));
    return hr.props(n);
  });
};
function jH() {
  var t, e, n = new hr.Promise(function(r, i) {
    t = r, e = i;
  });
  return {
    resolve: t,
    reject: e,
    promise: n
  };
}
var ut = {}, HH = $t, vn = ut.types = {
  document: "document",
  paragraph: "paragraph",
  run: "run",
  text: "text",
  tab: "tab",
  checkbox: "checkbox",
  hyperlink: "hyperlink",
  noteReference: "noteReference",
  image: "image",
  note: "note",
  commentReference: "commentReference",
  comment: "comment",
  table: "table",
  tableRow: "tableRow",
  tableCell: "tableCell",
  break: "break",
  bookmarkStart: "bookmarkStart"
};
function VH(t, e) {
  return e = e || {}, {
    type: vn.document,
    children: t,
    notes: e.notes || new Lm({}),
    comments: e.comments || []
  };
}
function qH(t, e) {
  e = e || {};
  var n = e.indent || {};
  return {
    type: vn.paragraph,
    children: t,
    styleId: e.styleId || null,
    styleName: e.styleName || null,
    numbering: e.numbering || null,
    alignment: e.alignment || null,
    indent: {
      start: n.start || null,
      end: n.end || null,
      firstLine: n.firstLine || null,
      hanging: n.hanging || null
    }
  };
}
function XH(t, e) {
  return e = e || {}, {
    type: vn.run,
    children: t,
    styleId: e.styleId || null,
    styleName: e.styleName || null,
    isBold: !!e.isBold,
    isUnderline: !!e.isUnderline,
    isItalic: !!e.isItalic,
    isStrikethrough: !!e.isStrikethrough,
    isAllCaps: !!e.isAllCaps,
    isSmallCaps: !!e.isSmallCaps,
    verticalAlignment: e.verticalAlignment || HF.baseline,
    font: e.font || null,
    fontSize: e.fontSize || null,
    highlight: e.highlight || null
  };
}
var HF = {
  baseline: "baseline",
  superscript: "superscript",
  subscript: "subscript"
};
function GH(t) {
  return {
    type: vn.text,
    value: t
  };
}
function JH() {
  return {
    type: vn.tab
  };
}
function YH(t) {
  return {
    type: vn.checkbox,
    checked: t.checked
  };
}
function ZH(t, e) {
  return {
    type: vn.hyperlink,
    children: t,
    href: e.href,
    anchor: e.anchor,
    targetFrame: e.targetFrame
  };
}
function KH(t) {
  return {
    type: vn.noteReference,
    noteType: t.noteType,
    noteId: t.noteId
  };
}
function Lm(t) {
  this._notes = HH.indexBy(t, function(e) {
    return VF(e.noteType, e.noteId);
  });
}
Lm.prototype.resolve = function(t) {
  return this.findNoteByKey(VF(t.noteType, t.noteId));
};
Lm.prototype.findNoteByKey = function(t) {
  return this._notes[t] || null;
};
function QH(t) {
  return {
    type: vn.note,
    noteType: t.noteType,
    noteId: t.noteId,
    body: t.body
  };
}
function eV(t) {
  return {
    type: vn.commentReference,
    commentId: t.commentId
  };
}
function tV(t) {
  return {
    type: vn.comment,
    commentId: t.commentId,
    body: t.body,
    authorName: t.authorName,
    authorInitials: t.authorInitials
  };
}
function VF(t, e) {
  return t + "-" + e;
}
function nV(t) {
  return {
    type: vn.image,
    // `read` is retained for backwards compatibility, but other read
    // methods should be preferred.
    read: function(e) {
      return e ? t.readImage(e) : t.readImage().then(function(n) {
        return Buffer.from(n);
      });
    },
    readAsArrayBuffer: function() {
      return t.readImage();
    },
    readAsBase64String: function() {
      return t.readImage("base64");
    },
    readAsBuffer: function() {
      return t.readImage().then(function(e) {
        return Buffer.from(e);
      });
    },
    altText: t.altText,
    contentType: t.contentType
  };
}
function rV(t, e) {
  return e = e || {}, {
    type: vn.table,
    children: t,
    styleId: e.styleId || null,
    styleName: e.styleName || null
  };
}
function iV(t, e) {
  return e = e || {}, {
    type: vn.tableRow,
    children: t,
    isHeader: e.isHeader || !1
  };
}
function oV(t, e) {
  return e = e || {}, {
    type: vn.tableCell,
    children: t,
    colSpan: e.colSpan == null ? 1 : e.colSpan,
    rowSpan: e.rowSpan == null ? 1 : e.rowSpan
  };
}
function Nx(t) {
  return {
    type: vn.break,
    breakType: t
  };
}
function aV(t) {
  return {
    type: vn.bookmarkStart,
    name: t.name
  };
}
ut.document = ut.Document = VH;
ut.paragraph = ut.Paragraph = qH;
ut.run = ut.Run = XH;
ut.text = ut.Text = GH;
ut.tab = ut.Tab = JH;
ut.checkbox = ut.Checkbox = YH;
ut.Hyperlink = ZH;
ut.noteReference = ut.NoteReference = KH;
ut.Notes = Lm;
ut.Note = QH;
ut.commentReference = eV;
ut.comment = tV;
ut.Image = nV;
ut.Table = rV;
ut.TableRow = iV;
ut.TableCell = oV;
ut.lineBreak = Nx("line");
ut.pageBreak = Nx("page");
ut.columnBreak = Nx("column");
ut.BookmarkStart = aV;
ut.verticalAlignment = HF;
var Ar = {}, Id = $t;
Ar.Result = Ki;
Ar.success = sV;
Ar.warning = lV;
Ar.error = cV;
function Ki(t, e) {
  this.value = t, this.messages = e || [];
}
Ki.prototype.map = function(t) {
  return new Ki(t(this.value), this.messages);
};
Ki.prototype.flatMap = function(t) {
  var e = t(this.value);
  return new Ki(e.value, Px([this, e]));
};
Ki.prototype.flatMapThen = function(t) {
  var e = this;
  return t(this.value).then(function(n) {
    return new Ki(n.value, Px([e, n]));
  });
};
Ki.combine = function(t) {
  var e = Id.flatten(Id.pluck(t, "value")), n = Px(t);
  return new Ki(e, n);
};
function sV(t) {
  return new Ki(t, []);
}
function lV(t) {
  return {
    type: "warning",
    message: t
  };
}
function cV(t) {
  return {
    type: "error",
    message: t.message,
    error: t
  };
}
function Px(t) {
  var e = [];
  return Id.flatten(Id.pluck(t, "messages"), !0).forEach(function(n) {
    uV(e, n) || e.push(n);
  }), e;
}
function uV(t, e) {
  return Id.find(t, fV.bind(null, e)) !== void 0;
}
function fV(t, e) {
  return t.type === e.type && t.message === e.message;
}
var Zd = {}, zm = {};
zm.byteLength = pV;
zm.toByteArray = mV;
zm.fromByteArray = vV;
var $i = [], qr = [], dV = typeof Uint8Array < "u" ? Uint8Array : Array, Yv = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Uc = 0, hV = Yv.length; Uc < hV; ++Uc)
  $i[Uc] = Yv[Uc], qr[Yv.charCodeAt(Uc)] = Uc;
qr[45] = 62;
qr[95] = 63;
function qF(t) {
  var e = t.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = t.indexOf("=");
  n === -1 && (n = e);
  var r = n === e ? 0 : 4 - n % 4;
  return [n, r];
}
function pV(t) {
  var e = qF(t), n = e[0], r = e[1];
  return (n + r) * 3 / 4 - r;
}
function gV(t, e, n) {
  return (e + n) * 3 / 4 - n;
}
function mV(t) {
  var e, n = qF(t), r = n[0], i = n[1], o = new dV(gV(t, r, i)), a = 0, s = i > 0 ? r - 4 : r, l;
  for (l = 0; l < s; l += 4)
    e = qr[t.charCodeAt(l)] << 18 | qr[t.charCodeAt(l + 1)] << 12 | qr[t.charCodeAt(l + 2)] << 6 | qr[t.charCodeAt(l + 3)], o[a++] = e >> 16 & 255, o[a++] = e >> 8 & 255, o[a++] = e & 255;
  return i === 2 && (e = qr[t.charCodeAt(l)] << 2 | qr[t.charCodeAt(l + 1)] >> 4, o[a++] = e & 255), i === 1 && (e = qr[t.charCodeAt(l)] << 10 | qr[t.charCodeAt(l + 1)] << 4 | qr[t.charCodeAt(l + 2)] >> 2, o[a++] = e >> 8 & 255, o[a++] = e & 255), o;
}
function yV(t) {
  return $i[t >> 18 & 63] + $i[t >> 12 & 63] + $i[t >> 6 & 63] + $i[t & 63];
}
function bV(t, e, n) {
  for (var r, i = [], o = e; o < n; o += 3)
    r = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (t[o + 2] & 255), i.push(yV(r));
  return i.join("");
}
function vV(t) {
  for (var e, n = t.length, r = n % 3, i = [], o = 16383, a = 0, s = n - r; a < s; a += o)
    i.push(bV(t, a, a + o > s ? s : a + o));
  return r === 1 ? (e = t[n - 1], i.push(
    $i[e >> 2] + $i[e << 4 & 63] + "=="
  )) : r === 2 && (e = (t[n - 2] << 8) + t[n - 1], i.push(
    $i[e >> 10] + $i[e >> 4 & 63] + $i[e << 2 & 63] + "="
  )), i.join("");
}
function cp(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var XF = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(t, e) {
  (function(n) {
    t.exports = n();
  })(function() {
    return function n(r, i, o) {
      function a(u, f) {
        if (!i[u]) {
          if (!r[u]) {
            var h = typeof cp == "function" && cp;
            if (!f && h) return h(u, !0);
            if (s) return s(u, !0);
            var p = new Error("Cannot find module '" + u + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var y = i[u] = { exports: {} };
          r[u][0].call(y.exports, function(b) {
            var x = r[u][1][b];
            return a(x || b);
          }, y, y.exports, n, r, i, o);
        }
        return i[u].exports;
      }
      for (var s = typeof cp == "function" && cp, l = 0; l < o.length; l++) a(o[l]);
      return a;
    }({ 1: [function(n, r, i) {
      var o = n("./utils"), a = n("./support"), s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      i.encode = function(l) {
        for (var u, f, h, p, y, b, x, v = [], D = 0, S = l.length, E = S, I = o.getTypeOf(l) !== "string"; D < l.length; ) E = S - D, h = I ? (u = l[D++], f = D < S ? l[D++] : 0, D < S ? l[D++] : 0) : (u = l.charCodeAt(D++), f = D < S ? l.charCodeAt(D++) : 0, D < S ? l.charCodeAt(D++) : 0), p = u >> 2, y = (3 & u) << 4 | f >> 4, b = 1 < E ? (15 & f) << 2 | h >> 6 : 64, x = 2 < E ? 63 & h : 64, v.push(s.charAt(p) + s.charAt(y) + s.charAt(b) + s.charAt(x));
        return v.join("");
      }, i.decode = function(l) {
        var u, f, h, p, y, b, x = 0, v = 0, D = "data:";
        if (l.substr(0, D.length) === D) throw new Error("Invalid base64 input, it looks like a data url.");
        var S, E = 3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (l.charAt(l.length - 1) === s.charAt(64) && E--, l.charAt(l.length - 2) === s.charAt(64) && E--, E % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (S = a.uint8array ? new Uint8Array(0 | E) : new Array(0 | E); x < l.length; ) u = s.indexOf(l.charAt(x++)) << 2 | (p = s.indexOf(l.charAt(x++))) >> 4, f = (15 & p) << 4 | (y = s.indexOf(l.charAt(x++))) >> 2, h = (3 & y) << 6 | (b = s.indexOf(l.charAt(x++))), S[v++] = u, y !== 64 && (S[v++] = f), b !== 64 && (S[v++] = h);
        return S;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(n, r, i) {
      var o = n("./external"), a = n("./stream/DataWorker"), s = n("./stream/Crc32Probe"), l = n("./stream/DataLengthProbe");
      function u(f, h, p, y, b) {
        this.compressedSize = f, this.uncompressedSize = h, this.crc32 = p, this.compression = y, this.compressedContent = b;
      }
      u.prototype = { getContentWorker: function() {
        var f = new a(o.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), h = this;
        return f.on("end", function() {
          if (this.streamInfo.data_length !== h.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), f;
      }, getCompressedWorker: function() {
        return new a(o.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, u.createWorkerFrom = function(f, h, p) {
        return f.pipe(new s()).pipe(new l("uncompressedSize")).pipe(h.compressWorker(p)).pipe(new l("compressedSize")).withStreamInfo("compression", h);
      }, r.exports = u;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(n, r, i) {
      var o = n("./stream/GenericWorker");
      i.STORE = { magic: "\0\0", compressWorker: function() {
        return new o("STORE compression");
      }, uncompressWorker: function() {
        return new o("STORE decompression");
      } }, i.DEFLATE = n("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(n, r, i) {
      var o = n("./utils"), a = function() {
        for (var s, l = [], u = 0; u < 256; u++) {
          s = u;
          for (var f = 0; f < 8; f++) s = 1 & s ? 3988292384 ^ s >>> 1 : s >>> 1;
          l[u] = s;
        }
        return l;
      }();
      r.exports = function(s, l) {
        return s !== void 0 && s.length ? o.getTypeOf(s) !== "string" ? function(u, f, h, p) {
          var y = a, b = p + h;
          u ^= -1;
          for (var x = p; x < b; x++) u = u >>> 8 ^ y[255 & (u ^ f[x])];
          return -1 ^ u;
        }(0 | l, s, s.length, 0) : function(u, f, h, p) {
          var y = a, b = p + h;
          u ^= -1;
          for (var x = p; x < b; x++) u = u >>> 8 ^ y[255 & (u ^ f.charCodeAt(x))];
          return -1 ^ u;
        }(0 | l, s, s.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(n, r, i) {
      i.base64 = !1, i.binary = !1, i.dir = !1, i.createFolders = !0, i.date = null, i.compression = null, i.compressionOptions = null, i.comment = null, i.unixPermissions = null, i.dosPermissions = null;
    }, {}], 6: [function(n, r, i) {
      var o = null;
      o = typeof Promise < "u" ? Promise : n("lie"), r.exports = { Promise: o };
    }, { lie: 37 }], 7: [function(n, r, i) {
      var o = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", a = n("pako"), s = n("./utils"), l = n("./stream/GenericWorker"), u = o ? "uint8array" : "array";
      function f(h, p) {
        l.call(this, "FlateWorker/" + h), this._pako = null, this._pakoAction = h, this._pakoOptions = p, this.meta = {};
      }
      i.magic = "\b\0", s.inherits(f, l), f.prototype.processChunk = function(h) {
        this.meta = h.meta, this._pako === null && this._createPako(), this._pako.push(s.transformTo(u, h.data), !1);
      }, f.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, f.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, f.prototype._createPako = function() {
        this._pako = new a[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var h = this;
        this._pako.onData = function(p) {
          h.push({ data: p, meta: h.meta });
        };
      }, i.compressWorker = function(h) {
        return new f("Deflate", h);
      }, i.uncompressWorker = function() {
        return new f("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(n, r, i) {
      function o(y, b) {
        var x, v = "";
        for (x = 0; x < b; x++) v += String.fromCharCode(255 & y), y >>>= 8;
        return v;
      }
      function a(y, b, x, v, D, S) {
        var E, I, R = y.file, O = y.compression, N = S !== u.utf8encode, q = s.transformTo("string", S(R.name)), $ = s.transformTo("string", u.utf8encode(R.name)), le = R.comment, ve = s.transformTo("string", S(le)), M = s.transformTo("string", u.utf8encode(le)), ee = $.length !== R.name.length, A = M.length !== le.length, oe = "", j = "", Q = "", G = R.dir, Z = R.date, re = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        b && !x || (re.crc32 = y.crc32, re.compressedSize = y.compressedSize, re.uncompressedSize = y.uncompressedSize);
        var V = 0;
        b && (V |= 8), N || !ee && !A || (V |= 2048);
        var P = 0, pe = 0;
        G && (P |= 16), D === "UNIX" ? (pe = 798, P |= function(be, _e) {
          var $e = be;
          return be || ($e = _e ? 16893 : 33204), (65535 & $e) << 16;
        }(R.unixPermissions, G)) : (pe = 20, P |= function(be) {
          return 63 & (be || 0);
        }(R.dosPermissions)), E = Z.getUTCHours(), E <<= 6, E |= Z.getUTCMinutes(), E <<= 5, E |= Z.getUTCSeconds() / 2, I = Z.getUTCFullYear() - 1980, I <<= 4, I |= Z.getUTCMonth() + 1, I <<= 5, I |= Z.getUTCDate(), ee && (j = o(1, 1) + o(f(q), 4) + $, oe += "up" + o(j.length, 2) + j), A && (Q = o(1, 1) + o(f(ve), 4) + M, oe += "uc" + o(Q.length, 2) + Q);
        var we = "";
        return we += `
\0`, we += o(V, 2), we += O.magic, we += o(E, 2), we += o(I, 2), we += o(re.crc32, 4), we += o(re.compressedSize, 4), we += o(re.uncompressedSize, 4), we += o(q.length, 2), we += o(oe.length, 2), { fileRecord: h.LOCAL_FILE_HEADER + we + q + oe, dirRecord: h.CENTRAL_FILE_HEADER + o(pe, 2) + we + o(ve.length, 2) + "\0\0\0\0" + o(P, 4) + o(v, 4) + q + oe + ve };
      }
      var s = n("../utils"), l = n("../stream/GenericWorker"), u = n("../utf8"), f = n("../crc32"), h = n("../signature");
      function p(y, b, x, v) {
        l.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = b, this.zipPlatform = x, this.encodeFileName = v, this.streamFiles = y, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      s.inherits(p, l), p.prototype.push = function(y) {
        var b = y.meta.percent || 0, x = this.entriesCount, v = this._sources.length;
        this.accumulate ? this.contentBuffer.push(y) : (this.bytesWritten += y.data.length, l.prototype.push.call(this, { data: y.data, meta: { currentFile: this.currentFile, percent: x ? (b + 100 * (x - v - 1)) / x : 100 } }));
      }, p.prototype.openedSource = function(y) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = y.file.name;
        var b = this.streamFiles && !y.file.dir;
        if (b) {
          var x = a(y, b, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: x.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, p.prototype.closedSource = function(y) {
        this.accumulate = !1;
        var b = this.streamFiles && !y.file.dir, x = a(y, b, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(x.dirRecord), b) this.push({ data: function(v) {
          return h.DATA_DESCRIPTOR + o(v.crc32, 4) + o(v.compressedSize, 4) + o(v.uncompressedSize, 4);
        }(y), meta: { percent: 100 } });
        else for (this.push({ data: x.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var y = this.bytesWritten, b = 0; b < this.dirRecords.length; b++) this.push({ data: this.dirRecords[b], meta: { percent: 100 } });
        var x = this.bytesWritten - y, v = function(D, S, E, I, R) {
          var O = s.transformTo("string", R(I));
          return h.CENTRAL_DIRECTORY_END + "\0\0\0\0" + o(D, 2) + o(D, 2) + o(S, 4) + o(E, 4) + o(O.length, 2) + O;
        }(this.dirRecords.length, x, y, this.zipComment, this.encodeFileName);
        this.push({ data: v, meta: { percent: 100 } });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(y) {
        this._sources.push(y);
        var b = this;
        return y.on("data", function(x) {
          b.processChunk(x);
        }), y.on("end", function() {
          b.closedSource(b.previous.streamInfo), b._sources.length ? b.prepareNextSource() : b.end();
        }), y.on("error", function(x) {
          b.error(x);
        }), this;
      }, p.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, p.prototype.error = function(y) {
        var b = this._sources;
        if (!l.prototype.error.call(this, y)) return !1;
        for (var x = 0; x < b.length; x++) try {
          b[x].error(y);
        } catch {
        }
        return !0;
      }, p.prototype.lock = function() {
        l.prototype.lock.call(this);
        for (var y = this._sources, b = 0; b < y.length; b++) y[b].lock();
      }, r.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(n, r, i) {
      var o = n("../compressions"), a = n("./ZipFileWorker");
      i.generateWorker = function(s, l, u) {
        var f = new a(l.streamFiles, u, l.platform, l.encodeFileName), h = 0;
        try {
          s.forEach(function(p, y) {
            h++;
            var b = function(S, E) {
              var I = S || E, R = o[I];
              if (!R) throw new Error(I + " is not a valid compression method !");
              return R;
            }(y.options.compression, l.compression), x = y.options.compressionOptions || l.compressionOptions || {}, v = y.dir, D = y.date;
            y._compressWorker(b, x).withStreamInfo("file", { name: p, dir: v, date: D, comment: y.comment || "", unixPermissions: y.unixPermissions, dosPermissions: y.dosPermissions }).pipe(f);
          }), f.entriesCount = h;
        } catch (p) {
          f.error(p);
        }
        return f;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(n, r, i) {
      function o() {
        if (!(this instanceof o)) return new o();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var a = new o();
          for (var s in this) typeof this[s] != "function" && (a[s] = this[s]);
          return a;
        };
      }
      (o.prototype = n("./object")).loadAsync = n("./load"), o.support = n("./support"), o.defaults = n("./defaults"), o.version = "3.10.1", o.loadAsync = function(a, s) {
        return new o().loadAsync(a, s);
      }, o.external = n("./external"), r.exports = o;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(n, r, i) {
      var o = n("./utils"), a = n("./external"), s = n("./utf8"), l = n("./zipEntries"), u = n("./stream/Crc32Probe"), f = n("./nodejsUtils");
      function h(p) {
        return new a.Promise(function(y, b) {
          var x = p.decompressed.getContentWorker().pipe(new u());
          x.on("error", function(v) {
            b(v);
          }).on("end", function() {
            x.streamInfo.crc32 !== p.decompressed.crc32 ? b(new Error("Corrupted zip : CRC32 mismatch")) : y();
          }).resume();
        });
      }
      r.exports = function(p, y) {
        var b = this;
        return y = o.extend(y || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: s.utf8decode }), f.isNode && f.isStream(p) ? a.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : o.prepareContent("the loaded zip file", p, !0, y.optimizedBinaryString, y.base64).then(function(x) {
          var v = new l(y);
          return v.load(x), v;
        }).then(function(x) {
          var v = [a.Promise.resolve(x)], D = x.files;
          if (y.checkCRC32) for (var S = 0; S < D.length; S++) v.push(h(D[S]));
          return a.Promise.all(v);
        }).then(function(x) {
          for (var v = x.shift(), D = v.files, S = 0; S < D.length; S++) {
            var E = D[S], I = E.fileNameStr, R = o.resolve(E.fileNameStr);
            b.file(R, E.decompressed, { binary: !0, optimizedBinaryString: !0, date: E.date, dir: E.dir, comment: E.fileCommentStr.length ? E.fileCommentStr : null, unixPermissions: E.unixPermissions, dosPermissions: E.dosPermissions, createFolders: y.createFolders }), E.dir || (b.file(R).unsafeOriginalName = I);
          }
          return v.zipComment.length && (b.comment = v.zipComment), b;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(n, r, i) {
      var o = n("../utils"), a = n("../stream/GenericWorker");
      function s(l, u) {
        a.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(u);
      }
      o.inherits(s, a), s.prototype._bindStream = function(l) {
        var u = this;
        (this._stream = l).pause(), l.on("data", function(f) {
          u.push({ data: f, meta: { percent: 0 } });
        }).on("error", function(f) {
          u.isPaused ? this.generatedError = f : u.error(f);
        }).on("end", function() {
          u.isPaused ? u._upstreamEnded = !0 : u.end();
        });
      }, s.prototype.pause = function() {
        return !!a.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, s.prototype.resume = function() {
        return !!a.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, r.exports = s;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(n, r, i) {
      var o = n("readable-stream").Readable;
      function a(s, l, u) {
        o.call(this, l), this._helper = s;
        var f = this;
        s.on("data", function(h, p) {
          f.push(h) || f._helper.pause(), u && u(p);
        }).on("error", function(h) {
          f.emit("error", h);
        }).on("end", function() {
          f.push(null);
        });
      }
      n("../utils").inherits(a, o), a.prototype._read = function() {
        this._helper.resume();
      }, r.exports = a;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(n, r, i) {
      r.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(o, a) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(o, a);
        if (typeof o == "number") throw new Error('The "data" argument must not be a number');
        return new Buffer(o, a);
      }, allocBuffer: function(o) {
        if (Buffer.alloc) return Buffer.alloc(o);
        var a = new Buffer(o);
        return a.fill(0), a;
      }, isBuffer: function(o) {
        return Buffer.isBuffer(o);
      }, isStream: function(o) {
        return o && typeof o.on == "function" && typeof o.pause == "function" && typeof o.resume == "function";
      } };
    }, {}], 15: [function(n, r, i) {
      function o(R, O, N) {
        var q, $ = s.getTypeOf(O), le = s.extend(N || {}, f);
        le.date = le.date || /* @__PURE__ */ new Date(), le.compression !== null && (le.compression = le.compression.toUpperCase()), typeof le.unixPermissions == "string" && (le.unixPermissions = parseInt(le.unixPermissions, 8)), le.unixPermissions && 16384 & le.unixPermissions && (le.dir = !0), le.dosPermissions && 16 & le.dosPermissions && (le.dir = !0), le.dir && (R = D(R)), le.createFolders && (q = v(R)) && S.call(this, q, !0);
        var ve = $ === "string" && le.binary === !1 && le.base64 === !1;
        N && N.binary !== void 0 || (le.binary = !ve), (O instanceof h && O.uncompressedSize === 0 || le.dir || !O || O.length === 0) && (le.base64 = !1, le.binary = !0, O = "", le.compression = "STORE", $ = "string");
        var M = null;
        M = O instanceof h || O instanceof l ? O : b.isNode && b.isStream(O) ? new x(R, O) : s.prepareContent(R, O, le.binary, le.optimizedBinaryString, le.base64);
        var ee = new p(R, M, le);
        this.files[R] = ee;
      }
      var a = n("./utf8"), s = n("./utils"), l = n("./stream/GenericWorker"), u = n("./stream/StreamHelper"), f = n("./defaults"), h = n("./compressedObject"), p = n("./zipObject"), y = n("./generate"), b = n("./nodejsUtils"), x = n("./nodejs/NodejsStreamInputAdapter"), v = function(R) {
        R.slice(-1) === "/" && (R = R.substring(0, R.length - 1));
        var O = R.lastIndexOf("/");
        return 0 < O ? R.substring(0, O) : "";
      }, D = function(R) {
        return R.slice(-1) !== "/" && (R += "/"), R;
      }, S = function(R, O) {
        return O = O !== void 0 ? O : f.createFolders, R = D(R), this.files[R] || o.call(this, R, null, { dir: !0, createFolders: O }), this.files[R];
      };
      function E(R) {
        return Object.prototype.toString.call(R) === "[object RegExp]";
      }
      var I = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(R) {
        var O, N, q;
        for (O in this.files) q = this.files[O], (N = O.slice(this.root.length, O.length)) && O.slice(0, this.root.length) === this.root && R(N, q);
      }, filter: function(R) {
        var O = [];
        return this.forEach(function(N, q) {
          R(N, q) && O.push(q);
        }), O;
      }, file: function(R, O, N) {
        if (arguments.length !== 1) return R = this.root + R, o.call(this, R, O, N), this;
        if (E(R)) {
          var q = R;
          return this.filter(function(le, ve) {
            return !ve.dir && q.test(le);
          });
        }
        var $ = this.files[this.root + R];
        return $ && !$.dir ? $ : null;
      }, folder: function(R) {
        if (!R) return this;
        if (E(R)) return this.filter(function($, le) {
          return le.dir && R.test($);
        });
        var O = this.root + R, N = S.call(this, O), q = this.clone();
        return q.root = N.name, q;
      }, remove: function(R) {
        R = this.root + R;
        var O = this.files[R];
        if (O || (R.slice(-1) !== "/" && (R += "/"), O = this.files[R]), O && !O.dir) delete this.files[R];
        else for (var N = this.filter(function($, le) {
          return le.name.slice(0, R.length) === R;
        }), q = 0; q < N.length; q++) delete this.files[N[q].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(R) {
        var O, N = {};
        try {
          if ((N = s.extend(R || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: a.utf8encode })).type = N.type.toLowerCase(), N.compression = N.compression.toUpperCase(), N.type === "binarystring" && (N.type = "string"), !N.type) throw new Error("No output type specified.");
          s.checkSupport(N.type), N.platform !== "darwin" && N.platform !== "freebsd" && N.platform !== "linux" && N.platform !== "sunos" || (N.platform = "UNIX"), N.platform === "win32" && (N.platform = "DOS");
          var q = N.comment || this.comment || "";
          O = y.generateWorker(this, N, q);
        } catch ($) {
          (O = new l("error")).error($);
        }
        return new u(O, N.type || "string", N.mimeType);
      }, generateAsync: function(R, O) {
        return this.generateInternalStream(R).accumulate(O);
      }, generateNodeStream: function(R, O) {
        return (R = R || {}).type || (R.type = "nodebuffer"), this.generateInternalStream(R).toNodejsStream(O);
      } };
      r.exports = I;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(n, r, i) {
      r.exports = n("stream");
    }, { stream: void 0 }], 17: [function(n, r, i) {
      var o = n("./DataReader");
      function a(s) {
        o.call(this, s);
        for (var l = 0; l < this.data.length; l++) s[l] = 255 & s[l];
      }
      n("../utils").inherits(a, o), a.prototype.byteAt = function(s) {
        return this.data[this.zero + s];
      }, a.prototype.lastIndexOfSignature = function(s) {
        for (var l = s.charCodeAt(0), u = s.charCodeAt(1), f = s.charCodeAt(2), h = s.charCodeAt(3), p = this.length - 4; 0 <= p; --p) if (this.data[p] === l && this.data[p + 1] === u && this.data[p + 2] === f && this.data[p + 3] === h) return p - this.zero;
        return -1;
      }, a.prototype.readAndCheckSignature = function(s) {
        var l = s.charCodeAt(0), u = s.charCodeAt(1), f = s.charCodeAt(2), h = s.charCodeAt(3), p = this.readData(4);
        return l === p[0] && u === p[1] && f === p[2] && h === p[3];
      }, a.prototype.readData = function(s) {
        if (this.checkOffset(s), s === 0) return [];
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + s);
        return this.index += s, l;
      }, r.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(n, r, i) {
      var o = n("../utils");
      function a(s) {
        this.data = s, this.length = s.length, this.index = 0, this.zero = 0;
      }
      a.prototype = { checkOffset: function(s) {
        this.checkIndex(this.index + s);
      }, checkIndex: function(s) {
        if (this.length < this.zero + s || s < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + s + "). Corrupted zip ?");
      }, setIndex: function(s) {
        this.checkIndex(s), this.index = s;
      }, skip: function(s) {
        this.setIndex(this.index + s);
      }, byteAt: function() {
      }, readInt: function(s) {
        var l, u = 0;
        for (this.checkOffset(s), l = this.index + s - 1; l >= this.index; l--) u = (u << 8) + this.byteAt(l);
        return this.index += s, u;
      }, readString: function(s) {
        return o.transformTo("string", this.readData(s));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var s = this.readInt(4);
        return new Date(Date.UTC(1980 + (s >> 25 & 127), (s >> 21 & 15) - 1, s >> 16 & 31, s >> 11 & 31, s >> 5 & 63, (31 & s) << 1));
      } }, r.exports = a;
    }, { "../utils": 32 }], 19: [function(n, r, i) {
      var o = n("./Uint8ArrayReader");
      function a(s) {
        o.call(this, s);
      }
      n("../utils").inherits(a, o), a.prototype.readData = function(s) {
        this.checkOffset(s);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + s);
        return this.index += s, l;
      }, r.exports = a;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(n, r, i) {
      var o = n("./DataReader");
      function a(s) {
        o.call(this, s);
      }
      n("../utils").inherits(a, o), a.prototype.byteAt = function(s) {
        return this.data.charCodeAt(this.zero + s);
      }, a.prototype.lastIndexOfSignature = function(s) {
        return this.data.lastIndexOf(s) - this.zero;
      }, a.prototype.readAndCheckSignature = function(s) {
        return s === this.readData(4);
      }, a.prototype.readData = function(s) {
        this.checkOffset(s);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + s);
        return this.index += s, l;
      }, r.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(n, r, i) {
      var o = n("./ArrayReader");
      function a(s) {
        o.call(this, s);
      }
      n("../utils").inherits(a, o), a.prototype.readData = function(s) {
        if (this.checkOffset(s), s === 0) return new Uint8Array(0);
        var l = this.data.subarray(this.zero + this.index, this.zero + this.index + s);
        return this.index += s, l;
      }, r.exports = a;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(n, r, i) {
      var o = n("../utils"), a = n("../support"), s = n("./ArrayReader"), l = n("./StringReader"), u = n("./NodeBufferReader"), f = n("./Uint8ArrayReader");
      r.exports = function(h) {
        var p = o.getTypeOf(h);
        return o.checkSupport(p), p !== "string" || a.uint8array ? p === "nodebuffer" ? new u(h) : a.uint8array ? new f(o.transformTo("uint8array", h)) : new s(o.transformTo("array", h)) : new l(h);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(n, r, i) {
      i.LOCAL_FILE_HEADER = "PK", i.CENTRAL_FILE_HEADER = "PK", i.CENTRAL_DIRECTORY_END = "PK", i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", i.ZIP64_CENTRAL_DIRECTORY_END = "PK", i.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(n, r, i) {
      var o = n("./GenericWorker"), a = n("../utils");
      function s(l) {
        o.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      a.inherits(s, o), s.prototype.processChunk = function(l) {
        this.push({ data: a.transformTo(this.destType, l.data), meta: l.meta });
      }, r.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(n, r, i) {
      var o = n("./GenericWorker"), a = n("../crc32");
      function s() {
        o.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      n("../utils").inherits(s, o), s.prototype.processChunk = function(l) {
        this.streamInfo.crc32 = a(l.data, this.streamInfo.crc32 || 0), this.push(l);
      }, r.exports = s;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(n, r, i) {
      var o = n("../utils"), a = n("./GenericWorker");
      function s(l) {
        a.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      o.inherits(s, a), s.prototype.processChunk = function(l) {
        if (l) {
          var u = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = u + l.data.length;
        }
        a.prototype.processChunk.call(this, l);
      }, r.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(n, r, i) {
      var o = n("../utils"), a = n("./GenericWorker");
      function s(l) {
        a.call(this, "DataWorker");
        var u = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, l.then(function(f) {
          u.dataIsReady = !0, u.data = f, u.max = f && f.length || 0, u.type = o.getTypeOf(f), u.isPaused || u._tickAndRepeat();
        }, function(f) {
          u.error(f);
        });
      }
      o.inherits(s, a), s.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this.data = null;
      }, s.prototype.resume = function() {
        return !!a.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, o.delay(this._tickAndRepeat, [], this)), !0);
      }, s.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (o.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, s.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var l = null, u = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            l = this.data.substring(this.index, u);
            break;
          case "uint8array":
            l = this.data.subarray(this.index, u);
            break;
          case "array":
          case "nodebuffer":
            l = this.data.slice(this.index, u);
        }
        return this.index = u, this.push({ data: l, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, r.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(n, r, i) {
      function o(a) {
        this.name = a || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      o.prototype = { push: function(a) {
        this.emit("data", a);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (a) {
          this.emit("error", a);
        }
        return !0;
      }, error: function(a) {
        return !this.isFinished && (this.isPaused ? this.generatedError = a : (this.isFinished = !0, this.emit("error", a), this.previous && this.previous.error(a), this.cleanUp()), !0);
      }, on: function(a, s) {
        return this._listeners[a].push(s), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(a, s) {
        if (this._listeners[a]) for (var l = 0; l < this._listeners[a].length; l++) this._listeners[a][l].call(this, s);
      }, pipe: function(a) {
        return a.registerPrevious(this);
      }, registerPrevious: function(a) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = a.streamInfo, this.mergeStreamInfo(), this.previous = a;
        var s = this;
        return a.on("data", function(l) {
          s.processChunk(l);
        }), a.on("end", function() {
          s.end();
        }), a.on("error", function(l) {
          s.error(l);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var a = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), a = !0), this.previous && this.previous.resume(), !a;
      }, flush: function() {
      }, processChunk: function(a) {
        this.push(a);
      }, withStreamInfo: function(a, s) {
        return this.extraStreamInfo[a] = s, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var a in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, a) && (this.streamInfo[a] = this.extraStreamInfo[a]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var a = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + a : a;
      } }, r.exports = o;
    }, {}], 29: [function(n, r, i) {
      var o = n("../utils"), a = n("./ConvertWorker"), s = n("./GenericWorker"), l = n("../base64"), u = n("../support"), f = n("../external"), h = null;
      if (u.nodestream) try {
        h = n("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function p(b, x) {
        return new f.Promise(function(v, D) {
          var S = [], E = b._internalType, I = b._outputType, R = b._mimeType;
          b.on("data", function(O, N) {
            S.push(O), x && x(N);
          }).on("error", function(O) {
            S = [], D(O);
          }).on("end", function() {
            try {
              var O = function(N, q, $) {
                switch (N) {
                  case "blob":
                    return o.newBlob(o.transformTo("arraybuffer", q), $);
                  case "base64":
                    return l.encode(q);
                  default:
                    return o.transformTo(N, q);
                }
              }(I, function(N, q) {
                var $, le = 0, ve = null, M = 0;
                for ($ = 0; $ < q.length; $++) M += q[$].length;
                switch (N) {
                  case "string":
                    return q.join("");
                  case "array":
                    return Array.prototype.concat.apply([], q);
                  case "uint8array":
                    for (ve = new Uint8Array(M), $ = 0; $ < q.length; $++) ve.set(q[$], le), le += q[$].length;
                    return ve;
                  case "nodebuffer":
                    return Buffer.concat(q);
                  default:
                    throw new Error("concat : unsupported type '" + N + "'");
                }
              }(E, S), R);
              v(O);
            } catch (N) {
              D(N);
            }
            S = [];
          }).resume();
        });
      }
      function y(b, x, v) {
        var D = x;
        switch (x) {
          case "blob":
          case "arraybuffer":
            D = "uint8array";
            break;
          case "base64":
            D = "string";
        }
        try {
          this._internalType = D, this._outputType = x, this._mimeType = v, o.checkSupport(D), this._worker = b.pipe(new a(D)), b.lock();
        } catch (S) {
          this._worker = new s("error"), this._worker.error(S);
        }
      }
      y.prototype = { accumulate: function(b) {
        return p(this, b);
      }, on: function(b, x) {
        var v = this;
        return b === "data" ? this._worker.on(b, function(D) {
          x.call(v, D.data, D.meta);
        }) : this._worker.on(b, function() {
          o.delay(x, arguments, v);
        }), this;
      }, resume: function() {
        return o.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(b) {
        if (o.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new h(this, { objectMode: this._outputType !== "nodebuffer" }, b);
      } }, r.exports = y;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(n, r, i) {
      if (i.base64 = !0, i.array = !0, i.string = !0, i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", i.nodebuffer = typeof Buffer < "u", i.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") i.blob = !1;
      else {
        var o = new ArrayBuffer(0);
        try {
          i.blob = new Blob([o], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var a = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            a.append(o), i.blob = a.getBlob("application/zip").size === 0;
          } catch {
            i.blob = !1;
          }
        }
      }
      try {
        i.nodestream = !!n("readable-stream").Readable;
      } catch {
        i.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(n, r, i) {
      for (var o = n("./utils"), a = n("./support"), s = n("./nodejsUtils"), l = n("./stream/GenericWorker"), u = new Array(256), f = 0; f < 256; f++) u[f] = 252 <= f ? 6 : 248 <= f ? 5 : 240 <= f ? 4 : 224 <= f ? 3 : 192 <= f ? 2 : 1;
      u[254] = u[254] = 1;
      function h() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function p() {
        l.call(this, "utf-8 encode");
      }
      i.utf8encode = function(y) {
        return a.nodebuffer ? s.newBufferFrom(y, "utf-8") : function(b) {
          var x, v, D, S, E, I = b.length, R = 0;
          for (S = 0; S < I; S++) (64512 & (v = b.charCodeAt(S))) == 55296 && S + 1 < I && (64512 & (D = b.charCodeAt(S + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (D - 56320), S++), R += v < 128 ? 1 : v < 2048 ? 2 : v < 65536 ? 3 : 4;
          for (x = a.uint8array ? new Uint8Array(R) : new Array(R), S = E = 0; E < R; S++) (64512 & (v = b.charCodeAt(S))) == 55296 && S + 1 < I && (64512 & (D = b.charCodeAt(S + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (D - 56320), S++), v < 128 ? x[E++] = v : (v < 2048 ? x[E++] = 192 | v >>> 6 : (v < 65536 ? x[E++] = 224 | v >>> 12 : (x[E++] = 240 | v >>> 18, x[E++] = 128 | v >>> 12 & 63), x[E++] = 128 | v >>> 6 & 63), x[E++] = 128 | 63 & v);
          return x;
        }(y);
      }, i.utf8decode = function(y) {
        return a.nodebuffer ? o.transformTo("nodebuffer", y).toString("utf-8") : function(b) {
          var x, v, D, S, E = b.length, I = new Array(2 * E);
          for (x = v = 0; x < E; ) if ((D = b[x++]) < 128) I[v++] = D;
          else if (4 < (S = u[D])) I[v++] = 65533, x += S - 1;
          else {
            for (D &= S === 2 ? 31 : S === 3 ? 15 : 7; 1 < S && x < E; ) D = D << 6 | 63 & b[x++], S--;
            1 < S ? I[v++] = 65533 : D < 65536 ? I[v++] = D : (D -= 65536, I[v++] = 55296 | D >> 10 & 1023, I[v++] = 56320 | 1023 & D);
          }
          return I.length !== v && (I.subarray ? I = I.subarray(0, v) : I.length = v), o.applyFromCharCode(I);
        }(y = o.transformTo(a.uint8array ? "uint8array" : "array", y));
      }, o.inherits(h, l), h.prototype.processChunk = function(y) {
        var b = o.transformTo(a.uint8array ? "uint8array" : "array", y.data);
        if (this.leftOver && this.leftOver.length) {
          if (a.uint8array) {
            var x = b;
            (b = new Uint8Array(x.length + this.leftOver.length)).set(this.leftOver, 0), b.set(x, this.leftOver.length);
          } else b = this.leftOver.concat(b);
          this.leftOver = null;
        }
        var v = function(S, E) {
          var I;
          for ((E = E || S.length) > S.length && (E = S.length), I = E - 1; 0 <= I && (192 & S[I]) == 128; ) I--;
          return I < 0 || I === 0 ? E : I + u[S[I]] > E ? I : E;
        }(b), D = b;
        v !== b.length && (a.uint8array ? (D = b.subarray(0, v), this.leftOver = b.subarray(v, b.length)) : (D = b.slice(0, v), this.leftOver = b.slice(v, b.length))), this.push({ data: i.utf8decode(D), meta: y.meta });
      }, h.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: i.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, i.Utf8DecodeWorker = h, o.inherits(p, l), p.prototype.processChunk = function(y) {
        this.push({ data: i.utf8encode(y.data), meta: y.meta });
      }, i.Utf8EncodeWorker = p;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(n, r, i) {
      var o = n("./support"), a = n("./base64"), s = n("./nodejsUtils"), l = n("./external");
      function u(x) {
        return x;
      }
      function f(x, v) {
        for (var D = 0; D < x.length; ++D) v[D] = 255 & x.charCodeAt(D);
        return v;
      }
      n("setimmediate"), i.newBlob = function(x, v) {
        i.checkSupport("blob");
        try {
          return new Blob([x], { type: v });
        } catch {
          try {
            var D = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return D.append(x), D.getBlob(v);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var h = { stringifyByChunk: function(x, v, D) {
        var S = [], E = 0, I = x.length;
        if (I <= D) return String.fromCharCode.apply(null, x);
        for (; E < I; ) v === "array" || v === "nodebuffer" ? S.push(String.fromCharCode.apply(null, x.slice(E, Math.min(E + D, I)))) : S.push(String.fromCharCode.apply(null, x.subarray(E, Math.min(E + D, I)))), E += D;
        return S.join("");
      }, stringifyByChar: function(x) {
        for (var v = "", D = 0; D < x.length; D++) v += String.fromCharCode(x[D]);
        return v;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return o.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return o.nodebuffer && String.fromCharCode.apply(null, s.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function p(x) {
        var v = 65536, D = i.getTypeOf(x), S = !0;
        if (D === "uint8array" ? S = h.applyCanBeUsed.uint8array : D === "nodebuffer" && (S = h.applyCanBeUsed.nodebuffer), S) for (; 1 < v; ) try {
          return h.stringifyByChunk(x, D, v);
        } catch {
          v = Math.floor(v / 2);
        }
        return h.stringifyByChar(x);
      }
      function y(x, v) {
        for (var D = 0; D < x.length; D++) v[D] = x[D];
        return v;
      }
      i.applyFromCharCode = p;
      var b = {};
      b.string = { string: u, array: function(x) {
        return f(x, new Array(x.length));
      }, arraybuffer: function(x) {
        return b.string.uint8array(x).buffer;
      }, uint8array: function(x) {
        return f(x, new Uint8Array(x.length));
      }, nodebuffer: function(x) {
        return f(x, s.allocBuffer(x.length));
      } }, b.array = { string: p, array: u, arraybuffer: function(x) {
        return new Uint8Array(x).buffer;
      }, uint8array: function(x) {
        return new Uint8Array(x);
      }, nodebuffer: function(x) {
        return s.newBufferFrom(x);
      } }, b.arraybuffer = { string: function(x) {
        return p(new Uint8Array(x));
      }, array: function(x) {
        return y(new Uint8Array(x), new Array(x.byteLength));
      }, arraybuffer: u, uint8array: function(x) {
        return new Uint8Array(x);
      }, nodebuffer: function(x) {
        return s.newBufferFrom(new Uint8Array(x));
      } }, b.uint8array = { string: p, array: function(x) {
        return y(x, new Array(x.length));
      }, arraybuffer: function(x) {
        return x.buffer;
      }, uint8array: u, nodebuffer: function(x) {
        return s.newBufferFrom(x);
      } }, b.nodebuffer = { string: p, array: function(x) {
        return y(x, new Array(x.length));
      }, arraybuffer: function(x) {
        return b.nodebuffer.uint8array(x).buffer;
      }, uint8array: function(x) {
        return y(x, new Uint8Array(x.length));
      }, nodebuffer: u }, i.transformTo = function(x, v) {
        if (v = v || "", !x) return v;
        i.checkSupport(x);
        var D = i.getTypeOf(v);
        return b[D][x](v);
      }, i.resolve = function(x) {
        for (var v = x.split("/"), D = [], S = 0; S < v.length; S++) {
          var E = v[S];
          E === "." || E === "" && S !== 0 && S !== v.length - 1 || (E === ".." ? D.pop() : D.push(E));
        }
        return D.join("/");
      }, i.getTypeOf = function(x) {
        return typeof x == "string" ? "string" : Object.prototype.toString.call(x) === "[object Array]" ? "array" : o.nodebuffer && s.isBuffer(x) ? "nodebuffer" : o.uint8array && x instanceof Uint8Array ? "uint8array" : o.arraybuffer && x instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, i.checkSupport = function(x) {
        if (!o[x.toLowerCase()]) throw new Error(x + " is not supported by this platform");
      }, i.MAX_VALUE_16BITS = 65535, i.MAX_VALUE_32BITS = -1, i.pretty = function(x) {
        var v, D, S = "";
        for (D = 0; D < (x || "").length; D++) S += "\\x" + ((v = x.charCodeAt(D)) < 16 ? "0" : "") + v.toString(16).toUpperCase();
        return S;
      }, i.delay = function(x, v, D) {
        setImmediate(function() {
          x.apply(D || null, v || []);
        });
      }, i.inherits = function(x, v) {
        function D() {
        }
        D.prototype = v.prototype, x.prototype = new D();
      }, i.extend = function() {
        var x, v, D = {};
        for (x = 0; x < arguments.length; x++) for (v in arguments[x]) Object.prototype.hasOwnProperty.call(arguments[x], v) && D[v] === void 0 && (D[v] = arguments[x][v]);
        return D;
      }, i.prepareContent = function(x, v, D, S, E) {
        return l.Promise.resolve(v).then(function(I) {
          return o.blob && (I instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(I)) !== -1) && typeof FileReader < "u" ? new l.Promise(function(R, O) {
            var N = new FileReader();
            N.onload = function(q) {
              R(q.target.result);
            }, N.onerror = function(q) {
              O(q.target.error);
            }, N.readAsArrayBuffer(I);
          }) : I;
        }).then(function(I) {
          var R = i.getTypeOf(I);
          return R ? (R === "arraybuffer" ? I = i.transformTo("uint8array", I) : R === "string" && (E ? I = a.decode(I) : D && S !== !0 && (I = function(O) {
            return f(O, o.uint8array ? new Uint8Array(O.length) : new Array(O.length));
          }(I))), I) : l.Promise.reject(new Error("Can't read the data of '" + x + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(n, r, i) {
      var o = n("./reader/readerFor"), a = n("./utils"), s = n("./signature"), l = n("./zipEntry"), u = n("./support");
      function f(h) {
        this.files = [], this.loadOptions = h;
      }
      f.prototype = { checkSignature: function(h) {
        if (!this.reader.readAndCheckSignature(h)) {
          this.reader.index -= 4;
          var p = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + a.pretty(p) + ", expected " + a.pretty(h) + ")");
        }
      }, isSignature: function(h, p) {
        var y = this.reader.index;
        this.reader.setIndex(h);
        var b = this.reader.readString(4) === p;
        return this.reader.setIndex(y), b;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var h = this.reader.readData(this.zipCommentLength), p = u.uint8array ? "uint8array" : "array", y = a.transformTo(p, h);
        this.zipComment = this.loadOptions.decodeFileName(y);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var h, p, y, b = this.zip64EndOfCentralSize - 44; 0 < b; ) h = this.reader.readInt(2), p = this.reader.readInt(4), y = this.reader.readData(p), this.zip64ExtensibleData[h] = { id: h, length: p, value: y };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var h, p;
        for (h = 0; h < this.files.length; h++) p = this.files[h], this.reader.setIndex(p.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), p.readLocalPart(this.reader), p.handleUTF8(), p.processAttributes();
      }, readCentralDir: function() {
        var h;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); ) (h = new l({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(h);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var h = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
        if (h < 0) throw this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(h);
        var p = h;
        if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === a.MAX_VALUE_16BITS || this.diskWithCentralDirStart === a.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === a.MAX_VALUE_16BITS || this.centralDirRecords === a.MAX_VALUE_16BITS || this.centralDirSize === a.MAX_VALUE_32BITS || this.centralDirOffset === a.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (h = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(h), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var y = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (y += 20, y += 12 + this.zip64EndOfCentralSize);
        var b = p - y;
        if (0 < b) this.isSignature(p, s.CENTRAL_FILE_HEADER) || (this.reader.zero = b);
        else if (b < 0) throw new Error("Corrupted zip: missing " + Math.abs(b) + " bytes.");
      }, prepareReader: function(h) {
        this.reader = o(h);
      }, load: function(h) {
        this.prepareReader(h), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, r.exports = f;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(n, r, i) {
      var o = n("./reader/readerFor"), a = n("./utils"), s = n("./compressedObject"), l = n("./crc32"), u = n("./utf8"), f = n("./compressions"), h = n("./support");
      function p(y, b) {
        this.options = y, this.loadOptions = b;
      }
      p.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(y) {
        var b, x;
        if (y.skip(22), this.fileNameLength = y.readInt(2), x = y.readInt(2), this.fileName = y.readData(this.fileNameLength), y.skip(x), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((b = function(v) {
          for (var D in f) if (Object.prototype.hasOwnProperty.call(f, D) && f[D].magic === v) return f[D];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + a.pretty(this.compressionMethod) + " unknown (inner file : " + a.transformTo("string", this.fileName) + ")");
        this.decompressed = new s(this.compressedSize, this.uncompressedSize, this.crc32, b, y.readData(this.compressedSize));
      }, readCentralPart: function(y) {
        this.versionMadeBy = y.readInt(2), y.skip(2), this.bitFlag = y.readInt(2), this.compressionMethod = y.readString(2), this.date = y.readDate(), this.crc32 = y.readInt(4), this.compressedSize = y.readInt(4), this.uncompressedSize = y.readInt(4);
        var b = y.readInt(2);
        if (this.extraFieldsLength = y.readInt(2), this.fileCommentLength = y.readInt(2), this.diskNumberStart = y.readInt(2), this.internalFileAttributes = y.readInt(2), this.externalFileAttributes = y.readInt(4), this.localHeaderOffset = y.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        y.skip(b), this.readExtraFields(y), this.parseZIP64ExtraField(y), this.fileComment = y.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var y = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), y == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), y == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var y = o(this.extraFields[1].value);
          this.uncompressedSize === a.MAX_VALUE_32BITS && (this.uncompressedSize = y.readInt(8)), this.compressedSize === a.MAX_VALUE_32BITS && (this.compressedSize = y.readInt(8)), this.localHeaderOffset === a.MAX_VALUE_32BITS && (this.localHeaderOffset = y.readInt(8)), this.diskNumberStart === a.MAX_VALUE_32BITS && (this.diskNumberStart = y.readInt(4));
        }
      }, readExtraFields: function(y) {
        var b, x, v, D = y.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); y.index + 4 < D; ) b = y.readInt(2), x = y.readInt(2), v = y.readData(x), this.extraFields[b] = { id: b, length: x, value: v };
        y.setIndex(D);
      }, handleUTF8: function() {
        var y = h.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = u.utf8decode(this.fileName), this.fileCommentStr = u.utf8decode(this.fileComment);
        else {
          var b = this.findExtraFieldUnicodePath();
          if (b !== null) this.fileNameStr = b;
          else {
            var x = a.transformTo(y, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(x);
          }
          var v = this.findExtraFieldUnicodeComment();
          if (v !== null) this.fileCommentStr = v;
          else {
            var D = a.transformTo(y, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(D);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var y = this.extraFields[28789];
        if (y) {
          var b = o(y.value);
          return b.readInt(1) !== 1 || l(this.fileName) !== b.readInt(4) ? null : u.utf8decode(b.readData(y.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var y = this.extraFields[25461];
        if (y) {
          var b = o(y.value);
          return b.readInt(1) !== 1 || l(this.fileComment) !== b.readInt(4) ? null : u.utf8decode(b.readData(y.length - 5));
        }
        return null;
      } }, r.exports = p;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(n, r, i) {
      function o(b, x, v) {
        this.name = b, this.dir = v.dir, this.date = v.date, this.comment = v.comment, this.unixPermissions = v.unixPermissions, this.dosPermissions = v.dosPermissions, this._data = x, this._dataBinary = v.binary, this.options = { compression: v.compression, compressionOptions: v.compressionOptions };
      }
      var a = n("./stream/StreamHelper"), s = n("./stream/DataWorker"), l = n("./utf8"), u = n("./compressedObject"), f = n("./stream/GenericWorker");
      o.prototype = { internalStream: function(b) {
        var x = null, v = "string";
        try {
          if (!b) throw new Error("No output type specified.");
          var D = (v = b.toLowerCase()) === "string" || v === "text";
          v !== "binarystring" && v !== "text" || (v = "string"), x = this._decompressWorker();
          var S = !this._dataBinary;
          S && !D && (x = x.pipe(new l.Utf8EncodeWorker())), !S && D && (x = x.pipe(new l.Utf8DecodeWorker()));
        } catch (E) {
          (x = new f("error")).error(E);
        }
        return new a(x, v, "");
      }, async: function(b, x) {
        return this.internalStream(b).accumulate(x);
      }, nodeStream: function(b, x) {
        return this.internalStream(b || "nodebuffer").toNodejsStream(x);
      }, _compressWorker: function(b, x) {
        if (this._data instanceof u && this._data.compression.magic === b.magic) return this._data.getCompressedWorker();
        var v = this._decompressWorker();
        return this._dataBinary || (v = v.pipe(new l.Utf8EncodeWorker())), u.createWorkerFrom(v, b, x);
      }, _decompressWorker: function() {
        return this._data instanceof u ? this._data.getContentWorker() : this._data instanceof f ? this._data : new s(this._data);
      } };
      for (var h = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], p = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, y = 0; y < h.length; y++) o.prototype[h[y]] = p;
      r.exports = o;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(n, r, i) {
      (function(o) {
        var a, s, l = o.MutationObserver || o.WebKitMutationObserver;
        if (l) {
          var u = 0, f = new l(b), h = o.document.createTextNode("");
          f.observe(h, { characterData: !0 }), a = function() {
            h.data = u = ++u % 2;
          };
        } else if (o.setImmediate || o.MessageChannel === void 0) a = "document" in o && "onreadystatechange" in o.document.createElement("script") ? function() {
          var x = o.document.createElement("script");
          x.onreadystatechange = function() {
            b(), x.onreadystatechange = null, x.parentNode.removeChild(x), x = null;
          }, o.document.documentElement.appendChild(x);
        } : function() {
          setTimeout(b, 0);
        };
        else {
          var p = new o.MessageChannel();
          p.port1.onmessage = b, a = function() {
            p.port2.postMessage(0);
          };
        }
        var y = [];
        function b() {
          var x, v;
          s = !0;
          for (var D = y.length; D; ) {
            for (v = y, y = [], x = -1; ++x < D; ) v[x]();
            D = y.length;
          }
          s = !1;
        }
        r.exports = function(x) {
          y.push(x) !== 1 || s || a();
        };
      }).call(this, typeof it < "u" ? it : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(n, r, i) {
      var o = n("immediate");
      function a() {
      }
      var s = {}, l = ["REJECTED"], u = ["FULFILLED"], f = ["PENDING"];
      function h(D) {
        if (typeof D != "function") throw new TypeError("resolver must be a function");
        this.state = f, this.queue = [], this.outcome = void 0, D !== a && x(this, D);
      }
      function p(D, S, E) {
        this.promise = D, typeof S == "function" && (this.onFulfilled = S, this.callFulfilled = this.otherCallFulfilled), typeof E == "function" && (this.onRejected = E, this.callRejected = this.otherCallRejected);
      }
      function y(D, S, E) {
        o(function() {
          var I;
          try {
            I = S(E);
          } catch (R) {
            return s.reject(D, R);
          }
          I === D ? s.reject(D, new TypeError("Cannot resolve promise with itself")) : s.resolve(D, I);
        });
      }
      function b(D) {
        var S = D && D.then;
        if (D && (typeof D == "object" || typeof D == "function") && typeof S == "function") return function() {
          S.apply(D, arguments);
        };
      }
      function x(D, S) {
        var E = !1;
        function I(N) {
          E || (E = !0, s.reject(D, N));
        }
        function R(N) {
          E || (E = !0, s.resolve(D, N));
        }
        var O = v(function() {
          S(R, I);
        });
        O.status === "error" && I(O.value);
      }
      function v(D, S) {
        var E = {};
        try {
          E.value = D(S), E.status = "success";
        } catch (I) {
          E.status = "error", E.value = I;
        }
        return E;
      }
      (r.exports = h).prototype.finally = function(D) {
        if (typeof D != "function") return this;
        var S = this.constructor;
        return this.then(function(E) {
          return S.resolve(D()).then(function() {
            return E;
          });
        }, function(E) {
          return S.resolve(D()).then(function() {
            throw E;
          });
        });
      }, h.prototype.catch = function(D) {
        return this.then(null, D);
      }, h.prototype.then = function(D, S) {
        if (typeof D != "function" && this.state === u || typeof S != "function" && this.state === l) return this;
        var E = new this.constructor(a);
        return this.state !== f ? y(E, this.state === u ? D : S, this.outcome) : this.queue.push(new p(E, D, S)), E;
      }, p.prototype.callFulfilled = function(D) {
        s.resolve(this.promise, D);
      }, p.prototype.otherCallFulfilled = function(D) {
        y(this.promise, this.onFulfilled, D);
      }, p.prototype.callRejected = function(D) {
        s.reject(this.promise, D);
      }, p.prototype.otherCallRejected = function(D) {
        y(this.promise, this.onRejected, D);
      }, s.resolve = function(D, S) {
        var E = v(b, S);
        if (E.status === "error") return s.reject(D, E.value);
        var I = E.value;
        if (I) x(D, I);
        else {
          D.state = u, D.outcome = S;
          for (var R = -1, O = D.queue.length; ++R < O; ) D.queue[R].callFulfilled(S);
        }
        return D;
      }, s.reject = function(D, S) {
        D.state = l, D.outcome = S;
        for (var E = -1, I = D.queue.length; ++E < I; ) D.queue[E].callRejected(S);
        return D;
      }, h.resolve = function(D) {
        return D instanceof this ? D : s.resolve(new this(a), D);
      }, h.reject = function(D) {
        var S = new this(a);
        return s.reject(S, D);
      }, h.all = function(D) {
        var S = this;
        if (Object.prototype.toString.call(D) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var E = D.length, I = !1;
        if (!E) return this.resolve([]);
        for (var R = new Array(E), O = 0, N = -1, q = new this(a); ++N < E; ) $(D[N], N);
        return q;
        function $(le, ve) {
          S.resolve(le).then(function(M) {
            R[ve] = M, ++O !== E || I || (I = !0, s.resolve(q, R));
          }, function(M) {
            I || (I = !0, s.reject(q, M));
          });
        }
      }, h.race = function(D) {
        var S = this;
        if (Object.prototype.toString.call(D) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var E = D.length, I = !1;
        if (!E) return this.resolve([]);
        for (var R = -1, O = new this(a); ++R < E; ) N = D[R], S.resolve(N).then(function(q) {
          I || (I = !0, s.resolve(O, q));
        }, function(q) {
          I || (I = !0, s.reject(O, q));
        });
        var N;
        return O;
      };
    }, { immediate: 36 }], 38: [function(n, r, i) {
      var o = {};
      (0, n("./lib/utils/common").assign)(o, n("./lib/deflate"), n("./lib/inflate"), n("./lib/zlib/constants")), r.exports = o;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(n, r, i) {
      var o = n("./zlib/deflate"), a = n("./utils/common"), s = n("./utils/strings"), l = n("./zlib/messages"), u = n("./zlib/zstream"), f = Object.prototype.toString, h = 0, p = -1, y = 0, b = 8;
      function x(D) {
        if (!(this instanceof x)) return new x(D);
        this.options = a.assign({ level: p, method: b, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: y, to: "" }, D || {});
        var S = this.options;
        S.raw && 0 < S.windowBits ? S.windowBits = -S.windowBits : S.gzip && 0 < S.windowBits && S.windowBits < 16 && (S.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var E = o.deflateInit2(this.strm, S.level, S.method, S.windowBits, S.memLevel, S.strategy);
        if (E !== h) throw new Error(l[E]);
        if (S.header && o.deflateSetHeader(this.strm, S.header), S.dictionary) {
          var I;
          if (I = typeof S.dictionary == "string" ? s.string2buf(S.dictionary) : f.call(S.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(S.dictionary) : S.dictionary, (E = o.deflateSetDictionary(this.strm, I)) !== h) throw new Error(l[E]);
          this._dict_set = !0;
        }
      }
      function v(D, S) {
        var E = new x(S);
        if (E.push(D, !0), E.err) throw E.msg || l[E.err];
        return E.result;
      }
      x.prototype.push = function(D, S) {
        var E, I, R = this.strm, O = this.options.chunkSize;
        if (this.ended) return !1;
        I = S === ~~S ? S : S === !0 ? 4 : 0, typeof D == "string" ? R.input = s.string2buf(D) : f.call(D) === "[object ArrayBuffer]" ? R.input = new Uint8Array(D) : R.input = D, R.next_in = 0, R.avail_in = R.input.length;
        do {
          if (R.avail_out === 0 && (R.output = new a.Buf8(O), R.next_out = 0, R.avail_out = O), (E = o.deflate(R, I)) !== 1 && E !== h) return this.onEnd(E), !(this.ended = !0);
          R.avail_out !== 0 && (R.avail_in !== 0 || I !== 4 && I !== 2) || (this.options.to === "string" ? this.onData(s.buf2binstring(a.shrinkBuf(R.output, R.next_out))) : this.onData(a.shrinkBuf(R.output, R.next_out)));
        } while ((0 < R.avail_in || R.avail_out === 0) && E !== 1);
        return I === 4 ? (E = o.deflateEnd(this.strm), this.onEnd(E), this.ended = !0, E === h) : I !== 2 || (this.onEnd(h), !(R.avail_out = 0));
      }, x.prototype.onData = function(D) {
        this.chunks.push(D);
      }, x.prototype.onEnd = function(D) {
        D === h && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = a.flattenChunks(this.chunks)), this.chunks = [], this.err = D, this.msg = this.strm.msg;
      }, i.Deflate = x, i.deflate = v, i.deflateRaw = function(D, S) {
        return (S = S || {}).raw = !0, v(D, S);
      }, i.gzip = function(D, S) {
        return (S = S || {}).gzip = !0, v(D, S);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(n, r, i) {
      var o = n("./zlib/inflate"), a = n("./utils/common"), s = n("./utils/strings"), l = n("./zlib/constants"), u = n("./zlib/messages"), f = n("./zlib/zstream"), h = n("./zlib/gzheader"), p = Object.prototype.toString;
      function y(x) {
        if (!(this instanceof y)) return new y(x);
        this.options = a.assign({ chunkSize: 16384, windowBits: 0, to: "" }, x || {});
        var v = this.options;
        v.raw && 0 <= v.windowBits && v.windowBits < 16 && (v.windowBits = -v.windowBits, v.windowBits === 0 && (v.windowBits = -15)), !(0 <= v.windowBits && v.windowBits < 16) || x && x.windowBits || (v.windowBits += 32), 15 < v.windowBits && v.windowBits < 48 && !(15 & v.windowBits) && (v.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new f(), this.strm.avail_out = 0;
        var D = o.inflateInit2(this.strm, v.windowBits);
        if (D !== l.Z_OK) throw new Error(u[D]);
        this.header = new h(), o.inflateGetHeader(this.strm, this.header);
      }
      function b(x, v) {
        var D = new y(v);
        if (D.push(x, !0), D.err) throw D.msg || u[D.err];
        return D.result;
      }
      y.prototype.push = function(x, v) {
        var D, S, E, I, R, O, N = this.strm, q = this.options.chunkSize, $ = this.options.dictionary, le = !1;
        if (this.ended) return !1;
        S = v === ~~v ? v : v === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof x == "string" ? N.input = s.binstring2buf(x) : p.call(x) === "[object ArrayBuffer]" ? N.input = new Uint8Array(x) : N.input = x, N.next_in = 0, N.avail_in = N.input.length;
        do {
          if (N.avail_out === 0 && (N.output = new a.Buf8(q), N.next_out = 0, N.avail_out = q), (D = o.inflate(N, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && $ && (O = typeof $ == "string" ? s.string2buf($) : p.call($) === "[object ArrayBuffer]" ? new Uint8Array($) : $, D = o.inflateSetDictionary(this.strm, O)), D === l.Z_BUF_ERROR && le === !0 && (D = l.Z_OK, le = !1), D !== l.Z_STREAM_END && D !== l.Z_OK) return this.onEnd(D), !(this.ended = !0);
          N.next_out && (N.avail_out !== 0 && D !== l.Z_STREAM_END && (N.avail_in !== 0 || S !== l.Z_FINISH && S !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (E = s.utf8border(N.output, N.next_out), I = N.next_out - E, R = s.buf2string(N.output, E), N.next_out = I, N.avail_out = q - I, I && a.arraySet(N.output, N.output, E, I, 0), this.onData(R)) : this.onData(a.shrinkBuf(N.output, N.next_out)))), N.avail_in === 0 && N.avail_out === 0 && (le = !0);
        } while ((0 < N.avail_in || N.avail_out === 0) && D !== l.Z_STREAM_END);
        return D === l.Z_STREAM_END && (S = l.Z_FINISH), S === l.Z_FINISH ? (D = o.inflateEnd(this.strm), this.onEnd(D), this.ended = !0, D === l.Z_OK) : S !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(N.avail_out = 0));
      }, y.prototype.onData = function(x) {
        this.chunks.push(x);
      }, y.prototype.onEnd = function(x) {
        x === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = a.flattenChunks(this.chunks)), this.chunks = [], this.err = x, this.msg = this.strm.msg;
      }, i.Inflate = y, i.inflate = b, i.inflateRaw = function(x, v) {
        return (v = v || {}).raw = !0, b(x, v);
      }, i.ungzip = b;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(n, r, i) {
      var o = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      i.assign = function(l) {
        for (var u = Array.prototype.slice.call(arguments, 1); u.length; ) {
          var f = u.shift();
          if (f) {
            if (typeof f != "object") throw new TypeError(f + "must be non-object");
            for (var h in f) f.hasOwnProperty(h) && (l[h] = f[h]);
          }
        }
        return l;
      }, i.shrinkBuf = function(l, u) {
        return l.length === u ? l : l.subarray ? l.subarray(0, u) : (l.length = u, l);
      };
      var a = { arraySet: function(l, u, f, h, p) {
        if (u.subarray && l.subarray) l.set(u.subarray(f, f + h), p);
        else for (var y = 0; y < h; y++) l[p + y] = u[f + y];
      }, flattenChunks: function(l) {
        var u, f, h, p, y, b;
        for (u = h = 0, f = l.length; u < f; u++) h += l[u].length;
        for (b = new Uint8Array(h), u = p = 0, f = l.length; u < f; u++) y = l[u], b.set(y, p), p += y.length;
        return b;
      } }, s = { arraySet: function(l, u, f, h, p) {
        for (var y = 0; y < h; y++) l[p + y] = u[f + y];
      }, flattenChunks: function(l) {
        return [].concat.apply([], l);
      } };
      i.setTyped = function(l) {
        l ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, a)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, s));
      }, i.setTyped(o);
    }, {}], 42: [function(n, r, i) {
      var o = n("./common"), a = !0, s = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        a = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        s = !1;
      }
      for (var l = new o.Buf8(256), u = 0; u < 256; u++) l[u] = 252 <= u ? 6 : 248 <= u ? 5 : 240 <= u ? 4 : 224 <= u ? 3 : 192 <= u ? 2 : 1;
      function f(h, p) {
        if (p < 65537 && (h.subarray && s || !h.subarray && a)) return String.fromCharCode.apply(null, o.shrinkBuf(h, p));
        for (var y = "", b = 0; b < p; b++) y += String.fromCharCode(h[b]);
        return y;
      }
      l[254] = l[254] = 1, i.string2buf = function(h) {
        var p, y, b, x, v, D = h.length, S = 0;
        for (x = 0; x < D; x++) (64512 & (y = h.charCodeAt(x))) == 55296 && x + 1 < D && (64512 & (b = h.charCodeAt(x + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (b - 56320), x++), S += y < 128 ? 1 : y < 2048 ? 2 : y < 65536 ? 3 : 4;
        for (p = new o.Buf8(S), x = v = 0; v < S; x++) (64512 & (y = h.charCodeAt(x))) == 55296 && x + 1 < D && (64512 & (b = h.charCodeAt(x + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (b - 56320), x++), y < 128 ? p[v++] = y : (y < 2048 ? p[v++] = 192 | y >>> 6 : (y < 65536 ? p[v++] = 224 | y >>> 12 : (p[v++] = 240 | y >>> 18, p[v++] = 128 | y >>> 12 & 63), p[v++] = 128 | y >>> 6 & 63), p[v++] = 128 | 63 & y);
        return p;
      }, i.buf2binstring = function(h) {
        return f(h, h.length);
      }, i.binstring2buf = function(h) {
        for (var p = new o.Buf8(h.length), y = 0, b = p.length; y < b; y++) p[y] = h.charCodeAt(y);
        return p;
      }, i.buf2string = function(h, p) {
        var y, b, x, v, D = p || h.length, S = new Array(2 * D);
        for (y = b = 0; y < D; ) if ((x = h[y++]) < 128) S[b++] = x;
        else if (4 < (v = l[x])) S[b++] = 65533, y += v - 1;
        else {
          for (x &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && y < D; ) x = x << 6 | 63 & h[y++], v--;
          1 < v ? S[b++] = 65533 : x < 65536 ? S[b++] = x : (x -= 65536, S[b++] = 55296 | x >> 10 & 1023, S[b++] = 56320 | 1023 & x);
        }
        return f(S, b);
      }, i.utf8border = function(h, p) {
        var y;
        for ((p = p || h.length) > h.length && (p = h.length), y = p - 1; 0 <= y && (192 & h[y]) == 128; ) y--;
        return y < 0 || y === 0 ? p : y + l[h[y]] > p ? y : p;
      };
    }, { "./common": 41 }], 43: [function(n, r, i) {
      r.exports = function(o, a, s, l) {
        for (var u = 65535 & o | 0, f = o >>> 16 & 65535 | 0, h = 0; s !== 0; ) {
          for (s -= h = 2e3 < s ? 2e3 : s; f = f + (u = u + a[l++] | 0) | 0, --h; ) ;
          u %= 65521, f %= 65521;
        }
        return u | f << 16 | 0;
      };
    }, {}], 44: [function(n, r, i) {
      r.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(n, r, i) {
      var o = function() {
        for (var a, s = [], l = 0; l < 256; l++) {
          a = l;
          for (var u = 0; u < 8; u++) a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
          s[l] = a;
        }
        return s;
      }();
      r.exports = function(a, s, l, u) {
        var f = o, h = u + l;
        a ^= -1;
        for (var p = u; p < h; p++) a = a >>> 8 ^ f[255 & (a ^ s[p])];
        return -1 ^ a;
      };
    }, {}], 46: [function(n, r, i) {
      var o, a = n("../utils/common"), s = n("./trees"), l = n("./adler32"), u = n("./crc32"), f = n("./messages"), h = 0, p = 4, y = 0, b = -2, x = -1, v = 4, D = 2, S = 8, E = 9, I = 286, R = 30, O = 19, N = 2 * I + 1, q = 15, $ = 3, le = 258, ve = le + $ + 1, M = 42, ee = 113, A = 1, oe = 2, j = 3, Q = 4;
      function G(k, ge) {
        return k.msg = f[ge], ge;
      }
      function Z(k) {
        return (k << 1) - (4 < k ? 9 : 0);
      }
      function re(k) {
        for (var ge = k.length; 0 <= --ge; ) k[ge] = 0;
      }
      function V(k) {
        var ge = k.state, ue = ge.pending;
        ue > k.avail_out && (ue = k.avail_out), ue !== 0 && (a.arraySet(k.output, ge.pending_buf, ge.pending_out, ue, k.next_out), k.next_out += ue, ge.pending_out += ue, k.total_out += ue, k.avail_out -= ue, ge.pending -= ue, ge.pending === 0 && (ge.pending_out = 0));
      }
      function P(k, ge) {
        s._tr_flush_block(k, 0 <= k.block_start ? k.block_start : -1, k.strstart - k.block_start, ge), k.block_start = k.strstart, V(k.strm);
      }
      function pe(k, ge) {
        k.pending_buf[k.pending++] = ge;
      }
      function we(k, ge) {
        k.pending_buf[k.pending++] = ge >>> 8 & 255, k.pending_buf[k.pending++] = 255 & ge;
      }
      function be(k, ge) {
        var ue, Y, H = k.max_chain_length, ae = k.strstart, Se = k.prev_length, ke = k.nice_match, se = k.strstart > k.w_size - ve ? k.strstart - (k.w_size - ve) : 0, K = k.window, ne = k.w_mask, ce = k.prev, xe = k.strstart + le, Be = K[ae + Se - 1], Me = K[ae + Se];
        k.prev_length >= k.good_match && (H >>= 2), ke > k.lookahead && (ke = k.lookahead);
        do
          if (K[(ue = ge) + Se] === Me && K[ue + Se - 1] === Be && K[ue] === K[ae] && K[++ue] === K[ae + 1]) {
            ae += 2, ue++;
            do
              ;
            while (K[++ae] === K[++ue] && K[++ae] === K[++ue] && K[++ae] === K[++ue] && K[++ae] === K[++ue] && K[++ae] === K[++ue] && K[++ae] === K[++ue] && K[++ae] === K[++ue] && K[++ae] === K[++ue] && ae < xe);
            if (Y = le - (xe - ae), ae = xe - le, Se < Y) {
              if (k.match_start = ge, ke <= (Se = Y)) break;
              Be = K[ae + Se - 1], Me = K[ae + Se];
            }
          }
        while ((ge = ce[ge & ne]) > se && --H != 0);
        return Se <= k.lookahead ? Se : k.lookahead;
      }
      function _e(k) {
        var ge, ue, Y, H, ae, Se, ke, se, K, ne, ce = k.w_size;
        do {
          if (H = k.window_size - k.lookahead - k.strstart, k.strstart >= ce + (ce - ve)) {
            for (a.arraySet(k.window, k.window, ce, ce, 0), k.match_start -= ce, k.strstart -= ce, k.block_start -= ce, ge = ue = k.hash_size; Y = k.head[--ge], k.head[ge] = ce <= Y ? Y - ce : 0, --ue; ) ;
            for (ge = ue = ce; Y = k.prev[--ge], k.prev[ge] = ce <= Y ? Y - ce : 0, --ue; ) ;
            H += ce;
          }
          if (k.strm.avail_in === 0) break;
          if (Se = k.strm, ke = k.window, se = k.strstart + k.lookahead, K = H, ne = void 0, ne = Se.avail_in, K < ne && (ne = K), ue = ne === 0 ? 0 : (Se.avail_in -= ne, a.arraySet(ke, Se.input, Se.next_in, ne, se), Se.state.wrap === 1 ? Se.adler = l(Se.adler, ke, ne, se) : Se.state.wrap === 2 && (Se.adler = u(Se.adler, ke, ne, se)), Se.next_in += ne, Se.total_in += ne, ne), k.lookahead += ue, k.lookahead + k.insert >= $) for (ae = k.strstart - k.insert, k.ins_h = k.window[ae], k.ins_h = (k.ins_h << k.hash_shift ^ k.window[ae + 1]) & k.hash_mask; k.insert && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[ae + $ - 1]) & k.hash_mask, k.prev[ae & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = ae, ae++, k.insert--, !(k.lookahead + k.insert < $)); ) ;
        } while (k.lookahead < ve && k.strm.avail_in !== 0);
      }
      function $e(k, ge) {
        for (var ue, Y; ; ) {
          if (k.lookahead < ve) {
            if (_e(k), k.lookahead < ve && ge === h) return A;
            if (k.lookahead === 0) break;
          }
          if (ue = 0, k.lookahead >= $ && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + $ - 1]) & k.hash_mask, ue = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart), ue !== 0 && k.strstart - ue <= k.w_size - ve && (k.match_length = be(k, ue)), k.match_length >= $) if (Y = s._tr_tally(k, k.strstart - k.match_start, k.match_length - $), k.lookahead -= k.match_length, k.match_length <= k.max_lazy_match && k.lookahead >= $) {
            for (k.match_length--; k.strstart++, k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + $ - 1]) & k.hash_mask, ue = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart, --k.match_length != 0; ) ;
            k.strstart++;
          } else k.strstart += k.match_length, k.match_length = 0, k.ins_h = k.window[k.strstart], k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + 1]) & k.hash_mask;
          else Y = s._tr_tally(k, 0, k.window[k.strstart]), k.lookahead--, k.strstart++;
          if (Y && (P(k, !1), k.strm.avail_out === 0)) return A;
        }
        return k.insert = k.strstart < $ - 1 ? k.strstart : $ - 1, ge === p ? (P(k, !0), k.strm.avail_out === 0 ? j : Q) : k.last_lit && (P(k, !1), k.strm.avail_out === 0) ? A : oe;
      }
      function Le(k, ge) {
        for (var ue, Y, H; ; ) {
          if (k.lookahead < ve) {
            if (_e(k), k.lookahead < ve && ge === h) return A;
            if (k.lookahead === 0) break;
          }
          if (ue = 0, k.lookahead >= $ && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + $ - 1]) & k.hash_mask, ue = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart), k.prev_length = k.match_length, k.prev_match = k.match_start, k.match_length = $ - 1, ue !== 0 && k.prev_length < k.max_lazy_match && k.strstart - ue <= k.w_size - ve && (k.match_length = be(k, ue), k.match_length <= 5 && (k.strategy === 1 || k.match_length === $ && 4096 < k.strstart - k.match_start) && (k.match_length = $ - 1)), k.prev_length >= $ && k.match_length <= k.prev_length) {
            for (H = k.strstart + k.lookahead - $, Y = s._tr_tally(k, k.strstart - 1 - k.prev_match, k.prev_length - $), k.lookahead -= k.prev_length - 1, k.prev_length -= 2; ++k.strstart <= H && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + $ - 1]) & k.hash_mask, ue = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart), --k.prev_length != 0; ) ;
            if (k.match_available = 0, k.match_length = $ - 1, k.strstart++, Y && (P(k, !1), k.strm.avail_out === 0)) return A;
          } else if (k.match_available) {
            if ((Y = s._tr_tally(k, 0, k.window[k.strstart - 1])) && P(k, !1), k.strstart++, k.lookahead--, k.strm.avail_out === 0) return A;
          } else k.match_available = 1, k.strstart++, k.lookahead--;
        }
        return k.match_available && (Y = s._tr_tally(k, 0, k.window[k.strstart - 1]), k.match_available = 0), k.insert = k.strstart < $ - 1 ? k.strstart : $ - 1, ge === p ? (P(k, !0), k.strm.avail_out === 0 ? j : Q) : k.last_lit && (P(k, !1), k.strm.avail_out === 0) ? A : oe;
      }
      function ze(k, ge, ue, Y, H) {
        this.good_length = k, this.max_lazy = ge, this.nice_length = ue, this.max_chain = Y, this.func = H;
      }
      function tt() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = S, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new a.Buf16(2 * N), this.dyn_dtree = new a.Buf16(2 * (2 * R + 1)), this.bl_tree = new a.Buf16(2 * (2 * O + 1)), re(this.dyn_ltree), re(this.dyn_dtree), re(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new a.Buf16(q + 1), this.heap = new a.Buf16(2 * I + 1), re(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new a.Buf16(2 * I + 1), re(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function ie(k) {
        var ge;
        return k && k.state ? (k.total_in = k.total_out = 0, k.data_type = D, (ge = k.state).pending = 0, ge.pending_out = 0, ge.wrap < 0 && (ge.wrap = -ge.wrap), ge.status = ge.wrap ? M : ee, k.adler = ge.wrap === 2 ? 0 : 1, ge.last_flush = h, s._tr_init(ge), y) : G(k, b);
      }
      function Ee(k) {
        var ge = ie(k);
        return ge === y && function(ue) {
          ue.window_size = 2 * ue.w_size, re(ue.head), ue.max_lazy_match = o[ue.level].max_lazy, ue.good_match = o[ue.level].good_length, ue.nice_match = o[ue.level].nice_length, ue.max_chain_length = o[ue.level].max_chain, ue.strstart = 0, ue.block_start = 0, ue.lookahead = 0, ue.insert = 0, ue.match_length = ue.prev_length = $ - 1, ue.match_available = 0, ue.ins_h = 0;
        }(k.state), ge;
      }
      function Re(k, ge, ue, Y, H, ae) {
        if (!k) return b;
        var Se = 1;
        if (ge === x && (ge = 6), Y < 0 ? (Se = 0, Y = -Y) : 15 < Y && (Se = 2, Y -= 16), H < 1 || E < H || ue !== S || Y < 8 || 15 < Y || ge < 0 || 9 < ge || ae < 0 || v < ae) return G(k, b);
        Y === 8 && (Y = 9);
        var ke = new tt();
        return (k.state = ke).strm = k, ke.wrap = Se, ke.gzhead = null, ke.w_bits = Y, ke.w_size = 1 << ke.w_bits, ke.w_mask = ke.w_size - 1, ke.hash_bits = H + 7, ke.hash_size = 1 << ke.hash_bits, ke.hash_mask = ke.hash_size - 1, ke.hash_shift = ~~((ke.hash_bits + $ - 1) / $), ke.window = new a.Buf8(2 * ke.w_size), ke.head = new a.Buf16(ke.hash_size), ke.prev = new a.Buf16(ke.w_size), ke.lit_bufsize = 1 << H + 6, ke.pending_buf_size = 4 * ke.lit_bufsize, ke.pending_buf = new a.Buf8(ke.pending_buf_size), ke.d_buf = 1 * ke.lit_bufsize, ke.l_buf = 3 * ke.lit_bufsize, ke.level = ge, ke.strategy = ae, ke.method = ue, Ee(k);
      }
      o = [new ze(0, 0, 0, 0, function(k, ge) {
        var ue = 65535;
        for (ue > k.pending_buf_size - 5 && (ue = k.pending_buf_size - 5); ; ) {
          if (k.lookahead <= 1) {
            if (_e(k), k.lookahead === 0 && ge === h) return A;
            if (k.lookahead === 0) break;
          }
          k.strstart += k.lookahead, k.lookahead = 0;
          var Y = k.block_start + ue;
          if ((k.strstart === 0 || k.strstart >= Y) && (k.lookahead = k.strstart - Y, k.strstart = Y, P(k, !1), k.strm.avail_out === 0) || k.strstart - k.block_start >= k.w_size - ve && (P(k, !1), k.strm.avail_out === 0)) return A;
        }
        return k.insert = 0, ge === p ? (P(k, !0), k.strm.avail_out === 0 ? j : Q) : (k.strstart > k.block_start && (P(k, !1), k.strm.avail_out), A);
      }), new ze(4, 4, 8, 4, $e), new ze(4, 5, 16, 8, $e), new ze(4, 6, 32, 32, $e), new ze(4, 4, 16, 16, Le), new ze(8, 16, 32, 32, Le), new ze(8, 16, 128, 128, Le), new ze(8, 32, 128, 256, Le), new ze(32, 128, 258, 1024, Le), new ze(32, 258, 258, 4096, Le)], i.deflateInit = function(k, ge) {
        return Re(k, ge, S, 15, 8, 0);
      }, i.deflateInit2 = Re, i.deflateReset = Ee, i.deflateResetKeep = ie, i.deflateSetHeader = function(k, ge) {
        return k && k.state ? k.state.wrap !== 2 ? b : (k.state.gzhead = ge, y) : b;
      }, i.deflate = function(k, ge) {
        var ue, Y, H, ae;
        if (!k || !k.state || 5 < ge || ge < 0) return k ? G(k, b) : b;
        if (Y = k.state, !k.output || !k.input && k.avail_in !== 0 || Y.status === 666 && ge !== p) return G(k, k.avail_out === 0 ? -5 : b);
        if (Y.strm = k, ue = Y.last_flush, Y.last_flush = ge, Y.status === M) if (Y.wrap === 2) k.adler = 0, pe(Y, 31), pe(Y, 139), pe(Y, 8), Y.gzhead ? (pe(Y, (Y.gzhead.text ? 1 : 0) + (Y.gzhead.hcrc ? 2 : 0) + (Y.gzhead.extra ? 4 : 0) + (Y.gzhead.name ? 8 : 0) + (Y.gzhead.comment ? 16 : 0)), pe(Y, 255 & Y.gzhead.time), pe(Y, Y.gzhead.time >> 8 & 255), pe(Y, Y.gzhead.time >> 16 & 255), pe(Y, Y.gzhead.time >> 24 & 255), pe(Y, Y.level === 9 ? 2 : 2 <= Y.strategy || Y.level < 2 ? 4 : 0), pe(Y, 255 & Y.gzhead.os), Y.gzhead.extra && Y.gzhead.extra.length && (pe(Y, 255 & Y.gzhead.extra.length), pe(Y, Y.gzhead.extra.length >> 8 & 255)), Y.gzhead.hcrc && (k.adler = u(k.adler, Y.pending_buf, Y.pending, 0)), Y.gzindex = 0, Y.status = 69) : (pe(Y, 0), pe(Y, 0), pe(Y, 0), pe(Y, 0), pe(Y, 0), pe(Y, Y.level === 9 ? 2 : 2 <= Y.strategy || Y.level < 2 ? 4 : 0), pe(Y, 3), Y.status = ee);
        else {
          var Se = S + (Y.w_bits - 8 << 4) << 8;
          Se |= (2 <= Y.strategy || Y.level < 2 ? 0 : Y.level < 6 ? 1 : Y.level === 6 ? 2 : 3) << 6, Y.strstart !== 0 && (Se |= 32), Se += 31 - Se % 31, Y.status = ee, we(Y, Se), Y.strstart !== 0 && (we(Y, k.adler >>> 16), we(Y, 65535 & k.adler)), k.adler = 1;
        }
        if (Y.status === 69) if (Y.gzhead.extra) {
          for (H = Y.pending; Y.gzindex < (65535 & Y.gzhead.extra.length) && (Y.pending !== Y.pending_buf_size || (Y.gzhead.hcrc && Y.pending > H && (k.adler = u(k.adler, Y.pending_buf, Y.pending - H, H)), V(k), H = Y.pending, Y.pending !== Y.pending_buf_size)); ) pe(Y, 255 & Y.gzhead.extra[Y.gzindex]), Y.gzindex++;
          Y.gzhead.hcrc && Y.pending > H && (k.adler = u(k.adler, Y.pending_buf, Y.pending - H, H)), Y.gzindex === Y.gzhead.extra.length && (Y.gzindex = 0, Y.status = 73);
        } else Y.status = 73;
        if (Y.status === 73) if (Y.gzhead.name) {
          H = Y.pending;
          do {
            if (Y.pending === Y.pending_buf_size && (Y.gzhead.hcrc && Y.pending > H && (k.adler = u(k.adler, Y.pending_buf, Y.pending - H, H)), V(k), H = Y.pending, Y.pending === Y.pending_buf_size)) {
              ae = 1;
              break;
            }
            ae = Y.gzindex < Y.gzhead.name.length ? 255 & Y.gzhead.name.charCodeAt(Y.gzindex++) : 0, pe(Y, ae);
          } while (ae !== 0);
          Y.gzhead.hcrc && Y.pending > H && (k.adler = u(k.adler, Y.pending_buf, Y.pending - H, H)), ae === 0 && (Y.gzindex = 0, Y.status = 91);
        } else Y.status = 91;
        if (Y.status === 91) if (Y.gzhead.comment) {
          H = Y.pending;
          do {
            if (Y.pending === Y.pending_buf_size && (Y.gzhead.hcrc && Y.pending > H && (k.adler = u(k.adler, Y.pending_buf, Y.pending - H, H)), V(k), H = Y.pending, Y.pending === Y.pending_buf_size)) {
              ae = 1;
              break;
            }
            ae = Y.gzindex < Y.gzhead.comment.length ? 255 & Y.gzhead.comment.charCodeAt(Y.gzindex++) : 0, pe(Y, ae);
          } while (ae !== 0);
          Y.gzhead.hcrc && Y.pending > H && (k.adler = u(k.adler, Y.pending_buf, Y.pending - H, H)), ae === 0 && (Y.status = 103);
        } else Y.status = 103;
        if (Y.status === 103 && (Y.gzhead.hcrc ? (Y.pending + 2 > Y.pending_buf_size && V(k), Y.pending + 2 <= Y.pending_buf_size && (pe(Y, 255 & k.adler), pe(Y, k.adler >> 8 & 255), k.adler = 0, Y.status = ee)) : Y.status = ee), Y.pending !== 0) {
          if (V(k), k.avail_out === 0) return Y.last_flush = -1, y;
        } else if (k.avail_in === 0 && Z(ge) <= Z(ue) && ge !== p) return G(k, -5);
        if (Y.status === 666 && k.avail_in !== 0) return G(k, -5);
        if (k.avail_in !== 0 || Y.lookahead !== 0 || ge !== h && Y.status !== 666) {
          var ke = Y.strategy === 2 ? function(se, K) {
            for (var ne; ; ) {
              if (se.lookahead === 0 && (_e(se), se.lookahead === 0)) {
                if (K === h) return A;
                break;
              }
              if (se.match_length = 0, ne = s._tr_tally(se, 0, se.window[se.strstart]), se.lookahead--, se.strstart++, ne && (P(se, !1), se.strm.avail_out === 0)) return A;
            }
            return se.insert = 0, K === p ? (P(se, !0), se.strm.avail_out === 0 ? j : Q) : se.last_lit && (P(se, !1), se.strm.avail_out === 0) ? A : oe;
          }(Y, ge) : Y.strategy === 3 ? function(se, K) {
            for (var ne, ce, xe, Be, Me = se.window; ; ) {
              if (se.lookahead <= le) {
                if (_e(se), se.lookahead <= le && K === h) return A;
                if (se.lookahead === 0) break;
              }
              if (se.match_length = 0, se.lookahead >= $ && 0 < se.strstart && (ce = Me[xe = se.strstart - 1]) === Me[++xe] && ce === Me[++xe] && ce === Me[++xe]) {
                Be = se.strstart + le;
                do
                  ;
                while (ce === Me[++xe] && ce === Me[++xe] && ce === Me[++xe] && ce === Me[++xe] && ce === Me[++xe] && ce === Me[++xe] && ce === Me[++xe] && ce === Me[++xe] && xe < Be);
                se.match_length = le - (Be - xe), se.match_length > se.lookahead && (se.match_length = se.lookahead);
              }
              if (se.match_length >= $ ? (ne = s._tr_tally(se, 1, se.match_length - $), se.lookahead -= se.match_length, se.strstart += se.match_length, se.match_length = 0) : (ne = s._tr_tally(se, 0, se.window[se.strstart]), se.lookahead--, se.strstart++), ne && (P(se, !1), se.strm.avail_out === 0)) return A;
            }
            return se.insert = 0, K === p ? (P(se, !0), se.strm.avail_out === 0 ? j : Q) : se.last_lit && (P(se, !1), se.strm.avail_out === 0) ? A : oe;
          }(Y, ge) : o[Y.level].func(Y, ge);
          if (ke !== j && ke !== Q || (Y.status = 666), ke === A || ke === j) return k.avail_out === 0 && (Y.last_flush = -1), y;
          if (ke === oe && (ge === 1 ? s._tr_align(Y) : ge !== 5 && (s._tr_stored_block(Y, 0, 0, !1), ge === 3 && (re(Y.head), Y.lookahead === 0 && (Y.strstart = 0, Y.block_start = 0, Y.insert = 0))), V(k), k.avail_out === 0)) return Y.last_flush = -1, y;
        }
        return ge !== p ? y : Y.wrap <= 0 ? 1 : (Y.wrap === 2 ? (pe(Y, 255 & k.adler), pe(Y, k.adler >> 8 & 255), pe(Y, k.adler >> 16 & 255), pe(Y, k.adler >> 24 & 255), pe(Y, 255 & k.total_in), pe(Y, k.total_in >> 8 & 255), pe(Y, k.total_in >> 16 & 255), pe(Y, k.total_in >> 24 & 255)) : (we(Y, k.adler >>> 16), we(Y, 65535 & k.adler)), V(k), 0 < Y.wrap && (Y.wrap = -Y.wrap), Y.pending !== 0 ? y : 1);
      }, i.deflateEnd = function(k) {
        var ge;
        return k && k.state ? (ge = k.state.status) !== M && ge !== 69 && ge !== 73 && ge !== 91 && ge !== 103 && ge !== ee && ge !== 666 ? G(k, b) : (k.state = null, ge === ee ? G(k, -3) : y) : b;
      }, i.deflateSetDictionary = function(k, ge) {
        var ue, Y, H, ae, Se, ke, se, K, ne = ge.length;
        if (!k || !k.state || (ae = (ue = k.state).wrap) === 2 || ae === 1 && ue.status !== M || ue.lookahead) return b;
        for (ae === 1 && (k.adler = l(k.adler, ge, ne, 0)), ue.wrap = 0, ne >= ue.w_size && (ae === 0 && (re(ue.head), ue.strstart = 0, ue.block_start = 0, ue.insert = 0), K = new a.Buf8(ue.w_size), a.arraySet(K, ge, ne - ue.w_size, ue.w_size, 0), ge = K, ne = ue.w_size), Se = k.avail_in, ke = k.next_in, se = k.input, k.avail_in = ne, k.next_in = 0, k.input = ge, _e(ue); ue.lookahead >= $; ) {
          for (Y = ue.strstart, H = ue.lookahead - ($ - 1); ue.ins_h = (ue.ins_h << ue.hash_shift ^ ue.window[Y + $ - 1]) & ue.hash_mask, ue.prev[Y & ue.w_mask] = ue.head[ue.ins_h], ue.head[ue.ins_h] = Y, Y++, --H; ) ;
          ue.strstart = Y, ue.lookahead = $ - 1, _e(ue);
        }
        return ue.strstart += ue.lookahead, ue.block_start = ue.strstart, ue.insert = ue.lookahead, ue.lookahead = 0, ue.match_length = ue.prev_length = $ - 1, ue.match_available = 0, k.next_in = ke, k.input = se, k.avail_in = Se, ue.wrap = ae, y;
      }, i.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(n, r, i) {
      r.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(n, r, i) {
      r.exports = function(o, a) {
        var s, l, u, f, h, p, y, b, x, v, D, S, E, I, R, O, N, q, $, le, ve, M, ee, A, oe;
        s = o.state, l = o.next_in, A = o.input, u = l + (o.avail_in - 5), f = o.next_out, oe = o.output, h = f - (a - o.avail_out), p = f + (o.avail_out - 257), y = s.dmax, b = s.wsize, x = s.whave, v = s.wnext, D = s.window, S = s.hold, E = s.bits, I = s.lencode, R = s.distcode, O = (1 << s.lenbits) - 1, N = (1 << s.distbits) - 1;
        e: do {
          E < 15 && (S += A[l++] << E, E += 8, S += A[l++] << E, E += 8), q = I[S & O];
          t: for (; ; ) {
            if (S >>>= $ = q >>> 24, E -= $, ($ = q >>> 16 & 255) === 0) oe[f++] = 65535 & q;
            else {
              if (!(16 & $)) {
                if (!(64 & $)) {
                  q = I[(65535 & q) + (S & (1 << $) - 1)];
                  continue t;
                }
                if (32 & $) {
                  s.mode = 12;
                  break e;
                }
                o.msg = "invalid literal/length code", s.mode = 30;
                break e;
              }
              le = 65535 & q, ($ &= 15) && (E < $ && (S += A[l++] << E, E += 8), le += S & (1 << $) - 1, S >>>= $, E -= $), E < 15 && (S += A[l++] << E, E += 8, S += A[l++] << E, E += 8), q = R[S & N];
              n: for (; ; ) {
                if (S >>>= $ = q >>> 24, E -= $, !(16 & ($ = q >>> 16 & 255))) {
                  if (!(64 & $)) {
                    q = R[(65535 & q) + (S & (1 << $) - 1)];
                    continue n;
                  }
                  o.msg = "invalid distance code", s.mode = 30;
                  break e;
                }
                if (ve = 65535 & q, E < ($ &= 15) && (S += A[l++] << E, (E += 8) < $ && (S += A[l++] << E, E += 8)), y < (ve += S & (1 << $) - 1)) {
                  o.msg = "invalid distance too far back", s.mode = 30;
                  break e;
                }
                if (S >>>= $, E -= $, ($ = f - h) < ve) {
                  if (x < ($ = ve - $) && s.sane) {
                    o.msg = "invalid distance too far back", s.mode = 30;
                    break e;
                  }
                  if (ee = D, (M = 0) === v) {
                    if (M += b - $, $ < le) {
                      for (le -= $; oe[f++] = D[M++], --$; ) ;
                      M = f - ve, ee = oe;
                    }
                  } else if (v < $) {
                    if (M += b + v - $, ($ -= v) < le) {
                      for (le -= $; oe[f++] = D[M++], --$; ) ;
                      if (M = 0, v < le) {
                        for (le -= $ = v; oe[f++] = D[M++], --$; ) ;
                        M = f - ve, ee = oe;
                      }
                    }
                  } else if (M += v - $, $ < le) {
                    for (le -= $; oe[f++] = D[M++], --$; ) ;
                    M = f - ve, ee = oe;
                  }
                  for (; 2 < le; ) oe[f++] = ee[M++], oe[f++] = ee[M++], oe[f++] = ee[M++], le -= 3;
                  le && (oe[f++] = ee[M++], 1 < le && (oe[f++] = ee[M++]));
                } else {
                  for (M = f - ve; oe[f++] = oe[M++], oe[f++] = oe[M++], oe[f++] = oe[M++], 2 < (le -= 3); ) ;
                  le && (oe[f++] = oe[M++], 1 < le && (oe[f++] = oe[M++]));
                }
                break;
              }
            }
            break;
          }
        } while (l < u && f < p);
        l -= le = E >> 3, S &= (1 << (E -= le << 3)) - 1, o.next_in = l, o.next_out = f, o.avail_in = l < u ? u - l + 5 : 5 - (l - u), o.avail_out = f < p ? p - f + 257 : 257 - (f - p), s.hold = S, s.bits = E;
      };
    }, {}], 49: [function(n, r, i) {
      var o = n("../utils/common"), a = n("./adler32"), s = n("./crc32"), l = n("./inffast"), u = n("./inftrees"), f = 1, h = 2, p = 0, y = -2, b = 1, x = 852, v = 592;
      function D(M) {
        return (M >>> 24 & 255) + (M >>> 8 & 65280) + ((65280 & M) << 8) + ((255 & M) << 24);
      }
      function S() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new o.Buf16(320), this.work = new o.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function E(M) {
        var ee;
        return M && M.state ? (ee = M.state, M.total_in = M.total_out = ee.total = 0, M.msg = "", ee.wrap && (M.adler = 1 & ee.wrap), ee.mode = b, ee.last = 0, ee.havedict = 0, ee.dmax = 32768, ee.head = null, ee.hold = 0, ee.bits = 0, ee.lencode = ee.lendyn = new o.Buf32(x), ee.distcode = ee.distdyn = new o.Buf32(v), ee.sane = 1, ee.back = -1, p) : y;
      }
      function I(M) {
        var ee;
        return M && M.state ? ((ee = M.state).wsize = 0, ee.whave = 0, ee.wnext = 0, E(M)) : y;
      }
      function R(M, ee) {
        var A, oe;
        return M && M.state ? (oe = M.state, ee < 0 ? (A = 0, ee = -ee) : (A = 1 + (ee >> 4), ee < 48 && (ee &= 15)), ee && (ee < 8 || 15 < ee) ? y : (oe.window !== null && oe.wbits !== ee && (oe.window = null), oe.wrap = A, oe.wbits = ee, I(M))) : y;
      }
      function O(M, ee) {
        var A, oe;
        return M ? (oe = new S(), (M.state = oe).window = null, (A = R(M, ee)) !== p && (M.state = null), A) : y;
      }
      var N, q, $ = !0;
      function le(M) {
        if ($) {
          var ee;
          for (N = new o.Buf32(512), q = new o.Buf32(32), ee = 0; ee < 144; ) M.lens[ee++] = 8;
          for (; ee < 256; ) M.lens[ee++] = 9;
          for (; ee < 280; ) M.lens[ee++] = 7;
          for (; ee < 288; ) M.lens[ee++] = 8;
          for (u(f, M.lens, 0, 288, N, 0, M.work, { bits: 9 }), ee = 0; ee < 32; ) M.lens[ee++] = 5;
          u(h, M.lens, 0, 32, q, 0, M.work, { bits: 5 }), $ = !1;
        }
        M.lencode = N, M.lenbits = 9, M.distcode = q, M.distbits = 5;
      }
      function ve(M, ee, A, oe) {
        var j, Q = M.state;
        return Q.window === null && (Q.wsize = 1 << Q.wbits, Q.wnext = 0, Q.whave = 0, Q.window = new o.Buf8(Q.wsize)), oe >= Q.wsize ? (o.arraySet(Q.window, ee, A - Q.wsize, Q.wsize, 0), Q.wnext = 0, Q.whave = Q.wsize) : (oe < (j = Q.wsize - Q.wnext) && (j = oe), o.arraySet(Q.window, ee, A - oe, j, Q.wnext), (oe -= j) ? (o.arraySet(Q.window, ee, A - oe, oe, 0), Q.wnext = oe, Q.whave = Q.wsize) : (Q.wnext += j, Q.wnext === Q.wsize && (Q.wnext = 0), Q.whave < Q.wsize && (Q.whave += j))), 0;
      }
      i.inflateReset = I, i.inflateReset2 = R, i.inflateResetKeep = E, i.inflateInit = function(M) {
        return O(M, 15);
      }, i.inflateInit2 = O, i.inflate = function(M, ee) {
        var A, oe, j, Q, G, Z, re, V, P, pe, we, be, _e, $e, Le, ze, tt, ie, Ee, Re, k, ge, ue, Y, H = 0, ae = new o.Buf8(4), Se = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!M || !M.state || !M.output || !M.input && M.avail_in !== 0) return y;
        (A = M.state).mode === 12 && (A.mode = 13), G = M.next_out, j = M.output, re = M.avail_out, Q = M.next_in, oe = M.input, Z = M.avail_in, V = A.hold, P = A.bits, pe = Z, we = re, ge = p;
        e: for (; ; ) switch (A.mode) {
          case b:
            if (A.wrap === 0) {
              A.mode = 13;
              break;
            }
            for (; P < 16; ) {
              if (Z === 0) break e;
              Z--, V += oe[Q++] << P, P += 8;
            }
            if (2 & A.wrap && V === 35615) {
              ae[A.check = 0] = 255 & V, ae[1] = V >>> 8 & 255, A.check = s(A.check, ae, 2, 0), P = V = 0, A.mode = 2;
              break;
            }
            if (A.flags = 0, A.head && (A.head.done = !1), !(1 & A.wrap) || (((255 & V) << 8) + (V >> 8)) % 31) {
              M.msg = "incorrect header check", A.mode = 30;
              break;
            }
            if ((15 & V) != 8) {
              M.msg = "unknown compression method", A.mode = 30;
              break;
            }
            if (P -= 4, k = 8 + (15 & (V >>>= 4)), A.wbits === 0) A.wbits = k;
            else if (k > A.wbits) {
              M.msg = "invalid window size", A.mode = 30;
              break;
            }
            A.dmax = 1 << k, M.adler = A.check = 1, A.mode = 512 & V ? 10 : 12, P = V = 0;
            break;
          case 2:
            for (; P < 16; ) {
              if (Z === 0) break e;
              Z--, V += oe[Q++] << P, P += 8;
            }
            if (A.flags = V, (255 & A.flags) != 8) {
              M.msg = "unknown compression method", A.mode = 30;
              break;
            }
            if (57344 & A.flags) {
              M.msg = "unknown header flags set", A.mode = 30;
              break;
            }
            A.head && (A.head.text = V >> 8 & 1), 512 & A.flags && (ae[0] = 255 & V, ae[1] = V >>> 8 & 255, A.check = s(A.check, ae, 2, 0)), P = V = 0, A.mode = 3;
          case 3:
            for (; P < 32; ) {
              if (Z === 0) break e;
              Z--, V += oe[Q++] << P, P += 8;
            }
            A.head && (A.head.time = V), 512 & A.flags && (ae[0] = 255 & V, ae[1] = V >>> 8 & 255, ae[2] = V >>> 16 & 255, ae[3] = V >>> 24 & 255, A.check = s(A.check, ae, 4, 0)), P = V = 0, A.mode = 4;
          case 4:
            for (; P < 16; ) {
              if (Z === 0) break e;
              Z--, V += oe[Q++] << P, P += 8;
            }
            A.head && (A.head.xflags = 255 & V, A.head.os = V >> 8), 512 & A.flags && (ae[0] = 255 & V, ae[1] = V >>> 8 & 255, A.check = s(A.check, ae, 2, 0)), P = V = 0, A.mode = 5;
          case 5:
            if (1024 & A.flags) {
              for (; P < 16; ) {
                if (Z === 0) break e;
                Z--, V += oe[Q++] << P, P += 8;
              }
              A.length = V, A.head && (A.head.extra_len = V), 512 & A.flags && (ae[0] = 255 & V, ae[1] = V >>> 8 & 255, A.check = s(A.check, ae, 2, 0)), P = V = 0;
            } else A.head && (A.head.extra = null);
            A.mode = 6;
          case 6:
            if (1024 & A.flags && (Z < (be = A.length) && (be = Z), be && (A.head && (k = A.head.extra_len - A.length, A.head.extra || (A.head.extra = new Array(A.head.extra_len)), o.arraySet(A.head.extra, oe, Q, be, k)), 512 & A.flags && (A.check = s(A.check, oe, be, Q)), Z -= be, Q += be, A.length -= be), A.length)) break e;
            A.length = 0, A.mode = 7;
          case 7:
            if (2048 & A.flags) {
              if (Z === 0) break e;
              for (be = 0; k = oe[Q + be++], A.head && k && A.length < 65536 && (A.head.name += String.fromCharCode(k)), k && be < Z; ) ;
              if (512 & A.flags && (A.check = s(A.check, oe, be, Q)), Z -= be, Q += be, k) break e;
            } else A.head && (A.head.name = null);
            A.length = 0, A.mode = 8;
          case 8:
            if (4096 & A.flags) {
              if (Z === 0) break e;
              for (be = 0; k = oe[Q + be++], A.head && k && A.length < 65536 && (A.head.comment += String.fromCharCode(k)), k && be < Z; ) ;
              if (512 & A.flags && (A.check = s(A.check, oe, be, Q)), Z -= be, Q += be, k) break e;
            } else A.head && (A.head.comment = null);
            A.mode = 9;
          case 9:
            if (512 & A.flags) {
              for (; P < 16; ) {
                if (Z === 0) break e;
                Z--, V += oe[Q++] << P, P += 8;
              }
              if (V !== (65535 & A.check)) {
                M.msg = "header crc mismatch", A.mode = 30;
                break;
              }
              P = V = 0;
            }
            A.head && (A.head.hcrc = A.flags >> 9 & 1, A.head.done = !0), M.adler = A.check = 0, A.mode = 12;
            break;
          case 10:
            for (; P < 32; ) {
              if (Z === 0) break e;
              Z--, V += oe[Q++] << P, P += 8;
            }
            M.adler = A.check = D(V), P = V = 0, A.mode = 11;
          case 11:
            if (A.havedict === 0) return M.next_out = G, M.avail_out = re, M.next_in = Q, M.avail_in = Z, A.hold = V, A.bits = P, 2;
            M.adler = A.check = 1, A.mode = 12;
          case 12:
            if (ee === 5 || ee === 6) break e;
          case 13:
            if (A.last) {
              V >>>= 7 & P, P -= 7 & P, A.mode = 27;
              break;
            }
            for (; P < 3; ) {
              if (Z === 0) break e;
              Z--, V += oe[Q++] << P, P += 8;
            }
            switch (A.last = 1 & V, P -= 1, 3 & (V >>>= 1)) {
              case 0:
                A.mode = 14;
                break;
              case 1:
                if (le(A), A.mode = 20, ee !== 6) break;
                V >>>= 2, P -= 2;
                break e;
              case 2:
                A.mode = 17;
                break;
              case 3:
                M.msg = "invalid block type", A.mode = 30;
            }
            V >>>= 2, P -= 2;
            break;
          case 14:
            for (V >>>= 7 & P, P -= 7 & P; P < 32; ) {
              if (Z === 0) break e;
              Z--, V += oe[Q++] << P, P += 8;
            }
            if ((65535 & V) != (V >>> 16 ^ 65535)) {
              M.msg = "invalid stored block lengths", A.mode = 30;
              break;
            }
            if (A.length = 65535 & V, P = V = 0, A.mode = 15, ee === 6) break e;
          case 15:
            A.mode = 16;
          case 16:
            if (be = A.length) {
              if (Z < be && (be = Z), re < be && (be = re), be === 0) break e;
              o.arraySet(j, oe, Q, be, G), Z -= be, Q += be, re -= be, G += be, A.length -= be;
              break;
            }
            A.mode = 12;
            break;
          case 17:
            for (; P < 14; ) {
              if (Z === 0) break e;
              Z--, V += oe[Q++] << P, P += 8;
            }
            if (A.nlen = 257 + (31 & V), V >>>= 5, P -= 5, A.ndist = 1 + (31 & V), V >>>= 5, P -= 5, A.ncode = 4 + (15 & V), V >>>= 4, P -= 4, 286 < A.nlen || 30 < A.ndist) {
              M.msg = "too many length or distance symbols", A.mode = 30;
              break;
            }
            A.have = 0, A.mode = 18;
          case 18:
            for (; A.have < A.ncode; ) {
              for (; P < 3; ) {
                if (Z === 0) break e;
                Z--, V += oe[Q++] << P, P += 8;
              }
              A.lens[Se[A.have++]] = 7 & V, V >>>= 3, P -= 3;
            }
            for (; A.have < 19; ) A.lens[Se[A.have++]] = 0;
            if (A.lencode = A.lendyn, A.lenbits = 7, ue = { bits: A.lenbits }, ge = u(0, A.lens, 0, 19, A.lencode, 0, A.work, ue), A.lenbits = ue.bits, ge) {
              M.msg = "invalid code lengths set", A.mode = 30;
              break;
            }
            A.have = 0, A.mode = 19;
          case 19:
            for (; A.have < A.nlen + A.ndist; ) {
              for (; ze = (H = A.lencode[V & (1 << A.lenbits) - 1]) >>> 16 & 255, tt = 65535 & H, !((Le = H >>> 24) <= P); ) {
                if (Z === 0) break e;
                Z--, V += oe[Q++] << P, P += 8;
              }
              if (tt < 16) V >>>= Le, P -= Le, A.lens[A.have++] = tt;
              else {
                if (tt === 16) {
                  for (Y = Le + 2; P < Y; ) {
                    if (Z === 0) break e;
                    Z--, V += oe[Q++] << P, P += 8;
                  }
                  if (V >>>= Le, P -= Le, A.have === 0) {
                    M.msg = "invalid bit length repeat", A.mode = 30;
                    break;
                  }
                  k = A.lens[A.have - 1], be = 3 + (3 & V), V >>>= 2, P -= 2;
                } else if (tt === 17) {
                  for (Y = Le + 3; P < Y; ) {
                    if (Z === 0) break e;
                    Z--, V += oe[Q++] << P, P += 8;
                  }
                  P -= Le, k = 0, be = 3 + (7 & (V >>>= Le)), V >>>= 3, P -= 3;
                } else {
                  for (Y = Le + 7; P < Y; ) {
                    if (Z === 0) break e;
                    Z--, V += oe[Q++] << P, P += 8;
                  }
                  P -= Le, k = 0, be = 11 + (127 & (V >>>= Le)), V >>>= 7, P -= 7;
                }
                if (A.have + be > A.nlen + A.ndist) {
                  M.msg = "invalid bit length repeat", A.mode = 30;
                  break;
                }
                for (; be--; ) A.lens[A.have++] = k;
              }
            }
            if (A.mode === 30) break;
            if (A.lens[256] === 0) {
              M.msg = "invalid code -- missing end-of-block", A.mode = 30;
              break;
            }
            if (A.lenbits = 9, ue = { bits: A.lenbits }, ge = u(f, A.lens, 0, A.nlen, A.lencode, 0, A.work, ue), A.lenbits = ue.bits, ge) {
              M.msg = "invalid literal/lengths set", A.mode = 30;
              break;
            }
            if (A.distbits = 6, A.distcode = A.distdyn, ue = { bits: A.distbits }, ge = u(h, A.lens, A.nlen, A.ndist, A.distcode, 0, A.work, ue), A.distbits = ue.bits, ge) {
              M.msg = "invalid distances set", A.mode = 30;
              break;
            }
            if (A.mode = 20, ee === 6) break e;
          case 20:
            A.mode = 21;
          case 21:
            if (6 <= Z && 258 <= re) {
              M.next_out = G, M.avail_out = re, M.next_in = Q, M.avail_in = Z, A.hold = V, A.bits = P, l(M, we), G = M.next_out, j = M.output, re = M.avail_out, Q = M.next_in, oe = M.input, Z = M.avail_in, V = A.hold, P = A.bits, A.mode === 12 && (A.back = -1);
              break;
            }
            for (A.back = 0; ze = (H = A.lencode[V & (1 << A.lenbits) - 1]) >>> 16 & 255, tt = 65535 & H, !((Le = H >>> 24) <= P); ) {
              if (Z === 0) break e;
              Z--, V += oe[Q++] << P, P += 8;
            }
            if (ze && !(240 & ze)) {
              for (ie = Le, Ee = ze, Re = tt; ze = (H = A.lencode[Re + ((V & (1 << ie + Ee) - 1) >> ie)]) >>> 16 & 255, tt = 65535 & H, !(ie + (Le = H >>> 24) <= P); ) {
                if (Z === 0) break e;
                Z--, V += oe[Q++] << P, P += 8;
              }
              V >>>= ie, P -= ie, A.back += ie;
            }
            if (V >>>= Le, P -= Le, A.back += Le, A.length = tt, ze === 0) {
              A.mode = 26;
              break;
            }
            if (32 & ze) {
              A.back = -1, A.mode = 12;
              break;
            }
            if (64 & ze) {
              M.msg = "invalid literal/length code", A.mode = 30;
              break;
            }
            A.extra = 15 & ze, A.mode = 22;
          case 22:
            if (A.extra) {
              for (Y = A.extra; P < Y; ) {
                if (Z === 0) break e;
                Z--, V += oe[Q++] << P, P += 8;
              }
              A.length += V & (1 << A.extra) - 1, V >>>= A.extra, P -= A.extra, A.back += A.extra;
            }
            A.was = A.length, A.mode = 23;
          case 23:
            for (; ze = (H = A.distcode[V & (1 << A.distbits) - 1]) >>> 16 & 255, tt = 65535 & H, !((Le = H >>> 24) <= P); ) {
              if (Z === 0) break e;
              Z--, V += oe[Q++] << P, P += 8;
            }
            if (!(240 & ze)) {
              for (ie = Le, Ee = ze, Re = tt; ze = (H = A.distcode[Re + ((V & (1 << ie + Ee) - 1) >> ie)]) >>> 16 & 255, tt = 65535 & H, !(ie + (Le = H >>> 24) <= P); ) {
                if (Z === 0) break e;
                Z--, V += oe[Q++] << P, P += 8;
              }
              V >>>= ie, P -= ie, A.back += ie;
            }
            if (V >>>= Le, P -= Le, A.back += Le, 64 & ze) {
              M.msg = "invalid distance code", A.mode = 30;
              break;
            }
            A.offset = tt, A.extra = 15 & ze, A.mode = 24;
          case 24:
            if (A.extra) {
              for (Y = A.extra; P < Y; ) {
                if (Z === 0) break e;
                Z--, V += oe[Q++] << P, P += 8;
              }
              A.offset += V & (1 << A.extra) - 1, V >>>= A.extra, P -= A.extra, A.back += A.extra;
            }
            if (A.offset > A.dmax) {
              M.msg = "invalid distance too far back", A.mode = 30;
              break;
            }
            A.mode = 25;
          case 25:
            if (re === 0) break e;
            if (be = we - re, A.offset > be) {
              if ((be = A.offset - be) > A.whave && A.sane) {
                M.msg = "invalid distance too far back", A.mode = 30;
                break;
              }
              _e = be > A.wnext ? (be -= A.wnext, A.wsize - be) : A.wnext - be, be > A.length && (be = A.length), $e = A.window;
            } else $e = j, _e = G - A.offset, be = A.length;
            for (re < be && (be = re), re -= be, A.length -= be; j[G++] = $e[_e++], --be; ) ;
            A.length === 0 && (A.mode = 21);
            break;
          case 26:
            if (re === 0) break e;
            j[G++] = A.length, re--, A.mode = 21;
            break;
          case 27:
            if (A.wrap) {
              for (; P < 32; ) {
                if (Z === 0) break e;
                Z--, V |= oe[Q++] << P, P += 8;
              }
              if (we -= re, M.total_out += we, A.total += we, we && (M.adler = A.check = A.flags ? s(A.check, j, we, G - we) : a(A.check, j, we, G - we)), we = re, (A.flags ? V : D(V)) !== A.check) {
                M.msg = "incorrect data check", A.mode = 30;
                break;
              }
              P = V = 0;
            }
            A.mode = 28;
          case 28:
            if (A.wrap && A.flags) {
              for (; P < 32; ) {
                if (Z === 0) break e;
                Z--, V += oe[Q++] << P, P += 8;
              }
              if (V !== (4294967295 & A.total)) {
                M.msg = "incorrect length check", A.mode = 30;
                break;
              }
              P = V = 0;
            }
            A.mode = 29;
          case 29:
            ge = 1;
            break e;
          case 30:
            ge = -3;
            break e;
          case 31:
            return -4;
          case 32:
          default:
            return y;
        }
        return M.next_out = G, M.avail_out = re, M.next_in = Q, M.avail_in = Z, A.hold = V, A.bits = P, (A.wsize || we !== M.avail_out && A.mode < 30 && (A.mode < 27 || ee !== 4)) && ve(M, M.output, M.next_out, we - M.avail_out) ? (A.mode = 31, -4) : (pe -= M.avail_in, we -= M.avail_out, M.total_in += pe, M.total_out += we, A.total += we, A.wrap && we && (M.adler = A.check = A.flags ? s(A.check, j, we, M.next_out - we) : a(A.check, j, we, M.next_out - we)), M.data_type = A.bits + (A.last ? 64 : 0) + (A.mode === 12 ? 128 : 0) + (A.mode === 20 || A.mode === 15 ? 256 : 0), (pe == 0 && we === 0 || ee === 4) && ge === p && (ge = -5), ge);
      }, i.inflateEnd = function(M) {
        if (!M || !M.state) return y;
        var ee = M.state;
        return ee.window && (ee.window = null), M.state = null, p;
      }, i.inflateGetHeader = function(M, ee) {
        var A;
        return M && M.state && 2 & (A = M.state).wrap ? ((A.head = ee).done = !1, p) : y;
      }, i.inflateSetDictionary = function(M, ee) {
        var A, oe = ee.length;
        return M && M.state ? (A = M.state).wrap !== 0 && A.mode !== 11 ? y : A.mode === 11 && a(1, ee, oe, 0) !== A.check ? -3 : ve(M, ee, oe, oe) ? (A.mode = 31, -4) : (A.havedict = 1, p) : y;
      }, i.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(n, r, i) {
      var o = n("../utils/common"), a = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], s = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], u = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      r.exports = function(f, h, p, y, b, x, v, D) {
        var S, E, I, R, O, N, q, $, le, ve = D.bits, M = 0, ee = 0, A = 0, oe = 0, j = 0, Q = 0, G = 0, Z = 0, re = 0, V = 0, P = null, pe = 0, we = new o.Buf16(16), be = new o.Buf16(16), _e = null, $e = 0;
        for (M = 0; M <= 15; M++) we[M] = 0;
        for (ee = 0; ee < y; ee++) we[h[p + ee]]++;
        for (j = ve, oe = 15; 1 <= oe && we[oe] === 0; oe--) ;
        if (oe < j && (j = oe), oe === 0) return b[x++] = 20971520, b[x++] = 20971520, D.bits = 1, 0;
        for (A = 1; A < oe && we[A] === 0; A++) ;
        for (j < A && (j = A), M = Z = 1; M <= 15; M++) if (Z <<= 1, (Z -= we[M]) < 0) return -1;
        if (0 < Z && (f === 0 || oe !== 1)) return -1;
        for (be[1] = 0, M = 1; M < 15; M++) be[M + 1] = be[M] + we[M];
        for (ee = 0; ee < y; ee++) h[p + ee] !== 0 && (v[be[h[p + ee]]++] = ee);
        if (N = f === 0 ? (P = _e = v, 19) : f === 1 ? (P = a, pe -= 257, _e = s, $e -= 257, 256) : (P = l, _e = u, -1), M = A, O = x, G = ee = V = 0, I = -1, R = (re = 1 << (Q = j)) - 1, f === 1 && 852 < re || f === 2 && 592 < re) return 1;
        for (; ; ) {
          for (q = M - G, le = v[ee] < N ? ($ = 0, v[ee]) : v[ee] > N ? ($ = _e[$e + v[ee]], P[pe + v[ee]]) : ($ = 96, 0), S = 1 << M - G, A = E = 1 << Q; b[O + (V >> G) + (E -= S)] = q << 24 | $ << 16 | le | 0, E !== 0; ) ;
          for (S = 1 << M - 1; V & S; ) S >>= 1;
          if (S !== 0 ? (V &= S - 1, V += S) : V = 0, ee++, --we[M] == 0) {
            if (M === oe) break;
            M = h[p + v[ee]];
          }
          if (j < M && (V & R) !== I) {
            for (G === 0 && (G = j), O += A, Z = 1 << (Q = M - G); Q + G < oe && !((Z -= we[Q + G]) <= 0); ) Q++, Z <<= 1;
            if (re += 1 << Q, f === 1 && 852 < re || f === 2 && 592 < re) return 1;
            b[I = V & R] = j << 24 | Q << 16 | O - x | 0;
          }
        }
        return V !== 0 && (b[O + V] = M - G << 24 | 64 << 16 | 0), D.bits = j, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(n, r, i) {
      r.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(n, r, i) {
      var o = n("../utils/common"), a = 0, s = 1;
      function l(H) {
        for (var ae = H.length; 0 <= --ae; ) H[ae] = 0;
      }
      var u = 0, f = 29, h = 256, p = h + 1 + f, y = 30, b = 19, x = 2 * p + 1, v = 15, D = 16, S = 7, E = 256, I = 16, R = 17, O = 18, N = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], q = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], $ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], le = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], ve = new Array(2 * (p + 2));
      l(ve);
      var M = new Array(2 * y);
      l(M);
      var ee = new Array(512);
      l(ee);
      var A = new Array(256);
      l(A);
      var oe = new Array(f);
      l(oe);
      var j, Q, G, Z = new Array(y);
      function re(H, ae, Se, ke, se) {
        this.static_tree = H, this.extra_bits = ae, this.extra_base = Se, this.elems = ke, this.max_length = se, this.has_stree = H && H.length;
      }
      function V(H, ae) {
        this.dyn_tree = H, this.max_code = 0, this.stat_desc = ae;
      }
      function P(H) {
        return H < 256 ? ee[H] : ee[256 + (H >>> 7)];
      }
      function pe(H, ae) {
        H.pending_buf[H.pending++] = 255 & ae, H.pending_buf[H.pending++] = ae >>> 8 & 255;
      }
      function we(H, ae, Se) {
        H.bi_valid > D - Se ? (H.bi_buf |= ae << H.bi_valid & 65535, pe(H, H.bi_buf), H.bi_buf = ae >> D - H.bi_valid, H.bi_valid += Se - D) : (H.bi_buf |= ae << H.bi_valid & 65535, H.bi_valid += Se);
      }
      function be(H, ae, Se) {
        we(H, Se[2 * ae], Se[2 * ae + 1]);
      }
      function _e(H, ae) {
        for (var Se = 0; Se |= 1 & H, H >>>= 1, Se <<= 1, 0 < --ae; ) ;
        return Se >>> 1;
      }
      function $e(H, ae, Se) {
        var ke, se, K = new Array(v + 1), ne = 0;
        for (ke = 1; ke <= v; ke++) K[ke] = ne = ne + Se[ke - 1] << 1;
        for (se = 0; se <= ae; se++) {
          var ce = H[2 * se + 1];
          ce !== 0 && (H[2 * se] = _e(K[ce]++, ce));
        }
      }
      function Le(H) {
        var ae;
        for (ae = 0; ae < p; ae++) H.dyn_ltree[2 * ae] = 0;
        for (ae = 0; ae < y; ae++) H.dyn_dtree[2 * ae] = 0;
        for (ae = 0; ae < b; ae++) H.bl_tree[2 * ae] = 0;
        H.dyn_ltree[2 * E] = 1, H.opt_len = H.static_len = 0, H.last_lit = H.matches = 0;
      }
      function ze(H) {
        8 < H.bi_valid ? pe(H, H.bi_buf) : 0 < H.bi_valid && (H.pending_buf[H.pending++] = H.bi_buf), H.bi_buf = 0, H.bi_valid = 0;
      }
      function tt(H, ae, Se, ke) {
        var se = 2 * ae, K = 2 * Se;
        return H[se] < H[K] || H[se] === H[K] && ke[ae] <= ke[Se];
      }
      function ie(H, ae, Se) {
        for (var ke = H.heap[Se], se = Se << 1; se <= H.heap_len && (se < H.heap_len && tt(ae, H.heap[se + 1], H.heap[se], H.depth) && se++, !tt(ae, ke, H.heap[se], H.depth)); ) H.heap[Se] = H.heap[se], Se = se, se <<= 1;
        H.heap[Se] = ke;
      }
      function Ee(H, ae, Se) {
        var ke, se, K, ne, ce = 0;
        if (H.last_lit !== 0) for (; ke = H.pending_buf[H.d_buf + 2 * ce] << 8 | H.pending_buf[H.d_buf + 2 * ce + 1], se = H.pending_buf[H.l_buf + ce], ce++, ke === 0 ? be(H, se, ae) : (be(H, (K = A[se]) + h + 1, ae), (ne = N[K]) !== 0 && we(H, se -= oe[K], ne), be(H, K = P(--ke), Se), (ne = q[K]) !== 0 && we(H, ke -= Z[K], ne)), ce < H.last_lit; ) ;
        be(H, E, ae);
      }
      function Re(H, ae) {
        var Se, ke, se, K = ae.dyn_tree, ne = ae.stat_desc.static_tree, ce = ae.stat_desc.has_stree, xe = ae.stat_desc.elems, Be = -1;
        for (H.heap_len = 0, H.heap_max = x, Se = 0; Se < xe; Se++) K[2 * Se] !== 0 ? (H.heap[++H.heap_len] = Be = Se, H.depth[Se] = 0) : K[2 * Se + 1] = 0;
        for (; H.heap_len < 2; ) K[2 * (se = H.heap[++H.heap_len] = Be < 2 ? ++Be : 0)] = 1, H.depth[se] = 0, H.opt_len--, ce && (H.static_len -= ne[2 * se + 1]);
        for (ae.max_code = Be, Se = H.heap_len >> 1; 1 <= Se; Se--) ie(H, K, Se);
        for (se = xe; Se = H.heap[1], H.heap[1] = H.heap[H.heap_len--], ie(H, K, 1), ke = H.heap[1], H.heap[--H.heap_max] = Se, H.heap[--H.heap_max] = ke, K[2 * se] = K[2 * Se] + K[2 * ke], H.depth[se] = (H.depth[Se] >= H.depth[ke] ? H.depth[Se] : H.depth[ke]) + 1, K[2 * Se + 1] = K[2 * ke + 1] = se, H.heap[1] = se++, ie(H, K, 1), 2 <= H.heap_len; ) ;
        H.heap[--H.heap_max] = H.heap[1], function(Me, Je) {
          var He, Ke, lt, nt, Bt, Bn, At = Je.dyn_tree, Ur = Je.max_code, xi = Je.stat_desc.static_tree, jt = Je.stat_desc.has_stree, Dn = Je.stat_desc.extra_bits, Mn = Je.stat_desc.extra_base, at = Je.stat_desc.max_length, on = 0;
          for (nt = 0; nt <= v; nt++) Me.bl_count[nt] = 0;
          for (At[2 * Me.heap[Me.heap_max] + 1] = 0, He = Me.heap_max + 1; He < x; He++) at < (nt = At[2 * At[2 * (Ke = Me.heap[He]) + 1] + 1] + 1) && (nt = at, on++), At[2 * Ke + 1] = nt, Ur < Ke || (Me.bl_count[nt]++, Bt = 0, Mn <= Ke && (Bt = Dn[Ke - Mn]), Bn = At[2 * Ke], Me.opt_len += Bn * (nt + Bt), jt && (Me.static_len += Bn * (xi[2 * Ke + 1] + Bt)));
          if (on !== 0) {
            do {
              for (nt = at - 1; Me.bl_count[nt] === 0; ) nt--;
              Me.bl_count[nt]--, Me.bl_count[nt + 1] += 2, Me.bl_count[at]--, on -= 2;
            } while (0 < on);
            for (nt = at; nt !== 0; nt--) for (Ke = Me.bl_count[nt]; Ke !== 0; ) Ur < (lt = Me.heap[--He]) || (At[2 * lt + 1] !== nt && (Me.opt_len += (nt - At[2 * lt + 1]) * At[2 * lt], At[2 * lt + 1] = nt), Ke--);
          }
        }(H, ae), $e(K, Be, H.bl_count);
      }
      function k(H, ae, Se) {
        var ke, se, K = -1, ne = ae[1], ce = 0, xe = 7, Be = 4;
        for (ne === 0 && (xe = 138, Be = 3), ae[2 * (Se + 1) + 1] = 65535, ke = 0; ke <= Se; ke++) se = ne, ne = ae[2 * (ke + 1) + 1], ++ce < xe && se === ne || (ce < Be ? H.bl_tree[2 * se] += ce : se !== 0 ? (se !== K && H.bl_tree[2 * se]++, H.bl_tree[2 * I]++) : ce <= 10 ? H.bl_tree[2 * R]++ : H.bl_tree[2 * O]++, K = se, Be = (ce = 0) === ne ? (xe = 138, 3) : se === ne ? (xe = 6, 3) : (xe = 7, 4));
      }
      function ge(H, ae, Se) {
        var ke, se, K = -1, ne = ae[1], ce = 0, xe = 7, Be = 4;
        for (ne === 0 && (xe = 138, Be = 3), ke = 0; ke <= Se; ke++) if (se = ne, ne = ae[2 * (ke + 1) + 1], !(++ce < xe && se === ne)) {
          if (ce < Be) for (; be(H, se, H.bl_tree), --ce != 0; ) ;
          else se !== 0 ? (se !== K && (be(H, se, H.bl_tree), ce--), be(H, I, H.bl_tree), we(H, ce - 3, 2)) : ce <= 10 ? (be(H, R, H.bl_tree), we(H, ce - 3, 3)) : (be(H, O, H.bl_tree), we(H, ce - 11, 7));
          K = se, Be = (ce = 0) === ne ? (xe = 138, 3) : se === ne ? (xe = 6, 3) : (xe = 7, 4);
        }
      }
      l(Z);
      var ue = !1;
      function Y(H, ae, Se, ke) {
        we(H, (u << 1) + (ke ? 1 : 0), 3), function(se, K, ne, ce) {
          ze(se), pe(se, ne), pe(se, ~ne), o.arraySet(se.pending_buf, se.window, K, ne, se.pending), se.pending += ne;
        }(H, ae, Se);
      }
      i._tr_init = function(H) {
        ue || (function() {
          var ae, Se, ke, se, K, ne = new Array(v + 1);
          for (se = ke = 0; se < f - 1; se++) for (oe[se] = ke, ae = 0; ae < 1 << N[se]; ae++) A[ke++] = se;
          for (A[ke - 1] = se, se = K = 0; se < 16; se++) for (Z[se] = K, ae = 0; ae < 1 << q[se]; ae++) ee[K++] = se;
          for (K >>= 7; se < y; se++) for (Z[se] = K << 7, ae = 0; ae < 1 << q[se] - 7; ae++) ee[256 + K++] = se;
          for (Se = 0; Se <= v; Se++) ne[Se] = 0;
          for (ae = 0; ae <= 143; ) ve[2 * ae + 1] = 8, ae++, ne[8]++;
          for (; ae <= 255; ) ve[2 * ae + 1] = 9, ae++, ne[9]++;
          for (; ae <= 279; ) ve[2 * ae + 1] = 7, ae++, ne[7]++;
          for (; ae <= 287; ) ve[2 * ae + 1] = 8, ae++, ne[8]++;
          for ($e(ve, p + 1, ne), ae = 0; ae < y; ae++) M[2 * ae + 1] = 5, M[2 * ae] = _e(ae, 5);
          j = new re(ve, N, h + 1, p, v), Q = new re(M, q, 0, y, v), G = new re(new Array(0), $, 0, b, S);
        }(), ue = !0), H.l_desc = new V(H.dyn_ltree, j), H.d_desc = new V(H.dyn_dtree, Q), H.bl_desc = new V(H.bl_tree, G), H.bi_buf = 0, H.bi_valid = 0, Le(H);
      }, i._tr_stored_block = Y, i._tr_flush_block = function(H, ae, Se, ke) {
        var se, K, ne = 0;
        0 < H.level ? (H.strm.data_type === 2 && (H.strm.data_type = function(ce) {
          var xe, Be = 4093624447;
          for (xe = 0; xe <= 31; xe++, Be >>>= 1) if (1 & Be && ce.dyn_ltree[2 * xe] !== 0) return a;
          if (ce.dyn_ltree[18] !== 0 || ce.dyn_ltree[20] !== 0 || ce.dyn_ltree[26] !== 0) return s;
          for (xe = 32; xe < h; xe++) if (ce.dyn_ltree[2 * xe] !== 0) return s;
          return a;
        }(H)), Re(H, H.l_desc), Re(H, H.d_desc), ne = function(ce) {
          var xe;
          for (k(ce, ce.dyn_ltree, ce.l_desc.max_code), k(ce, ce.dyn_dtree, ce.d_desc.max_code), Re(ce, ce.bl_desc), xe = b - 1; 3 <= xe && ce.bl_tree[2 * le[xe] + 1] === 0; xe--) ;
          return ce.opt_len += 3 * (xe + 1) + 5 + 5 + 4, xe;
        }(H), se = H.opt_len + 3 + 7 >>> 3, (K = H.static_len + 3 + 7 >>> 3) <= se && (se = K)) : se = K = Se + 5, Se + 4 <= se && ae !== -1 ? Y(H, ae, Se, ke) : H.strategy === 4 || K === se ? (we(H, 2 + (ke ? 1 : 0), 3), Ee(H, ve, M)) : (we(H, 4 + (ke ? 1 : 0), 3), function(ce, xe, Be, Me) {
          var Je;
          for (we(ce, xe - 257, 5), we(ce, Be - 1, 5), we(ce, Me - 4, 4), Je = 0; Je < Me; Je++) we(ce, ce.bl_tree[2 * le[Je] + 1], 3);
          ge(ce, ce.dyn_ltree, xe - 1), ge(ce, ce.dyn_dtree, Be - 1);
        }(H, H.l_desc.max_code + 1, H.d_desc.max_code + 1, ne + 1), Ee(H, H.dyn_ltree, H.dyn_dtree)), Le(H), ke && ze(H);
      }, i._tr_tally = function(H, ae, Se) {
        return H.pending_buf[H.d_buf + 2 * H.last_lit] = ae >>> 8 & 255, H.pending_buf[H.d_buf + 2 * H.last_lit + 1] = 255 & ae, H.pending_buf[H.l_buf + H.last_lit] = 255 & Se, H.last_lit++, ae === 0 ? H.dyn_ltree[2 * Se]++ : (H.matches++, ae--, H.dyn_ltree[2 * (A[Se] + h + 1)]++, H.dyn_dtree[2 * P(ae)]++), H.last_lit === H.lit_bufsize - 1;
      }, i._tr_align = function(H) {
        we(H, 2, 3), be(H, E, ve), function(ae) {
          ae.bi_valid === 16 ? (pe(ae, ae.bi_buf), ae.bi_buf = 0, ae.bi_valid = 0) : 8 <= ae.bi_valid && (ae.pending_buf[ae.pending++] = 255 & ae.bi_buf, ae.bi_buf >>= 8, ae.bi_valid -= 8);
        }(H);
      };
    }, { "../utils/common": 41 }], 53: [function(n, r, i) {
      r.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(n, r, i) {
      (function(o) {
        (function(a, s) {
          if (!a.setImmediate) {
            var l, u, f, h, p = 1, y = {}, b = !1, x = a.document, v = Object.getPrototypeOf && Object.getPrototypeOf(a);
            v = v && v.setTimeout ? v : a, l = {}.toString.call(a.process) === "[object process]" ? function(I) {
              process.nextTick(function() {
                S(I);
              });
            } : function() {
              if (a.postMessage && !a.importScripts) {
                var I = !0, R = a.onmessage;
                return a.onmessage = function() {
                  I = !1;
                }, a.postMessage("", "*"), a.onmessage = R, I;
              }
            }() ? (h = "setImmediate$" + Math.random() + "$", a.addEventListener ? a.addEventListener("message", E, !1) : a.attachEvent("onmessage", E), function(I) {
              a.postMessage(h + I, "*");
            }) : a.MessageChannel ? ((f = new MessageChannel()).port1.onmessage = function(I) {
              S(I.data);
            }, function(I) {
              f.port2.postMessage(I);
            }) : x && "onreadystatechange" in x.createElement("script") ? (u = x.documentElement, function(I) {
              var R = x.createElement("script");
              R.onreadystatechange = function() {
                S(I), R.onreadystatechange = null, u.removeChild(R), R = null;
              }, u.appendChild(R);
            }) : function(I) {
              setTimeout(S, 0, I);
            }, v.setImmediate = function(I) {
              typeof I != "function" && (I = new Function("" + I));
              for (var R = new Array(arguments.length - 1), O = 0; O < R.length; O++) R[O] = arguments[O + 1];
              var N = { callback: I, args: R };
              return y[p] = N, l(p), p++;
            }, v.clearImmediate = D;
          }
          function D(I) {
            delete y[I];
          }
          function S(I) {
            if (b) setTimeout(S, 0, I);
            else {
              var R = y[I];
              if (R) {
                b = !0;
                try {
                  (function(O) {
                    var N = O.callback, q = O.args;
                    switch (q.length) {
                      case 0:
                        N();
                        break;
                      case 1:
                        N(q[0]);
                        break;
                      case 2:
                        N(q[0], q[1]);
                        break;
                      case 3:
                        N(q[0], q[1], q[2]);
                        break;
                      default:
                        N.apply(s, q);
                    }
                  })(R);
                } finally {
                  D(I), b = !1;
                }
              }
            }
          }
          function E(I) {
            I.source === a && typeof I.data == "string" && I.data.indexOf(h) === 0 && S(+I.data.slice(h.length));
          }
        })(typeof self > "u" ? o === void 0 ? this : o : self);
      }).call(this, typeof it < "u" ? it : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(XF);
var xV = XF.exports, DV = zm, wV = xV;
Zd.openArrayBuffer = SV;
Zd.splitPath = TV;
Zd.joinPath = CV;
function SV(t) {
  return wV.loadAsync(t).then(function(e) {
    function n(a) {
      return e.file(a) !== null;
    }
    function r(a, s) {
      return e.file(a).async("uint8array").then(function(l) {
        if (s === "base64")
          return DV.fromByteArray(l);
        if (s) {
          var u = new TextDecoder(s);
          return u.decode(l);
        } else
          return l;
      });
    }
    function i(a, s) {
      e.file(a, s);
    }
    function o() {
      return e.generateAsync({ type: "arraybuffer" });
    }
    return {
      exists: n,
      read: r,
      write: i,
      toArrayBuffer: o
    };
  });
}
function TV(t) {
  var e = t.lastIndexOf("/");
  return e === -1 ? { dirname: "", basename: t } : {
    dirname: t.substring(0, e),
    basename: t.substring(e + 1)
  };
}
function CV() {
  var t = Array.prototype.filter.call(arguments, function(n) {
    return n;
  }), e = [];
  return t.forEach(function(n) {
    /^\//.test(n) ? e = [n] : e.push(n);
  }), e.join("/");
}
var Wx = {}, Jo = {}, Fu = {}, $m = $t;
Fu.Element = Ru;
Fu.element = function(t, e, n) {
  return new Ru(t, e, n);
};
Fu.text = function(t) {
  return {
    type: "text",
    value: t
  };
};
var GF = Fu.emptyElement = {
  first: function() {
    return null;
  },
  firstOrEmpty: function() {
    return GF;
  },
  attributes: {},
  children: []
};
function Ru(t, e, n) {
  this.type = "element", this.name = t, this.attributes = e || {}, this.children = n || [];
}
Ru.prototype.first = function(t) {
  return $m.find(this.children, function(e) {
    return e.name === t;
  });
};
Ru.prototype.firstOrEmpty = function(t) {
  return this.first(t) || GF;
};
Ru.prototype.getElementsByTagName = function(t) {
  var e = $m.filter(this.children, function(n) {
    return n.name === t;
  });
  return JF(e);
};
Ru.prototype.text = function() {
  if (this.children.length === 0)
    return "";
  if (this.children.length !== 1 || this.children[0].type !== "text")
    throw new Error("Not implemented");
  return this.children[0].value;
};
var EV = {
  getElementsByTagName: function(t) {
    return JF($m.flatten(this.map(function(e) {
      return e.getElementsByTagName(t);
    }, !0)));
  }
};
function JF(t) {
  return $m.extend(t, EV);
}
var YF = {}, Lx = {}, jm = {}, io = {}, Yo = {};
function _V(t, e, n) {
  if (n === void 0 && (n = Array.prototype), t && typeof n.find == "function")
    return n.find.call(t, e);
  for (var r = 0; r < t.length; r++)
    if (Object.prototype.hasOwnProperty.call(t, r)) {
      var i = t[r];
      if (e.call(void 0, i, r, t))
        return i;
    }
}
function zx(t, e) {
  return e === void 0 && (e = Object), e && typeof e.freeze == "function" ? e.freeze(t) : t;
}
function kV(t, e) {
  if (t === null || typeof t != "object")
    throw new TypeError("target is not an object");
  for (var n in e)
    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
  return t;
}
var ZF = zx({
  /**
   * `text/html`, the only mime type that triggers treating an XML document as HTML.
   *
   * @see DOMParser.SupportedType.isHTML
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
   */
  HTML: "text/html",
  /**
   * Helper method to check a mime type if it indicates an HTML document
   *
   * @param {string} [value]
   * @returns {boolean}
   *
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
  isHTML: function(t) {
    return t === ZF.HTML;
  },
  /**
   * `application/xml`, the standard mime type for XML documents.
   *
   * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
   * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_APPLICATION: "application/xml",
  /**
   * `text/html`, an alias for `application/xml`.
   *
   * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
   * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_TEXT: "text/xml",
  /**
   * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
   * but is parsed as an XML document.
   *
   * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
   * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
   */
  XML_XHTML_APPLICATION: "application/xhtml+xml",
  /**
   * `image/svg+xml`,
   *
   * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
   * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
   * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
   */
  XML_SVG_IMAGE: "image/svg+xml"
}), KF = zx({
  /**
   * The XHTML namespace.
   *
   * @see http://www.w3.org/1999/xhtml
   */
  HTML: "http://www.w3.org/1999/xhtml",
  /**
   * Checks if `uri` equals `NAMESPACE.HTML`.
   *
   * @param {string} [uri]
   *
   * @see NAMESPACE.HTML
   */
  isHTML: function(t) {
    return t === KF.HTML;
  },
  /**
   * The SVG namespace.
   *
   * @see http://www.w3.org/2000/svg
   */
  SVG: "http://www.w3.org/2000/svg",
  /**
   * The `xml:` namespace.
   *
   * @see http://www.w3.org/XML/1998/namespace
   */
  XML: "http://www.w3.org/XML/1998/namespace",
  /**
   * The `xmlns:` namespace
   *
   * @see https://www.w3.org/2000/xmlns/
   */
  XMLNS: "http://www.w3.org/2000/xmlns/"
});
Yo.assign = kV;
Yo.find = _V;
Yo.freeze = zx;
Yo.MIME_TYPE = ZF;
Yo.NAMESPACE = KF;
var QF = Yo, qi = QF.find, Bd = QF.NAMESPACE;
function AV(t) {
  return t !== "";
}
function UV(t) {
  return t ? t.split(/[\t\n\f\r ]+/).filter(AV) : [];
}
function FV(t, e) {
  return t.hasOwnProperty(e) || (t[e] = !0), t;
}
function HC(t) {
  if (!t) return [];
  var e = UV(t);
  return Object.keys(e.reduce(FV, {}));
}
function RV(t) {
  return function(e) {
    return t && t.indexOf(e) !== -1;
  };
}
function Kd(t, e) {
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
}
function gr(t, e) {
  var n = t.prototype;
  if (!(n instanceof e)) {
    let r = function() {
    };
    r.prototype = e.prototype, r = new r(), Kd(n, r), t.prototype = n = r;
  }
  n.constructor != t && (typeof t != "function" && console.error("unknown Class:" + t), n.constructor = t);
}
var mr = {}, pi = mr.ELEMENT_NODE = 1, pu = mr.ATTRIBUTE_NODE = 2, rm = mr.TEXT_NODE = 3, eR = mr.CDATA_SECTION_NODE = 4, tR = mr.ENTITY_REFERENCE_NODE = 5, OV = mr.ENTITY_NODE = 6, nR = mr.PROCESSING_INSTRUCTION_NODE = 7, rR = mr.COMMENT_NODE = 8, iR = mr.DOCUMENT_NODE = 9, oR = mr.DOCUMENT_TYPE_NODE = 10, Ho = mr.DOCUMENT_FRAGMENT_NODE = 11, IV = mr.NOTATION_NODE = 12, In = {}, nn = {};
In.INDEX_SIZE_ERR = (nn[1] = "Index size error", 1);
In.DOMSTRING_SIZE_ERR = (nn[2] = "DOMString size error", 2);
var cr = In.HIERARCHY_REQUEST_ERR = (nn[3] = "Hierarchy request error", 3);
In.WRONG_DOCUMENT_ERR = (nn[4] = "Wrong document", 4);
In.INVALID_CHARACTER_ERR = (nn[5] = "Invalid character", 5);
In.NO_DATA_ALLOWED_ERR = (nn[6] = "No data allowed", 6);
In.NO_MODIFICATION_ALLOWED_ERR = (nn[7] = "No modification allowed", 7);
var aR = In.NOT_FOUND_ERR = (nn[8] = "Not found", 8);
In.NOT_SUPPORTED_ERR = (nn[9] = "Not supported", 9);
var VC = In.INUSE_ATTRIBUTE_ERR = (nn[10] = "Attribute in use", 10);
In.INVALID_STATE_ERR = (nn[11] = "Invalid state", 11);
In.SYNTAX_ERR = (nn[12] = "Syntax error", 12);
In.INVALID_MODIFICATION_ERR = (nn[13] = "Invalid modification", 13);
In.NAMESPACE_ERR = (nn[14] = "Invalid namespace", 14);
In.INVALID_ACCESS_ERR = (nn[15] = "Invalid access", 15);
function zt(t, e) {
  if (e instanceof Error)
    var n = e;
  else
    n = this, Error.call(this, nn[t]), this.message = nn[t], Error.captureStackTrace && Error.captureStackTrace(this, zt);
  return n.code = t, e && (this.message = this.message + ": " + e), n;
}
zt.prototype = Error.prototype;
Kd(In, zt);
function Wo() {
}
Wo.prototype = {
  /**
   * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
   * @standard level1
   */
  length: 0,
  /**
   * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
   * @standard level1
   * @param index  unsigned long
   *   Index into the collection.
   * @return Node
   * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
   */
  item: function(t) {
    return t >= 0 && t < this.length ? this[t] : null;
  },
  toString: function(t, e) {
    for (var n = [], r = 0; r < this.length; r++)
      zc(this[r], n, t, e);
    return n.join("");
  },
  /**
   * @private
   * @param {function (Node):boolean} predicate
   * @returns {Node[]}
   */
  filter: function(t) {
    return Array.prototype.filter.call(this, t);
  },
  /**
   * @private
   * @param {Node} item
   * @returns {number}
   */
  indexOf: function(t) {
    return Array.prototype.indexOf.call(this, t);
  }
};
function gu(t, e) {
  this._node = t, this._refresh = e, $x(this);
}
function $x(t) {
  var e = t._node._inc || t._node.ownerDocument._inc;
  if (t._inc !== e) {
    var n = t._refresh(t._node);
    if (bR(t, "length", n.length), !t.$$length || n.length < t.$$length)
      for (var r = n.length; r in t; r++)
        Object.prototype.hasOwnProperty.call(t, r) && delete t[r];
    Kd(n, t), t._inc = e;
  }
}
gu.prototype.item = function(t) {
  return $x(this), this[t] || null;
};
gr(gu, Wo);
function im() {
}
function sR(t, e) {
  for (var n = t.length; n--; )
    if (t[n] === e)
      return n;
}
function qC(t, e, n, r) {
  if (r ? e[sR(e, r)] = n : e[e.length++] = n, t) {
    n.ownerElement = t;
    var i = t.ownerDocument;
    i && (r && uR(i, t, r), BV(i, t, n));
  }
}
function XC(t, e, n) {
  var r = sR(e, n);
  if (r >= 0) {
    for (var i = e.length - 1; r < i; )
      e[r] = e[++r];
    if (e.length = i, t) {
      var o = t.ownerDocument;
      o && (uR(o, t, n), n.ownerElement = null);
    }
  } else
    throw new zt(aR, new Error(t.tagName + "@" + n));
}
im.prototype = {
  length: 0,
  item: Wo.prototype.item,
  getNamedItem: function(t) {
    for (var e = this.length; e--; ) {
      var n = this[e];
      if (n.nodeName == t)
        return n;
    }
  },
  setNamedItem: function(t) {
    var e = t.ownerElement;
    if (e && e != this._ownerElement)
      throw new zt(VC);
    var n = this.getNamedItem(t.nodeName);
    return qC(this._ownerElement, this, t, n), n;
  },
  /* returns Node */
  setNamedItemNS: function(t) {
    var e = t.ownerElement, n;
    if (e && e != this._ownerElement)
      throw new zt(VC);
    return n = this.getNamedItemNS(t.namespaceURI, t.localName), qC(this._ownerElement, this, t, n), n;
  },
  /* returns Node */
  removeNamedItem: function(t) {
    var e = this.getNamedItem(t);
    return XC(this._ownerElement, this, e), e;
  },
  // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
  //for level2
  removeNamedItemNS: function(t, e) {
    var n = this.getNamedItemNS(t, e);
    return XC(this._ownerElement, this, n), n;
  },
  getNamedItemNS: function(t, e) {
    for (var n = this.length; n--; ) {
      var r = this[n];
      if (r.localName == e && r.namespaceURI == t)
        return r;
    }
    return null;
  }
};
function lR() {
}
lR.prototype = {
  /**
   * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
   * The different implementations fairly diverged in what kind of features were reported.
   * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
   *
   * @deprecated It is deprecated and modern browsers return true in all cases.
   *
   * @param {string} feature
   * @param {string} [version]
   * @returns {boolean} always true
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
   * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
   */
  hasFeature: function(t, e) {
    return !0;
  },
  /**
   * Creates an XML Document object of the specified type with its document element.
   *
   * __It behaves slightly different from the description in the living standard__:
   * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
   * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string|null} namespaceURI
   * @param {string} qualifiedName
   * @param {DocumentType=null} doctype
   * @returns {Document}
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocument: function(t, e, n) {
    var r = new Qd();
    if (r.implementation = this, r.childNodes = new Wo(), r.doctype = n || null, n && r.appendChild(n), e) {
      var i = r.createElementNS(t, e);
      r.appendChild(i);
    }
    return r;
  },
  /**
   * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
   *
   * __This behavior is slightly different from the in the specs__:
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string} qualifiedName
   * @param {string} [publicId]
   * @param {string} [systemId]
   * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
   * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocumentType: function(t, e, n) {
    var r = new Hm();
    return r.name = t, r.nodeName = t, r.publicId = e || "", r.systemId = n || "", r;
  }
};
function vt() {
}
vt.prototype = {
  firstChild: null,
  lastChild: null,
  previousSibling: null,
  nextSibling: null,
  attributes: null,
  parentNode: null,
  childNodes: null,
  ownerDocument: null,
  nodeValue: null,
  namespaceURI: null,
  prefix: null,
  localName: null,
  // Modified in DOM Level 2:
  insertBefore: function(t, e) {
    return om(this, t, e);
  },
  replaceChild: function(t, e) {
    om(this, t, e, dR), e && this.removeChild(e);
  },
  removeChild: function(t) {
    return fR(this, t);
  },
  appendChild: function(t) {
    return this.insertBefore(t, null);
  },
  hasChildNodes: function() {
    return this.firstChild != null;
  },
  cloneNode: function(t) {
    return j0(this.ownerDocument || this, this, t);
  },
  // Modified in DOM Level 2:
  normalize: function() {
    for (var t = this.firstChild; t; ) {
      var e = t.nextSibling;
      e && e.nodeType == rm && t.nodeType == rm ? (this.removeChild(e), t.appendData(e.data)) : (t.normalize(), t = e);
    }
  },
  // Introduced in DOM Level 2:
  isSupported: function(t, e) {
    return this.ownerDocument.implementation.hasFeature(t, e);
  },
  // Introduced in DOM Level 2:
  hasAttributes: function() {
    return this.attributes.length > 0;
  },
  /**
   * Look up the prefix associated to the given namespace URI, starting from this node.
   * **The default namespace declarations are ignored by this method.**
   * See Namespace Prefix Lookup for details on the algorithm used by this method.
   *
   * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
   *
   * @param {string | null} namespaceURI
   * @returns {string | null}
   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
   * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
   * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
   * @see https://github.com/xmldom/xmldom/issues/322
   */
  lookupPrefix: function(t) {
    for (var e = this; e; ) {
      var n = e._nsMap;
      if (n) {
        for (var r in n)
          if (Object.prototype.hasOwnProperty.call(n, r) && n[r] === t)
            return r;
      }
      e = e.nodeType == pu ? e.ownerDocument : e.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  lookupNamespaceURI: function(t) {
    for (var e = this; e; ) {
      var n = e._nsMap;
      if (n && Object.prototype.hasOwnProperty.call(n, t))
        return n[t];
      e = e.nodeType == pu ? e.ownerDocument : e.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  isDefaultNamespace: function(t) {
    var e = this.lookupPrefix(t);
    return e == null;
  }
};
function cR(t) {
  return t == "<" && "&lt;" || t == ">" && "&gt;" || t == "&" && "&amp;" || t == '"' && "&quot;" || "&#" + t.charCodeAt() + ";";
}
Kd(mr, vt);
Kd(mr, vt.prototype);
function Md(t, e) {
  if (e(t))
    return !0;
  if (t = t.firstChild)
    do
      if (Md(t, e))
        return !0;
    while (t = t.nextSibling);
}
function Qd() {
  this.ownerDocument = this;
}
function BV(t, e, n) {
  t && t._inc++;
  var r = n.namespaceURI;
  r === Bd.XMLNS && (e._nsMap[n.prefix ? n.localName : ""] = n.value);
}
function uR(t, e, n, r) {
  t && t._inc++;
  var i = n.namespaceURI;
  i === Bd.XMLNS && delete e._nsMap[n.prefix ? n.localName : ""];
}
function jx(t, e, n) {
  if (t && t._inc) {
    t._inc++;
    var r = e.childNodes;
    if (n)
      r[r.length++] = n;
    else {
      for (var i = e.firstChild, o = 0; i; )
        r[o++] = i, i = i.nextSibling;
      r.length = o, delete r[r.length];
    }
  }
}
function fR(t, e) {
  var n = e.previousSibling, r = e.nextSibling;
  return n ? n.nextSibling = r : t.firstChild = r, r ? r.previousSibling = n : t.lastChild = n, e.parentNode = null, e.previousSibling = null, e.nextSibling = null, jx(t.ownerDocument, t), e;
}
function MV(t) {
  return t && (t.nodeType === vt.DOCUMENT_NODE || t.nodeType === vt.DOCUMENT_FRAGMENT_NODE || t.nodeType === vt.ELEMENT_NODE);
}
function NV(t) {
  return t && (Xi(t) || Hx(t) || Vo(t) || t.nodeType === vt.DOCUMENT_FRAGMENT_NODE || t.nodeType === vt.COMMENT_NODE || t.nodeType === vt.PROCESSING_INSTRUCTION_NODE);
}
function Vo(t) {
  return t && t.nodeType === vt.DOCUMENT_TYPE_NODE;
}
function Xi(t) {
  return t && t.nodeType === vt.ELEMENT_NODE;
}
function Hx(t) {
  return t && t.nodeType === vt.TEXT_NODE;
}
function GC(t, e) {
  var n = t.childNodes || [];
  if (qi(n, Xi) || Vo(e))
    return !1;
  var r = qi(n, Vo);
  return !(e && r && n.indexOf(r) > n.indexOf(e));
}
function JC(t, e) {
  var n = t.childNodes || [];
  function r(o) {
    return Xi(o) && o !== e;
  }
  if (qi(n, r))
    return !1;
  var i = qi(n, Vo);
  return !(e && i && n.indexOf(i) > n.indexOf(e));
}
function PV(t, e, n) {
  if (!MV(t))
    throw new zt(cr, "Unexpected parent node type " + t.nodeType);
  if (n && n.parentNode !== t)
    throw new zt(aR, "child not in parent");
  if (
    // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
    !NV(e) || // 5. If either `node` is a Text node and `parent` is a document,
    // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
    // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
    // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
    Vo(e) && t.nodeType !== vt.DOCUMENT_NODE
  )
    throw new zt(
      cr,
      "Unexpected node type " + e.nodeType + " for parent node type " + t.nodeType
    );
}
function WV(t, e, n) {
  var r = t.childNodes || [], i = e.childNodes || [];
  if (e.nodeType === vt.DOCUMENT_FRAGMENT_NODE) {
    var o = i.filter(Xi);
    if (o.length > 1 || qi(i, Hx))
      throw new zt(cr, "More than one element or text in fragment");
    if (o.length === 1 && !GC(t, n))
      throw new zt(cr, "Element in fragment can not be inserted before doctype");
  }
  if (Xi(e) && !GC(t, n))
    throw new zt(cr, "Only one element can be added and only after doctype");
  if (Vo(e)) {
    if (qi(r, Vo))
      throw new zt(cr, "Only one doctype is allowed");
    var a = qi(r, Xi);
    if (n && r.indexOf(a) < r.indexOf(n))
      throw new zt(cr, "Doctype can only be inserted before an element");
    if (!n && a)
      throw new zt(cr, "Doctype can not be appended since element is present");
  }
}
function dR(t, e, n) {
  var r = t.childNodes || [], i = e.childNodes || [];
  if (e.nodeType === vt.DOCUMENT_FRAGMENT_NODE) {
    var o = i.filter(Xi);
    if (o.length > 1 || qi(i, Hx))
      throw new zt(cr, "More than one element or text in fragment");
    if (o.length === 1 && !JC(t, n))
      throw new zt(cr, "Element in fragment can not be inserted before doctype");
  }
  if (Xi(e) && !JC(t, n))
    throw new zt(cr, "Only one element can be added and only after doctype");
  if (Vo(e)) {
    if (qi(r, function(l) {
      return Vo(l) && l !== n;
    }))
      throw new zt(cr, "Only one doctype is allowed");
    var a = qi(r, Xi);
    if (n && r.indexOf(a) < r.indexOf(n))
      throw new zt(cr, "Doctype can only be inserted before an element");
  }
}
function om(t, e, n, r) {
  PV(t, e, n), t.nodeType === vt.DOCUMENT_NODE && (r || WV)(t, e, n);
  var i = e.parentNode;
  if (i && i.removeChild(e), e.nodeType === Ho) {
    var o = e.firstChild;
    if (o == null)
      return e;
    var a = e.lastChild;
  } else
    o = a = e;
  var s = n ? n.previousSibling : t.lastChild;
  o.previousSibling = s, a.nextSibling = n, s ? s.nextSibling = o : t.firstChild = o, n == null ? t.lastChild = a : n.previousSibling = a;
  do
    o.parentNode = t;
  while (o !== a && (o = o.nextSibling));
  return jx(t.ownerDocument || t, t), e.nodeType == Ho && (e.firstChild = e.lastChild = null), e;
}
function LV(t, e) {
  return e.parentNode && e.parentNode.removeChild(e), e.parentNode = t, e.previousSibling = t.lastChild, e.nextSibling = null, e.previousSibling ? e.previousSibling.nextSibling = e : t.firstChild = e, t.lastChild = e, jx(t.ownerDocument, t, e), e;
}
Qd.prototype = {
  //implementation : null,
  nodeName: "#document",
  nodeType: iR,
  /**
   * The DocumentType node of the document.
   *
   * @readonly
   * @type DocumentType
   */
  doctype: null,
  documentElement: null,
  _inc: 1,
  insertBefore: function(t, e) {
    if (t.nodeType == Ho) {
      for (var n = t.firstChild; n; ) {
        var r = n.nextSibling;
        this.insertBefore(n, e), n = r;
      }
      return t;
    }
    return om(this, t, e), t.ownerDocument = this, this.documentElement === null && t.nodeType === pi && (this.documentElement = t), t;
  },
  removeChild: function(t) {
    return this.documentElement == t && (this.documentElement = null), fR(this, t);
  },
  replaceChild: function(t, e) {
    om(this, t, e, dR), t.ownerDocument = this, e && this.removeChild(e), Xi(t) && (this.documentElement = t);
  },
  // Introduced in DOM Level 2:
  importNode: function(t, e) {
    return yR(this, t, e);
  },
  // Introduced in DOM Level 2:
  getElementById: function(t) {
    var e = null;
    return Md(this.documentElement, function(n) {
      if (n.nodeType == pi && n.getAttribute("id") == t)
        return e = n, !0;
    }), e;
  },
  /**
   * The `getElementsByClassName` method of `Document` interface returns an array-like object
   * of all child elements which have **all** of the given class name(s).
   *
   * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
   *
   *
   * Warning: This is a live LiveNodeList.
   * Changes in the DOM will reflect in the array as the changes occur.
   * If an element selected by this array no longer qualifies for the selector,
   * it will automatically be removed. Be aware of this for iteration purposes.
   *
   * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
   * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
   */
  getElementsByClassName: function(t) {
    var e = HC(t);
    return new gu(this, function(n) {
      var r = [];
      return e.length > 0 && Md(n.documentElement, function(i) {
        if (i !== n && i.nodeType === pi) {
          var o = i.getAttribute("class");
          if (o) {
            var a = t === o;
            if (!a) {
              var s = HC(o);
              a = e.every(RV(s));
            }
            a && r.push(i);
          }
        }
      }), r;
    });
  },
  //document factory method:
  createElement: function(t) {
    var e = new ml();
    e.ownerDocument = this, e.nodeName = t, e.tagName = t, e.localName = t, e.childNodes = new Wo();
    var n = e.attributes = new im();
    return n._ownerElement = e, e;
  },
  createDocumentFragment: function() {
    var t = new Vm();
    return t.ownerDocument = this, t.childNodes = new Wo(), t;
  },
  createTextNode: function(t) {
    var e = new Vx();
    return e.ownerDocument = this, e.appendData(t), e;
  },
  createComment: function(t) {
    var e = new qx();
    return e.ownerDocument = this, e.appendData(t), e;
  },
  createCDATASection: function(t) {
    var e = new Xx();
    return e.ownerDocument = this, e.appendData(t), e;
  },
  createProcessingInstruction: function(t, e) {
    var n = new Jx();
    return n.ownerDocument = this, n.tagName = n.nodeName = n.target = t, n.nodeValue = n.data = e, n;
  },
  createAttribute: function(t) {
    var e = new am();
    return e.ownerDocument = this, e.name = t, e.nodeName = t, e.localName = t, e.specified = !0, e;
  },
  createEntityReference: function(t) {
    var e = new Gx();
    return e.ownerDocument = this, e.nodeName = t, e;
  },
  // Introduced in DOM Level 2:
  createElementNS: function(t, e) {
    var n = new ml(), r = e.split(":"), i = n.attributes = new im();
    return n.childNodes = new Wo(), n.ownerDocument = this, n.nodeName = e, n.tagName = e, n.namespaceURI = t, r.length == 2 ? (n.prefix = r[0], n.localName = r[1]) : n.localName = e, i._ownerElement = n, n;
  },
  // Introduced in DOM Level 2:
  createAttributeNS: function(t, e) {
    var n = new am(), r = e.split(":");
    return n.ownerDocument = this, n.nodeName = e, n.name = e, n.namespaceURI = t, n.specified = !0, r.length == 2 ? (n.prefix = r[0], n.localName = r[1]) : n.localName = e, n;
  }
};
gr(Qd, vt);
function ml() {
  this._nsMap = {};
}
ml.prototype = {
  nodeType: pi,
  hasAttribute: function(t) {
    return this.getAttributeNode(t) != null;
  },
  getAttribute: function(t) {
    var e = this.getAttributeNode(t);
    return e && e.value || "";
  },
  getAttributeNode: function(t) {
    return this.attributes.getNamedItem(t);
  },
  setAttribute: function(t, e) {
    var n = this.ownerDocument.createAttribute(t);
    n.value = n.nodeValue = "" + e, this.setAttributeNode(n);
  },
  removeAttribute: function(t) {
    var e = this.getAttributeNode(t);
    e && this.removeAttributeNode(e);
  },
  //four real opeartion method
  appendChild: function(t) {
    return t.nodeType === Ho ? this.insertBefore(t, null) : LV(this, t);
  },
  setAttributeNode: function(t) {
    return this.attributes.setNamedItem(t);
  },
  setAttributeNodeNS: function(t) {
    return this.attributes.setNamedItemNS(t);
  },
  removeAttributeNode: function(t) {
    return this.attributes.removeNamedItem(t.nodeName);
  },
  //get real attribute name,and remove it by removeAttributeNode
  removeAttributeNS: function(t, e) {
    var n = this.getAttributeNodeNS(t, e);
    n && this.removeAttributeNode(n);
  },
  hasAttributeNS: function(t, e) {
    return this.getAttributeNodeNS(t, e) != null;
  },
  getAttributeNS: function(t, e) {
    var n = this.getAttributeNodeNS(t, e);
    return n && n.value || "";
  },
  setAttributeNS: function(t, e, n) {
    var r = this.ownerDocument.createAttributeNS(t, e);
    r.value = r.nodeValue = "" + n, this.setAttributeNode(r);
  },
  getAttributeNodeNS: function(t, e) {
    return this.attributes.getNamedItemNS(t, e);
  },
  getElementsByTagName: function(t) {
    return new gu(this, function(e) {
      var n = [];
      return Md(e, function(r) {
        r !== e && r.nodeType == pi && (t === "*" || r.tagName == t) && n.push(r);
      }), n;
    });
  },
  getElementsByTagNameNS: function(t, e) {
    return new gu(this, function(n) {
      var r = [];
      return Md(n, function(i) {
        i !== n && i.nodeType === pi && (t === "*" || i.namespaceURI === t) && (e === "*" || i.localName == e) && r.push(i);
      }), r;
    });
  }
};
Qd.prototype.getElementsByTagName = ml.prototype.getElementsByTagName;
Qd.prototype.getElementsByTagNameNS = ml.prototype.getElementsByTagNameNS;
gr(ml, vt);
function am() {
}
am.prototype.nodeType = pu;
gr(am, vt);
function eh() {
}
eh.prototype = {
  data: "",
  substringData: function(t, e) {
    return this.data.substring(t, t + e);
  },
  appendData: function(t) {
    t = this.data + t, this.nodeValue = this.data = t, this.length = t.length;
  },
  insertData: function(t, e) {
    this.replaceData(t, 0, e);
  },
  appendChild: function(t) {
    throw new Error(nn[cr]);
  },
  deleteData: function(t, e) {
    this.replaceData(t, e, "");
  },
  replaceData: function(t, e, n) {
    var r = this.data.substring(0, t), i = this.data.substring(t + e);
    n = r + n + i, this.nodeValue = this.data = n, this.length = n.length;
  }
};
gr(eh, vt);
function Vx() {
}
Vx.prototype = {
  nodeName: "#text",
  nodeType: rm,
  splitText: function(t) {
    var e = this.data, n = e.substring(t);
    e = e.substring(0, t), this.data = this.nodeValue = e, this.length = e.length;
    var r = this.ownerDocument.createTextNode(n);
    return this.parentNode && this.parentNode.insertBefore(r, this.nextSibling), r;
  }
};
gr(Vx, eh);
function qx() {
}
qx.prototype = {
  nodeName: "#comment",
  nodeType: rR
};
gr(qx, eh);
function Xx() {
}
Xx.prototype = {
  nodeName: "#cdata-section",
  nodeType: eR
};
gr(Xx, eh);
function Hm() {
}
Hm.prototype.nodeType = oR;
gr(Hm, vt);
function hR() {
}
hR.prototype.nodeType = IV;
gr(hR, vt);
function pR() {
}
pR.prototype.nodeType = OV;
gr(pR, vt);
function Gx() {
}
Gx.prototype.nodeType = tR;
gr(Gx, vt);
function Vm() {
}
Vm.prototype.nodeName = "#document-fragment";
Vm.prototype.nodeType = Ho;
gr(Vm, vt);
function Jx() {
}
Jx.prototype.nodeType = nR;
gr(Jx, vt);
function gR() {
}
gR.prototype.serializeToString = function(t, e, n) {
  return mR.call(t, e, n);
};
vt.prototype.toString = mR;
function mR(t, e) {
  var n = [], r = this.nodeType == 9 && this.documentElement || this, i = r.prefix, o = r.namespaceURI;
  if (o && i == null) {
    var i = r.lookupPrefix(o);
    if (i == null)
      var a = [
        { namespace: o, prefix: null }
        //{namespace:uri,prefix:''}
      ];
  }
  return zc(this, n, t, e, a), n.join("");
}
function YC(t, e, n) {
  var r = t.prefix || "", i = t.namespaceURI;
  if (!i || r === "xml" && i === Bd.XML || i === Bd.XMLNS)
    return !1;
  for (var o = n.length; o--; ) {
    var a = n[o];
    if (a.prefix === r)
      return a.namespace !== i;
  }
  return !0;
}
function Zv(t, e, n) {
  t.push(" ", e, '="', n.replace(/[<>&"\t\n\r]/g, cR), '"');
}
function zc(t, e, n, r, i) {
  if (i || (i = []), r)
    if (t = r(t), t) {
      if (typeof t == "string") {
        e.push(t);
        return;
      }
    } else
      return;
  switch (t.nodeType) {
    case pi:
      var o = t.attributes, a = o.length, D = t.firstChild, s = t.tagName;
      n = Bd.isHTML(t.namespaceURI) || n;
      var l = s;
      if (!n && !t.prefix && t.namespaceURI) {
        for (var u, f = 0; f < o.length; f++)
          if (o.item(f).name === "xmlns") {
            u = o.item(f).value;
            break;
          }
        if (!u)
          for (var h = i.length - 1; h >= 0; h--) {
            var p = i[h];
            if (p.prefix === "" && p.namespace === t.namespaceURI) {
              u = p.namespace;
              break;
            }
          }
        if (u !== t.namespaceURI)
          for (var h = i.length - 1; h >= 0; h--) {
            var p = i[h];
            if (p.namespace === t.namespaceURI) {
              p.prefix && (l = p.prefix + ":" + s);
              break;
            }
          }
      }
      e.push("<", l);
      for (var y = 0; y < a; y++) {
        var b = o.item(y);
        b.prefix == "xmlns" ? i.push({ prefix: b.localName, namespace: b.value }) : b.nodeName == "xmlns" && i.push({ prefix: "", namespace: b.value });
      }
      for (var y = 0; y < a; y++) {
        var b = o.item(y);
        if (YC(b, n, i)) {
          var x = b.prefix || "", v = b.namespaceURI;
          Zv(e, x ? "xmlns:" + x : "xmlns", v), i.push({ prefix: x, namespace: v });
        }
        zc(b, e, n, r, i);
      }
      if (s === l && YC(t, n, i)) {
        var x = t.prefix || "", v = t.namespaceURI;
        Zv(e, x ? "xmlns:" + x : "xmlns", v), i.push({ prefix: x, namespace: v });
      }
      if (D || n && !/^(?:meta|link|img|br|hr|input)$/i.test(s)) {
        if (e.push(">"), n && /^script$/i.test(s))
          for (; D; )
            D.data ? e.push(D.data) : zc(D, e, n, r, i.slice()), D = D.nextSibling;
        else
          for (; D; )
            zc(D, e, n, r, i.slice()), D = D.nextSibling;
        e.push("</", l, ">");
      } else
        e.push("/>");
      return;
    case iR:
    case Ho:
      for (var D = t.firstChild; D; )
        zc(D, e, n, r, i.slice()), D = D.nextSibling;
      return;
    case pu:
      return Zv(e, t.name, t.value);
    case rm:
      return e.push(
        t.data.replace(/[<&>]/g, cR)
      );
    case eR:
      return e.push("<![CDATA[", t.data, "]]>");
    case rR:
      return e.push("<!--", t.data, "-->");
    case oR:
      var S = t.publicId, E = t.systemId;
      if (e.push("<!DOCTYPE ", t.name), S)
        e.push(" PUBLIC ", S), E && E != "." && e.push(" ", E), e.push(">");
      else if (E && E != ".")
        e.push(" SYSTEM ", E, ">");
      else {
        var I = t.internalSubset;
        I && e.push(" [", I, "]"), e.push(">");
      }
      return;
    case nR:
      return e.push("<?", t.target, " ", t.data, "?>");
    case tR:
      return e.push("&", t.nodeName, ";");
    default:
      e.push("??", t.nodeName);
  }
}
function yR(t, e, n) {
  var r;
  switch (e.nodeType) {
    case pi:
      r = e.cloneNode(!1), r.ownerDocument = t;
    case Ho:
      break;
    case pu:
      n = !0;
      break;
  }
  if (r || (r = e.cloneNode(!1)), r.ownerDocument = t, r.parentNode = null, n)
    for (var i = e.firstChild; i; )
      r.appendChild(yR(t, i, n)), i = i.nextSibling;
  return r;
}
function j0(t, e, n) {
  var r = new e.constructor();
  for (var i in e)
    if (Object.prototype.hasOwnProperty.call(e, i)) {
      var o = e[i];
      typeof o != "object" && o != r[i] && (r[i] = o);
    }
  switch (e.childNodes && (r.childNodes = new Wo()), r.ownerDocument = t, r.nodeType) {
    case pi:
      var a = e.attributes, s = r.attributes = new im(), l = a.length;
      s._ownerElement = r;
      for (var u = 0; u < l; u++)
        r.setAttributeNode(j0(t, a.item(u), !0));
      break;
    case pu:
      n = !0;
  }
  if (n)
    for (var f = e.firstChild; f; )
      r.appendChild(j0(t, f, n)), f = f.nextSibling;
  return r;
}
function bR(t, e, n) {
  t[e] = n;
}
try {
  if (Object.defineProperty) {
    let t = function(e) {
      switch (e.nodeType) {
        case pi:
        case Ho:
          var n = [];
          for (e = e.firstChild; e; )
            e.nodeType !== 7 && e.nodeType !== 8 && n.push(t(e)), e = e.nextSibling;
          return n.join("");
        default:
          return e.nodeValue;
      }
    };
    Object.defineProperty(gu.prototype, "length", {
      get: function() {
        return $x(this), this.$$length;
      }
    }), Object.defineProperty(vt.prototype, "textContent", {
      get: function() {
        return t(this);
      },
      set: function(e) {
        switch (this.nodeType) {
          case pi:
          case Ho:
            for (; this.firstChild; )
              this.removeChild(this.firstChild);
            (e || String(e)) && this.appendChild(this.ownerDocument.createTextNode(e));
            break;
          default:
            this.data = e, this.value = e, this.nodeValue = e;
        }
      }
    }), bR = function(e, n, r) {
      e["$$" + n] = r;
    };
  }
} catch {
}
io.DocumentType = Hm;
io.DOMException = zt;
io.DOMImplementation = lR;
io.Element = ml;
io.Node = vt;
io.NodeList = Wo;
io.XMLSerializer = gR;
var qm = {}, vR = {};
(function(t) {
  var e = Yo.freeze;
  t.XML_ENTITIES = e({
    amp: "&",
    apos: "'",
    gt: ">",
    lt: "<",
    quot: '"'
  }), t.HTML_ENTITIES = e({
    Aacute: "Á",
    aacute: "á",
    Abreve: "Ă",
    abreve: "ă",
    ac: "∾",
    acd: "∿",
    acE: "∾̳",
    Acirc: "Â",
    acirc: "â",
    acute: "´",
    Acy: "А",
    acy: "а",
    AElig: "Æ",
    aelig: "æ",
    af: "⁡",
    Afr: "𝔄",
    afr: "𝔞",
    Agrave: "À",
    agrave: "à",
    alefsym: "ℵ",
    aleph: "ℵ",
    Alpha: "Α",
    alpha: "α",
    Amacr: "Ā",
    amacr: "ā",
    amalg: "⨿",
    AMP: "&",
    amp: "&",
    And: "⩓",
    and: "∧",
    andand: "⩕",
    andd: "⩜",
    andslope: "⩘",
    andv: "⩚",
    ang: "∠",
    ange: "⦤",
    angle: "∠",
    angmsd: "∡",
    angmsdaa: "⦨",
    angmsdab: "⦩",
    angmsdac: "⦪",
    angmsdad: "⦫",
    angmsdae: "⦬",
    angmsdaf: "⦭",
    angmsdag: "⦮",
    angmsdah: "⦯",
    angrt: "∟",
    angrtvb: "⊾",
    angrtvbd: "⦝",
    angsph: "∢",
    angst: "Å",
    angzarr: "⍼",
    Aogon: "Ą",
    aogon: "ą",
    Aopf: "𝔸",
    aopf: "𝕒",
    ap: "≈",
    apacir: "⩯",
    apE: "⩰",
    ape: "≊",
    apid: "≋",
    apos: "'",
    ApplyFunction: "⁡",
    approx: "≈",
    approxeq: "≊",
    Aring: "Å",
    aring: "å",
    Ascr: "𝒜",
    ascr: "𝒶",
    Assign: "≔",
    ast: "*",
    asymp: "≈",
    asympeq: "≍",
    Atilde: "Ã",
    atilde: "ã",
    Auml: "Ä",
    auml: "ä",
    awconint: "∳",
    awint: "⨑",
    backcong: "≌",
    backepsilon: "϶",
    backprime: "‵",
    backsim: "∽",
    backsimeq: "⋍",
    Backslash: "∖",
    Barv: "⫧",
    barvee: "⊽",
    Barwed: "⌆",
    barwed: "⌅",
    barwedge: "⌅",
    bbrk: "⎵",
    bbrktbrk: "⎶",
    bcong: "≌",
    Bcy: "Б",
    bcy: "б",
    bdquo: "„",
    becaus: "∵",
    Because: "∵",
    because: "∵",
    bemptyv: "⦰",
    bepsi: "϶",
    bernou: "ℬ",
    Bernoullis: "ℬ",
    Beta: "Β",
    beta: "β",
    beth: "ℶ",
    between: "≬",
    Bfr: "𝔅",
    bfr: "𝔟",
    bigcap: "⋂",
    bigcirc: "◯",
    bigcup: "⋃",
    bigodot: "⨀",
    bigoplus: "⨁",
    bigotimes: "⨂",
    bigsqcup: "⨆",
    bigstar: "★",
    bigtriangledown: "▽",
    bigtriangleup: "△",
    biguplus: "⨄",
    bigvee: "⋁",
    bigwedge: "⋀",
    bkarow: "⤍",
    blacklozenge: "⧫",
    blacksquare: "▪",
    blacktriangle: "▴",
    blacktriangledown: "▾",
    blacktriangleleft: "◂",
    blacktriangleright: "▸",
    blank: "␣",
    blk12: "▒",
    blk14: "░",
    blk34: "▓",
    block: "█",
    bne: "=⃥",
    bnequiv: "≡⃥",
    bNot: "⫭",
    bnot: "⌐",
    Bopf: "𝔹",
    bopf: "𝕓",
    bot: "⊥",
    bottom: "⊥",
    bowtie: "⋈",
    boxbox: "⧉",
    boxDL: "╗",
    boxDl: "╖",
    boxdL: "╕",
    boxdl: "┐",
    boxDR: "╔",
    boxDr: "╓",
    boxdR: "╒",
    boxdr: "┌",
    boxH: "═",
    boxh: "─",
    boxHD: "╦",
    boxHd: "╤",
    boxhD: "╥",
    boxhd: "┬",
    boxHU: "╩",
    boxHu: "╧",
    boxhU: "╨",
    boxhu: "┴",
    boxminus: "⊟",
    boxplus: "⊞",
    boxtimes: "⊠",
    boxUL: "╝",
    boxUl: "╜",
    boxuL: "╛",
    boxul: "┘",
    boxUR: "╚",
    boxUr: "╙",
    boxuR: "╘",
    boxur: "└",
    boxV: "║",
    boxv: "│",
    boxVH: "╬",
    boxVh: "╫",
    boxvH: "╪",
    boxvh: "┼",
    boxVL: "╣",
    boxVl: "╢",
    boxvL: "╡",
    boxvl: "┤",
    boxVR: "╠",
    boxVr: "╟",
    boxvR: "╞",
    boxvr: "├",
    bprime: "‵",
    Breve: "˘",
    breve: "˘",
    brvbar: "¦",
    Bscr: "ℬ",
    bscr: "𝒷",
    bsemi: "⁏",
    bsim: "∽",
    bsime: "⋍",
    bsol: "\\",
    bsolb: "⧅",
    bsolhsub: "⟈",
    bull: "•",
    bullet: "•",
    bump: "≎",
    bumpE: "⪮",
    bumpe: "≏",
    Bumpeq: "≎",
    bumpeq: "≏",
    Cacute: "Ć",
    cacute: "ć",
    Cap: "⋒",
    cap: "∩",
    capand: "⩄",
    capbrcup: "⩉",
    capcap: "⩋",
    capcup: "⩇",
    capdot: "⩀",
    CapitalDifferentialD: "ⅅ",
    caps: "∩︀",
    caret: "⁁",
    caron: "ˇ",
    Cayleys: "ℭ",
    ccaps: "⩍",
    Ccaron: "Č",
    ccaron: "č",
    Ccedil: "Ç",
    ccedil: "ç",
    Ccirc: "Ĉ",
    ccirc: "ĉ",
    Cconint: "∰",
    ccups: "⩌",
    ccupssm: "⩐",
    Cdot: "Ċ",
    cdot: "ċ",
    cedil: "¸",
    Cedilla: "¸",
    cemptyv: "⦲",
    cent: "¢",
    CenterDot: "·",
    centerdot: "·",
    Cfr: "ℭ",
    cfr: "𝔠",
    CHcy: "Ч",
    chcy: "ч",
    check: "✓",
    checkmark: "✓",
    Chi: "Χ",
    chi: "χ",
    cir: "○",
    circ: "ˆ",
    circeq: "≗",
    circlearrowleft: "↺",
    circlearrowright: "↻",
    circledast: "⊛",
    circledcirc: "⊚",
    circleddash: "⊝",
    CircleDot: "⊙",
    circledR: "®",
    circledS: "Ⓢ",
    CircleMinus: "⊖",
    CirclePlus: "⊕",
    CircleTimes: "⊗",
    cirE: "⧃",
    cire: "≗",
    cirfnint: "⨐",
    cirmid: "⫯",
    cirscir: "⧂",
    ClockwiseContourIntegral: "∲",
    CloseCurlyDoubleQuote: "”",
    CloseCurlyQuote: "’",
    clubs: "♣",
    clubsuit: "♣",
    Colon: "∷",
    colon: ":",
    Colone: "⩴",
    colone: "≔",
    coloneq: "≔",
    comma: ",",
    commat: "@",
    comp: "∁",
    compfn: "∘",
    complement: "∁",
    complexes: "ℂ",
    cong: "≅",
    congdot: "⩭",
    Congruent: "≡",
    Conint: "∯",
    conint: "∮",
    ContourIntegral: "∮",
    Copf: "ℂ",
    copf: "𝕔",
    coprod: "∐",
    Coproduct: "∐",
    COPY: "©",
    copy: "©",
    copysr: "℗",
    CounterClockwiseContourIntegral: "∳",
    crarr: "↵",
    Cross: "⨯",
    cross: "✗",
    Cscr: "𝒞",
    cscr: "𝒸",
    csub: "⫏",
    csube: "⫑",
    csup: "⫐",
    csupe: "⫒",
    ctdot: "⋯",
    cudarrl: "⤸",
    cudarrr: "⤵",
    cuepr: "⋞",
    cuesc: "⋟",
    cularr: "↶",
    cularrp: "⤽",
    Cup: "⋓",
    cup: "∪",
    cupbrcap: "⩈",
    CupCap: "≍",
    cupcap: "⩆",
    cupcup: "⩊",
    cupdot: "⊍",
    cupor: "⩅",
    cups: "∪︀",
    curarr: "↷",
    curarrm: "⤼",
    curlyeqprec: "⋞",
    curlyeqsucc: "⋟",
    curlyvee: "⋎",
    curlywedge: "⋏",
    curren: "¤",
    curvearrowleft: "↶",
    curvearrowright: "↷",
    cuvee: "⋎",
    cuwed: "⋏",
    cwconint: "∲",
    cwint: "∱",
    cylcty: "⌭",
    Dagger: "‡",
    dagger: "†",
    daleth: "ℸ",
    Darr: "↡",
    dArr: "⇓",
    darr: "↓",
    dash: "‐",
    Dashv: "⫤",
    dashv: "⊣",
    dbkarow: "⤏",
    dblac: "˝",
    Dcaron: "Ď",
    dcaron: "ď",
    Dcy: "Д",
    dcy: "д",
    DD: "ⅅ",
    dd: "ⅆ",
    ddagger: "‡",
    ddarr: "⇊",
    DDotrahd: "⤑",
    ddotseq: "⩷",
    deg: "°",
    Del: "∇",
    Delta: "Δ",
    delta: "δ",
    demptyv: "⦱",
    dfisht: "⥿",
    Dfr: "𝔇",
    dfr: "𝔡",
    dHar: "⥥",
    dharl: "⇃",
    dharr: "⇂",
    DiacriticalAcute: "´",
    DiacriticalDot: "˙",
    DiacriticalDoubleAcute: "˝",
    DiacriticalGrave: "`",
    DiacriticalTilde: "˜",
    diam: "⋄",
    Diamond: "⋄",
    diamond: "⋄",
    diamondsuit: "♦",
    diams: "♦",
    die: "¨",
    DifferentialD: "ⅆ",
    digamma: "ϝ",
    disin: "⋲",
    div: "÷",
    divide: "÷",
    divideontimes: "⋇",
    divonx: "⋇",
    DJcy: "Ђ",
    djcy: "ђ",
    dlcorn: "⌞",
    dlcrop: "⌍",
    dollar: "$",
    Dopf: "𝔻",
    dopf: "𝕕",
    Dot: "¨",
    dot: "˙",
    DotDot: "⃜",
    doteq: "≐",
    doteqdot: "≑",
    DotEqual: "≐",
    dotminus: "∸",
    dotplus: "∔",
    dotsquare: "⊡",
    doublebarwedge: "⌆",
    DoubleContourIntegral: "∯",
    DoubleDot: "¨",
    DoubleDownArrow: "⇓",
    DoubleLeftArrow: "⇐",
    DoubleLeftRightArrow: "⇔",
    DoubleLeftTee: "⫤",
    DoubleLongLeftArrow: "⟸",
    DoubleLongLeftRightArrow: "⟺",
    DoubleLongRightArrow: "⟹",
    DoubleRightArrow: "⇒",
    DoubleRightTee: "⊨",
    DoubleUpArrow: "⇑",
    DoubleUpDownArrow: "⇕",
    DoubleVerticalBar: "∥",
    DownArrow: "↓",
    Downarrow: "⇓",
    downarrow: "↓",
    DownArrowBar: "⤓",
    DownArrowUpArrow: "⇵",
    DownBreve: "̑",
    downdownarrows: "⇊",
    downharpoonleft: "⇃",
    downharpoonright: "⇂",
    DownLeftRightVector: "⥐",
    DownLeftTeeVector: "⥞",
    DownLeftVector: "↽",
    DownLeftVectorBar: "⥖",
    DownRightTeeVector: "⥟",
    DownRightVector: "⇁",
    DownRightVectorBar: "⥗",
    DownTee: "⊤",
    DownTeeArrow: "↧",
    drbkarow: "⤐",
    drcorn: "⌟",
    drcrop: "⌌",
    Dscr: "𝒟",
    dscr: "𝒹",
    DScy: "Ѕ",
    dscy: "ѕ",
    dsol: "⧶",
    Dstrok: "Đ",
    dstrok: "đ",
    dtdot: "⋱",
    dtri: "▿",
    dtrif: "▾",
    duarr: "⇵",
    duhar: "⥯",
    dwangle: "⦦",
    DZcy: "Џ",
    dzcy: "џ",
    dzigrarr: "⟿",
    Eacute: "É",
    eacute: "é",
    easter: "⩮",
    Ecaron: "Ě",
    ecaron: "ě",
    ecir: "≖",
    Ecirc: "Ê",
    ecirc: "ê",
    ecolon: "≕",
    Ecy: "Э",
    ecy: "э",
    eDDot: "⩷",
    Edot: "Ė",
    eDot: "≑",
    edot: "ė",
    ee: "ⅇ",
    efDot: "≒",
    Efr: "𝔈",
    efr: "𝔢",
    eg: "⪚",
    Egrave: "È",
    egrave: "è",
    egs: "⪖",
    egsdot: "⪘",
    el: "⪙",
    Element: "∈",
    elinters: "⏧",
    ell: "ℓ",
    els: "⪕",
    elsdot: "⪗",
    Emacr: "Ē",
    emacr: "ē",
    empty: "∅",
    emptyset: "∅",
    EmptySmallSquare: "◻",
    emptyv: "∅",
    EmptyVerySmallSquare: "▫",
    emsp: " ",
    emsp13: " ",
    emsp14: " ",
    ENG: "Ŋ",
    eng: "ŋ",
    ensp: " ",
    Eogon: "Ę",
    eogon: "ę",
    Eopf: "𝔼",
    eopf: "𝕖",
    epar: "⋕",
    eparsl: "⧣",
    eplus: "⩱",
    epsi: "ε",
    Epsilon: "Ε",
    epsilon: "ε",
    epsiv: "ϵ",
    eqcirc: "≖",
    eqcolon: "≕",
    eqsim: "≂",
    eqslantgtr: "⪖",
    eqslantless: "⪕",
    Equal: "⩵",
    equals: "=",
    EqualTilde: "≂",
    equest: "≟",
    Equilibrium: "⇌",
    equiv: "≡",
    equivDD: "⩸",
    eqvparsl: "⧥",
    erarr: "⥱",
    erDot: "≓",
    Escr: "ℰ",
    escr: "ℯ",
    esdot: "≐",
    Esim: "⩳",
    esim: "≂",
    Eta: "Η",
    eta: "η",
    ETH: "Ð",
    eth: "ð",
    Euml: "Ë",
    euml: "ë",
    euro: "€",
    excl: "!",
    exist: "∃",
    Exists: "∃",
    expectation: "ℰ",
    ExponentialE: "ⅇ",
    exponentiale: "ⅇ",
    fallingdotseq: "≒",
    Fcy: "Ф",
    fcy: "ф",
    female: "♀",
    ffilig: "ﬃ",
    fflig: "ﬀ",
    ffllig: "ﬄ",
    Ffr: "𝔉",
    ffr: "𝔣",
    filig: "ﬁ",
    FilledSmallSquare: "◼",
    FilledVerySmallSquare: "▪",
    fjlig: "fj",
    flat: "♭",
    fllig: "ﬂ",
    fltns: "▱",
    fnof: "ƒ",
    Fopf: "𝔽",
    fopf: "𝕗",
    ForAll: "∀",
    forall: "∀",
    fork: "⋔",
    forkv: "⫙",
    Fouriertrf: "ℱ",
    fpartint: "⨍",
    frac12: "½",
    frac13: "⅓",
    frac14: "¼",
    frac15: "⅕",
    frac16: "⅙",
    frac18: "⅛",
    frac23: "⅔",
    frac25: "⅖",
    frac34: "¾",
    frac35: "⅗",
    frac38: "⅜",
    frac45: "⅘",
    frac56: "⅚",
    frac58: "⅝",
    frac78: "⅞",
    frasl: "⁄",
    frown: "⌢",
    Fscr: "ℱ",
    fscr: "𝒻",
    gacute: "ǵ",
    Gamma: "Γ",
    gamma: "γ",
    Gammad: "Ϝ",
    gammad: "ϝ",
    gap: "⪆",
    Gbreve: "Ğ",
    gbreve: "ğ",
    Gcedil: "Ģ",
    Gcirc: "Ĝ",
    gcirc: "ĝ",
    Gcy: "Г",
    gcy: "г",
    Gdot: "Ġ",
    gdot: "ġ",
    gE: "≧",
    ge: "≥",
    gEl: "⪌",
    gel: "⋛",
    geq: "≥",
    geqq: "≧",
    geqslant: "⩾",
    ges: "⩾",
    gescc: "⪩",
    gesdot: "⪀",
    gesdoto: "⪂",
    gesdotol: "⪄",
    gesl: "⋛︀",
    gesles: "⪔",
    Gfr: "𝔊",
    gfr: "𝔤",
    Gg: "⋙",
    gg: "≫",
    ggg: "⋙",
    gimel: "ℷ",
    GJcy: "Ѓ",
    gjcy: "ѓ",
    gl: "≷",
    gla: "⪥",
    glE: "⪒",
    glj: "⪤",
    gnap: "⪊",
    gnapprox: "⪊",
    gnE: "≩",
    gne: "⪈",
    gneq: "⪈",
    gneqq: "≩",
    gnsim: "⋧",
    Gopf: "𝔾",
    gopf: "𝕘",
    grave: "`",
    GreaterEqual: "≥",
    GreaterEqualLess: "⋛",
    GreaterFullEqual: "≧",
    GreaterGreater: "⪢",
    GreaterLess: "≷",
    GreaterSlantEqual: "⩾",
    GreaterTilde: "≳",
    Gscr: "𝒢",
    gscr: "ℊ",
    gsim: "≳",
    gsime: "⪎",
    gsiml: "⪐",
    Gt: "≫",
    GT: ">",
    gt: ">",
    gtcc: "⪧",
    gtcir: "⩺",
    gtdot: "⋗",
    gtlPar: "⦕",
    gtquest: "⩼",
    gtrapprox: "⪆",
    gtrarr: "⥸",
    gtrdot: "⋗",
    gtreqless: "⋛",
    gtreqqless: "⪌",
    gtrless: "≷",
    gtrsim: "≳",
    gvertneqq: "≩︀",
    gvnE: "≩︀",
    Hacek: "ˇ",
    hairsp: " ",
    half: "½",
    hamilt: "ℋ",
    HARDcy: "Ъ",
    hardcy: "ъ",
    hArr: "⇔",
    harr: "↔",
    harrcir: "⥈",
    harrw: "↭",
    Hat: "^",
    hbar: "ℏ",
    Hcirc: "Ĥ",
    hcirc: "ĥ",
    hearts: "♥",
    heartsuit: "♥",
    hellip: "…",
    hercon: "⊹",
    Hfr: "ℌ",
    hfr: "𝔥",
    HilbertSpace: "ℋ",
    hksearow: "⤥",
    hkswarow: "⤦",
    hoarr: "⇿",
    homtht: "∻",
    hookleftarrow: "↩",
    hookrightarrow: "↪",
    Hopf: "ℍ",
    hopf: "𝕙",
    horbar: "―",
    HorizontalLine: "─",
    Hscr: "ℋ",
    hscr: "𝒽",
    hslash: "ℏ",
    Hstrok: "Ħ",
    hstrok: "ħ",
    HumpDownHump: "≎",
    HumpEqual: "≏",
    hybull: "⁃",
    hyphen: "‐",
    Iacute: "Í",
    iacute: "í",
    ic: "⁣",
    Icirc: "Î",
    icirc: "î",
    Icy: "И",
    icy: "и",
    Idot: "İ",
    IEcy: "Е",
    iecy: "е",
    iexcl: "¡",
    iff: "⇔",
    Ifr: "ℑ",
    ifr: "𝔦",
    Igrave: "Ì",
    igrave: "ì",
    ii: "ⅈ",
    iiiint: "⨌",
    iiint: "∭",
    iinfin: "⧜",
    iiota: "℩",
    IJlig: "Ĳ",
    ijlig: "ĳ",
    Im: "ℑ",
    Imacr: "Ī",
    imacr: "ī",
    image: "ℑ",
    ImaginaryI: "ⅈ",
    imagline: "ℐ",
    imagpart: "ℑ",
    imath: "ı",
    imof: "⊷",
    imped: "Ƶ",
    Implies: "⇒",
    in: "∈",
    incare: "℅",
    infin: "∞",
    infintie: "⧝",
    inodot: "ı",
    Int: "∬",
    int: "∫",
    intcal: "⊺",
    integers: "ℤ",
    Integral: "∫",
    intercal: "⊺",
    Intersection: "⋂",
    intlarhk: "⨗",
    intprod: "⨼",
    InvisibleComma: "⁣",
    InvisibleTimes: "⁢",
    IOcy: "Ё",
    iocy: "ё",
    Iogon: "Į",
    iogon: "į",
    Iopf: "𝕀",
    iopf: "𝕚",
    Iota: "Ι",
    iota: "ι",
    iprod: "⨼",
    iquest: "¿",
    Iscr: "ℐ",
    iscr: "𝒾",
    isin: "∈",
    isindot: "⋵",
    isinE: "⋹",
    isins: "⋴",
    isinsv: "⋳",
    isinv: "∈",
    it: "⁢",
    Itilde: "Ĩ",
    itilde: "ĩ",
    Iukcy: "І",
    iukcy: "і",
    Iuml: "Ï",
    iuml: "ï",
    Jcirc: "Ĵ",
    jcirc: "ĵ",
    Jcy: "Й",
    jcy: "й",
    Jfr: "𝔍",
    jfr: "𝔧",
    jmath: "ȷ",
    Jopf: "𝕁",
    jopf: "𝕛",
    Jscr: "𝒥",
    jscr: "𝒿",
    Jsercy: "Ј",
    jsercy: "ј",
    Jukcy: "Є",
    jukcy: "є",
    Kappa: "Κ",
    kappa: "κ",
    kappav: "ϰ",
    Kcedil: "Ķ",
    kcedil: "ķ",
    Kcy: "К",
    kcy: "к",
    Kfr: "𝔎",
    kfr: "𝔨",
    kgreen: "ĸ",
    KHcy: "Х",
    khcy: "х",
    KJcy: "Ќ",
    kjcy: "ќ",
    Kopf: "𝕂",
    kopf: "𝕜",
    Kscr: "𝒦",
    kscr: "𝓀",
    lAarr: "⇚",
    Lacute: "Ĺ",
    lacute: "ĺ",
    laemptyv: "⦴",
    lagran: "ℒ",
    Lambda: "Λ",
    lambda: "λ",
    Lang: "⟪",
    lang: "⟨",
    langd: "⦑",
    langle: "⟨",
    lap: "⪅",
    Laplacetrf: "ℒ",
    laquo: "«",
    Larr: "↞",
    lArr: "⇐",
    larr: "←",
    larrb: "⇤",
    larrbfs: "⤟",
    larrfs: "⤝",
    larrhk: "↩",
    larrlp: "↫",
    larrpl: "⤹",
    larrsim: "⥳",
    larrtl: "↢",
    lat: "⪫",
    lAtail: "⤛",
    latail: "⤙",
    late: "⪭",
    lates: "⪭︀",
    lBarr: "⤎",
    lbarr: "⤌",
    lbbrk: "❲",
    lbrace: "{",
    lbrack: "[",
    lbrke: "⦋",
    lbrksld: "⦏",
    lbrkslu: "⦍",
    Lcaron: "Ľ",
    lcaron: "ľ",
    Lcedil: "Ļ",
    lcedil: "ļ",
    lceil: "⌈",
    lcub: "{",
    Lcy: "Л",
    lcy: "л",
    ldca: "⤶",
    ldquo: "“",
    ldquor: "„",
    ldrdhar: "⥧",
    ldrushar: "⥋",
    ldsh: "↲",
    lE: "≦",
    le: "≤",
    LeftAngleBracket: "⟨",
    LeftArrow: "←",
    Leftarrow: "⇐",
    leftarrow: "←",
    LeftArrowBar: "⇤",
    LeftArrowRightArrow: "⇆",
    leftarrowtail: "↢",
    LeftCeiling: "⌈",
    LeftDoubleBracket: "⟦",
    LeftDownTeeVector: "⥡",
    LeftDownVector: "⇃",
    LeftDownVectorBar: "⥙",
    LeftFloor: "⌊",
    leftharpoondown: "↽",
    leftharpoonup: "↼",
    leftleftarrows: "⇇",
    LeftRightArrow: "↔",
    Leftrightarrow: "⇔",
    leftrightarrow: "↔",
    leftrightarrows: "⇆",
    leftrightharpoons: "⇋",
    leftrightsquigarrow: "↭",
    LeftRightVector: "⥎",
    LeftTee: "⊣",
    LeftTeeArrow: "↤",
    LeftTeeVector: "⥚",
    leftthreetimes: "⋋",
    LeftTriangle: "⊲",
    LeftTriangleBar: "⧏",
    LeftTriangleEqual: "⊴",
    LeftUpDownVector: "⥑",
    LeftUpTeeVector: "⥠",
    LeftUpVector: "↿",
    LeftUpVectorBar: "⥘",
    LeftVector: "↼",
    LeftVectorBar: "⥒",
    lEg: "⪋",
    leg: "⋚",
    leq: "≤",
    leqq: "≦",
    leqslant: "⩽",
    les: "⩽",
    lescc: "⪨",
    lesdot: "⩿",
    lesdoto: "⪁",
    lesdotor: "⪃",
    lesg: "⋚︀",
    lesges: "⪓",
    lessapprox: "⪅",
    lessdot: "⋖",
    lesseqgtr: "⋚",
    lesseqqgtr: "⪋",
    LessEqualGreater: "⋚",
    LessFullEqual: "≦",
    LessGreater: "≶",
    lessgtr: "≶",
    LessLess: "⪡",
    lesssim: "≲",
    LessSlantEqual: "⩽",
    LessTilde: "≲",
    lfisht: "⥼",
    lfloor: "⌊",
    Lfr: "𝔏",
    lfr: "𝔩",
    lg: "≶",
    lgE: "⪑",
    lHar: "⥢",
    lhard: "↽",
    lharu: "↼",
    lharul: "⥪",
    lhblk: "▄",
    LJcy: "Љ",
    ljcy: "љ",
    Ll: "⋘",
    ll: "≪",
    llarr: "⇇",
    llcorner: "⌞",
    Lleftarrow: "⇚",
    llhard: "⥫",
    lltri: "◺",
    Lmidot: "Ŀ",
    lmidot: "ŀ",
    lmoust: "⎰",
    lmoustache: "⎰",
    lnap: "⪉",
    lnapprox: "⪉",
    lnE: "≨",
    lne: "⪇",
    lneq: "⪇",
    lneqq: "≨",
    lnsim: "⋦",
    loang: "⟬",
    loarr: "⇽",
    lobrk: "⟦",
    LongLeftArrow: "⟵",
    Longleftarrow: "⟸",
    longleftarrow: "⟵",
    LongLeftRightArrow: "⟷",
    Longleftrightarrow: "⟺",
    longleftrightarrow: "⟷",
    longmapsto: "⟼",
    LongRightArrow: "⟶",
    Longrightarrow: "⟹",
    longrightarrow: "⟶",
    looparrowleft: "↫",
    looparrowright: "↬",
    lopar: "⦅",
    Lopf: "𝕃",
    lopf: "𝕝",
    loplus: "⨭",
    lotimes: "⨴",
    lowast: "∗",
    lowbar: "_",
    LowerLeftArrow: "↙",
    LowerRightArrow: "↘",
    loz: "◊",
    lozenge: "◊",
    lozf: "⧫",
    lpar: "(",
    lparlt: "⦓",
    lrarr: "⇆",
    lrcorner: "⌟",
    lrhar: "⇋",
    lrhard: "⥭",
    lrm: "‎",
    lrtri: "⊿",
    lsaquo: "‹",
    Lscr: "ℒ",
    lscr: "𝓁",
    Lsh: "↰",
    lsh: "↰",
    lsim: "≲",
    lsime: "⪍",
    lsimg: "⪏",
    lsqb: "[",
    lsquo: "‘",
    lsquor: "‚",
    Lstrok: "Ł",
    lstrok: "ł",
    Lt: "≪",
    LT: "<",
    lt: "<",
    ltcc: "⪦",
    ltcir: "⩹",
    ltdot: "⋖",
    lthree: "⋋",
    ltimes: "⋉",
    ltlarr: "⥶",
    ltquest: "⩻",
    ltri: "◃",
    ltrie: "⊴",
    ltrif: "◂",
    ltrPar: "⦖",
    lurdshar: "⥊",
    luruhar: "⥦",
    lvertneqq: "≨︀",
    lvnE: "≨︀",
    macr: "¯",
    male: "♂",
    malt: "✠",
    maltese: "✠",
    Map: "⤅",
    map: "↦",
    mapsto: "↦",
    mapstodown: "↧",
    mapstoleft: "↤",
    mapstoup: "↥",
    marker: "▮",
    mcomma: "⨩",
    Mcy: "М",
    mcy: "м",
    mdash: "—",
    mDDot: "∺",
    measuredangle: "∡",
    MediumSpace: " ",
    Mellintrf: "ℳ",
    Mfr: "𝔐",
    mfr: "𝔪",
    mho: "℧",
    micro: "µ",
    mid: "∣",
    midast: "*",
    midcir: "⫰",
    middot: "·",
    minus: "−",
    minusb: "⊟",
    minusd: "∸",
    minusdu: "⨪",
    MinusPlus: "∓",
    mlcp: "⫛",
    mldr: "…",
    mnplus: "∓",
    models: "⊧",
    Mopf: "𝕄",
    mopf: "𝕞",
    mp: "∓",
    Mscr: "ℳ",
    mscr: "𝓂",
    mstpos: "∾",
    Mu: "Μ",
    mu: "μ",
    multimap: "⊸",
    mumap: "⊸",
    nabla: "∇",
    Nacute: "Ń",
    nacute: "ń",
    nang: "∠⃒",
    nap: "≉",
    napE: "⩰̸",
    napid: "≋̸",
    napos: "ŉ",
    napprox: "≉",
    natur: "♮",
    natural: "♮",
    naturals: "ℕ",
    nbsp: " ",
    nbump: "≎̸",
    nbumpe: "≏̸",
    ncap: "⩃",
    Ncaron: "Ň",
    ncaron: "ň",
    Ncedil: "Ņ",
    ncedil: "ņ",
    ncong: "≇",
    ncongdot: "⩭̸",
    ncup: "⩂",
    Ncy: "Н",
    ncy: "н",
    ndash: "–",
    ne: "≠",
    nearhk: "⤤",
    neArr: "⇗",
    nearr: "↗",
    nearrow: "↗",
    nedot: "≐̸",
    NegativeMediumSpace: "​",
    NegativeThickSpace: "​",
    NegativeThinSpace: "​",
    NegativeVeryThinSpace: "​",
    nequiv: "≢",
    nesear: "⤨",
    nesim: "≂̸",
    NestedGreaterGreater: "≫",
    NestedLessLess: "≪",
    NewLine: `
`,
    nexist: "∄",
    nexists: "∄",
    Nfr: "𝔑",
    nfr: "𝔫",
    ngE: "≧̸",
    nge: "≱",
    ngeq: "≱",
    ngeqq: "≧̸",
    ngeqslant: "⩾̸",
    nges: "⩾̸",
    nGg: "⋙̸",
    ngsim: "≵",
    nGt: "≫⃒",
    ngt: "≯",
    ngtr: "≯",
    nGtv: "≫̸",
    nhArr: "⇎",
    nharr: "↮",
    nhpar: "⫲",
    ni: "∋",
    nis: "⋼",
    nisd: "⋺",
    niv: "∋",
    NJcy: "Њ",
    njcy: "њ",
    nlArr: "⇍",
    nlarr: "↚",
    nldr: "‥",
    nlE: "≦̸",
    nle: "≰",
    nLeftarrow: "⇍",
    nleftarrow: "↚",
    nLeftrightarrow: "⇎",
    nleftrightarrow: "↮",
    nleq: "≰",
    nleqq: "≦̸",
    nleqslant: "⩽̸",
    nles: "⩽̸",
    nless: "≮",
    nLl: "⋘̸",
    nlsim: "≴",
    nLt: "≪⃒",
    nlt: "≮",
    nltri: "⋪",
    nltrie: "⋬",
    nLtv: "≪̸",
    nmid: "∤",
    NoBreak: "⁠",
    NonBreakingSpace: " ",
    Nopf: "ℕ",
    nopf: "𝕟",
    Not: "⫬",
    not: "¬",
    NotCongruent: "≢",
    NotCupCap: "≭",
    NotDoubleVerticalBar: "∦",
    NotElement: "∉",
    NotEqual: "≠",
    NotEqualTilde: "≂̸",
    NotExists: "∄",
    NotGreater: "≯",
    NotGreaterEqual: "≱",
    NotGreaterFullEqual: "≧̸",
    NotGreaterGreater: "≫̸",
    NotGreaterLess: "≹",
    NotGreaterSlantEqual: "⩾̸",
    NotGreaterTilde: "≵",
    NotHumpDownHump: "≎̸",
    NotHumpEqual: "≏̸",
    notin: "∉",
    notindot: "⋵̸",
    notinE: "⋹̸",
    notinva: "∉",
    notinvb: "⋷",
    notinvc: "⋶",
    NotLeftTriangle: "⋪",
    NotLeftTriangleBar: "⧏̸",
    NotLeftTriangleEqual: "⋬",
    NotLess: "≮",
    NotLessEqual: "≰",
    NotLessGreater: "≸",
    NotLessLess: "≪̸",
    NotLessSlantEqual: "⩽̸",
    NotLessTilde: "≴",
    NotNestedGreaterGreater: "⪢̸",
    NotNestedLessLess: "⪡̸",
    notni: "∌",
    notniva: "∌",
    notnivb: "⋾",
    notnivc: "⋽",
    NotPrecedes: "⊀",
    NotPrecedesEqual: "⪯̸",
    NotPrecedesSlantEqual: "⋠",
    NotReverseElement: "∌",
    NotRightTriangle: "⋫",
    NotRightTriangleBar: "⧐̸",
    NotRightTriangleEqual: "⋭",
    NotSquareSubset: "⊏̸",
    NotSquareSubsetEqual: "⋢",
    NotSquareSuperset: "⊐̸",
    NotSquareSupersetEqual: "⋣",
    NotSubset: "⊂⃒",
    NotSubsetEqual: "⊈",
    NotSucceeds: "⊁",
    NotSucceedsEqual: "⪰̸",
    NotSucceedsSlantEqual: "⋡",
    NotSucceedsTilde: "≿̸",
    NotSuperset: "⊃⃒",
    NotSupersetEqual: "⊉",
    NotTilde: "≁",
    NotTildeEqual: "≄",
    NotTildeFullEqual: "≇",
    NotTildeTilde: "≉",
    NotVerticalBar: "∤",
    npar: "∦",
    nparallel: "∦",
    nparsl: "⫽⃥",
    npart: "∂̸",
    npolint: "⨔",
    npr: "⊀",
    nprcue: "⋠",
    npre: "⪯̸",
    nprec: "⊀",
    npreceq: "⪯̸",
    nrArr: "⇏",
    nrarr: "↛",
    nrarrc: "⤳̸",
    nrarrw: "↝̸",
    nRightarrow: "⇏",
    nrightarrow: "↛",
    nrtri: "⋫",
    nrtrie: "⋭",
    nsc: "⊁",
    nsccue: "⋡",
    nsce: "⪰̸",
    Nscr: "𝒩",
    nscr: "𝓃",
    nshortmid: "∤",
    nshortparallel: "∦",
    nsim: "≁",
    nsime: "≄",
    nsimeq: "≄",
    nsmid: "∤",
    nspar: "∦",
    nsqsube: "⋢",
    nsqsupe: "⋣",
    nsub: "⊄",
    nsubE: "⫅̸",
    nsube: "⊈",
    nsubset: "⊂⃒",
    nsubseteq: "⊈",
    nsubseteqq: "⫅̸",
    nsucc: "⊁",
    nsucceq: "⪰̸",
    nsup: "⊅",
    nsupE: "⫆̸",
    nsupe: "⊉",
    nsupset: "⊃⃒",
    nsupseteq: "⊉",
    nsupseteqq: "⫆̸",
    ntgl: "≹",
    Ntilde: "Ñ",
    ntilde: "ñ",
    ntlg: "≸",
    ntriangleleft: "⋪",
    ntrianglelefteq: "⋬",
    ntriangleright: "⋫",
    ntrianglerighteq: "⋭",
    Nu: "Ν",
    nu: "ν",
    num: "#",
    numero: "№",
    numsp: " ",
    nvap: "≍⃒",
    nVDash: "⊯",
    nVdash: "⊮",
    nvDash: "⊭",
    nvdash: "⊬",
    nvge: "≥⃒",
    nvgt: ">⃒",
    nvHarr: "⤄",
    nvinfin: "⧞",
    nvlArr: "⤂",
    nvle: "≤⃒",
    nvlt: "<⃒",
    nvltrie: "⊴⃒",
    nvrArr: "⤃",
    nvrtrie: "⊵⃒",
    nvsim: "∼⃒",
    nwarhk: "⤣",
    nwArr: "⇖",
    nwarr: "↖",
    nwarrow: "↖",
    nwnear: "⤧",
    Oacute: "Ó",
    oacute: "ó",
    oast: "⊛",
    ocir: "⊚",
    Ocirc: "Ô",
    ocirc: "ô",
    Ocy: "О",
    ocy: "о",
    odash: "⊝",
    Odblac: "Ő",
    odblac: "ő",
    odiv: "⨸",
    odot: "⊙",
    odsold: "⦼",
    OElig: "Œ",
    oelig: "œ",
    ofcir: "⦿",
    Ofr: "𝔒",
    ofr: "𝔬",
    ogon: "˛",
    Ograve: "Ò",
    ograve: "ò",
    ogt: "⧁",
    ohbar: "⦵",
    ohm: "Ω",
    oint: "∮",
    olarr: "↺",
    olcir: "⦾",
    olcross: "⦻",
    oline: "‾",
    olt: "⧀",
    Omacr: "Ō",
    omacr: "ō",
    Omega: "Ω",
    omega: "ω",
    Omicron: "Ο",
    omicron: "ο",
    omid: "⦶",
    ominus: "⊖",
    Oopf: "𝕆",
    oopf: "𝕠",
    opar: "⦷",
    OpenCurlyDoubleQuote: "“",
    OpenCurlyQuote: "‘",
    operp: "⦹",
    oplus: "⊕",
    Or: "⩔",
    or: "∨",
    orarr: "↻",
    ord: "⩝",
    order: "ℴ",
    orderof: "ℴ",
    ordf: "ª",
    ordm: "º",
    origof: "⊶",
    oror: "⩖",
    orslope: "⩗",
    orv: "⩛",
    oS: "Ⓢ",
    Oscr: "𝒪",
    oscr: "ℴ",
    Oslash: "Ø",
    oslash: "ø",
    osol: "⊘",
    Otilde: "Õ",
    otilde: "õ",
    Otimes: "⨷",
    otimes: "⊗",
    otimesas: "⨶",
    Ouml: "Ö",
    ouml: "ö",
    ovbar: "⌽",
    OverBar: "‾",
    OverBrace: "⏞",
    OverBracket: "⎴",
    OverParenthesis: "⏜",
    par: "∥",
    para: "¶",
    parallel: "∥",
    parsim: "⫳",
    parsl: "⫽",
    part: "∂",
    PartialD: "∂",
    Pcy: "П",
    pcy: "п",
    percnt: "%",
    period: ".",
    permil: "‰",
    perp: "⊥",
    pertenk: "‱",
    Pfr: "𝔓",
    pfr: "𝔭",
    Phi: "Φ",
    phi: "φ",
    phiv: "ϕ",
    phmmat: "ℳ",
    phone: "☎",
    Pi: "Π",
    pi: "π",
    pitchfork: "⋔",
    piv: "ϖ",
    planck: "ℏ",
    planckh: "ℎ",
    plankv: "ℏ",
    plus: "+",
    plusacir: "⨣",
    plusb: "⊞",
    pluscir: "⨢",
    plusdo: "∔",
    plusdu: "⨥",
    pluse: "⩲",
    PlusMinus: "±",
    plusmn: "±",
    plussim: "⨦",
    plustwo: "⨧",
    pm: "±",
    Poincareplane: "ℌ",
    pointint: "⨕",
    Popf: "ℙ",
    popf: "𝕡",
    pound: "£",
    Pr: "⪻",
    pr: "≺",
    prap: "⪷",
    prcue: "≼",
    prE: "⪳",
    pre: "⪯",
    prec: "≺",
    precapprox: "⪷",
    preccurlyeq: "≼",
    Precedes: "≺",
    PrecedesEqual: "⪯",
    PrecedesSlantEqual: "≼",
    PrecedesTilde: "≾",
    preceq: "⪯",
    precnapprox: "⪹",
    precneqq: "⪵",
    precnsim: "⋨",
    precsim: "≾",
    Prime: "″",
    prime: "′",
    primes: "ℙ",
    prnap: "⪹",
    prnE: "⪵",
    prnsim: "⋨",
    prod: "∏",
    Product: "∏",
    profalar: "⌮",
    profline: "⌒",
    profsurf: "⌓",
    prop: "∝",
    Proportion: "∷",
    Proportional: "∝",
    propto: "∝",
    prsim: "≾",
    prurel: "⊰",
    Pscr: "𝒫",
    pscr: "𝓅",
    Psi: "Ψ",
    psi: "ψ",
    puncsp: " ",
    Qfr: "𝔔",
    qfr: "𝔮",
    qint: "⨌",
    Qopf: "ℚ",
    qopf: "𝕢",
    qprime: "⁗",
    Qscr: "𝒬",
    qscr: "𝓆",
    quaternions: "ℍ",
    quatint: "⨖",
    quest: "?",
    questeq: "≟",
    QUOT: '"',
    quot: '"',
    rAarr: "⇛",
    race: "∽̱",
    Racute: "Ŕ",
    racute: "ŕ",
    radic: "√",
    raemptyv: "⦳",
    Rang: "⟫",
    rang: "⟩",
    rangd: "⦒",
    range: "⦥",
    rangle: "⟩",
    raquo: "»",
    Rarr: "↠",
    rArr: "⇒",
    rarr: "→",
    rarrap: "⥵",
    rarrb: "⇥",
    rarrbfs: "⤠",
    rarrc: "⤳",
    rarrfs: "⤞",
    rarrhk: "↪",
    rarrlp: "↬",
    rarrpl: "⥅",
    rarrsim: "⥴",
    Rarrtl: "⤖",
    rarrtl: "↣",
    rarrw: "↝",
    rAtail: "⤜",
    ratail: "⤚",
    ratio: "∶",
    rationals: "ℚ",
    RBarr: "⤐",
    rBarr: "⤏",
    rbarr: "⤍",
    rbbrk: "❳",
    rbrace: "}",
    rbrack: "]",
    rbrke: "⦌",
    rbrksld: "⦎",
    rbrkslu: "⦐",
    Rcaron: "Ř",
    rcaron: "ř",
    Rcedil: "Ŗ",
    rcedil: "ŗ",
    rceil: "⌉",
    rcub: "}",
    Rcy: "Р",
    rcy: "р",
    rdca: "⤷",
    rdldhar: "⥩",
    rdquo: "”",
    rdquor: "”",
    rdsh: "↳",
    Re: "ℜ",
    real: "ℜ",
    realine: "ℛ",
    realpart: "ℜ",
    reals: "ℝ",
    rect: "▭",
    REG: "®",
    reg: "®",
    ReverseElement: "∋",
    ReverseEquilibrium: "⇋",
    ReverseUpEquilibrium: "⥯",
    rfisht: "⥽",
    rfloor: "⌋",
    Rfr: "ℜ",
    rfr: "𝔯",
    rHar: "⥤",
    rhard: "⇁",
    rharu: "⇀",
    rharul: "⥬",
    Rho: "Ρ",
    rho: "ρ",
    rhov: "ϱ",
    RightAngleBracket: "⟩",
    RightArrow: "→",
    Rightarrow: "⇒",
    rightarrow: "→",
    RightArrowBar: "⇥",
    RightArrowLeftArrow: "⇄",
    rightarrowtail: "↣",
    RightCeiling: "⌉",
    RightDoubleBracket: "⟧",
    RightDownTeeVector: "⥝",
    RightDownVector: "⇂",
    RightDownVectorBar: "⥕",
    RightFloor: "⌋",
    rightharpoondown: "⇁",
    rightharpoonup: "⇀",
    rightleftarrows: "⇄",
    rightleftharpoons: "⇌",
    rightrightarrows: "⇉",
    rightsquigarrow: "↝",
    RightTee: "⊢",
    RightTeeArrow: "↦",
    RightTeeVector: "⥛",
    rightthreetimes: "⋌",
    RightTriangle: "⊳",
    RightTriangleBar: "⧐",
    RightTriangleEqual: "⊵",
    RightUpDownVector: "⥏",
    RightUpTeeVector: "⥜",
    RightUpVector: "↾",
    RightUpVectorBar: "⥔",
    RightVector: "⇀",
    RightVectorBar: "⥓",
    ring: "˚",
    risingdotseq: "≓",
    rlarr: "⇄",
    rlhar: "⇌",
    rlm: "‏",
    rmoust: "⎱",
    rmoustache: "⎱",
    rnmid: "⫮",
    roang: "⟭",
    roarr: "⇾",
    robrk: "⟧",
    ropar: "⦆",
    Ropf: "ℝ",
    ropf: "𝕣",
    roplus: "⨮",
    rotimes: "⨵",
    RoundImplies: "⥰",
    rpar: ")",
    rpargt: "⦔",
    rppolint: "⨒",
    rrarr: "⇉",
    Rrightarrow: "⇛",
    rsaquo: "›",
    Rscr: "ℛ",
    rscr: "𝓇",
    Rsh: "↱",
    rsh: "↱",
    rsqb: "]",
    rsquo: "’",
    rsquor: "’",
    rthree: "⋌",
    rtimes: "⋊",
    rtri: "▹",
    rtrie: "⊵",
    rtrif: "▸",
    rtriltri: "⧎",
    RuleDelayed: "⧴",
    ruluhar: "⥨",
    rx: "℞",
    Sacute: "Ś",
    sacute: "ś",
    sbquo: "‚",
    Sc: "⪼",
    sc: "≻",
    scap: "⪸",
    Scaron: "Š",
    scaron: "š",
    sccue: "≽",
    scE: "⪴",
    sce: "⪰",
    Scedil: "Ş",
    scedil: "ş",
    Scirc: "Ŝ",
    scirc: "ŝ",
    scnap: "⪺",
    scnE: "⪶",
    scnsim: "⋩",
    scpolint: "⨓",
    scsim: "≿",
    Scy: "С",
    scy: "с",
    sdot: "⋅",
    sdotb: "⊡",
    sdote: "⩦",
    searhk: "⤥",
    seArr: "⇘",
    searr: "↘",
    searrow: "↘",
    sect: "§",
    semi: ";",
    seswar: "⤩",
    setminus: "∖",
    setmn: "∖",
    sext: "✶",
    Sfr: "𝔖",
    sfr: "𝔰",
    sfrown: "⌢",
    sharp: "♯",
    SHCHcy: "Щ",
    shchcy: "щ",
    SHcy: "Ш",
    shcy: "ш",
    ShortDownArrow: "↓",
    ShortLeftArrow: "←",
    shortmid: "∣",
    shortparallel: "∥",
    ShortRightArrow: "→",
    ShortUpArrow: "↑",
    shy: "­",
    Sigma: "Σ",
    sigma: "σ",
    sigmaf: "ς",
    sigmav: "ς",
    sim: "∼",
    simdot: "⩪",
    sime: "≃",
    simeq: "≃",
    simg: "⪞",
    simgE: "⪠",
    siml: "⪝",
    simlE: "⪟",
    simne: "≆",
    simplus: "⨤",
    simrarr: "⥲",
    slarr: "←",
    SmallCircle: "∘",
    smallsetminus: "∖",
    smashp: "⨳",
    smeparsl: "⧤",
    smid: "∣",
    smile: "⌣",
    smt: "⪪",
    smte: "⪬",
    smtes: "⪬︀",
    SOFTcy: "Ь",
    softcy: "ь",
    sol: "/",
    solb: "⧄",
    solbar: "⌿",
    Sopf: "𝕊",
    sopf: "𝕤",
    spades: "♠",
    spadesuit: "♠",
    spar: "∥",
    sqcap: "⊓",
    sqcaps: "⊓︀",
    sqcup: "⊔",
    sqcups: "⊔︀",
    Sqrt: "√",
    sqsub: "⊏",
    sqsube: "⊑",
    sqsubset: "⊏",
    sqsubseteq: "⊑",
    sqsup: "⊐",
    sqsupe: "⊒",
    sqsupset: "⊐",
    sqsupseteq: "⊒",
    squ: "□",
    Square: "□",
    square: "□",
    SquareIntersection: "⊓",
    SquareSubset: "⊏",
    SquareSubsetEqual: "⊑",
    SquareSuperset: "⊐",
    SquareSupersetEqual: "⊒",
    SquareUnion: "⊔",
    squarf: "▪",
    squf: "▪",
    srarr: "→",
    Sscr: "𝒮",
    sscr: "𝓈",
    ssetmn: "∖",
    ssmile: "⌣",
    sstarf: "⋆",
    Star: "⋆",
    star: "☆",
    starf: "★",
    straightepsilon: "ϵ",
    straightphi: "ϕ",
    strns: "¯",
    Sub: "⋐",
    sub: "⊂",
    subdot: "⪽",
    subE: "⫅",
    sube: "⊆",
    subedot: "⫃",
    submult: "⫁",
    subnE: "⫋",
    subne: "⊊",
    subplus: "⪿",
    subrarr: "⥹",
    Subset: "⋐",
    subset: "⊂",
    subseteq: "⊆",
    subseteqq: "⫅",
    SubsetEqual: "⊆",
    subsetneq: "⊊",
    subsetneqq: "⫋",
    subsim: "⫇",
    subsub: "⫕",
    subsup: "⫓",
    succ: "≻",
    succapprox: "⪸",
    succcurlyeq: "≽",
    Succeeds: "≻",
    SucceedsEqual: "⪰",
    SucceedsSlantEqual: "≽",
    SucceedsTilde: "≿",
    succeq: "⪰",
    succnapprox: "⪺",
    succneqq: "⪶",
    succnsim: "⋩",
    succsim: "≿",
    SuchThat: "∋",
    Sum: "∑",
    sum: "∑",
    sung: "♪",
    Sup: "⋑",
    sup: "⊃",
    sup1: "¹",
    sup2: "²",
    sup3: "³",
    supdot: "⪾",
    supdsub: "⫘",
    supE: "⫆",
    supe: "⊇",
    supedot: "⫄",
    Superset: "⊃",
    SupersetEqual: "⊇",
    suphsol: "⟉",
    suphsub: "⫗",
    suplarr: "⥻",
    supmult: "⫂",
    supnE: "⫌",
    supne: "⊋",
    supplus: "⫀",
    Supset: "⋑",
    supset: "⊃",
    supseteq: "⊇",
    supseteqq: "⫆",
    supsetneq: "⊋",
    supsetneqq: "⫌",
    supsim: "⫈",
    supsub: "⫔",
    supsup: "⫖",
    swarhk: "⤦",
    swArr: "⇙",
    swarr: "↙",
    swarrow: "↙",
    swnwar: "⤪",
    szlig: "ß",
    Tab: "	",
    target: "⌖",
    Tau: "Τ",
    tau: "τ",
    tbrk: "⎴",
    Tcaron: "Ť",
    tcaron: "ť",
    Tcedil: "Ţ",
    tcedil: "ţ",
    Tcy: "Т",
    tcy: "т",
    tdot: "⃛",
    telrec: "⌕",
    Tfr: "𝔗",
    tfr: "𝔱",
    there4: "∴",
    Therefore: "∴",
    therefore: "∴",
    Theta: "Θ",
    theta: "θ",
    thetasym: "ϑ",
    thetav: "ϑ",
    thickapprox: "≈",
    thicksim: "∼",
    ThickSpace: "  ",
    thinsp: " ",
    ThinSpace: " ",
    thkap: "≈",
    thksim: "∼",
    THORN: "Þ",
    thorn: "þ",
    Tilde: "∼",
    tilde: "˜",
    TildeEqual: "≃",
    TildeFullEqual: "≅",
    TildeTilde: "≈",
    times: "×",
    timesb: "⊠",
    timesbar: "⨱",
    timesd: "⨰",
    tint: "∭",
    toea: "⤨",
    top: "⊤",
    topbot: "⌶",
    topcir: "⫱",
    Topf: "𝕋",
    topf: "𝕥",
    topfork: "⫚",
    tosa: "⤩",
    tprime: "‴",
    TRADE: "™",
    trade: "™",
    triangle: "▵",
    triangledown: "▿",
    triangleleft: "◃",
    trianglelefteq: "⊴",
    triangleq: "≜",
    triangleright: "▹",
    trianglerighteq: "⊵",
    tridot: "◬",
    trie: "≜",
    triminus: "⨺",
    TripleDot: "⃛",
    triplus: "⨹",
    trisb: "⧍",
    tritime: "⨻",
    trpezium: "⏢",
    Tscr: "𝒯",
    tscr: "𝓉",
    TScy: "Ц",
    tscy: "ц",
    TSHcy: "Ћ",
    tshcy: "ћ",
    Tstrok: "Ŧ",
    tstrok: "ŧ",
    twixt: "≬",
    twoheadleftarrow: "↞",
    twoheadrightarrow: "↠",
    Uacute: "Ú",
    uacute: "ú",
    Uarr: "↟",
    uArr: "⇑",
    uarr: "↑",
    Uarrocir: "⥉",
    Ubrcy: "Ў",
    ubrcy: "ў",
    Ubreve: "Ŭ",
    ubreve: "ŭ",
    Ucirc: "Û",
    ucirc: "û",
    Ucy: "У",
    ucy: "у",
    udarr: "⇅",
    Udblac: "Ű",
    udblac: "ű",
    udhar: "⥮",
    ufisht: "⥾",
    Ufr: "𝔘",
    ufr: "𝔲",
    Ugrave: "Ù",
    ugrave: "ù",
    uHar: "⥣",
    uharl: "↿",
    uharr: "↾",
    uhblk: "▀",
    ulcorn: "⌜",
    ulcorner: "⌜",
    ulcrop: "⌏",
    ultri: "◸",
    Umacr: "Ū",
    umacr: "ū",
    uml: "¨",
    UnderBar: "_",
    UnderBrace: "⏟",
    UnderBracket: "⎵",
    UnderParenthesis: "⏝",
    Union: "⋃",
    UnionPlus: "⊎",
    Uogon: "Ų",
    uogon: "ų",
    Uopf: "𝕌",
    uopf: "𝕦",
    UpArrow: "↑",
    Uparrow: "⇑",
    uparrow: "↑",
    UpArrowBar: "⤒",
    UpArrowDownArrow: "⇅",
    UpDownArrow: "↕",
    Updownarrow: "⇕",
    updownarrow: "↕",
    UpEquilibrium: "⥮",
    upharpoonleft: "↿",
    upharpoonright: "↾",
    uplus: "⊎",
    UpperLeftArrow: "↖",
    UpperRightArrow: "↗",
    Upsi: "ϒ",
    upsi: "υ",
    upsih: "ϒ",
    Upsilon: "Υ",
    upsilon: "υ",
    UpTee: "⊥",
    UpTeeArrow: "↥",
    upuparrows: "⇈",
    urcorn: "⌝",
    urcorner: "⌝",
    urcrop: "⌎",
    Uring: "Ů",
    uring: "ů",
    urtri: "◹",
    Uscr: "𝒰",
    uscr: "𝓊",
    utdot: "⋰",
    Utilde: "Ũ",
    utilde: "ũ",
    utri: "▵",
    utrif: "▴",
    uuarr: "⇈",
    Uuml: "Ü",
    uuml: "ü",
    uwangle: "⦧",
    vangrt: "⦜",
    varepsilon: "ϵ",
    varkappa: "ϰ",
    varnothing: "∅",
    varphi: "ϕ",
    varpi: "ϖ",
    varpropto: "∝",
    vArr: "⇕",
    varr: "↕",
    varrho: "ϱ",
    varsigma: "ς",
    varsubsetneq: "⊊︀",
    varsubsetneqq: "⫋︀",
    varsupsetneq: "⊋︀",
    varsupsetneqq: "⫌︀",
    vartheta: "ϑ",
    vartriangleleft: "⊲",
    vartriangleright: "⊳",
    Vbar: "⫫",
    vBar: "⫨",
    vBarv: "⫩",
    Vcy: "В",
    vcy: "в",
    VDash: "⊫",
    Vdash: "⊩",
    vDash: "⊨",
    vdash: "⊢",
    Vdashl: "⫦",
    Vee: "⋁",
    vee: "∨",
    veebar: "⊻",
    veeeq: "≚",
    vellip: "⋮",
    Verbar: "‖",
    verbar: "|",
    Vert: "‖",
    vert: "|",
    VerticalBar: "∣",
    VerticalLine: "|",
    VerticalSeparator: "❘",
    VerticalTilde: "≀",
    VeryThinSpace: " ",
    Vfr: "𝔙",
    vfr: "𝔳",
    vltri: "⊲",
    vnsub: "⊂⃒",
    vnsup: "⊃⃒",
    Vopf: "𝕍",
    vopf: "𝕧",
    vprop: "∝",
    vrtri: "⊳",
    Vscr: "𝒱",
    vscr: "𝓋",
    vsubnE: "⫋︀",
    vsubne: "⊊︀",
    vsupnE: "⫌︀",
    vsupne: "⊋︀",
    Vvdash: "⊪",
    vzigzag: "⦚",
    Wcirc: "Ŵ",
    wcirc: "ŵ",
    wedbar: "⩟",
    Wedge: "⋀",
    wedge: "∧",
    wedgeq: "≙",
    weierp: "℘",
    Wfr: "𝔚",
    wfr: "𝔴",
    Wopf: "𝕎",
    wopf: "𝕨",
    wp: "℘",
    wr: "≀",
    wreath: "≀",
    Wscr: "𝒲",
    wscr: "𝓌",
    xcap: "⋂",
    xcirc: "◯",
    xcup: "⋃",
    xdtri: "▽",
    Xfr: "𝔛",
    xfr: "𝔵",
    xhArr: "⟺",
    xharr: "⟷",
    Xi: "Ξ",
    xi: "ξ",
    xlArr: "⟸",
    xlarr: "⟵",
    xmap: "⟼",
    xnis: "⋻",
    xodot: "⨀",
    Xopf: "𝕏",
    xopf: "𝕩",
    xoplus: "⨁",
    xotime: "⨂",
    xrArr: "⟹",
    xrarr: "⟶",
    Xscr: "𝒳",
    xscr: "𝓍",
    xsqcup: "⨆",
    xuplus: "⨄",
    xutri: "△",
    xvee: "⋁",
    xwedge: "⋀",
    Yacute: "Ý",
    yacute: "ý",
    YAcy: "Я",
    yacy: "я",
    Ycirc: "Ŷ",
    ycirc: "ŷ",
    Ycy: "Ы",
    ycy: "ы",
    yen: "¥",
    Yfr: "𝔜",
    yfr: "𝔶",
    YIcy: "Ї",
    yicy: "ї",
    Yopf: "𝕐",
    yopf: "𝕪",
    Yscr: "𝒴",
    yscr: "𝓎",
    YUcy: "Ю",
    yucy: "ю",
    Yuml: "Ÿ",
    yuml: "ÿ",
    Zacute: "Ź",
    zacute: "ź",
    Zcaron: "Ž",
    zcaron: "ž",
    Zcy: "З",
    zcy: "з",
    Zdot: "Ż",
    zdot: "ż",
    zeetrf: "ℨ",
    ZeroWidthSpace: "​",
    Zeta: "Ζ",
    zeta: "ζ",
    Zfr: "ℨ",
    zfr: "𝔷",
    ZHcy: "Ж",
    zhcy: "ж",
    zigrarr: "⇝",
    Zopf: "ℤ",
    zopf: "𝕫",
    Zscr: "𝒵",
    zscr: "𝓏",
    zwj: "‍",
    zwnj: "‌"
  }), t.entityMap = t.HTML_ENTITIES;
})(vR);
var Yx = {}, Nd = Yo.NAMESPACE, H0 = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, ZC = new RegExp("[\\-\\.0-9" + H0.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), KC = new RegExp("^" + H0.source + ZC.source + "*(?::" + H0.source + ZC.source + "*)?$"), Bf = 0, ka = 1, Fc = 2, Mf = 3, Rc = 4, Oc = 5, Nf = 6, up = 7;
function mu(t, e) {
  this.message = t, this.locator = e, Error.captureStackTrace && Error.captureStackTrace(this, mu);
}
mu.prototype = new Error();
mu.prototype.name = mu.name;
function xR() {
}
xR.prototype = {
  parse: function(t, e, n) {
    var r = this.domBuilder;
    r.startDocument(), DR(e, e = {}), zV(
      t,
      e,
      n,
      r,
      this.errorHandler
    ), r.endDocument();
  }
};
function zV(t, e, n, r, i) {
  function o(j) {
    if (j > 65535) {
      j -= 65536;
      var Q = 55296 + (j >> 10), G = 56320 + (j & 1023);
      return String.fromCharCode(Q, G);
    } else
      return String.fromCharCode(j);
  }
  function a(j) {
    var Q = j.slice(1, -1);
    return Object.hasOwnProperty.call(n, Q) ? n[Q] : Q.charAt(0) === "#" ? o(parseInt(Q.substr(1).replace("x", "0x"))) : (i.error("entity not found:" + j), j);
  }
  function s(j) {
    if (j > x) {
      var Q = t.substring(x, j).replace(/&#?\w+;/g, a);
      p && l(x), r.characters(Q, 0, j - x), x = j;
    }
  }
  function l(j, Q) {
    for (; j >= f && (Q = h.exec(t)); )
      u = Q.index, f = u + Q[0].length, p.lineNumber++;
    p.columnNumber = j - u + 1;
  }
  for (var u = 0, f = 0, h = /.*(?:\r\n?|\n)|.*$/g, p = r.locator, y = [{ currentNSMap: e }], b = {}, x = 0; ; ) {
    try {
      var v = t.indexOf("<", x);
      if (v < 0) {
        if (!t.substr(x).match(/^\s*$/)) {
          var D = r.doc, S = D.createTextNode(t.substr(x));
          D.appendChild(S), r.currentElement = S;
        }
        return;
      }
      switch (v > x && s(v), t.charAt(v + 1)) {
        case "/":
          var ve = t.indexOf(">", v + 3), E = t.substring(v + 2, ve).replace(/[ \t\n\r]+$/g, ""), I = y.pop();
          ve < 0 ? (E = t.substring(v + 2).replace(/[\s<].*/, ""), i.error("end tag name: " + E + " is not complete:" + I.tagName), ve = v + 1 + E.length) : E.match(/\s</) && (E = E.replace(/[\s<].*/, ""), i.error("end tag name: " + E + " maybe not complete"), ve = v + 1 + E.length);
          var R = I.localNSMap, O = I.tagName == E, N = O || I.tagName && I.tagName.toLowerCase() == E.toLowerCase();
          if (N) {
            if (r.endElement(I.uri, I.localName, E), R)
              for (var q in R)
                Object.prototype.hasOwnProperty.call(R, q) && r.endPrefixMapping(q);
            O || i.fatalError("end tag name: " + E + " is not match the current start tagName:" + I.tagName);
          } else
            y.push(I);
          ve++;
          break;
        case "?":
          p && l(v), ve = qV(t, v, r);
          break;
        case "!":
          p && l(v), ve = VV(t, v, r, i);
          break;
        default:
          p && l(v);
          var $ = new wR(), le = y[y.length - 1].currentNSMap, ve = $V(t, v, $, le, a, i), M = $.length;
          if (!$.closed && HV(t, ve, $.tagName, b) && ($.closed = !0, n.nbsp || i.warning("unclosed xml attribute")), p && M) {
            for (var ee = QC(p, {}), A = 0; A < M; A++) {
              var oe = $[A];
              l(oe.offset), oe.locator = QC(p, {});
            }
            r.locator = ee, eE($, r, le) && y.push($), r.locator = p;
          } else
            eE($, r, le) && y.push($);
          Nd.isHTML($.uri) && !$.closed ? ve = jV(t, ve, $.tagName, a, r) : ve++;
      }
    } catch (j) {
      if (j instanceof mu)
        throw j;
      i.error("element parse error: " + j), ve = -1;
    }
    ve > x ? x = ve : s(Math.max(v, x) + 1);
  }
}
function QC(t, e) {
  return e.lineNumber = t.lineNumber, e.columnNumber = t.columnNumber, e;
}
function $V(t, e, n, r, i, o) {
  function a(p, y, b) {
    n.attributeNames.hasOwnProperty(p) && o.fatalError("Attribute " + p + " redefined"), n.addValue(
      p,
      // @see https://www.w3.org/TR/xml/#AVNormalize
      // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
      // - recursive replacement of (DTD) entity references
      // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
      y.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, i),
      b
    );
  }
  for (var s, l, u = ++e, f = Bf; ; ) {
    var h = t.charAt(u);
    switch (h) {
      case "=":
        if (f === ka)
          s = t.slice(e, u), f = Mf;
        else if (f === Fc)
          f = Mf;
        else
          throw new Error("attribute equal must after attrName");
        break;
      case "'":
      case '"':
        if (f === Mf || f === ka)
          if (f === ka && (o.warning('attribute value must after "="'), s = t.slice(e, u)), e = u + 1, u = t.indexOf(h, e), u > 0)
            l = t.slice(e, u), a(s, l, e - 1), f = Oc;
          else
            throw new Error("attribute value no end '" + h + "' match");
        else if (f == Rc)
          l = t.slice(e, u), a(s, l, e), o.warning('attribute "' + s + '" missed start quot(' + h + ")!!"), e = u + 1, f = Oc;
        else
          throw new Error('attribute value must after "="');
        break;
      case "/":
        switch (f) {
          case Bf:
            n.setTagName(t.slice(e, u));
          case Oc:
          case Nf:
          case up:
            f = up, n.closed = !0;
          case Rc:
          case ka:
            break;
          case Fc:
            n.closed = !0;
            break;
          default:
            throw new Error("attribute invalid close char('/')");
        }
        break;
      case "":
        return o.error("unexpected end of input"), f == Bf && n.setTagName(t.slice(e, u)), u;
      case ">":
        switch (f) {
          case Bf:
            n.setTagName(t.slice(e, u));
          case Oc:
          case Nf:
          case up:
            break;
          case Rc:
          case ka:
            l = t.slice(e, u), l.slice(-1) === "/" && (n.closed = !0, l = l.slice(0, -1));
          case Fc:
            f === Fc && (l = s), f == Rc ? (o.warning('attribute "' + l + '" missed quot(")!'), a(s, l, e)) : ((!Nd.isHTML(r[""]) || !l.match(/^(?:disabled|checked|selected)$/i)) && o.warning('attribute "' + l + '" missed value!! "' + l + '" instead!!'), a(l, l, e));
            break;
          case Mf:
            throw new Error("attribute value missed!!");
        }
        return u;
      case "":
        h = " ";
      default:
        if (h <= " ")
          switch (f) {
            case Bf:
              n.setTagName(t.slice(e, u)), f = Nf;
              break;
            case ka:
              s = t.slice(e, u), f = Fc;
              break;
            case Rc:
              var l = t.slice(e, u);
              o.warning('attribute "' + l + '" missed quot(")!!'), a(s, l, e);
            case Oc:
              f = Nf;
              break;
          }
        else
          switch (f) {
            case Fc:
              n.tagName, (!Nd.isHTML(r[""]) || !s.match(/^(?:disabled|checked|selected)$/i)) && o.warning('attribute "' + s + '" missed value!! "' + s + '" instead2!!'), a(s, s, e), e = u, f = ka;
              break;
            case Oc:
              o.warning('attribute space is required"' + s + '"!!');
            case Nf:
              f = ka, e = u;
              break;
            case Mf:
              f = Rc, e = u;
              break;
            case up:
              throw new Error("elements closed character '/' and '>' must be connected to");
          }
    }
    u++;
  }
}
function eE(t, e, n) {
  for (var r = t.tagName, i = null, h = t.length; h--; ) {
    var o = t[h], a = o.qName, s = o.value, p = a.indexOf(":");
    if (p > 0)
      var l = o.prefix = a.slice(0, p), u = a.slice(p + 1), f = l === "xmlns" && u;
    else
      u = a, l = null, f = a === "xmlns" && "";
    o.localName = u, f !== !1 && (i == null && (i = {}, DR(n, n = {})), n[f] = i[f] = s, o.uri = Nd.XMLNS, e.startPrefixMapping(f, s));
  }
  for (var h = t.length; h--; ) {
    o = t[h];
    var l = o.prefix;
    l && (l === "xml" && (o.uri = Nd.XML), l !== "xmlns" && (o.uri = n[l || ""]));
  }
  var p = r.indexOf(":");
  p > 0 ? (l = t.prefix = r.slice(0, p), u = t.localName = r.slice(p + 1)) : (l = null, u = t.localName = r);
  var y = t.uri = n[l || ""];
  if (e.startElement(y, u, r, t), t.closed) {
    if (e.endElement(y, u, r), i)
      for (l in i)
        Object.prototype.hasOwnProperty.call(i, l) && e.endPrefixMapping(l);
  } else
    return t.currentNSMap = n, t.localNSMap = i, !0;
}
function jV(t, e, n, r, i) {
  if (/^(?:script|textarea)$/i.test(n)) {
    var o = t.indexOf("</" + n + ">", e), a = t.substring(e + 1, o);
    if (/[&<]/.test(a))
      return /^script$/i.test(n) ? (i.characters(a, 0, a.length), o) : (a = a.replace(/&#?\w+;/g, r), i.characters(a, 0, a.length), o);
  }
  return e + 1;
}
function HV(t, e, n, r) {
  var i = r[n];
  return i == null && (i = t.lastIndexOf("</" + n + ">"), i < e && (i = t.lastIndexOf("</" + n)), r[n] = i), i < e;
}
function DR(t, e) {
  for (var n in t)
    Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
}
function VV(t, e, n, r) {
  var i = t.charAt(e + 2);
  switch (i) {
    case "-":
      if (t.charAt(e + 3) === "-") {
        var o = t.indexOf("-->", e + 4);
        return o > e ? (n.comment(t, e + 4, o - e - 4), o + 3) : (r.error("Unclosed comment"), -1);
      } else
        return -1;
    default:
      if (t.substr(e + 3, 6) == "CDATA[") {
        var o = t.indexOf("]]>", e + 9);
        return n.startCDATA(), n.characters(t, e + 9, o - e - 9), n.endCDATA(), o + 3;
      }
      var a = XV(t, e), s = a.length;
      if (s > 1 && /!doctype/i.test(a[0][0])) {
        var l = a[1][0], u = !1, f = !1;
        s > 3 && (/^public$/i.test(a[2][0]) ? (u = a[3][0], f = s > 4 && a[4][0]) : /^system$/i.test(a[2][0]) && (f = a[3][0]));
        var h = a[s - 1];
        return n.startDTD(l, u, f), n.endDTD(), h.index + h[0].length;
      }
  }
  return -1;
}
function qV(t, e, n) {
  var r = t.indexOf("?>", e);
  if (r) {
    var i = t.substring(e, r).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
    return i ? (i[0].length, n.processingInstruction(i[1], i[2]), r + 2) : -1;
  }
  return -1;
}
function wR() {
  this.attributeNames = {};
}
wR.prototype = {
  setTagName: function(t) {
    if (!KC.test(t))
      throw new Error("invalid tagName:" + t);
    this.tagName = t;
  },
  addValue: function(t, e, n) {
    if (!KC.test(t))
      throw new Error("invalid attribute:" + t);
    this.attributeNames[t] = this.length, this[this.length++] = { qName: t, value: e, offset: n };
  },
  length: 0,
  getLocalName: function(t) {
    return this[t].localName;
  },
  getLocator: function(t) {
    return this[t].locator;
  },
  getQName: function(t) {
    return this[t].qName;
  },
  getURI: function(t) {
    return this[t].uri;
  },
  getValue: function(t) {
    return this[t].value;
  }
  //	,getIndex:function(uri, localName)){
  //		if(localName){
  //
  //		}else{
  //			var qName = uri
  //		}
  //	},
  //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
  //	getType:function(uri,localName){}
  //	getType:function(i){},
};
function XV(t, e) {
  var n, r = [], i = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
  for (i.lastIndex = e, i.exec(t); n = i.exec(t); )
    if (r.push(n), n[1]) return r;
}
Yx.XMLReader = xR;
Yx.ParseError = mu;
var GV = Yo, JV = io, tE = vR, SR = Yx, YV = JV.DOMImplementation, nE = GV.NAMESPACE, ZV = SR.ParseError, KV = SR.XMLReader;
function TR(t) {
  return t.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028]/g, `
`);
}
function CR(t) {
  this.options = t || { locator: {} };
}
CR.prototype.parseFromString = function(t, e) {
  var n = this.options, r = new KV(), i = n.domBuilder || new th(), o = n.errorHandler, a = n.locator, s = n.xmlns || {}, l = /\/x?html?$/.test(e), u = l ? tE.HTML_ENTITIES : tE.XML_ENTITIES;
  a && i.setDocumentLocator(a), r.errorHandler = QV(o, i, a), r.domBuilder = n.domBuilder || i, l && (s[""] = nE.HTML), s.xml = s.xml || nE.XML;
  var f = n.normalizeLineEndings || TR;
  return t && typeof t == "string" ? r.parse(
    f(t),
    s,
    u
  ) : r.errorHandler.error("invalid doc source"), i.doc;
};
function QV(t, e, n) {
  if (!t) {
    if (e instanceof th)
      return e;
    t = e;
  }
  var r = {}, i = t instanceof Function;
  n = n || {};
  function o(a) {
    var s = t[a];
    !s && i && (s = t.length == 2 ? function(l) {
      t(a, l);
    } : t), r[a] = s && function(l) {
      s("[xmldom " + a + "]	" + l + V0(n));
    } || function() {
    };
  }
  return o("warning"), o("error"), o("fatalError"), r;
}
function th() {
  this.cdata = !1;
}
function Ic(t, e) {
  e.lineNumber = t.lineNumber, e.columnNumber = t.columnNumber;
}
th.prototype = {
  startDocument: function() {
    this.doc = new YV().createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId);
  },
  startElement: function(t, e, n, r) {
    var i = this.doc, o = i.createElementNS(t, n || e), a = r.length;
    fp(this, o), this.currentElement = o, this.locator && Ic(this.locator, o);
    for (var s = 0; s < a; s++) {
      var t = r.getURI(s), l = r.getValue(s), n = r.getQName(s), u = i.createAttributeNS(t, n);
      this.locator && Ic(r.getLocator(s), u), u.value = u.nodeValue = l, o.setAttributeNode(u);
    }
  },
  endElement: function(t, e, n) {
    var r = this.currentElement;
    r.tagName, this.currentElement = r.parentNode;
  },
  startPrefixMapping: function(t, e) {
  },
  endPrefixMapping: function(t) {
  },
  processingInstruction: function(t, e) {
    var n = this.doc.createProcessingInstruction(t, e);
    this.locator && Ic(this.locator, n), fp(this, n);
  },
  ignorableWhitespace: function(t, e, n) {
  },
  characters: function(t, e, n) {
    if (t = rE.apply(this, arguments), t) {
      if (this.cdata)
        var r = this.doc.createCDATASection(t);
      else
        var r = this.doc.createTextNode(t);
      this.currentElement ? this.currentElement.appendChild(r) : /^\s*$/.test(t) && this.doc.appendChild(r), this.locator && Ic(this.locator, r);
    }
  },
  skippedEntity: function(t) {
  },
  endDocument: function() {
    this.doc.normalize();
  },
  setDocumentLocator: function(t) {
    (this.locator = t) && (t.lineNumber = 0);
  },
  //LexicalHandler
  comment: function(t, e, n) {
    t = rE.apply(this, arguments);
    var r = this.doc.createComment(t);
    this.locator && Ic(this.locator, r), fp(this, r);
  },
  startCDATA: function() {
    this.cdata = !0;
  },
  endCDATA: function() {
    this.cdata = !1;
  },
  startDTD: function(t, e, n) {
    var r = this.doc.implementation;
    if (r && r.createDocumentType) {
      var i = r.createDocumentType(t, e, n);
      this.locator && Ic(this.locator, i), fp(this, i), this.doc.doctype = i;
    }
  },
  /**
   * @see org.xml.sax.ErrorHandler
   * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
   */
  warning: function(t) {
    console.warn("[xmldom warning]	" + t, V0(this.locator));
  },
  error: function(t) {
    console.error("[xmldom error]	" + t, V0(this.locator));
  },
  fatalError: function(t) {
    throw new ZV(t, this.locator);
  }
};
function V0(t) {
  if (t)
    return `
@` + (t.systemId || "") + "#[line:" + t.lineNumber + ",col:" + t.columnNumber + "]";
}
function rE(t, e, n) {
  return typeof t == "string" ? t.substr(e, n) : t.length >= e + n || e ? new java.lang.String(t, e, n) + "" : t;
}
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(t) {
  th.prototype[t] = function() {
    return null;
  };
});
function fp(t, e) {
  t.currentElement ? t.currentElement.appendChild(e) : t.doc.appendChild(e);
}
qm.__DOMHandler = th;
qm.normalizeLineEndings = TR;
qm.DOMParser = CR;
var ER = io;
jm.DOMImplementation = ER.DOMImplementation;
jm.XMLSerializer = ER.XMLSerializer;
jm.DOMParser = qm.DOMParser;
var eq = jm, tq = io;
function nq(t) {
  var e = null, n = new eq.DOMParser({
    errorHandler: function(i, o) {
      e = { level: i, message: o };
    }
  }), r = n.parseFromString(t);
  if (e === null)
    return r;
  throw new Error(e.level + ": " + e.message);
}
Lx.parseFromString = nq;
Lx.Node = tq.Node;
var Kv = rn, iE = $t, _R = Lx, kR = Fu, rq = kR.Element;
YF.readString = iq;
var oE = _R.Node;
function iq(t, e) {
  e = e || {};
  try {
    var n = _R.parseFromString(t, "text/xml");
  } catch (a) {
    return Kv.reject(a);
  }
  if (n.documentElement.tagName === "parsererror")
    return Kv.resolve(new Error(n.documentElement.textContent));
  function r(a) {
    switch (a.nodeType) {
      case oE.ELEMENT_NODE:
        return i(a);
      case oE.TEXT_NODE:
        return kR.text(a.nodeValue);
    }
  }
  function i(a) {
    var s = o(a), l = [];
    iE.forEach(a.childNodes, function(f) {
      var h = r(f);
      h && l.push(h);
    });
    var u = {};
    return iE.forEach(a.attributes, function(f) {
      u[o(f)] = f.value;
    }), new rq(s, u, l);
  }
  function o(a) {
    if (a.namespaceURI) {
      var s = e[a.namespaceURI], l;
      return s ? l = s + ":" : l = "{" + a.namespaceURI + "}", l + a.localName;
    } else
      return a.localName;
  }
  return Kv.resolve(r(n.documentElement));
}
var AR = {}, Vf = {}, Ao = {}, aE;
function ds() {
  return aE || (aE = 1, (function() {
    var t, e, n, r, i, o, a, s = [].slice, l = {}.hasOwnProperty;
    t = function() {
      var u, f, h, p, y, b;
      if (b = arguments[0], y = 2 <= arguments.length ? s.call(arguments, 1) : [], i(Object.assign))
        Object.assign.apply(null, arguments);
      else
        for (u = 0, h = y.length; u < h; u++)
          if (p = y[u], p != null)
            for (f in p)
              l.call(p, f) && (b[f] = p[f]);
      return b;
    }, i = function(u) {
      return !!u && Object.prototype.toString.call(u) === "[object Function]";
    }, o = function(u) {
      var f;
      return !!u && ((f = typeof u) == "function" || f === "object");
    }, n = function(u) {
      return i(Array.isArray) ? Array.isArray(u) : Object.prototype.toString.call(u) === "[object Array]";
    }, r = function(u) {
      var f;
      if (n(u))
        return !u.length;
      for (f in u)
        if (l.call(u, f))
          return !1;
      return !0;
    }, a = function(u) {
      var f, h;
      return o(u) && (h = Object.getPrototypeOf(u)) && (f = h.constructor) && typeof f == "function" && f instanceof f && Function.prototype.toString.call(f) === Function.prototype.toString.call(Object);
    }, e = function(u) {
      return i(u.valueOf) ? u.valueOf() : u;
    }, Ao.assign = t, Ao.isFunction = i, Ao.isObject = o, Ao.isArray = n, Ao.isEmpty = r, Ao.isPlainObject = a, Ao.getValue = e;
  }).call(it)), Ao;
}
var Qv = { exports: {} }, e1 = { exports: {} }, t1 = { exports: {} }, n1 = { exports: {} }, sE;
function UR() {
  return sE || (sE = 1, (function() {
    n1.exports = function() {
      function t(e, n, r) {
        if (this.options = e.options, this.stringify = e.stringify, this.parent = e, n == null)
          throw new Error("Missing attribute name. " + this.debugInfo(n));
        if (r == null)
          throw new Error("Missing attribute value. " + this.debugInfo(n));
        this.name = this.stringify.attName(n), this.value = this.stringify.attValue(r);
      }
      return t.prototype.clone = function() {
        return Object.create(this);
      }, t.prototype.toString = function(e) {
        return this.options.writer.set(e).attribute(this);
      }, t.prototype.debugInfo = function(e) {
        return e = e || this.name, e == null ? "parent: <" + this.parent.name + ">" : "attribute: {" + e + "}, parent: <" + this.parent.name + ">";
      }, t;
    }();
  }).call(it)), n1.exports;
}
var lE;
function Xm() {
  return lE || (lE = 1, (function() {
    var t, e, n, r, i, o, a = function(l, u) {
      for (var f in u)
        s.call(u, f) && (l[f] = u[f]);
      function h() {
        this.constructor = l;
      }
      return h.prototype = u.prototype, l.prototype = new h(), l.__super__ = u.prototype, l;
    }, s = {}.hasOwnProperty;
    o = ds(), i = o.isObject, r = o.isFunction, n = o.getValue, e = yr(), t = UR(), t1.exports = function(l) {
      a(u, l);
      function u(f, h, p) {
        if (u.__super__.constructor.call(this, f), h == null)
          throw new Error("Missing element name. " + this.debugInfo());
        this.name = this.stringify.eleName(h), this.attributes = {}, p != null && this.attribute(p), f.isDocument && (this.isRoot = !0, this.documentObject = f, f.rootObject = this);
      }
      return u.prototype.clone = function() {
        var f, h, p, y;
        p = Object.create(this), p.isRoot && (p.documentObject = null), p.attributes = {}, y = this.attributes;
        for (h in y)
          s.call(y, h) && (f = y[h], p.attributes[h] = f.clone());
        return p.children = [], this.children.forEach(function(b) {
          var x;
          return x = b.clone(), x.parent = p, p.children.push(x);
        }), p;
      }, u.prototype.attribute = function(f, h) {
        var p, y;
        if (f != null && (f = n(f)), i(f))
          for (p in f)
            s.call(f, p) && (y = f[p], this.attribute(p, y));
        else
          r(h) && (h = h.apply()), (!this.options.skipNullAttributes || h != null) && (this.attributes[f] = new t(this, f, h));
        return this;
      }, u.prototype.removeAttribute = function(f) {
        var h, p, y;
        if (f == null)
          throw new Error("Missing attribute name. " + this.debugInfo());
        if (f = n(f), Array.isArray(f))
          for (p = 0, y = f.length; p < y; p++)
            h = f[p], delete this.attributes[h];
        else
          delete this.attributes[f];
        return this;
      }, u.prototype.toString = function(f) {
        return this.options.writer.set(f).element(this);
      }, u.prototype.att = function(f, h) {
        return this.attribute(f, h);
      }, u.prototype.a = function(f, h) {
        return this.attribute(f, h);
      }, u;
    }(e);
  }).call(it)), t1.exports;
}
var r1 = { exports: {} }, cE;
function Gm() {
  return cE || (cE = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = yr(), r1.exports = function(r) {
      e(i, r);
      function i(o, a) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing CDATA text. " + this.debugInfo());
        this.text = this.stringify.cdata(a);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(o) {
        return this.options.writer.set(o).cdata(this);
      }, i;
    }(t);
  }).call(it)), r1.exports;
}
var i1 = { exports: {} }, uE;
function Jm() {
  return uE || (uE = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = yr(), i1.exports = function(r) {
      e(i, r);
      function i(o, a) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing comment text. " + this.debugInfo());
        this.text = this.stringify.comment(a);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(o) {
        return this.options.writer.set(o).comment(this);
      }, i;
    }(t);
  }).call(it)), i1.exports;
}
var o1 = { exports: {} }, fE;
function Ym() {
  return fE || (fE = 1, (function() {
    var t, e, n = function(i, o) {
      for (var a in o)
        r.call(o, a) && (i[a] = o[a]);
      function s() {
        this.constructor = i;
      }
      return s.prototype = o.prototype, i.prototype = new s(), i.__super__ = o.prototype, i;
    }, r = {}.hasOwnProperty;
    e = ds().isObject, t = yr(), o1.exports = function(i) {
      n(o, i);
      function o(a, s, l, u) {
        var f;
        o.__super__.constructor.call(this, a), e(s) && (f = s, s = f.version, l = f.encoding, u = f.standalone), s || (s = "1.0"), this.version = this.stringify.xmlVersion(s), l != null && (this.encoding = this.stringify.xmlEncoding(l)), u != null && (this.standalone = this.stringify.xmlStandalone(u));
      }
      return o.prototype.toString = function(a) {
        return this.options.writer.set(a).declaration(this);
      }, o;
    }(t);
  }).call(it)), o1.exports;
}
var a1 = { exports: {} }, s1 = { exports: {} }, dE;
function Zm() {
  return dE || (dE = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = yr(), s1.exports = function(r) {
      e(i, r);
      function i(o, a, s, l, u, f) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        if (s == null)
          throw new Error("Missing DTD attribute name. " + this.debugInfo(a));
        if (!l)
          throw new Error("Missing DTD attribute type. " + this.debugInfo(a));
        if (!u)
          throw new Error("Missing DTD attribute default. " + this.debugInfo(a));
        if (u.indexOf("#") !== 0 && (u = "#" + u), !u.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/))
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(a));
        if (f && !u.match(/^(#FIXED|#DEFAULT)$/))
          throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(a));
        this.elementName = this.stringify.eleName(a), this.attributeName = this.stringify.attName(s), this.attributeType = this.stringify.dtdAttType(l), this.defaultValue = this.stringify.dtdAttDefault(f), this.defaultValueType = u;
      }
      return i.prototype.toString = function(o) {
        return this.options.writer.set(o).dtdAttList(this);
      }, i;
    }(t);
  }).call(it)), s1.exports;
}
var l1 = { exports: {} }, hE;
function Km() {
  return hE || (hE = 1, (function() {
    var t, e, n = function(i, o) {
      for (var a in o)
        r.call(o, a) && (i[a] = o[a]);
      function s() {
        this.constructor = i;
      }
      return s.prototype = o.prototype, i.prototype = new s(), i.__super__ = o.prototype, i;
    }, r = {}.hasOwnProperty;
    e = ds().isObject, t = yr(), l1.exports = function(i) {
      n(o, i);
      function o(a, s, l, u) {
        if (o.__super__.constructor.call(this, a), l == null)
          throw new Error("Missing DTD entity name. " + this.debugInfo(l));
        if (u == null)
          throw new Error("Missing DTD entity value. " + this.debugInfo(l));
        if (this.pe = !!s, this.name = this.stringify.eleName(l), !e(u))
          this.value = this.stringify.dtdEntityValue(u);
        else {
          if (!u.pubID && !u.sysID)
            throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(l));
          if (u.pubID && !u.sysID)
            throw new Error("System identifier is required for a public external entity. " + this.debugInfo(l));
          if (u.pubID != null && (this.pubID = this.stringify.dtdPubID(u.pubID)), u.sysID != null && (this.sysID = this.stringify.dtdSysID(u.sysID)), u.nData != null && (this.nData = this.stringify.dtdNData(u.nData)), this.pe && this.nData)
            throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(l));
        }
      }
      return o.prototype.toString = function(a) {
        return this.options.writer.set(a).dtdEntity(this);
      }, o;
    }(t);
  }).call(it)), l1.exports;
}
var c1 = { exports: {} }, pE;
function Qm() {
  return pE || (pE = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = yr(), c1.exports = function(r) {
      e(i, r);
      function i(o, a, s) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing DTD element name. " + this.debugInfo());
        s || (s = "(#PCDATA)"), Array.isArray(s) && (s = "(" + s.join(",") + ")"), this.name = this.stringify.eleName(a), this.value = this.stringify.dtdElementValue(s);
      }
      return i.prototype.toString = function(o) {
        return this.options.writer.set(o).dtdElement(this);
      }, i;
    }(t);
  }).call(it)), c1.exports;
}
var u1 = { exports: {} }, gE;
function ey() {
  return gE || (gE = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = yr(), u1.exports = function(r) {
      e(i, r);
      function i(o, a, s) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing DTD notation name. " + this.debugInfo(a));
        if (!s.pubID && !s.sysID)
          throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(a));
        this.name = this.stringify.eleName(a), s.pubID != null && (this.pubID = this.stringify.dtdPubID(s.pubID)), s.sysID != null && (this.sysID = this.stringify.dtdSysID(s.sysID));
      }
      return i.prototype.toString = function(o) {
        return this.options.writer.set(o).dtdNotation(this);
      }, i;
    }(t);
  }).call(it)), u1.exports;
}
var mE;
function ty() {
  return mE || (mE = 1, (function() {
    var t, e, n, r, i, o, a = function(l, u) {
      for (var f in u)
        s.call(u, f) && (l[f] = u[f]);
      function h() {
        this.constructor = l;
      }
      return h.prototype = u.prototype, l.prototype = new h(), l.__super__ = u.prototype, l;
    }, s = {}.hasOwnProperty;
    o = ds().isObject, i = yr(), t = Zm(), n = Km(), e = Qm(), r = ey(), a1.exports = function(l) {
      a(u, l);
      function u(f, h, p) {
        var y, b;
        u.__super__.constructor.call(this, f), this.name = "!DOCTYPE", this.documentObject = f, o(h) && (y = h, h = y.pubID, p = y.sysID), p == null && (b = [h, p], p = b[0], h = b[1]), h != null && (this.pubID = this.stringify.dtdPubID(h)), p != null && (this.sysID = this.stringify.dtdSysID(p));
      }
      return u.prototype.element = function(f, h) {
        var p;
        return p = new e(this, f, h), this.children.push(p), this;
      }, u.prototype.attList = function(f, h, p, y, b) {
        var x;
        return x = new t(this, f, h, p, y, b), this.children.push(x), this;
      }, u.prototype.entity = function(f, h) {
        var p;
        return p = new n(this, !1, f, h), this.children.push(p), this;
      }, u.prototype.pEntity = function(f, h) {
        var p;
        return p = new n(this, !0, f, h), this.children.push(p), this;
      }, u.prototype.notation = function(f, h) {
        var p;
        return p = new r(this, f, h), this.children.push(p), this;
      }, u.prototype.toString = function(f) {
        return this.options.writer.set(f).docType(this);
      }, u.prototype.ele = function(f, h) {
        return this.element(f, h);
      }, u.prototype.att = function(f, h, p, y, b) {
        return this.attList(f, h, p, y, b);
      }, u.prototype.ent = function(f, h) {
        return this.entity(f, h);
      }, u.prototype.pent = function(f, h) {
        return this.pEntity(f, h);
      }, u.prototype.not = function(f, h) {
        return this.notation(f, h);
      }, u.prototype.up = function() {
        return this.root() || this.documentObject;
      }, u;
    }(i);
  }).call(it)), a1.exports;
}
var f1 = { exports: {} }, yE;
function ny() {
  return yE || (yE = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = yr(), f1.exports = function(r) {
      e(i, r);
      function i(o, a) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing raw text. " + this.debugInfo());
        this.value = this.stringify.raw(a);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(o) {
        return this.options.writer.set(o).raw(this);
      }, i;
    }(t);
  }).call(it)), f1.exports;
}
var d1 = { exports: {} }, bE;
function ry() {
  return bE || (bE = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = yr(), d1.exports = function(r) {
      e(i, r);
      function i(o, a) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing element text. " + this.debugInfo());
        this.value = this.stringify.eleText(a);
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(o) {
        return this.options.writer.set(o).text(this);
      }, i;
    }(t);
  }).call(it)), d1.exports;
}
var h1 = { exports: {} }, vE;
function iy() {
  return vE || (vE = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = yr(), h1.exports = function(r) {
      e(i, r);
      function i(o, a, s) {
        if (i.__super__.constructor.call(this, o), a == null)
          throw new Error("Missing instruction target. " + this.debugInfo());
        this.target = this.stringify.insTarget(a), s && (this.value = this.stringify.insValue(s));
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(o) {
        return this.options.writer.set(o).processingInstruction(this);
      }, i;
    }(t);
  }).call(it)), h1.exports;
}
var p1 = { exports: {} }, xE;
function Zx() {
  return xE || (xE = 1, (function() {
    var t, e = function(r, i) {
      for (var o in i)
        n.call(i, o) && (r[o] = i[o]);
      function a() {
        this.constructor = r;
      }
      return a.prototype = i.prototype, r.prototype = new a(), r.__super__ = i.prototype, r;
    }, n = {}.hasOwnProperty;
    t = yr(), p1.exports = function(r) {
      e(i, r);
      function i(o) {
        i.__super__.constructor.call(this, o), this.isDummy = !0;
      }
      return i.prototype.clone = function() {
        return Object.create(this);
      }, i.prototype.toString = function(o) {
        return "";
      }, i;
    }(t);
  }).call(it)), p1.exports;
}
var DE;
function yr() {
  return DE || (DE = 1, (function() {
    var t, e, n, r, i, o, a, s, l, u, f, h, p, y, b = {}.hasOwnProperty;
    y = ds(), p = y.isObject, h = y.isFunction, f = y.isEmpty, u = y.getValue, o = null, t = null, e = null, n = null, r = null, s = null, l = null, a = null, i = null, e1.exports = function() {
      function x(v) {
        this.parent = v, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), this.children = [], o || (o = Xm(), t = Gm(), e = Jm(), n = Ym(), r = ty(), s = ny(), l = ry(), a = iy(), i = Zx());
      }
      return x.prototype.element = function(v, D, S) {
        var E, I, R, O, N, q, $, le, ve, M, ee;
        if (q = null, D === null && S == null && (ve = [{}, null], D = ve[0], S = ve[1]), D == null && (D = {}), D = u(D), p(D) || (M = [D, S], S = M[0], D = M[1]), v != null && (v = u(v)), Array.isArray(v))
          for (R = 0, $ = v.length; R < $; R++)
            I = v[R], q = this.element(I);
        else if (h(v))
          q = this.element(v.apply());
        else if (p(v)) {
          for (N in v)
            if (b.call(v, N))
              if (ee = v[N], h(ee) && (ee = ee.apply()), p(ee) && f(ee) && (ee = null), !this.options.ignoreDecorators && this.stringify.convertAttKey && N.indexOf(this.stringify.convertAttKey) === 0)
                q = this.attribute(N.substr(this.stringify.convertAttKey.length), ee);
              else if (!this.options.separateArrayItems && Array.isArray(ee))
                for (O = 0, le = ee.length; O < le; O++)
                  I = ee[O], E = {}, E[N] = I, q = this.element(E);
              else p(ee) ? (q = this.element(N), q.element(ee)) : q = this.element(N, ee);
        } else this.options.skipNullNodes && S === null ? q = this.dummy() : !this.options.ignoreDecorators && this.stringify.convertTextKey && v.indexOf(this.stringify.convertTextKey) === 0 ? q = this.text(S) : !this.options.ignoreDecorators && this.stringify.convertCDataKey && v.indexOf(this.stringify.convertCDataKey) === 0 ? q = this.cdata(S) : !this.options.ignoreDecorators && this.stringify.convertCommentKey && v.indexOf(this.stringify.convertCommentKey) === 0 ? q = this.comment(S) : !this.options.ignoreDecorators && this.stringify.convertRawKey && v.indexOf(this.stringify.convertRawKey) === 0 ? q = this.raw(S) : !this.options.ignoreDecorators && this.stringify.convertPIKey && v.indexOf(this.stringify.convertPIKey) === 0 ? q = this.instruction(v.substr(this.stringify.convertPIKey.length), S) : q = this.node(v, D, S);
        if (q == null)
          throw new Error("Could not create any elements with: " + v + ". " + this.debugInfo());
        return q;
      }, x.prototype.insertBefore = function(v, D, S) {
        var E, I, R;
        if (this.isRoot)
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(v));
        return I = this.parent.children.indexOf(this), R = this.parent.children.splice(I), E = this.parent.element(v, D, S), Array.prototype.push.apply(this.parent.children, R), E;
      }, x.prototype.insertAfter = function(v, D, S) {
        var E, I, R;
        if (this.isRoot)
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(v));
        return I = this.parent.children.indexOf(this), R = this.parent.children.splice(I + 1), E = this.parent.element(v, D, S), Array.prototype.push.apply(this.parent.children, R), E;
      }, x.prototype.remove = function() {
        var v;
        if (this.isRoot)
          throw new Error("Cannot remove the root element. " + this.debugInfo());
        return v = this.parent.children.indexOf(this), [].splice.apply(this.parent.children, [v, v - v + 1].concat([])), this.parent;
      }, x.prototype.node = function(v, D, S) {
        var E, I;
        return v != null && (v = u(v)), D || (D = {}), D = u(D), p(D) || (I = [D, S], S = I[0], D = I[1]), E = new o(this, v, D), S != null && E.text(S), this.children.push(E), E;
      }, x.prototype.text = function(v) {
        var D;
        return D = new l(this, v), this.children.push(D), this;
      }, x.prototype.cdata = function(v) {
        var D;
        return D = new t(this, v), this.children.push(D), this;
      }, x.prototype.comment = function(v) {
        var D;
        return D = new e(this, v), this.children.push(D), this;
      }, x.prototype.commentBefore = function(v) {
        var D, S;
        return D = this.parent.children.indexOf(this), S = this.parent.children.splice(D), this.parent.comment(v), Array.prototype.push.apply(this.parent.children, S), this;
      }, x.prototype.commentAfter = function(v) {
        var D, S;
        return D = this.parent.children.indexOf(this), S = this.parent.children.splice(D + 1), this.parent.comment(v), Array.prototype.push.apply(this.parent.children, S), this;
      }, x.prototype.raw = function(v) {
        var D;
        return D = new s(this, v), this.children.push(D), this;
      }, x.prototype.dummy = function() {
        var v;
        return v = new i(this), this.children.push(v), v;
      }, x.prototype.instruction = function(v, D) {
        var S, E, I, R, O;
        if (v != null && (v = u(v)), D != null && (D = u(D)), Array.isArray(v))
          for (R = 0, O = v.length; R < O; R++)
            S = v[R], this.instruction(S);
        else if (p(v))
          for (S in v)
            b.call(v, S) && (E = v[S], this.instruction(S, E));
        else
          h(D) && (D = D.apply()), I = new a(this, v, D), this.children.push(I);
        return this;
      }, x.prototype.instructionBefore = function(v, D) {
        var S, E;
        return S = this.parent.children.indexOf(this), E = this.parent.children.splice(S), this.parent.instruction(v, D), Array.prototype.push.apply(this.parent.children, E), this;
      }, x.prototype.instructionAfter = function(v, D) {
        var S, E;
        return S = this.parent.children.indexOf(this), E = this.parent.children.splice(S + 1), this.parent.instruction(v, D), Array.prototype.push.apply(this.parent.children, E), this;
      }, x.prototype.declaration = function(v, D, S) {
        var E, I;
        return E = this.document(), I = new n(E, v, D, S), E.children[0] instanceof n ? E.children[0] = I : E.children.unshift(I), E.root() || E;
      }, x.prototype.doctype = function(v, D) {
        var S, E, I, R, O, N, q, $, le, ve;
        for (E = this.document(), I = new r(E, v, D), le = E.children, R = O = 0, q = le.length; O < q; R = ++O)
          if (S = le[R], S instanceof r)
            return E.children[R] = I, I;
        for (ve = E.children, R = N = 0, $ = ve.length; N < $; R = ++N)
          if (S = ve[R], S.isRoot)
            return E.children.splice(R, 0, I), I;
        return E.children.push(I), I;
      }, x.prototype.up = function() {
        if (this.isRoot)
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
        return this.parent;
      }, x.prototype.root = function() {
        var v;
        for (v = this; v; ) {
          if (v.isDocument)
            return v.rootObject;
          if (v.isRoot)
            return v;
          v = v.parent;
        }
      }, x.prototype.document = function() {
        var v;
        for (v = this; v; ) {
          if (v.isDocument)
            return v;
          v = v.parent;
        }
      }, x.prototype.end = function(v) {
        return this.document().end(v);
      }, x.prototype.prev = function() {
        var v;
        for (v = this.parent.children.indexOf(this); v > 0 && this.parent.children[v - 1].isDummy; )
          v = v - 1;
        if (v < 1)
          throw new Error("Already at the first node. " + this.debugInfo());
        return this.parent.children[v - 1];
      }, x.prototype.next = function() {
        var v;
        for (v = this.parent.children.indexOf(this); v < this.parent.children.length - 1 && this.parent.children[v + 1].isDummy; )
          v = v + 1;
        if (v === -1 || v === this.parent.children.length - 1)
          throw new Error("Already at the last node. " + this.debugInfo());
        return this.parent.children[v + 1];
      }, x.prototype.importDocument = function(v) {
        var D;
        return D = v.root().clone(), D.parent = this, D.isRoot = !1, this.children.push(D), this;
      }, x.prototype.debugInfo = function(v) {
        var D, S;
        return v = v || this.name, v == null && !((D = this.parent) != null && D.name) ? "" : v == null ? "parent: <" + this.parent.name + ">" : (S = this.parent) != null && S.name ? "node: <" + v + ">, parent: <" + this.parent.name + ">" : "node: <" + v + ">";
      }, x.prototype.ele = function(v, D, S) {
        return this.element(v, D, S);
      }, x.prototype.nod = function(v, D, S) {
        return this.node(v, D, S);
      }, x.prototype.txt = function(v) {
        return this.text(v);
      }, x.prototype.dat = function(v) {
        return this.cdata(v);
      }, x.prototype.com = function(v) {
        return this.comment(v);
      }, x.prototype.ins = function(v, D) {
        return this.instruction(v, D);
      }, x.prototype.doc = function() {
        return this.document();
      }, x.prototype.dec = function(v, D, S) {
        return this.declaration(v, D, S);
      }, x.prototype.dtd = function(v, D) {
        return this.doctype(v, D);
      }, x.prototype.e = function(v, D, S) {
        return this.element(v, D, S);
      }, x.prototype.n = function(v, D, S) {
        return this.node(v, D, S);
      }, x.prototype.t = function(v) {
        return this.text(v);
      }, x.prototype.d = function(v) {
        return this.cdata(v);
      }, x.prototype.c = function(v) {
        return this.comment(v);
      }, x.prototype.r = function(v) {
        return this.raw(v);
      }, x.prototype.i = function(v, D) {
        return this.instruction(v, D);
      }, x.prototype.u = function() {
        return this.up();
      }, x.prototype.importXMLBuilder = function(v) {
        return this.importDocument(v);
      }, x;
    }();
  }).call(it)), e1.exports;
}
var g1 = { exports: {} }, wE;
function FR() {
  return wE || (wE = 1, (function() {
    var t = function(n, r) {
      return function() {
        return n.apply(r, arguments);
      };
    }, e = {}.hasOwnProperty;
    g1.exports = function() {
      function n(r) {
        this.assertLegalChar = t(this.assertLegalChar, this);
        var i, o, a;
        r || (r = {}), this.noDoubleEncoding = r.noDoubleEncoding, o = r.stringify || {};
        for (i in o)
          e.call(o, i) && (a = o[i], this[i] = a);
      }
      return n.prototype.eleName = function(r) {
        return r = "" + r || "", this.assertLegalChar(r);
      }, n.prototype.eleText = function(r) {
        return r = "" + r || "", this.assertLegalChar(this.elEscape(r));
      }, n.prototype.cdata = function(r) {
        return r = "" + r || "", r = r.replace("]]>", "]]]]><![CDATA[>"), this.assertLegalChar(r);
      }, n.prototype.comment = function(r) {
        if (r = "" + r || "", r.match(/--/))
          throw new Error("Comment text cannot contain double-hypen: " + r);
        return this.assertLegalChar(r);
      }, n.prototype.raw = function(r) {
        return "" + r || "";
      }, n.prototype.attName = function(r) {
        return r = "" + r || "";
      }, n.prototype.attValue = function(r) {
        return r = "" + r || "", this.attEscape(r);
      }, n.prototype.insTarget = function(r) {
        return "" + r || "";
      }, n.prototype.insValue = function(r) {
        if (r = "" + r || "", r.match(/\?>/))
          throw new Error("Invalid processing instruction value: " + r);
        return r;
      }, n.prototype.xmlVersion = function(r) {
        if (r = "" + r || "", !r.match(/1\.[0-9]+/))
          throw new Error("Invalid version number: " + r);
        return r;
      }, n.prototype.xmlEncoding = function(r) {
        if (r = "" + r || "", !r.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/))
          throw new Error("Invalid encoding: " + r);
        return r;
      }, n.prototype.xmlStandalone = function(r) {
        return r ? "yes" : "no";
      }, n.prototype.dtdPubID = function(r) {
        return "" + r || "";
      }, n.prototype.dtdSysID = function(r) {
        return "" + r || "";
      }, n.prototype.dtdElementValue = function(r) {
        return "" + r || "";
      }, n.prototype.dtdAttType = function(r) {
        return "" + r || "";
      }, n.prototype.dtdAttDefault = function(r) {
        return r != null ? "" + r || "" : r;
      }, n.prototype.dtdEntityValue = function(r) {
        return "" + r || "";
      }, n.prototype.dtdNData = function(r) {
        return "" + r || "";
      }, n.prototype.convertAttKey = "@", n.prototype.convertPIKey = "?", n.prototype.convertTextKey = "#text", n.prototype.convertCDataKey = "#cdata", n.prototype.convertCommentKey = "#comment", n.prototype.convertRawKey = "#raw", n.prototype.assertLegalChar = function(r) {
        var i;
        if (i = r.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), i)
          throw new Error("Invalid character in string: " + r + " at index " + i.index);
        return r;
      }, n.prototype.elEscape = function(r) {
        var i;
        return i = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, r.replace(i, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
      }, n.prototype.attEscape = function(r) {
        var i;
        return i = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, r.replace(i, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
      }, n;
    }();
  }).call(it)), g1.exports;
}
var m1 = { exports: {} }, y1 = { exports: {} }, SE;
function RR() {
  return SE || (SE = 1, (function() {
    var t = {}.hasOwnProperty;
    y1.exports = function() {
      function e(n) {
        var r, i, o, a, s, l, u, f, h;
        n || (n = {}), this.pretty = n.pretty || !1, this.allowEmpty = (i = n.allowEmpty) != null ? i : !1, this.pretty ? (this.indent = (o = n.indent) != null ? o : "  ", this.newline = (a = n.newline) != null ? a : `
`, this.offset = (s = n.offset) != null ? s : 0, this.dontprettytextnodes = (l = n.dontprettytextnodes) != null ? l : 0) : (this.indent = "", this.newline = "", this.offset = 0, this.dontprettytextnodes = 0), this.spacebeforeslash = (u = n.spacebeforeslash) != null ? u : "", this.spacebeforeslash === !0 && (this.spacebeforeslash = " "), this.newlinedefault = this.newline, this.prettydefault = this.pretty, f = n.writer || {};
        for (r in f)
          t.call(f, r) && (h = f[r], this[r] = h);
      }
      return e.prototype.set = function(n) {
        var r, i, o;
        n || (n = {}), "pretty" in n && (this.pretty = n.pretty), "allowEmpty" in n && (this.allowEmpty = n.allowEmpty), this.pretty ? (this.indent = "indent" in n ? n.indent : "  ", this.newline = "newline" in n ? n.newline : `
`, this.offset = "offset" in n ? n.offset : 0, this.dontprettytextnodes = "dontprettytextnodes" in n ? n.dontprettytextnodes : 0) : (this.indent = "", this.newline = "", this.offset = 0, this.dontprettytextnodes = 0), this.spacebeforeslash = "spacebeforeslash" in n ? n.spacebeforeslash : "", this.spacebeforeslash === !0 && (this.spacebeforeslash = " "), this.newlinedefault = this.newline, this.prettydefault = this.pretty, i = n.writer || {};
        for (r in i)
          t.call(i, r) && (o = i[r], this[r] = o);
        return this;
      }, e.prototype.space = function(n) {
        var r;
        return this.pretty ? (r = (n || 0) + this.offset + 1, r > 0 ? new Array(r).join(this.indent) : "") : "";
      }, e;
    }();
  }).call(it)), y1.exports;
}
var TE;
function Kx() {
  return TE || (TE = 1, (function() {
    var t, e, n, r, i, o, a, s, l, u, f, h, p, y, b = function(v, D) {
      for (var S in D)
        x.call(D, S) && (v[S] = D[S]);
      function E() {
        this.constructor = v;
      }
      return E.prototype = D.prototype, v.prototype = new E(), v.__super__ = D.prototype, v;
    }, x = {}.hasOwnProperty;
    a = Ym(), s = ty(), t = Gm(), e = Jm(), u = Xm(), h = ny(), p = ry(), f = iy(), l = Zx(), n = Zm(), r = Qm(), i = Km(), o = ey(), y = RR(), m1.exports = function(v) {
      b(D, v);
      function D(S) {
        D.__super__.constructor.call(this, S);
      }
      return D.prototype.document = function(S) {
        var E, I, R, O, N;
        for (this.textispresent = !1, O = "", N = S.children, I = 0, R = N.length; I < R; I++)
          E = N[I], !(E instanceof l) && (O += (function() {
            switch (!1) {
              case !(E instanceof a):
                return this.declaration(E);
              case !(E instanceof s):
                return this.docType(E);
              case !(E instanceof e):
                return this.comment(E);
              case !(E instanceof f):
                return this.processingInstruction(E);
              default:
                return this.element(E, 0);
            }
          }).call(this));
        return this.pretty && O.slice(-this.newline.length) === this.newline && (O = O.slice(0, -this.newline.length)), O;
      }, D.prototype.attribute = function(S) {
        return " " + S.name + '="' + S.value + '"';
      }, D.prototype.cdata = function(S, E) {
        return this.space(E) + "<![CDATA[" + S.text + "]]>" + this.newline;
      }, D.prototype.comment = function(S, E) {
        return this.space(E) + "<!-- " + S.text + " -->" + this.newline;
      }, D.prototype.declaration = function(S, E) {
        var I;
        return I = this.space(E), I += '<?xml version="' + S.version + '"', S.encoding != null && (I += ' encoding="' + S.encoding + '"'), S.standalone != null && (I += ' standalone="' + S.standalone + '"'), I += this.spacebeforeslash + "?>", I += this.newline, I;
      }, D.prototype.docType = function(S, E) {
        var I, R, O, N, q;
        if (E || (E = 0), N = this.space(E), N += "<!DOCTYPE " + S.root().name, S.pubID && S.sysID ? N += ' PUBLIC "' + S.pubID + '" "' + S.sysID + '"' : S.sysID && (N += ' SYSTEM "' + S.sysID + '"'), S.children.length > 0) {
          for (N += " [", N += this.newline, q = S.children, R = 0, O = q.length; R < O; R++)
            I = q[R], N += (function() {
              switch (!1) {
                case !(I instanceof n):
                  return this.dtdAttList(I, E + 1);
                case !(I instanceof r):
                  return this.dtdElement(I, E + 1);
                case !(I instanceof i):
                  return this.dtdEntity(I, E + 1);
                case !(I instanceof o):
                  return this.dtdNotation(I, E + 1);
                case !(I instanceof t):
                  return this.cdata(I, E + 1);
                case !(I instanceof e):
                  return this.comment(I, E + 1);
                case !(I instanceof f):
                  return this.processingInstruction(I, E + 1);
                default:
                  throw new Error("Unknown DTD node type: " + I.constructor.name);
              }
            }).call(this);
          N += "]";
        }
        return N += this.spacebeforeslash + ">", N += this.newline, N;
      }, D.prototype.element = function(S, E) {
        var I, R, O, N, q, $, le, ve, M, ee, A, oe, j;
        E || (E = 0), j = !1, this.textispresent ? (this.newline = "", this.pretty = !1) : (this.newline = this.newlinedefault, this.pretty = this.prettydefault), oe = this.space(E), ve = "", ve += oe + "<" + S.name, M = S.attributes;
        for (le in M)
          x.call(M, le) && (I = M[le], ve += this.attribute(I));
        if (S.children.length === 0 || S.children.every(function(Q) {
          return Q.value === "";
        }))
          this.allowEmpty ? ve += "></" + S.name + ">" + this.newline : ve += this.spacebeforeslash + "/>" + this.newline;
        else if (this.pretty && S.children.length === 1 && S.children[0].value != null)
          ve += ">", ve += S.children[0].value, ve += "</" + S.name + ">" + this.newline;
        else {
          if (this.dontprettytextnodes) {
            for (ee = S.children, O = 0, q = ee.length; O < q; O++)
              if (R = ee[O], R.value != null) {
                this.textispresent++, j = !0;
                break;
              }
          }
          for (this.textispresent && (this.newline = "", this.pretty = !1, oe = this.space(E)), ve += ">" + this.newline, A = S.children, N = 0, $ = A.length; N < $; N++)
            R = A[N], ve += (function() {
              switch (!1) {
                case !(R instanceof t):
                  return this.cdata(R, E + 1);
                case !(R instanceof e):
                  return this.comment(R, E + 1);
                case !(R instanceof u):
                  return this.element(R, E + 1);
                case !(R instanceof h):
                  return this.raw(R, E + 1);
                case !(R instanceof p):
                  return this.text(R, E + 1);
                case !(R instanceof f):
                  return this.processingInstruction(R, E + 1);
                case !(R instanceof l):
                  return "";
                default:
                  throw new Error("Unknown XML node type: " + R.constructor.name);
              }
            }).call(this);
          j && this.textispresent--, this.textispresent || (this.newline = this.newlinedefault, this.pretty = this.prettydefault), ve += oe + "</" + S.name + ">" + this.newline;
        }
        return ve;
      }, D.prototype.processingInstruction = function(S, E) {
        var I;
        return I = this.space(E) + "<?" + S.target, S.value && (I += " " + S.value), I += this.spacebeforeslash + "?>" + this.newline, I;
      }, D.prototype.raw = function(S, E) {
        return this.space(E) + S.value + this.newline;
      }, D.prototype.text = function(S, E) {
        return this.space(E) + S.value + this.newline;
      }, D.prototype.dtdAttList = function(S, E) {
        var I;
        return I = this.space(E) + "<!ATTLIST " + S.elementName + " " + S.attributeName + " " + S.attributeType, S.defaultValueType !== "#DEFAULT" && (I += " " + S.defaultValueType), S.defaultValue && (I += ' "' + S.defaultValue + '"'), I += this.spacebeforeslash + ">" + this.newline, I;
      }, D.prototype.dtdElement = function(S, E) {
        return this.space(E) + "<!ELEMENT " + S.name + " " + S.value + this.spacebeforeslash + ">" + this.newline;
      }, D.prototype.dtdEntity = function(S, E) {
        var I;
        return I = this.space(E) + "<!ENTITY", S.pe && (I += " %"), I += " " + S.name, S.value ? I += ' "' + S.value + '"' : (S.pubID && S.sysID ? I += ' PUBLIC "' + S.pubID + '" "' + S.sysID + '"' : S.sysID && (I += ' SYSTEM "' + S.sysID + '"'), S.nData && (I += " NDATA " + S.nData)), I += this.spacebeforeslash + ">" + this.newline, I;
      }, D.prototype.dtdNotation = function(S, E) {
        var I;
        return I = this.space(E) + "<!NOTATION " + S.name, S.pubID && S.sysID ? I += ' PUBLIC "' + S.pubID + '" "' + S.sysID + '"' : S.pubID ? I += ' PUBLIC "' + S.pubID + '"' : S.sysID && (I += ' SYSTEM "' + S.sysID + '"'), I += this.spacebeforeslash + ">" + this.newline, I;
      }, D.prototype.openNode = function(S, E) {
        var I, R, O, N;
        if (E || (E = 0), S instanceof u) {
          O = this.space(E) + "<" + S.name, N = S.attributes;
          for (R in N)
            x.call(N, R) && (I = N[R], O += this.attribute(I));
          return O += (S.children ? ">" : "/>") + this.newline, O;
        } else
          return O = this.space(E) + "<!DOCTYPE " + S.rootNodeName, S.pubID && S.sysID ? O += ' PUBLIC "' + S.pubID + '" "' + S.sysID + '"' : S.sysID && (O += ' SYSTEM "' + S.sysID + '"'), O += (S.children ? " [" : ">") + this.newline, O;
      }, D.prototype.closeNode = function(S, E) {
        switch (E || (E = 0), !1) {
          case !(S instanceof u):
            return this.space(E) + "</" + S.name + ">" + this.newline;
          case !(S instanceof s):
            return this.space(E) + "]>" + this.newline;
        }
      }, D;
    }(y);
  }).call(it)), m1.exports;
}
var CE;
function oq() {
  return CE || (CE = 1, (function() {
    var t, e, n, r, i = function(a, s) {
      for (var l in s)
        o.call(s, l) && (a[l] = s[l]);
      function u() {
        this.constructor = a;
      }
      return u.prototype = s.prototype, a.prototype = new u(), a.__super__ = s.prototype, a;
    }, o = {}.hasOwnProperty;
    r = ds().isPlainObject, t = yr(), n = FR(), e = Kx(), Qv.exports = function(a) {
      i(s, a);
      function s(l) {
        s.__super__.constructor.call(this, null), this.name = "?xml", l || (l = {}), l.writer || (l.writer = new e()), this.options = l, this.stringify = new n(l), this.isDocument = !0;
      }
      return s.prototype.end = function(l) {
        var u;
        return l ? r(l) && (u = l, l = this.options.writer.set(u)) : l = this.options.writer, l.document(this);
      }, s.prototype.toString = function(l) {
        return this.options.writer.set(l).document(this);
      }, s;
    }(t);
  }).call(it)), Qv.exports;
}
var b1 = { exports: {} }, EE;
function aq() {
  return EE || (EE = 1, (function() {
    var t, e, n, r, i, o, a, s, l, u, f, h, p, y, b, x, v, D, S, E, I = {}.hasOwnProperty;
    E = ds(), D = E.isObject, v = E.isFunction, S = E.isPlainObject, x = E.getValue, u = Xm(), e = Gm(), n = Jm(), h = ny(), b = ry(), f = iy(), s = Ym(), l = ty(), r = Zm(), o = Km(), i = Qm(), a = ey(), t = UR(), y = FR(), p = Kx(), b1.exports = function() {
      function R(O, N, q) {
        var $;
        this.name = "?xml", O || (O = {}), O.writer ? S(O.writer) && ($ = O.writer, O.writer = new p($)) : O.writer = new p(O), this.options = O, this.writer = O.writer, this.stringify = new y(O), this.onDataCallback = N || function() {
        }, this.onEndCallback = q || function() {
        }, this.currentNode = null, this.currentLevel = -1, this.openTags = {}, this.documentStarted = !1, this.documentCompleted = !1, this.root = null;
      }
      return R.prototype.node = function(O, N, q) {
        var $, le;
        if (O == null)
          throw new Error("Missing node name.");
        if (this.root && this.currentLevel === -1)
          throw new Error("Document can only have one root node. " + this.debugInfo(O));
        return this.openCurrent(), O = x(O), N === null && q == null && ($ = [{}, null], N = $[0], q = $[1]), N == null && (N = {}), N = x(N), D(N) || (le = [N, q], q = le[0], N = le[1]), this.currentNode = new u(this, O, N), this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, q != null && this.text(q), this;
      }, R.prototype.element = function(O, N, q) {
        return this.currentNode && this.currentNode instanceof l ? this.dtdElement.apply(this, arguments) : this.node(O, N, q);
      }, R.prototype.attribute = function(O, N) {
        var q, $;
        if (!this.currentNode || this.currentNode.children)
          throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(O));
        if (O != null && (O = x(O)), D(O))
          for (q in O)
            I.call(O, q) && ($ = O[q], this.attribute(q, $));
        else
          v(N) && (N = N.apply()), (!this.options.skipNullAttributes || N != null) && (this.currentNode.attributes[O] = new t(this, O, N));
        return this;
      }, R.prototype.text = function(O) {
        var N;
        return this.openCurrent(), N = new b(this, O), this.onData(this.writer.text(N, this.currentLevel + 1), this.currentLevel + 1), this;
      }, R.prototype.cdata = function(O) {
        var N;
        return this.openCurrent(), N = new e(this, O), this.onData(this.writer.cdata(N, this.currentLevel + 1), this.currentLevel + 1), this;
      }, R.prototype.comment = function(O) {
        var N;
        return this.openCurrent(), N = new n(this, O), this.onData(this.writer.comment(N, this.currentLevel + 1), this.currentLevel + 1), this;
      }, R.prototype.raw = function(O) {
        var N;
        return this.openCurrent(), N = new h(this, O), this.onData(this.writer.raw(N, this.currentLevel + 1), this.currentLevel + 1), this;
      }, R.prototype.instruction = function(O, N) {
        var q, $, le, ve, M;
        if (this.openCurrent(), O != null && (O = x(O)), N != null && (N = x(N)), Array.isArray(O))
          for (q = 0, ve = O.length; q < ve; q++)
            $ = O[q], this.instruction($);
        else if (D(O))
          for ($ in O)
            I.call(O, $) && (le = O[$], this.instruction($, le));
        else
          v(N) && (N = N.apply()), M = new f(this, O, N), this.onData(this.writer.processingInstruction(M, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      }, R.prototype.declaration = function(O, N, q) {
        var $;
        if (this.openCurrent(), this.documentStarted)
          throw new Error("declaration() must be the first node.");
        return $ = new s(this, O, N, q), this.onData(this.writer.declaration($, this.currentLevel + 1), this.currentLevel + 1), this;
      }, R.prototype.doctype = function(O, N, q) {
        if (this.openCurrent(), O == null)
          throw new Error("Missing root node name.");
        if (this.root)
          throw new Error("dtd() must come before the root node.");
        return this.currentNode = new l(this, N, q), this.currentNode.rootNodeName = O, this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, this;
      }, R.prototype.dtdElement = function(O, N) {
        var q;
        return this.openCurrent(), q = new i(this, O, N), this.onData(this.writer.dtdElement(q, this.currentLevel + 1), this.currentLevel + 1), this;
      }, R.prototype.attList = function(O, N, q, $, le) {
        var ve;
        return this.openCurrent(), ve = new r(this, O, N, q, $, le), this.onData(this.writer.dtdAttList(ve, this.currentLevel + 1), this.currentLevel + 1), this;
      }, R.prototype.entity = function(O, N) {
        var q;
        return this.openCurrent(), q = new o(this, !1, O, N), this.onData(this.writer.dtdEntity(q, this.currentLevel + 1), this.currentLevel + 1), this;
      }, R.prototype.pEntity = function(O, N) {
        var q;
        return this.openCurrent(), q = new o(this, !0, O, N), this.onData(this.writer.dtdEntity(q, this.currentLevel + 1), this.currentLevel + 1), this;
      }, R.prototype.notation = function(O, N) {
        var q;
        return this.openCurrent(), q = new a(this, O, N), this.onData(this.writer.dtdNotation(q, this.currentLevel + 1), this.currentLevel + 1), this;
      }, R.prototype.up = function() {
        if (this.currentLevel < 0)
          throw new Error("The document node has no parent.");
        return this.currentNode ? (this.currentNode.children ? this.closeNode(this.currentNode) : this.openNode(this.currentNode), this.currentNode = null) : this.closeNode(this.openTags[this.currentLevel]), delete this.openTags[this.currentLevel], this.currentLevel--, this;
      }, R.prototype.end = function() {
        for (; this.currentLevel >= 0; )
          this.up();
        return this.onEnd();
      }, R.prototype.openCurrent = function() {
        if (this.currentNode)
          return this.currentNode.children = !0, this.openNode(this.currentNode);
      }, R.prototype.openNode = function(O) {
        if (!O.isOpen)
          return !this.root && this.currentLevel === 0 && O instanceof u && (this.root = O), this.onData(this.writer.openNode(O, this.currentLevel), this.currentLevel), O.isOpen = !0;
      }, R.prototype.closeNode = function(O) {
        if (!O.isClosed)
          return this.onData(this.writer.closeNode(O, this.currentLevel), this.currentLevel), O.isClosed = !0;
      }, R.prototype.onData = function(O, N) {
        return this.documentStarted = !0, this.onDataCallback(O, N + 1);
      }, R.prototype.onEnd = function() {
        return this.documentCompleted = !0, this.onEndCallback();
      }, R.prototype.debugInfo = function(O) {
        return O == null ? "" : "node: <" + O + ">";
      }, R.prototype.ele = function() {
        return this.element.apply(this, arguments);
      }, R.prototype.nod = function(O, N, q) {
        return this.node(O, N, q);
      }, R.prototype.txt = function(O) {
        return this.text(O);
      }, R.prototype.dat = function(O) {
        return this.cdata(O);
      }, R.prototype.com = function(O) {
        return this.comment(O);
      }, R.prototype.ins = function(O, N) {
        return this.instruction(O, N);
      }, R.prototype.dec = function(O, N, q) {
        return this.declaration(O, N, q);
      }, R.prototype.dtd = function(O, N, q) {
        return this.doctype(O, N, q);
      }, R.prototype.e = function(O, N, q) {
        return this.element(O, N, q);
      }, R.prototype.n = function(O, N, q) {
        return this.node(O, N, q);
      }, R.prototype.t = function(O) {
        return this.text(O);
      }, R.prototype.d = function(O) {
        return this.cdata(O);
      }, R.prototype.c = function(O) {
        return this.comment(O);
      }, R.prototype.r = function(O) {
        return this.raw(O);
      }, R.prototype.i = function(O, N) {
        return this.instruction(O, N);
      }, R.prototype.att = function() {
        return this.currentNode && this.currentNode instanceof l ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
      }, R.prototype.a = function() {
        return this.currentNode && this.currentNode instanceof l ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
      }, R.prototype.ent = function(O, N) {
        return this.entity(O, N);
      }, R.prototype.pent = function(O, N) {
        return this.pEntity(O, N);
      }, R.prototype.not = function(O, N) {
        return this.notation(O, N);
      }, R;
    }();
  }).call(it)), b1.exports;
}
var v1 = { exports: {} }, _E;
function sq() {
  return _E || (_E = 1, (function() {
    var t, e, n, r, i, o, a, s, l, u, f, h, p, y, b = function(v, D) {
      for (var S in D)
        x.call(D, S) && (v[S] = D[S]);
      function E() {
        this.constructor = v;
      }
      return E.prototype = D.prototype, v.prototype = new E(), v.__super__ = D.prototype, v;
    }, x = {}.hasOwnProperty;
    a = Ym(), s = ty(), t = Gm(), e = Jm(), u = Xm(), h = ny(), p = ry(), f = iy(), l = Zx(), n = Zm(), r = Qm(), i = Km(), o = ey(), y = RR(), v1.exports = function(v) {
      b(D, v);
      function D(S, E) {
        D.__super__.constructor.call(this, E), this.stream = S;
      }
      return D.prototype.document = function(S) {
        var E, I, R, O, N, q, $, le;
        for (q = S.children, I = 0, O = q.length; I < O; I++)
          E = q[I], E.isLastRootNode = !1;
        for (S.children[S.children.length - 1].isLastRootNode = !0, $ = S.children, le = [], R = 0, N = $.length; R < N; R++)
          if (E = $[R], !(E instanceof l))
            switch (!1) {
              case !(E instanceof a):
                le.push(this.declaration(E));
                break;
              case !(E instanceof s):
                le.push(this.docType(E));
                break;
              case !(E instanceof e):
                le.push(this.comment(E));
                break;
              case !(E instanceof f):
                le.push(this.processingInstruction(E));
                break;
              default:
                le.push(this.element(E));
            }
        return le;
      }, D.prototype.attribute = function(S) {
        return this.stream.write(" " + S.name + '="' + S.value + '"');
      }, D.prototype.cdata = function(S, E) {
        return this.stream.write(this.space(E) + "<![CDATA[" + S.text + "]]>" + this.endline(S));
      }, D.prototype.comment = function(S, E) {
        return this.stream.write(this.space(E) + "<!-- " + S.text + " -->" + this.endline(S));
      }, D.prototype.declaration = function(S, E) {
        return this.stream.write(this.space(E)), this.stream.write('<?xml version="' + S.version + '"'), S.encoding != null && this.stream.write(' encoding="' + S.encoding + '"'), S.standalone != null && this.stream.write(' standalone="' + S.standalone + '"'), this.stream.write(this.spacebeforeslash + "?>"), this.stream.write(this.endline(S));
      }, D.prototype.docType = function(S, E) {
        var I, R, O, N;
        if (E || (E = 0), this.stream.write(this.space(E)), this.stream.write("<!DOCTYPE " + S.root().name), S.pubID && S.sysID ? this.stream.write(' PUBLIC "' + S.pubID + '" "' + S.sysID + '"') : S.sysID && this.stream.write(' SYSTEM "' + S.sysID + '"'), S.children.length > 0) {
          for (this.stream.write(" ["), this.stream.write(this.endline(S)), N = S.children, R = 0, O = N.length; R < O; R++)
            switch (I = N[R], !1) {
              case !(I instanceof n):
                this.dtdAttList(I, E + 1);
                break;
              case !(I instanceof r):
                this.dtdElement(I, E + 1);
                break;
              case !(I instanceof i):
                this.dtdEntity(I, E + 1);
                break;
              case !(I instanceof o):
                this.dtdNotation(I, E + 1);
                break;
              case !(I instanceof t):
                this.cdata(I, E + 1);
                break;
              case !(I instanceof e):
                this.comment(I, E + 1);
                break;
              case !(I instanceof f):
                this.processingInstruction(I, E + 1);
                break;
              default:
                throw new Error("Unknown DTD node type: " + I.constructor.name);
            }
          this.stream.write("]");
        }
        return this.stream.write(this.spacebeforeslash + ">"), this.stream.write(this.endline(S));
      }, D.prototype.element = function(S, E) {
        var I, R, O, N, q, $, le, ve;
        E || (E = 0), ve = this.space(E), this.stream.write(ve + "<" + S.name), $ = S.attributes;
        for (q in $)
          x.call($, q) && (I = $[q], this.attribute(I));
        if (S.children.length === 0 || S.children.every(function(M) {
          return M.value === "";
        }))
          this.allowEmpty ? this.stream.write("></" + S.name + ">") : this.stream.write(this.spacebeforeslash + "/>");
        else if (this.pretty && S.children.length === 1 && S.children[0].value != null)
          this.stream.write(">"), this.stream.write(S.children[0].value), this.stream.write("</" + S.name + ">");
        else {
          for (this.stream.write(">" + this.newline), le = S.children, O = 0, N = le.length; O < N; O++)
            switch (R = le[O], !1) {
              case !(R instanceof t):
                this.cdata(R, E + 1);
                break;
              case !(R instanceof e):
                this.comment(R, E + 1);
                break;
              case !(R instanceof u):
                this.element(R, E + 1);
                break;
              case !(R instanceof h):
                this.raw(R, E + 1);
                break;
              case !(R instanceof p):
                this.text(R, E + 1);
                break;
              case !(R instanceof f):
                this.processingInstruction(R, E + 1);
                break;
              case !(R instanceof l):
                break;
              default:
                throw new Error("Unknown XML node type: " + R.constructor.name);
            }
          this.stream.write(ve + "</" + S.name + ">");
        }
        return this.stream.write(this.endline(S));
      }, D.prototype.processingInstruction = function(S, E) {
        return this.stream.write(this.space(E) + "<?" + S.target), S.value && this.stream.write(" " + S.value), this.stream.write(this.spacebeforeslash + "?>" + this.endline(S));
      }, D.prototype.raw = function(S, E) {
        return this.stream.write(this.space(E) + S.value + this.endline(S));
      }, D.prototype.text = function(S, E) {
        return this.stream.write(this.space(E) + S.value + this.endline(S));
      }, D.prototype.dtdAttList = function(S, E) {
        return this.stream.write(this.space(E) + "<!ATTLIST " + S.elementName + " " + S.attributeName + " " + S.attributeType), S.defaultValueType !== "#DEFAULT" && this.stream.write(" " + S.defaultValueType), S.defaultValue && this.stream.write(' "' + S.defaultValue + '"'), this.stream.write(this.spacebeforeslash + ">" + this.endline(S));
      }, D.prototype.dtdElement = function(S, E) {
        return this.stream.write(this.space(E) + "<!ELEMENT " + S.name + " " + S.value), this.stream.write(this.spacebeforeslash + ">" + this.endline(S));
      }, D.prototype.dtdEntity = function(S, E) {
        return this.stream.write(this.space(E) + "<!ENTITY"), S.pe && this.stream.write(" %"), this.stream.write(" " + S.name), S.value ? this.stream.write(' "' + S.value + '"') : (S.pubID && S.sysID ? this.stream.write(' PUBLIC "' + S.pubID + '" "' + S.sysID + '"') : S.sysID && this.stream.write(' SYSTEM "' + S.sysID + '"'), S.nData && this.stream.write(" NDATA " + S.nData)), this.stream.write(this.spacebeforeslash + ">" + this.endline(S));
      }, D.prototype.dtdNotation = function(S, E) {
        return this.stream.write(this.space(E) + "<!NOTATION " + S.name), S.pubID && S.sysID ? this.stream.write(' PUBLIC "' + S.pubID + '" "' + S.sysID + '"') : S.pubID ? this.stream.write(' PUBLIC "' + S.pubID + '"') : S.sysID && this.stream.write(' SYSTEM "' + S.sysID + '"'), this.stream.write(this.spacebeforeslash + ">" + this.endline(S));
      }, D.prototype.endline = function(S) {
        return S.isLastRootNode ? "" : this.newline;
      }, D;
    }(y);
  }).call(it)), v1.exports;
}
(function() {
  var t, e, n, r, i, o, a;
  a = ds(), i = a.assign, o = a.isFunction, t = oq(), e = aq(), r = Kx(), n = sq(), Vf.create = function(s, l, u, f) {
    var h, p;
    if (s == null)
      throw new Error("Root element needs a name.");
    return f = i({}, l, u, f), h = new t(f), p = h.element(s), f.headless || (h.declaration(f), (f.pubID != null || f.sysID != null) && h.doctype(f)), p;
  }, Vf.begin = function(s, l, u) {
    var f;
    return o(s) && (f = [s, l], l = f[0], u = f[1], s = {}), l ? new e(s, l, u) : new t(s);
  }, Vf.stringWriter = function(s) {
    return new r(s);
  }, Vf.streamWriter = function(s, l) {
    return new n(s, l);
  };
}).call(it);
var kE = $t, lq = Vf;
AR.writeString = cq;
function cq(t, e) {
  var n = kE.invert(e), r = {
    element: o,
    text: uq
  };
  function i(l, u) {
    return r[u.type](l, u);
  }
  function o(l, u) {
    var f = l.element(a(u.name), u.attributes);
    u.children.forEach(function(h) {
      i(f, h);
    });
  }
  function a(l) {
    var u = /^\{(.*)\}(.*)$/.exec(l);
    if (u) {
      var f = n[u[1]];
      return f + (f === "" ? "" : ":") + u[2];
    } else
      return l;
  }
  function s(l) {
    var u = lq.create(a(l.name), {
      version: "1.0",
      encoding: "UTF-8",
      standalone: !0
    });
    return kE.forEach(e, function(f, h) {
      var p = "xmlns" + (h === "" ? "" : ":" + h);
      u.attribute(p, f);
    }), l.children.forEach(function(f) {
      i(u, f);
    }), u.end();
  }
  return s(t);
}
function uq(t, e) {
  t.text(e.value);
}
var oy = Fu;
Jo.Element = oy.Element;
Jo.element = oy.element;
Jo.emptyElement = oy.emptyElement;
Jo.text = oy.text;
Jo.readString = YF.readString;
Jo.writeString = AR.writeString;
var fq = $t, dq = rn, hq = Jo;
Wx.read = OR;
Wx.readXmlFromZipFile = gq;
var pq = {
  // Transitional format
  "http://schemas.openxmlformats.org/wordprocessingml/2006/main": "w",
  "http://schemas.openxmlformats.org/officeDocument/2006/relationships": "r",
  "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing": "wp",
  "http://schemas.openxmlformats.org/drawingml/2006/main": "a",
  "http://schemas.openxmlformats.org/drawingml/2006/picture": "pic",
  // Strict format
  "http://purl.oclc.org/ooxml/wordprocessingml/main": "w",
  "http://purl.oclc.org/ooxml/officeDocument/relationships": "r",
  "http://purl.oclc.org/ooxml/drawingml/wordprocessingDrawing": "wp",
  "http://purl.oclc.org/ooxml/drawingml/main": "a",
  "http://purl.oclc.org/ooxml/drawingml/picture": "pic",
  // Common
  "http://schemas.openxmlformats.org/package/2006/content-types": "content-types",
  "http://schemas.openxmlformats.org/package/2006/relationships": "relationships",
  "http://schemas.openxmlformats.org/markup-compatibility/2006": "mc",
  "urn:schemas-microsoft-com:vml": "v",
  "urn:schemas-microsoft-com:office:word": "office-word",
  // [MS-DOCX]: Word Extensions to the Office Open XML (.docx) File Format
  // https://learn.microsoft.com/en-us/openspecs/office_standards/ms-docx/b839fe1f-e1ca-4fa6-8c26-5954d0abbccd
  "http://schemas.microsoft.com/office/word/2010/wordml": "wordml"
};
function OR(t) {
  return hq.readString(t, pq).then(function(e) {
    return IR(e)[0];
  });
}
function gq(t, e) {
  return t.exists(e) ? t.read(e, "utf-8").then(mq).then(OR) : dq.resolve(null);
}
function mq(t) {
  return t.replace(/^\uFEFF/g, "");
}
function IR(t) {
  return t.type === "element" ? t.name === "mc:AlternateContent" ? t.first("mc:Fallback").children : (t.children = fq.flatten(t.children.map(IR, !0)), [t]) : [t];
}
var Qx = {}, Ja = {}, eD = {};
Object.defineProperty(eD, "__esModule", { value: !0 });
var yq = [
  { "Typeface name": "Symbol", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
  { "Typeface name": "Symbol", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "33", "Unicode hex": "21" },
  { "Typeface name": "Symbol", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "8704", "Unicode hex": "2200" },
  { "Typeface name": "Symbol", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "35", "Unicode hex": "23" },
  { "Typeface name": "Symbol", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "8707", "Unicode hex": "2203" },
  { "Typeface name": "Symbol", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "37", "Unicode hex": "25" },
  { "Typeface name": "Symbol", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "38", "Unicode hex": "26" },
  { "Typeface name": "Symbol", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "8717", "Unicode hex": "220D" },
  { "Typeface name": "Symbol", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "40", "Unicode hex": "28" },
  { "Typeface name": "Symbol", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "41", "Unicode hex": "29" },
  { "Typeface name": "Symbol", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "42", "Unicode hex": "2A" },
  { "Typeface name": "Symbol", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "43", "Unicode hex": "2B" },
  { "Typeface name": "Symbol", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "44", "Unicode hex": "2C" },
  { "Typeface name": "Symbol", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "8722", "Unicode hex": "2212" },
  { "Typeface name": "Symbol", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "46", "Unicode hex": "2E" },
  { "Typeface name": "Symbol", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "47", "Unicode hex": "2F" },
  { "Typeface name": "Symbol", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "48", "Unicode hex": "30" },
  { "Typeface name": "Symbol", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "49", "Unicode hex": "31" },
  { "Typeface name": "Symbol", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "50", "Unicode hex": "32" },
  { "Typeface name": "Symbol", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "51", "Unicode hex": "33" },
  { "Typeface name": "Symbol", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "52", "Unicode hex": "34" },
  { "Typeface name": "Symbol", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "53", "Unicode hex": "35" },
  { "Typeface name": "Symbol", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "54", "Unicode hex": "36" },
  { "Typeface name": "Symbol", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "55", "Unicode hex": "37" },
  { "Typeface name": "Symbol", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "56", "Unicode hex": "38" },
  { "Typeface name": "Symbol", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "57", "Unicode hex": "39" },
  { "Typeface name": "Symbol", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "58", "Unicode hex": "3A" },
  { "Typeface name": "Symbol", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "59", "Unicode hex": "3B" },
  { "Typeface name": "Symbol", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "60", "Unicode hex": "3C" },
  { "Typeface name": "Symbol", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "61", "Unicode hex": "3D" },
  { "Typeface name": "Symbol", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "62", "Unicode hex": "3E" },
  { "Typeface name": "Symbol", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "63", "Unicode hex": "3F" },
  { "Typeface name": "Symbol", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "8773", "Unicode hex": "2245" },
  { "Typeface name": "Symbol", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "913", "Unicode hex": "391" },
  { "Typeface name": "Symbol", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "914", "Unicode hex": "392" },
  { "Typeface name": "Symbol", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "935", "Unicode hex": "3A7" },
  { "Typeface name": "Symbol", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "916", "Unicode hex": "394" },
  { "Typeface name": "Symbol", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "917", "Unicode hex": "395" },
  { "Typeface name": "Symbol", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "934", "Unicode hex": "3A6" },
  { "Typeface name": "Symbol", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "915", "Unicode hex": "393" },
  { "Typeface name": "Symbol", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "919", "Unicode hex": "397" },
  { "Typeface name": "Symbol", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "921", "Unicode hex": "399" },
  { "Typeface name": "Symbol", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "977", "Unicode hex": "3D1" },
  { "Typeface name": "Symbol", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "922", "Unicode hex": "39A" },
  { "Typeface name": "Symbol", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "923", "Unicode hex": "39B" },
  { "Typeface name": "Symbol", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "924", "Unicode hex": "39C" },
  { "Typeface name": "Symbol", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "925", "Unicode hex": "39D" },
  { "Typeface name": "Symbol", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "927", "Unicode hex": "39F" },
  { "Typeface name": "Symbol", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "928", "Unicode hex": "3A0" },
  { "Typeface name": "Symbol", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "920", "Unicode hex": "398" },
  { "Typeface name": "Symbol", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "929", "Unicode hex": "3A1" },
  { "Typeface name": "Symbol", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "931", "Unicode hex": "3A3" },
  { "Typeface name": "Symbol", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "932", "Unicode hex": "3A4" },
  { "Typeface name": "Symbol", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "933", "Unicode hex": "3A5" },
  { "Typeface name": "Symbol", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "962", "Unicode hex": "3C2" },
  { "Typeface name": "Symbol", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "937", "Unicode hex": "3A9" },
  { "Typeface name": "Symbol", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "926", "Unicode hex": "39E" },
  { "Typeface name": "Symbol", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "936", "Unicode hex": "3A8" },
  { "Typeface name": "Symbol", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "918", "Unicode hex": "396" },
  { "Typeface name": "Symbol", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "91", "Unicode hex": "5B" },
  { "Typeface name": "Symbol", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "8756", "Unicode hex": "2234" },
  { "Typeface name": "Symbol", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "93", "Unicode hex": "5D" },
  { "Typeface name": "Symbol", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "8869", "Unicode hex": "22A5" },
  { "Typeface name": "Symbol", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "95", "Unicode hex": "5F" },
  { "Typeface name": "Symbol", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "8254", "Unicode hex": "203E" },
  { "Typeface name": "Symbol", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "945", "Unicode hex": "3B1" },
  { "Typeface name": "Symbol", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "946", "Unicode hex": "3B2" },
  { "Typeface name": "Symbol", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "967", "Unicode hex": "3C7" },
  { "Typeface name": "Symbol", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "948", "Unicode hex": "3B4" },
  { "Typeface name": "Symbol", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "949", "Unicode hex": "3B5" },
  { "Typeface name": "Symbol", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "966", "Unicode hex": "3C6" },
  { "Typeface name": "Symbol", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "947", "Unicode hex": "3B3" },
  { "Typeface name": "Symbol", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "951", "Unicode hex": "3B7" },
  { "Typeface name": "Symbol", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "953", "Unicode hex": "3B9" },
  { "Typeface name": "Symbol", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "981", "Unicode hex": "3D5" },
  { "Typeface name": "Symbol", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "954", "Unicode hex": "3BA" },
  { "Typeface name": "Symbol", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "955", "Unicode hex": "3BB" },
  { "Typeface name": "Symbol", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "956", "Unicode hex": "3BC" },
  { "Typeface name": "Symbol", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "957", "Unicode hex": "3BD" },
  { "Typeface name": "Symbol", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "959", "Unicode hex": "3BF" },
  { "Typeface name": "Symbol", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "960", "Unicode hex": "3C0" },
  { "Typeface name": "Symbol", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "952", "Unicode hex": "3B8" },
  { "Typeface name": "Symbol", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "961", "Unicode hex": "3C1" },
  { "Typeface name": "Symbol", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "963", "Unicode hex": "3C3" },
  { "Typeface name": "Symbol", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "964", "Unicode hex": "3C4" },
  { "Typeface name": "Symbol", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "965", "Unicode hex": "3C5" },
  { "Typeface name": "Symbol", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "982", "Unicode hex": "3D6" },
  { "Typeface name": "Symbol", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "969", "Unicode hex": "3C9" },
  { "Typeface name": "Symbol", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "958", "Unicode hex": "3BE" },
  { "Typeface name": "Symbol", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "968", "Unicode hex": "3C8" },
  { "Typeface name": "Symbol", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "950", "Unicode hex": "3B6" },
  { "Typeface name": "Symbol", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "123", "Unicode hex": "7B" },
  { "Typeface name": "Symbol", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "124", "Unicode hex": "7C" },
  { "Typeface name": "Symbol", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "125", "Unicode hex": "7D" },
  { "Typeface name": "Symbol", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "126", "Unicode hex": "7E" },
  { "Typeface name": "Symbol", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "8364", "Unicode hex": "20AC" },
  { "Typeface name": "Symbol", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "978", "Unicode hex": "3D2" },
  { "Typeface name": "Symbol", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "8242", "Unicode hex": "2032" },
  { "Typeface name": "Symbol", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "8804", "Unicode hex": "2264" },
  { "Typeface name": "Symbol", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "8260", "Unicode hex": "2044" },
  { "Typeface name": "Symbol", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "8734", "Unicode hex": "221E" },
  { "Typeface name": "Symbol", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "402", "Unicode hex": "192" },
  { "Typeface name": "Symbol", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9827", "Unicode hex": "2663" },
  { "Typeface name": "Symbol", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9830", "Unicode hex": "2666" },
  { "Typeface name": "Symbol", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "9829", "Unicode hex": "2665" },
  { "Typeface name": "Symbol", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "9824", "Unicode hex": "2660" },
  { "Typeface name": "Symbol", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "8596", "Unicode hex": "2194" },
  { "Typeface name": "Symbol", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "8592", "Unicode hex": "2190" },
  { "Typeface name": "Symbol", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "8593", "Unicode hex": "2191" },
  { "Typeface name": "Symbol", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "8594", "Unicode hex": "2192" },
  { "Typeface name": "Symbol", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "8595", "Unicode hex": "2193" },
  { "Typeface name": "Symbol", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "176", "Unicode hex": "B0" },
  { "Typeface name": "Symbol", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "177", "Unicode hex": "B1" },
  { "Typeface name": "Symbol", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "8243", "Unicode hex": "2033" },
  { "Typeface name": "Symbol", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "8805", "Unicode hex": "2265" },
  { "Typeface name": "Symbol", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "215", "Unicode hex": "D7" },
  { "Typeface name": "Symbol", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "8733", "Unicode hex": "221D" },
  { "Typeface name": "Symbol", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "8706", "Unicode hex": "2202" },
  { "Typeface name": "Symbol", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "8226", "Unicode hex": "2022" },
  { "Typeface name": "Symbol", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "247", "Unicode hex": "F7" },
  { "Typeface name": "Symbol", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "8800", "Unicode hex": "2260" },
  { "Typeface name": "Symbol", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "8801", "Unicode hex": "2261" },
  { "Typeface name": "Symbol", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "8776", "Unicode hex": "2248" },
  { "Typeface name": "Symbol", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "8230", "Unicode hex": "2026" },
  { "Typeface name": "Symbol", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "9168", "Unicode hex": "23D0" },
  { "Typeface name": "Symbol", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "9135", "Unicode hex": "23AF" },
  { "Typeface name": "Symbol", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "8629", "Unicode hex": "21B5" },
  { "Typeface name": "Symbol", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "8501", "Unicode hex": "2135" },
  { "Typeface name": "Symbol", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "8465", "Unicode hex": "2111" },
  { "Typeface name": "Symbol", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "8476", "Unicode hex": "211C" },
  { "Typeface name": "Symbol", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "8472", "Unicode hex": "2118" },
  { "Typeface name": "Symbol", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "8855", "Unicode hex": "2297" },
  { "Typeface name": "Symbol", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "8853", "Unicode hex": "2295" },
  { "Typeface name": "Symbol", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "8709", "Unicode hex": "2205" },
  { "Typeface name": "Symbol", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "8745", "Unicode hex": "2229" },
  { "Typeface name": "Symbol", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "8746", "Unicode hex": "222A" },
  { "Typeface name": "Symbol", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "8835", "Unicode hex": "2283" },
  { "Typeface name": "Symbol", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "8839", "Unicode hex": "2287" },
  { "Typeface name": "Symbol", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "8836", "Unicode hex": "2284" },
  { "Typeface name": "Symbol", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "8834", "Unicode hex": "2282" },
  { "Typeface name": "Symbol", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "8838", "Unicode hex": "2286" },
  { "Typeface name": "Symbol", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "8712", "Unicode hex": "2208" },
  { "Typeface name": "Symbol", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "8713", "Unicode hex": "2209" },
  { "Typeface name": "Symbol", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "8736", "Unicode hex": "2220" },
  { "Typeface name": "Symbol", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "8711", "Unicode hex": "2207" },
  { "Typeface name": "Symbol", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "174", "Unicode hex": "AE" },
  { "Typeface name": "Symbol", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "169", "Unicode hex": "A9" },
  { "Typeface name": "Symbol", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "8482", "Unicode hex": "2122" },
  { "Typeface name": "Symbol", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "8719", "Unicode hex": "220F" },
  { "Typeface name": "Symbol", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8730", "Unicode hex": "221A" },
  { "Typeface name": "Symbol", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "8901", "Unicode hex": "22C5" },
  { "Typeface name": "Symbol", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "172", "Unicode hex": "AC" },
  { "Typeface name": "Symbol", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "8743", "Unicode hex": "2227" },
  { "Typeface name": "Symbol", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "8744", "Unicode hex": "2228" },
  { "Typeface name": "Symbol", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "8660", "Unicode hex": "21D4" },
  { "Typeface name": "Symbol", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "8656", "Unicode hex": "21D0" },
  { "Typeface name": "Symbol", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "8657", "Unicode hex": "21D1" },
  { "Typeface name": "Symbol", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "8658", "Unicode hex": "21D2" },
  { "Typeface name": "Symbol", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "8659", "Unicode hex": "21D3" },
  { "Typeface name": "Symbol", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "9674", "Unicode hex": "25CA" },
  { "Typeface name": "Symbol", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "12296", "Unicode hex": "3008" },
  { "Typeface name": "Symbol", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "174", "Unicode hex": "AE" },
  { "Typeface name": "Symbol", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "169", "Unicode hex": "A9" },
  { "Typeface name": "Symbol", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "8482", "Unicode hex": "2122" },
  { "Typeface name": "Symbol", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "8721", "Unicode hex": "2211" },
  { "Typeface name": "Symbol", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "9115", "Unicode hex": "239B" },
  { "Typeface name": "Symbol", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "9116", "Unicode hex": "239C" },
  { "Typeface name": "Symbol", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9117", "Unicode hex": "239D" },
  { "Typeface name": "Symbol", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9121", "Unicode hex": "23A1" },
  { "Typeface name": "Symbol", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "9122", "Unicode hex": "23A2" },
  { "Typeface name": "Symbol", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "9123", "Unicode hex": "23A3" },
  { "Typeface name": "Symbol", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "9127", "Unicode hex": "23A7" },
  { "Typeface name": "Symbol", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "9128", "Unicode hex": "23A8" },
  { "Typeface name": "Symbol", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "9129", "Unicode hex": "23A9" },
  { "Typeface name": "Symbol", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "9130", "Unicode hex": "23AA" },
  { "Typeface name": "Symbol", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "63743", "Unicode hex": "F8FF" },
  { "Typeface name": "Symbol", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "12297", "Unicode hex": "3009" },
  { "Typeface name": "Symbol", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8747", "Unicode hex": "222B" },
  { "Typeface name": "Symbol", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "8992", "Unicode hex": "2320" },
  { "Typeface name": "Symbol", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "9134", "Unicode hex": "23AE" },
  { "Typeface name": "Symbol", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "8993", "Unicode hex": "2321" },
  { "Typeface name": "Symbol", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "9118", "Unicode hex": "239E" },
  { "Typeface name": "Symbol", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "9119", "Unicode hex": "239F" },
  { "Typeface name": "Symbol", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "9120", "Unicode hex": "23A0" },
  { "Typeface name": "Symbol", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "9124", "Unicode hex": "23A4" },
  { "Typeface name": "Symbol", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "9125", "Unicode hex": "23A5" },
  { "Typeface name": "Symbol", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "9126", "Unicode hex": "23A6" },
  { "Typeface name": "Symbol", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "9131", "Unicode hex": "23AB" },
  { "Typeface name": "Symbol", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "9132", "Unicode hex": "23AC" },
  { "Typeface name": "Symbol", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "9133", "Unicode hex": "23AD" },
  { "Typeface name": "Webdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
  { "Typeface name": "Webdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128375", "Unicode hex": "1F577" },
  { "Typeface name": "Webdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128376", "Unicode hex": "1F578" },
  { "Typeface name": "Webdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128370", "Unicode hex": "1F572" },
  { "Typeface name": "Webdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128374", "Unicode hex": "1F576" },
  { "Typeface name": "Webdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "127942", "Unicode hex": "1F3C6" },
  { "Typeface name": "Webdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "127894", "Unicode hex": "1F396" },
  { "Typeface name": "Webdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128391", "Unicode hex": "1F587" },
  { "Typeface name": "Webdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128488", "Unicode hex": "1F5E8" },
  { "Typeface name": "Webdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128489", "Unicode hex": "1F5E9" },
  { "Typeface name": "Webdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128496", "Unicode hex": "1F5F0" },
  { "Typeface name": "Webdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128497", "Unicode hex": "1F5F1" },
  { "Typeface name": "Webdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "127798", "Unicode hex": "1F336" },
  { "Typeface name": "Webdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "127895", "Unicode hex": "1F397" },
  { "Typeface name": "Webdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128638", "Unicode hex": "1F67E" },
  { "Typeface name": "Webdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128636", "Unicode hex": "1F67C" },
  { "Typeface name": "Webdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128469", "Unicode hex": "1F5D5" },
  { "Typeface name": "Webdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128470", "Unicode hex": "1F5D6" },
  { "Typeface name": "Webdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128471", "Unicode hex": "1F5D7" },
  { "Typeface name": "Webdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "9204", "Unicode hex": "23F4" },
  { "Typeface name": "Webdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "9205", "Unicode hex": "23F5" },
  { "Typeface name": "Webdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "9206", "Unicode hex": "23F6" },
  { "Typeface name": "Webdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "9207", "Unicode hex": "23F7" },
  { "Typeface name": "Webdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "9194", "Unicode hex": "23EA" },
  { "Typeface name": "Webdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "9193", "Unicode hex": "23E9" },
  { "Typeface name": "Webdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "9198", "Unicode hex": "23EE" },
  { "Typeface name": "Webdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "9197", "Unicode hex": "23ED" },
  { "Typeface name": "Webdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "9208", "Unicode hex": "23F8" },
  { "Typeface name": "Webdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "9209", "Unicode hex": "23F9" },
  { "Typeface name": "Webdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "9210", "Unicode hex": "23FA" },
  { "Typeface name": "Webdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128474", "Unicode hex": "1F5DA" },
  { "Typeface name": "Webdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128499", "Unicode hex": "1F5F3" },
  { "Typeface name": "Webdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128736", "Unicode hex": "1F6E0" },
  { "Typeface name": "Webdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "127959", "Unicode hex": "1F3D7" },
  { "Typeface name": "Webdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "127960", "Unicode hex": "1F3D8" },
  { "Typeface name": "Webdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "127961", "Unicode hex": "1F3D9" },
  { "Typeface name": "Webdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "127962", "Unicode hex": "1F3DA" },
  { "Typeface name": "Webdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "127964", "Unicode hex": "1F3DC" },
  { "Typeface name": "Webdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "127981", "Unicode hex": "1F3ED" },
  { "Typeface name": "Webdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "127963", "Unicode hex": "1F3DB" },
  { "Typeface name": "Webdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "127968", "Unicode hex": "1F3E0" },
  { "Typeface name": "Webdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "127958", "Unicode hex": "1F3D6" },
  { "Typeface name": "Webdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "127965", "Unicode hex": "1F3DD" },
  { "Typeface name": "Webdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128739", "Unicode hex": "1F6E3" },
  { "Typeface name": "Webdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128269", "Unicode hex": "1F50D" },
  { "Typeface name": "Webdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "127956", "Unicode hex": "1F3D4" },
  { "Typeface name": "Webdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128065", "Unicode hex": "1F441" },
  { "Typeface name": "Webdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128066", "Unicode hex": "1F442" },
  { "Typeface name": "Webdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127966", "Unicode hex": "1F3DE" },
  { "Typeface name": "Webdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "127957", "Unicode hex": "1F3D5" },
  { "Typeface name": "Webdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "128740", "Unicode hex": "1F6E4" },
  { "Typeface name": "Webdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127967", "Unicode hex": "1F3DF" },
  { "Typeface name": "Webdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "128755", "Unicode hex": "1F6F3" },
  { "Typeface name": "Webdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128364", "Unicode hex": "1F56C" },
  { "Typeface name": "Webdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "128363", "Unicode hex": "1F56B" },
  { "Typeface name": "Webdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128360", "Unicode hex": "1F568" },
  { "Typeface name": "Webdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "128264", "Unicode hex": "1F508" },
  { "Typeface name": "Webdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "127892", "Unicode hex": "1F394" },
  { "Typeface name": "Webdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "127893", "Unicode hex": "1F395" },
  { "Typeface name": "Webdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128492", "Unicode hex": "1F5EC" },
  { "Typeface name": "Webdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128637", "Unicode hex": "1F67D" },
  { "Typeface name": "Webdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "128493", "Unicode hex": "1F5ED" },
  { "Typeface name": "Webdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128490", "Unicode hex": "1F5EA" },
  { "Typeface name": "Webdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128491", "Unicode hex": "1F5EB" },
  { "Typeface name": "Webdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "11156", "Unicode hex": "2B94" },
  { "Typeface name": "Webdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "10004", "Unicode hex": "2714" },
  { "Typeface name": "Webdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128690", "Unicode hex": "1F6B2" },
  { "Typeface name": "Webdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "11036", "Unicode hex": "2B1C" },
  { "Typeface name": "Webdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128737", "Unicode hex": "1F6E1" },
  { "Typeface name": "Webdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128230", "Unicode hex": "1F4E6" },
  { "Typeface name": "Webdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128753", "Unicode hex": "1F6F1" },
  { "Typeface name": "Webdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "11035", "Unicode hex": "2B1B" },
  { "Typeface name": "Webdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128657", "Unicode hex": "1F691" },
  { "Typeface name": "Webdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "128712", "Unicode hex": "1F6C8" },
  { "Typeface name": "Webdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128745", "Unicode hex": "1F6E9" },
  { "Typeface name": "Webdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128752", "Unicode hex": "1F6F0" },
  { "Typeface name": "Webdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "128968", "Unicode hex": "1F7C8" },
  { "Typeface name": "Webdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128372", "Unicode hex": "1F574" },
  { "Typeface name": "Webdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "11044", "Unicode hex": "2B24" },
  { "Typeface name": "Webdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128741", "Unicode hex": "1F6E5" },
  { "Typeface name": "Webdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128660", "Unicode hex": "1F694" },
  { "Typeface name": "Webdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "128472", "Unicode hex": "1F5D8" },
  { "Typeface name": "Webdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "128473", "Unicode hex": "1F5D9" },
  { "Typeface name": "Webdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "10067", "Unicode hex": "2753" },
  { "Typeface name": "Webdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "128754", "Unicode hex": "1F6F2" },
  { "Typeface name": "Webdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "128647", "Unicode hex": "1F687" },
  { "Typeface name": "Webdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "128653", "Unicode hex": "1F68D" },
  { "Typeface name": "Webdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9971", "Unicode hex": "26F3" },
  { "Typeface name": "Webdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10680", "Unicode hex": "29B8" },
  { "Typeface name": "Webdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "8854", "Unicode hex": "2296" },
  { "Typeface name": "Webdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "128685", "Unicode hex": "1F6AD" },
  { "Typeface name": "Webdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "128494", "Unicode hex": "1F5EE" },
  { "Typeface name": "Webdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "9168", "Unicode hex": "23D0" },
  { "Typeface name": "Webdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128495", "Unicode hex": "1F5EF" },
  { "Typeface name": "Webdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128498", "Unicode hex": "1F5F2" },
  { "Typeface name": "Webdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128697", "Unicode hex": "1F6B9" },
  { "Typeface name": "Webdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "128698", "Unicode hex": "1F6BA" },
  { "Typeface name": "Webdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "128713", "Unicode hex": "1F6C9" },
  { "Typeface name": "Webdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "128714", "Unicode hex": "1F6CA" },
  { "Typeface name": "Webdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "128700", "Unicode hex": "1F6BC" },
  { "Typeface name": "Webdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "128125", "Unicode hex": "1F47D" },
  { "Typeface name": "Webdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "127947", "Unicode hex": "1F3CB" },
  { "Typeface name": "Webdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "9975", "Unicode hex": "26F7" },
  { "Typeface name": "Webdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "127938", "Unicode hex": "1F3C2" },
  { "Typeface name": "Webdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "127948", "Unicode hex": "1F3CC" },
  { "Typeface name": "Webdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "127946", "Unicode hex": "1F3CA" },
  { "Typeface name": "Webdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127940", "Unicode hex": "1F3C4" },
  { "Typeface name": "Webdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "127949", "Unicode hex": "1F3CD" },
  { "Typeface name": "Webdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "127950", "Unicode hex": "1F3CE" },
  { "Typeface name": "Webdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128664", "Unicode hex": "1F698" },
  { "Typeface name": "Webdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128480", "Unicode hex": "1F5E0" },
  { "Typeface name": "Webdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128738", "Unicode hex": "1F6E2" },
  { "Typeface name": "Webdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128176", "Unicode hex": "1F4B0" },
  { "Typeface name": "Webdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "127991", "Unicode hex": "1F3F7" },
  { "Typeface name": "Webdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128179", "Unicode hex": "1F4B3" },
  { "Typeface name": "Webdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128106", "Unicode hex": "1F46A" },
  { "Typeface name": "Webdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "128481", "Unicode hex": "1F5E1" },
  { "Typeface name": "Webdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128482", "Unicode hex": "1F5E2" },
  { "Typeface name": "Webdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128483", "Unicode hex": "1F5E3" },
  { "Typeface name": "Webdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "10031", "Unicode hex": "272F" },
  { "Typeface name": "Webdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128388", "Unicode hex": "1F584" },
  { "Typeface name": "Webdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128389", "Unicode hex": "1F585" },
  { "Typeface name": "Webdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128387", "Unicode hex": "1F583" },
  { "Typeface name": "Webdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128390", "Unicode hex": "1F586" },
  { "Typeface name": "Webdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128441", "Unicode hex": "1F5B9" },
  { "Typeface name": "Webdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "128442", "Unicode hex": "1F5BA" },
  { "Typeface name": "Webdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128443", "Unicode hex": "1F5BB" },
  { "Typeface name": "Webdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128373", "Unicode hex": "1F575" },
  { "Typeface name": "Webdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "128368", "Unicode hex": "1F570" },
  { "Typeface name": "Webdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128445", "Unicode hex": "1F5BD" },
  { "Typeface name": "Webdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128446", "Unicode hex": "1F5BE" },
  { "Typeface name": "Webdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
  { "Typeface name": "Webdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128466", "Unicode hex": "1F5D2" },
  { "Typeface name": "Webdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128467", "Unicode hex": "1F5D3" },
  { "Typeface name": "Webdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128366", "Unicode hex": "1F56E" },
  { "Typeface name": "Webdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128218", "Unicode hex": "1F4DA" },
  { "Typeface name": "Webdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128478", "Unicode hex": "1F5DE" },
  { "Typeface name": "Webdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128479", "Unicode hex": "1F5DF" },
  { "Typeface name": "Webdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128451", "Unicode hex": "1F5C3" },
  { "Typeface name": "Webdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128450", "Unicode hex": "1F5C2" },
  { "Typeface name": "Webdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128444", "Unicode hex": "1F5BC" },
  { "Typeface name": "Webdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "127917", "Unicode hex": "1F3AD" },
  { "Typeface name": "Webdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "127900", "Unicode hex": "1F39C" },
  { "Typeface name": "Webdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "127896", "Unicode hex": "1F398" },
  { "Typeface name": "Webdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "127897", "Unicode hex": "1F399" },
  { "Typeface name": "Webdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "127911", "Unicode hex": "1F3A7" },
  { "Typeface name": "Webdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128191", "Unicode hex": "1F4BF" },
  { "Typeface name": "Webdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "127902", "Unicode hex": "1F39E" },
  { "Typeface name": "Webdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128247", "Unicode hex": "1F4F7" },
  { "Typeface name": "Webdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "127903", "Unicode hex": "1F39F" },
  { "Typeface name": "Webdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "127916", "Unicode hex": "1F3AC" },
  { "Typeface name": "Webdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128253", "Unicode hex": "1F4FD" },
  { "Typeface name": "Webdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128249", "Unicode hex": "1F4F9" },
  { "Typeface name": "Webdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128254", "Unicode hex": "1F4FE" },
  { "Typeface name": "Webdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128251", "Unicode hex": "1F4FB" },
  { "Typeface name": "Webdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "127898", "Unicode hex": "1F39A" },
  { "Typeface name": "Webdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "127899", "Unicode hex": "1F39B" },
  { "Typeface name": "Webdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128250", "Unicode hex": "1F4FA" },
  { "Typeface name": "Webdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128187", "Unicode hex": "1F4BB" },
  { "Typeface name": "Webdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128421", "Unicode hex": "1F5A5" },
  { "Typeface name": "Webdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128422", "Unicode hex": "1F5A6" },
  { "Typeface name": "Webdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128423", "Unicode hex": "1F5A7" },
  { "Typeface name": "Webdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "128377", "Unicode hex": "1F579" },
  { "Typeface name": "Webdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "127918", "Unicode hex": "1F3AE" },
  { "Typeface name": "Webdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "128379", "Unicode hex": "1F57B" },
  { "Typeface name": "Webdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128380", "Unicode hex": "1F57C" },
  { "Typeface name": "Webdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128223", "Unicode hex": "1F4DF" },
  { "Typeface name": "Webdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128385", "Unicode hex": "1F581" },
  { "Typeface name": "Webdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128384", "Unicode hex": "1F580" },
  { "Typeface name": "Webdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128424", "Unicode hex": "1F5A8" },
  { "Typeface name": "Webdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128425", "Unicode hex": "1F5A9" },
  { "Typeface name": "Webdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128447", "Unicode hex": "1F5BF" },
  { "Typeface name": "Webdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128426", "Unicode hex": "1F5AA" },
  { "Typeface name": "Webdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128476", "Unicode hex": "1F5DC" },
  { "Typeface name": "Webdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128274", "Unicode hex": "1F512" },
  { "Typeface name": "Webdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128275", "Unicode hex": "1F513" },
  { "Typeface name": "Webdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128477", "Unicode hex": "1F5DD" },
  { "Typeface name": "Webdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128229", "Unicode hex": "1F4E5" },
  { "Typeface name": "Webdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128228", "Unicode hex": "1F4E4" },
  { "Typeface name": "Webdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128371", "Unicode hex": "1F573" },
  { "Typeface name": "Webdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "127779", "Unicode hex": "1F323" },
  { "Typeface name": "Webdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "127780", "Unicode hex": "1F324" },
  { "Typeface name": "Webdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "127781", "Unicode hex": "1F325" },
  { "Typeface name": "Webdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "127782", "Unicode hex": "1F326" },
  { "Typeface name": "Webdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "9729", "Unicode hex": "2601" },
  { "Typeface name": "Webdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "127784", "Unicode hex": "1F328" },
  { "Typeface name": "Webdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "127783", "Unicode hex": "1F327" },
  { "Typeface name": "Webdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "127785", "Unicode hex": "1F329" },
  { "Typeface name": "Webdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "127786", "Unicode hex": "1F32A" },
  { "Typeface name": "Webdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "127788", "Unicode hex": "1F32C" },
  { "Typeface name": "Webdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "127787", "Unicode hex": "1F32B" },
  { "Typeface name": "Webdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "127772", "Unicode hex": "1F31C" },
  { "Typeface name": "Webdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "127777", "Unicode hex": "1F321" },
  { "Typeface name": "Webdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128715", "Unicode hex": "1F6CB" },
  { "Typeface name": "Webdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128719", "Unicode hex": "1F6CF" },
  { "Typeface name": "Webdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "127869", "Unicode hex": "1F37D" },
  { "Typeface name": "Webdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "127864", "Unicode hex": "1F378" },
  { "Typeface name": "Webdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128718", "Unicode hex": "1F6CE" },
  { "Typeface name": "Webdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128717", "Unicode hex": "1F6CD" },
  { "Typeface name": "Webdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9413", "Unicode hex": "24C5" },
  { "Typeface name": "Webdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9855", "Unicode hex": "267F" },
  { "Typeface name": "Webdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128710", "Unicode hex": "1F6C6" },
  { "Typeface name": "Webdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "128392", "Unicode hex": "1F588" },
  { "Typeface name": "Webdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "127891", "Unicode hex": "1F393" },
  { "Typeface name": "Webdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128484", "Unicode hex": "1F5E4" },
  { "Typeface name": "Webdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128485", "Unicode hex": "1F5E5" },
  { "Typeface name": "Webdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128486", "Unicode hex": "1F5E6" },
  { "Typeface name": "Webdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "128487", "Unicode hex": "1F5E7" },
  { "Typeface name": "Webdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128746", "Unicode hex": "1F6EA" },
  { "Typeface name": "Webdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128063", "Unicode hex": "1F43F" },
  { "Typeface name": "Webdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "128038", "Unicode hex": "1F426" },
  { "Typeface name": "Webdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128031", "Unicode hex": "1F41F" },
  { "Typeface name": "Webdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128021", "Unicode hex": "1F415" },
  { "Typeface name": "Webdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "128008", "Unicode hex": "1F408" },
  { "Typeface name": "Webdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "128620", "Unicode hex": "1F66C" },
  { "Typeface name": "Webdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "128622", "Unicode hex": "1F66E" },
  { "Typeface name": "Webdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "128621", "Unicode hex": "1F66D" },
  { "Typeface name": "Webdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "128623", "Unicode hex": "1F66F" },
  { "Typeface name": "Webdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128506", "Unicode hex": "1F5FA" },
  { "Typeface name": "Webdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "127757", "Unicode hex": "1F30D" },
  { "Typeface name": "Webdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "127759", "Unicode hex": "1F30F" },
  { "Typeface name": "Webdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "127758", "Unicode hex": "1F30E" },
  { "Typeface name": "Webdings", "Dingbat dec": "255", "Dingbat hex": "FF", "Unicode dec": "128330", "Unicode hex": "1F54A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
  { "Typeface name": "Wingdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128393", "Unicode hex": "1F589" },
  { "Typeface name": "Wingdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "9986", "Unicode hex": "2702" },
  { "Typeface name": "Wingdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "9985", "Unicode hex": "2701" },
  { "Typeface name": "Wingdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128083", "Unicode hex": "1F453" },
  { "Typeface name": "Wingdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "128365", "Unicode hex": "1F56D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "128366", "Unicode hex": "1F56E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128367", "Unicode hex": "1F56F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128383", "Unicode hex": "1F57F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "9990", "Unicode hex": "2706" },
  { "Typeface name": "Wingdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128386", "Unicode hex": "1F582" },
  { "Typeface name": "Wingdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128387", "Unicode hex": "1F583" },
  { "Typeface name": "Wingdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128234", "Unicode hex": "1F4EA" },
  { "Typeface name": "Wingdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128235", "Unicode hex": "1F4EB" },
  { "Typeface name": "Wingdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128236", "Unicode hex": "1F4EC" },
  { "Typeface name": "Wingdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128237", "Unicode hex": "1F4ED" },
  { "Typeface name": "Wingdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128448", "Unicode hex": "1F5C0" },
  { "Typeface name": "Wingdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128449", "Unicode hex": "1F5C1" },
  { "Typeface name": "Wingdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128462", "Unicode hex": "1F5CE" },
  { "Typeface name": "Wingdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128463", "Unicode hex": "1F5CF" },
  { "Typeface name": "Wingdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128464", "Unicode hex": "1F5D0" },
  { "Typeface name": "Wingdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128452", "Unicode hex": "1F5C4" },
  { "Typeface name": "Wingdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "8987", "Unicode hex": "231B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128430", "Unicode hex": "1F5AE" },
  { "Typeface name": "Wingdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128432", "Unicode hex": "1F5B0" },
  { "Typeface name": "Wingdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128434", "Unicode hex": "1F5B2" },
  { "Typeface name": "Wingdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128435", "Unicode hex": "1F5B3" },
  { "Typeface name": "Wingdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128436", "Unicode hex": "1F5B4" },
  { "Typeface name": "Wingdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128427", "Unicode hex": "1F5AB" },
  { "Typeface name": "Wingdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128428", "Unicode hex": "1F5AC" },
  { "Typeface name": "Wingdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "9991", "Unicode hex": "2707" },
  { "Typeface name": "Wingdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "9997", "Unicode hex": "270D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128398", "Unicode hex": "1F58E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "9996", "Unicode hex": "270C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128399", "Unicode hex": "1F58F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128077", "Unicode hex": "1F44D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128078", "Unicode hex": "1F44E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "9756", "Unicode hex": "261C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "9758", "Unicode hex": "261E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "9757", "Unicode hex": "261D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "9759", "Unicode hex": "261F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128400", "Unicode hex": "1F590" },
  { "Typeface name": "Wingdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "9786", "Unicode hex": "263A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128528", "Unicode hex": "1F610" },
  { "Typeface name": "Wingdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "9785", "Unicode hex": "2639" },
  { "Typeface name": "Wingdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128163", "Unicode hex": "1F4A3" },
  { "Typeface name": "Wingdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128369", "Unicode hex": "1F571" },
  { "Typeface name": "Wingdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "127987", "Unicode hex": "1F3F3" },
  { "Typeface name": "Wingdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127985", "Unicode hex": "1F3F1" },
  { "Typeface name": "Wingdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "9992", "Unicode hex": "2708" },
  { "Typeface name": "Wingdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9788", "Unicode hex": "263C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127778", "Unicode hex": "1F322" },
  { "Typeface name": "Wingdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "10052", "Unicode hex": "2744" },
  { "Typeface name": "Wingdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128326", "Unicode hex": "1F546" },
  { "Typeface name": "Wingdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "10014", "Unicode hex": "271E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128328", "Unicode hex": "1F548" },
  { "Typeface name": "Wingdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10016", "Unicode hex": "2720" },
  { "Typeface name": "Wingdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "10017", "Unicode hex": "2721" },
  { "Typeface name": "Wingdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "9770", "Unicode hex": "262A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "9775", "Unicode hex": "262F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128329", "Unicode hex": "1F549" },
  { "Typeface name": "Wingdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "9784", "Unicode hex": "2638" },
  { "Typeface name": "Wingdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "9800", "Unicode hex": "2648" },
  { "Typeface name": "Wingdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "9801", "Unicode hex": "2649" },
  { "Typeface name": "Wingdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "9802", "Unicode hex": "264A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "9803", "Unicode hex": "264B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "9804", "Unicode hex": "264C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "9805", "Unicode hex": "264D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "9806", "Unicode hex": "264E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "9807", "Unicode hex": "264F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "9808", "Unicode hex": "2650" },
  { "Typeface name": "Wingdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "9809", "Unicode hex": "2651" },
  { "Typeface name": "Wingdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "9810", "Unicode hex": "2652" },
  { "Typeface name": "Wingdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9811", "Unicode hex": "2653" },
  { "Typeface name": "Wingdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128624", "Unicode hex": "1F670" },
  { "Typeface name": "Wingdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128629", "Unicode hex": "1F675" },
  { "Typeface name": "Wingdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9899", "Unicode hex": "26AB" },
  { "Typeface name": "Wingdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128318", "Unicode hex": "1F53E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9724", "Unicode hex": "25FC" },
  { "Typeface name": "Wingdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128911", "Unicode hex": "1F78F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128912", "Unicode hex": "1F790" },
  { "Typeface name": "Wingdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "10065", "Unicode hex": "2751" },
  { "Typeface name": "Wingdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "10066", "Unicode hex": "2752" },
  { "Typeface name": "Wingdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "128927", "Unicode hex": "1F79F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "10731", "Unicode hex": "29EB" },
  { "Typeface name": "Wingdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9670", "Unicode hex": "25C6" },
  { "Typeface name": "Wingdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10070", "Unicode hex": "2756" },
  { "Typeface name": "Wingdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "11049", "Unicode hex": "2B29" },
  { "Typeface name": "Wingdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "8999", "Unicode hex": "2327" },
  { "Typeface name": "Wingdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "11193", "Unicode hex": "2BB9" },
  { "Typeface name": "Wingdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "8984", "Unicode hex": "2318" },
  { "Typeface name": "Wingdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "127989", "Unicode hex": "1F3F5" },
  { "Typeface name": "Wingdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "127990", "Unicode hex": "1F3F6" },
  { "Typeface name": "Wingdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128630", "Unicode hex": "1F676" },
  { "Typeface name": "Wingdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128631", "Unicode hex": "1F677" },
  { "Typeface name": "Wingdings", "Dingbat dec": "127", "Dingbat hex": "7F", "Unicode dec": "9647", "Unicode hex": "25AF" },
  { "Typeface name": "Wingdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "127243", "Unicode hex": "1F10B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "10112", "Unicode hex": "2780" },
  { "Typeface name": "Wingdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "10113", "Unicode hex": "2781" },
  { "Typeface name": "Wingdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "10114", "Unicode hex": "2782" },
  { "Typeface name": "Wingdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "10115", "Unicode hex": "2783" },
  { "Typeface name": "Wingdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10116", "Unicode hex": "2784" },
  { "Typeface name": "Wingdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "10117", "Unicode hex": "2785" },
  { "Typeface name": "Wingdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "10118", "Unicode hex": "2786" },
  { "Typeface name": "Wingdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "10119", "Unicode hex": "2787" },
  { "Typeface name": "Wingdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "10120", "Unicode hex": "2788" },
  { "Typeface name": "Wingdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "10121", "Unicode hex": "2789" },
  { "Typeface name": "Wingdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127244", "Unicode hex": "1F10C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "10122", "Unicode hex": "278A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "10123", "Unicode hex": "278B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "10124", "Unicode hex": "278C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "10125", "Unicode hex": "278D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "10126", "Unicode hex": "278E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "10127", "Unicode hex": "278F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "10128", "Unicode hex": "2790" },
  { "Typeface name": "Wingdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "10129", "Unicode hex": "2791" },
  { "Typeface name": "Wingdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "10130", "Unicode hex": "2792" },
  { "Typeface name": "Wingdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "10131", "Unicode hex": "2793" },
  { "Typeface name": "Wingdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128610", "Unicode hex": "1F662" },
  { "Typeface name": "Wingdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128608", "Unicode hex": "1F660" },
  { "Typeface name": "Wingdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "128609", "Unicode hex": "1F661" },
  { "Typeface name": "Wingdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128611", "Unicode hex": "1F663" },
  { "Typeface name": "Wingdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128606", "Unicode hex": "1F65E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128604", "Unicode hex": "1F65C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128605", "Unicode hex": "1F65D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128607", "Unicode hex": "1F65F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "8729", "Unicode hex": "2219" },
  { "Typeface name": "Wingdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "8226", "Unicode hex": "2022" },
  { "Typeface name": "Wingdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "11037", "Unicode hex": "2B1D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "11096", "Unicode hex": "2B58" },
  { "Typeface name": "Wingdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128902", "Unicode hex": "1F786" },
  { "Typeface name": "Wingdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128904", "Unicode hex": "1F788" },
  { "Typeface name": "Wingdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128906", "Unicode hex": "1F78A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128907", "Unicode hex": "1F78B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128319", "Unicode hex": "1F53F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9642", "Unicode hex": "25AA" },
  { "Typeface name": "Wingdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128910", "Unicode hex": "1F78E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128961", "Unicode hex": "1F7C1" },
  { "Typeface name": "Wingdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128965", "Unicode hex": "1F7C5" },
  { "Typeface name": "Wingdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "9733", "Unicode hex": "2605" },
  { "Typeface name": "Wingdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128971", "Unicode hex": "1F7CB" },
  { "Typeface name": "Wingdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128975", "Unicode hex": "1F7CF" },
  { "Typeface name": "Wingdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "128979", "Unicode hex": "1F7D3" },
  { "Typeface name": "Wingdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "128977", "Unicode hex": "1F7D1" },
  { "Typeface name": "Wingdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "11216", "Unicode hex": "2BD0" },
  { "Typeface name": "Wingdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "8982", "Unicode hex": "2316" },
  { "Typeface name": "Wingdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "11214", "Unicode hex": "2BCE" },
  { "Typeface name": "Wingdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "11215", "Unicode hex": "2BCF" },
  { "Typeface name": "Wingdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "11217", "Unicode hex": "2BD1" },
  { "Typeface name": "Wingdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "10026", "Unicode hex": "272A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "10032", "Unicode hex": "2730" },
  { "Typeface name": "Wingdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "128336", "Unicode hex": "1F550" },
  { "Typeface name": "Wingdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128337", "Unicode hex": "1F551" },
  { "Typeface name": "Wingdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128338", "Unicode hex": "1F552" },
  { "Typeface name": "Wingdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128339", "Unicode hex": "1F553" },
  { "Typeface name": "Wingdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128340", "Unicode hex": "1F554" },
  { "Typeface name": "Wingdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "128341", "Unicode hex": "1F555" },
  { "Typeface name": "Wingdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "128342", "Unicode hex": "1F556" },
  { "Typeface name": "Wingdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128343", "Unicode hex": "1F557" },
  { "Typeface name": "Wingdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128344", "Unicode hex": "1F558" },
  { "Typeface name": "Wingdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128345", "Unicode hex": "1F559" },
  { "Typeface name": "Wingdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128346", "Unicode hex": "1F55A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128347", "Unicode hex": "1F55B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11184", "Unicode hex": "2BB0" },
  { "Typeface name": "Wingdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11185", "Unicode hex": "2BB1" },
  { "Typeface name": "Wingdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11186", "Unicode hex": "2BB2" },
  { "Typeface name": "Wingdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "11187", "Unicode hex": "2BB3" },
  { "Typeface name": "Wingdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "11188", "Unicode hex": "2BB4" },
  { "Typeface name": "Wingdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "11189", "Unicode hex": "2BB5" },
  { "Typeface name": "Wingdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11190", "Unicode hex": "2BB6" },
  { "Typeface name": "Wingdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11191", "Unicode hex": "2BB7" },
  { "Typeface name": "Wingdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128618", "Unicode hex": "1F66A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128619", "Unicode hex": "1F66B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128597", "Unicode hex": "1F655" },
  { "Typeface name": "Wingdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128596", "Unicode hex": "1F654" },
  { "Typeface name": "Wingdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128599", "Unicode hex": "1F657" },
  { "Typeface name": "Wingdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128598", "Unicode hex": "1F656" },
  { "Typeface name": "Wingdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128592", "Unicode hex": "1F650" },
  { "Typeface name": "Wingdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128593", "Unicode hex": "1F651" },
  { "Typeface name": "Wingdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128594", "Unicode hex": "1F652" },
  { "Typeface name": "Wingdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128595", "Unicode hex": "1F653" },
  { "Typeface name": "Wingdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "9003", "Unicode hex": "232B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8998", "Unicode hex": "2326" },
  { "Typeface name": "Wingdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "11160", "Unicode hex": "2B98" },
  { "Typeface name": "Wingdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "11162", "Unicode hex": "2B9A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "11161", "Unicode hex": "2B99" },
  { "Typeface name": "Wingdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "11163", "Unicode hex": "2B9B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "11144", "Unicode hex": "2B88" },
  { "Typeface name": "Wingdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "11146", "Unicode hex": "2B8A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "11145", "Unicode hex": "2B89" },
  { "Typeface name": "Wingdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "11147", "Unicode hex": "2B8B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129128", "Unicode hex": "1F868" },
  { "Typeface name": "Wingdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129130", "Unicode hex": "1F86A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129129", "Unicode hex": "1F869" },
  { "Typeface name": "Wingdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129131", "Unicode hex": "1F86B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129132", "Unicode hex": "1F86C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129133", "Unicode hex": "1F86D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129135", "Unicode hex": "1F86F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129134", "Unicode hex": "1F86E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129144", "Unicode hex": "1F878" },
  { "Typeface name": "Wingdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129146", "Unicode hex": "1F87A" },
  { "Typeface name": "Wingdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129145", "Unicode hex": "1F879" },
  { "Typeface name": "Wingdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129147", "Unicode hex": "1F87B" },
  { "Typeface name": "Wingdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129148", "Unicode hex": "1F87C" },
  { "Typeface name": "Wingdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129149", "Unicode hex": "1F87D" },
  { "Typeface name": "Wingdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129151", "Unicode hex": "1F87F" },
  { "Typeface name": "Wingdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129150", "Unicode hex": "1F87E" },
  { "Typeface name": "Wingdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "8678", "Unicode hex": "21E6" },
  { "Typeface name": "Wingdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "8680", "Unicode hex": "21E8" },
  { "Typeface name": "Wingdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "8679", "Unicode hex": "21E7" },
  { "Typeface name": "Wingdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8681", "Unicode hex": "21E9" },
  { "Typeface name": "Wingdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "11012", "Unicode hex": "2B04" },
  { "Typeface name": "Wingdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "8691", "Unicode hex": "21F3" },
  { "Typeface name": "Wingdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "11009", "Unicode hex": "2B01" },
  { "Typeface name": "Wingdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11008", "Unicode hex": "2B00" },
  { "Typeface name": "Wingdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11011", "Unicode hex": "2B03" },
  { "Typeface name": "Wingdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "11010", "Unicode hex": "2B02" },
  { "Typeface name": "Wingdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "129196", "Unicode hex": "1F8AC" },
  { "Typeface name": "Wingdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "129197", "Unicode hex": "1F8AD" },
  { "Typeface name": "Wingdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128502", "Unicode hex": "1F5F6" },
  { "Typeface name": "Wingdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "10003", "Unicode hex": "2713" },
  { "Typeface name": "Wingdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "128503", "Unicode hex": "1F5F7" },
  { "Typeface name": "Wingdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "128505", "Unicode hex": "1F5F9" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128394", "Unicode hex": "1F58A" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128395", "Unicode hex": "1F58B" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128396", "Unicode hex": "1F58C" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128397", "Unicode hex": "1F58D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "9988", "Unicode hex": "2704" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "9984", "Unicode hex": "2700" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128382", "Unicode hex": "1F57E" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128381", "Unicode hex": "1F57D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128453", "Unicode hex": "1F5C5" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128454", "Unicode hex": "1F5C6" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128455", "Unicode hex": "1F5C7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128456", "Unicode hex": "1F5C8" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128457", "Unicode hex": "1F5C9" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128458", "Unicode hex": "1F5CA" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128459", "Unicode hex": "1F5CB" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128460", "Unicode hex": "1F5CC" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128461", "Unicode hex": "1F5CD" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128465", "Unicode hex": "1F5D1" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128468", "Unicode hex": "1F5D4" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128437", "Unicode hex": "1F5B5" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "128438", "Unicode hex": "1F5B6" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128439", "Unicode hex": "1F5B7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128440", "Unicode hex": "1F5B8" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128429", "Unicode hex": "1F5AD" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128431", "Unicode hex": "1F5AF" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128433", "Unicode hex": "1F5B1" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128402", "Unicode hex": "1F592" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128403", "Unicode hex": "1F593" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128408", "Unicode hex": "1F598" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128409", "Unicode hex": "1F599" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128410", "Unicode hex": "1F59A" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "128411", "Unicode hex": "1F59B" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128072", "Unicode hex": "1F448" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128073", "Unicode hex": "1F449" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128412", "Unicode hex": "1F59C" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "128413", "Unicode hex": "1F59D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "128414", "Unicode hex": "1F59E" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "128415", "Unicode hex": "1F59F" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "128416", "Unicode hex": "1F5A0" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128417", "Unicode hex": "1F5A1" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "128070", "Unicode hex": "1F446" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128071", "Unicode hex": "1F447" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128418", "Unicode hex": "1F5A2" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128419", "Unicode hex": "1F5A3" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128401", "Unicode hex": "1F591" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128500", "Unicode hex": "1F5F4" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "128504", "Unicode hex": "1F5F8" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "128501", "Unicode hex": "1F5F5" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9745", "Unicode hex": "2611" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "11197", "Unicode hex": "2BBD" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "9746", "Unicode hex": "2612" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "11198", "Unicode hex": "2BBE" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "11199", "Unicode hex": "2BBF" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128711", "Unicode hex": "1F6C7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10680", "Unicode hex": "29B8" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "128625", "Unicode hex": "1F671" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "128628", "Unicode hex": "1F674" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128626", "Unicode hex": "1F672" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128627", "Unicode hex": "1F673" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "8253", "Unicode hex": "203D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128633", "Unicode hex": "1F679" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128634", "Unicode hex": "1F67A" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "128635", "Unicode hex": "1F67B" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "128614", "Unicode hex": "1F666" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128612", "Unicode hex": "1F664" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "128613", "Unicode hex": "1F665" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128615", "Unicode hex": "1F667" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128602", "Unicode hex": "1F65A" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128600", "Unicode hex": "1F658" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "128601", "Unicode hex": "1F659" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128603", "Unicode hex": "1F65B" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9450", "Unicode hex": "24EA" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "9312", "Unicode hex": "2460" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "9313", "Unicode hex": "2461" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9314", "Unicode hex": "2462" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "9315", "Unicode hex": "2463" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9316", "Unicode hex": "2464" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "9317", "Unicode hex": "2465" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9318", "Unicode hex": "2466" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9319", "Unicode hex": "2467" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9320", "Unicode hex": "2468" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9321", "Unicode hex": "2469" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9471", "Unicode hex": "24FF" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "10102", "Unicode hex": "2776" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10103", "Unicode hex": "2777" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "10104", "Unicode hex": "2778" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10105", "Unicode hex": "2779" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "10106", "Unicode hex": "277A" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "10107", "Unicode hex": "277B" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "10108", "Unicode hex": "277C" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "10109", "Unicode hex": "277D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "10110", "Unicode hex": "277E" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "10111", "Unicode hex": "277F" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "9737", "Unicode hex": "2609" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "127765", "Unicode hex": "1F315" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "9789", "Unicode hex": "263D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "9790", "Unicode hex": "263E" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11839", "Unicode hex": "2E3F" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10013", "Unicode hex": "271D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "128327", "Unicode hex": "1F547" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "128348", "Unicode hex": "1F55C" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "128349", "Unicode hex": "1F55D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "128350", "Unicode hex": "1F55E" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "128351", "Unicode hex": "1F55F" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "128352", "Unicode hex": "1F560" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "128353", "Unicode hex": "1F561" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "128354", "Unicode hex": "1F562" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128355", "Unicode hex": "1F563" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128356", "Unicode hex": "1F564" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128357", "Unicode hex": "1F565" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128358", "Unicode hex": "1F566" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "128359", "Unicode hex": "1F567" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128616", "Unicode hex": "1F668" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128617", "Unicode hex": "1F669" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "8901", "Unicode hex": "22C5" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128900", "Unicode hex": "1F784" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "10625", "Unicode hex": "2981" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "9679", "Unicode hex": "25CF" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "9675", "Unicode hex": "25CB" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128901", "Unicode hex": "1F785" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128903", "Unicode hex": "1F787" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128905", "Unicode hex": "1F789" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "8857", "Unicode hex": "2299" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "10687", "Unicode hex": "29BF" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128908", "Unicode hex": "1F78C" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128909", "Unicode hex": "1F78D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "9726", "Unicode hex": "25FE" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "9632", "Unicode hex": "25A0" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "9633", "Unicode hex": "25A1" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128913", "Unicode hex": "1F791" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128914", "Unicode hex": "1F792" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128915", "Unicode hex": "1F793" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128916", "Unicode hex": "1F794" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9635", "Unicode hex": "25A3" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128917", "Unicode hex": "1F795" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128918", "Unicode hex": "1F796" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128919", "Unicode hex": "1F797" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128920", "Unicode hex": "1F798" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "11049", "Unicode hex": "2B29" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "11045", "Unicode hex": "2B25" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "9671", "Unicode hex": "25C7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "128922", "Unicode hex": "1F79A" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "9672", "Unicode hex": "25C8" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "128923", "Unicode hex": "1F79B" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128924", "Unicode hex": "1F79C" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "128925", "Unicode hex": "1F79D" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128926", "Unicode hex": "1F79E" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "11050", "Unicode hex": "2B2A" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "11047", "Unicode hex": "2B27" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "9674", "Unicode hex": "25CA" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128928", "Unicode hex": "1F7A0" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "9686", "Unicode hex": "25D6" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "9687", "Unicode hex": "25D7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "11210", "Unicode hex": "2BCA" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "11211", "Unicode hex": "2BCB" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "11200", "Unicode hex": "2BC0" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "11201", "Unicode hex": "2BC1" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "11039", "Unicode hex": "2B1F" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "11202", "Unicode hex": "2BC2" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "11043", "Unicode hex": "2B23" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11042", "Unicode hex": "2B22" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11203", "Unicode hex": "2BC3" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11204", "Unicode hex": "2BC4" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128929", "Unicode hex": "1F7A1" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128930", "Unicode hex": "1F7A2" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128931", "Unicode hex": "1F7A3" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128932", "Unicode hex": "1F7A4" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128933", "Unicode hex": "1F7A5" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128934", "Unicode hex": "1F7A6" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128935", "Unicode hex": "1F7A7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128936", "Unicode hex": "1F7A8" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128937", "Unicode hex": "1F7A9" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128938", "Unicode hex": "1F7AA" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128939", "Unicode hex": "1F7AB" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128940", "Unicode hex": "1F7AC" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128941", "Unicode hex": "1F7AD" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128942", "Unicode hex": "1F7AE" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128943", "Unicode hex": "1F7AF" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "128944", "Unicode hex": "1F7B0" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "128945", "Unicode hex": "1F7B1" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "128946", "Unicode hex": "1F7B2" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "128947", "Unicode hex": "1F7B3" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "128948", "Unicode hex": "1F7B4" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "128949", "Unicode hex": "1F7B5" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "128950", "Unicode hex": "1F7B6" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "128951", "Unicode hex": "1F7B7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "128952", "Unicode hex": "1F7B8" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "128953", "Unicode hex": "1F7B9" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "128954", "Unicode hex": "1F7BA" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "128955", "Unicode hex": "1F7BB" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "128956", "Unicode hex": "1F7BC" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128957", "Unicode hex": "1F7BD" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128958", "Unicode hex": "1F7BE" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "128959", "Unicode hex": "1F7BF" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "128960", "Unicode hex": "1F7C0" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128962", "Unicode hex": "1F7C2" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128964", "Unicode hex": "1F7C4" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "128966", "Unicode hex": "1F7C6" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "128969", "Unicode hex": "1F7C9" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128970", "Unicode hex": "1F7CA" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "10038", "Unicode hex": "2736" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "128972", "Unicode hex": "1F7CC" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128974", "Unicode hex": "1F7CE" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128976", "Unicode hex": "1F7D0" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128978", "Unicode hex": "1F7D2" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "10041", "Unicode hex": "2739" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128963", "Unicode hex": "1F7C3" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128967", "Unicode hex": "1F7C7" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "10031", "Unicode hex": "272F" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128973", "Unicode hex": "1F7CD" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128980", "Unicode hex": "1F7D4" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11212", "Unicode hex": "2BCC" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11213", "Unicode hex": "2BCD" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "8251", "Unicode hex": "203B" },
  { "Typeface name": "Wingdings 2", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "8258", "Unicode hex": "2042" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "11104", "Unicode hex": "2B60" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "11106", "Unicode hex": "2B62" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "11105", "Unicode hex": "2B61" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "11107", "Unicode hex": "2B63" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "11110", "Unicode hex": "2B66" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "11111", "Unicode hex": "2B67" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "11113", "Unicode hex": "2B69" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "11112", "Unicode hex": "2B68" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "11120", "Unicode hex": "2B70" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "11122", "Unicode hex": "2B72" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "11121", "Unicode hex": "2B71" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "11123", "Unicode hex": "2B73" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "11126", "Unicode hex": "2B76" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "11128", "Unicode hex": "2B78" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "11131", "Unicode hex": "2B7B" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "11133", "Unicode hex": "2B7D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "11108", "Unicode hex": "2B64" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "11109", "Unicode hex": "2B65" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "11114", "Unicode hex": "2B6A" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "11116", "Unicode hex": "2B6C" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "11115", "Unicode hex": "2B6B" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "11117", "Unicode hex": "2B6D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "11085", "Unicode hex": "2B4D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "11168", "Unicode hex": "2BA0" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "11169", "Unicode hex": "2BA1" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "11170", "Unicode hex": "2BA2" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "11171", "Unicode hex": "2BA3" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "11172", "Unicode hex": "2BA4" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "11173", "Unicode hex": "2BA5" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "11174", "Unicode hex": "2BA6" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "11175", "Unicode hex": "2BA7" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "11152", "Unicode hex": "2B90" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "11153", "Unicode hex": "2B91" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "11154", "Unicode hex": "2B92" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "11155", "Unicode hex": "2B93" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "11136", "Unicode hex": "2B80" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "11139", "Unicode hex": "2B83" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "11134", "Unicode hex": "2B7E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "11135", "Unicode hex": "2B7F" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "11140", "Unicode hex": "2B84" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "11142", "Unicode hex": "2B86" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "11141", "Unicode hex": "2B85" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "11143", "Unicode hex": "2B87" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "11151", "Unicode hex": "2B8F" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "11149", "Unicode hex": "2B8D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "11150", "Unicode hex": "2B8E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "11148", "Unicode hex": "2B8C" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "11118", "Unicode hex": "2B6E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "11119", "Unicode hex": "2B6F" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9099", "Unicode hex": "238B" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "8996", "Unicode hex": "2324" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "8963", "Unicode hex": "2303" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "8997", "Unicode hex": "2325" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "9251", "Unicode hex": "2423" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "9085", "Unicode hex": "237D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "8682", "Unicode hex": "21EA" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "11192", "Unicode hex": "2BB8" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "129184", "Unicode hex": "1F8A0" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "129185", "Unicode hex": "1F8A1" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "129186", "Unicode hex": "1F8A2" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "129187", "Unicode hex": "1F8A3" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "129188", "Unicode hex": "1F8A4" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "129189", "Unicode hex": "1F8A5" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "129190", "Unicode hex": "1F8A6" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "129191", "Unicode hex": "1F8A7" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "129192", "Unicode hex": "1F8A8" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "129193", "Unicode hex": "1F8A9" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "129194", "Unicode hex": "1F8AA" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "129195", "Unicode hex": "1F8AB" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "129104", "Unicode hex": "1F850" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "129106", "Unicode hex": "1F852" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "129105", "Unicode hex": "1F851" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "129107", "Unicode hex": "1F853" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "129108", "Unicode hex": "1F854" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "129109", "Unicode hex": "1F855" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "129111", "Unicode hex": "1F857" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "129110", "Unicode hex": "1F856" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "129112", "Unicode hex": "1F858" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "129113", "Unicode hex": "1F859" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9650", "Unicode hex": "25B2" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9660", "Unicode hex": "25BC" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9651", "Unicode hex": "25B3" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9661", "Unicode hex": "25BD" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9664", "Unicode hex": "25C0" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9654", "Unicode hex": "25B6" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "9665", "Unicode hex": "25C1" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9655", "Unicode hex": "25B7" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "9699", "Unicode hex": "25E3" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "9698", "Unicode hex": "25E2" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "9700", "Unicode hex": "25E4" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "9701", "Unicode hex": "25E5" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "128896", "Unicode hex": "1F780" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128898", "Unicode hex": "1F782" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128897", "Unicode hex": "1F781" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128899", "Unicode hex": "1F783" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "11205", "Unicode hex": "2BC5" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "11206", "Unicode hex": "2BC6" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "11207", "Unicode hex": "2BC7" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11208", "Unicode hex": "2BC8" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "11164", "Unicode hex": "2B9C" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "11166", "Unicode hex": "2B9E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "11165", "Unicode hex": "2B9D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "11167", "Unicode hex": "2B9F" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "129040", "Unicode hex": "1F810" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "129042", "Unicode hex": "1F812" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "129041", "Unicode hex": "1F811" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "129043", "Unicode hex": "1F813" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "129044", "Unicode hex": "1F814" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "129046", "Unicode hex": "1F816" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "129045", "Unicode hex": "1F815" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "129047", "Unicode hex": "1F817" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "129048", "Unicode hex": "1F818" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "129050", "Unicode hex": "1F81A" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "129049", "Unicode hex": "1F819" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "129051", "Unicode hex": "1F81B" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "129052", "Unicode hex": "1F81C" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "129054", "Unicode hex": "1F81E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "129053", "Unicode hex": "1F81D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "129055", "Unicode hex": "1F81F" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "129024", "Unicode hex": "1F800" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "129026", "Unicode hex": "1F802" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "129025", "Unicode hex": "1F801" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "129027", "Unicode hex": "1F803" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "129028", "Unicode hex": "1F804" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "129030", "Unicode hex": "1F806" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "129029", "Unicode hex": "1F805" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "129031", "Unicode hex": "1F807" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "129032", "Unicode hex": "1F808" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "129034", "Unicode hex": "1F80A" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "129033", "Unicode hex": "1F809" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "129035", "Unicode hex": "1F80B" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "129056", "Unicode hex": "1F820" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "129058", "Unicode hex": "1F822" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "129060", "Unicode hex": "1F824" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "129062", "Unicode hex": "1F826" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "129064", "Unicode hex": "1F828" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "129066", "Unicode hex": "1F82A" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "129068", "Unicode hex": "1F82C" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "129180", "Unicode hex": "1F89C" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "129181", "Unicode hex": "1F89D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "129182", "Unicode hex": "1F89E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "129183", "Unicode hex": "1F89F" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "129070", "Unicode hex": "1F82E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "129072", "Unicode hex": "1F830" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "129074", "Unicode hex": "1F832" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "129076", "Unicode hex": "1F834" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "129078", "Unicode hex": "1F836" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "129080", "Unicode hex": "1F838" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "129082", "Unicode hex": "1F83A" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "129081", "Unicode hex": "1F839" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "129083", "Unicode hex": "1F83B" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "129176", "Unicode hex": "1F898" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "129178", "Unicode hex": "1F89A" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "129177", "Unicode hex": "1F899" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "129179", "Unicode hex": "1F89B" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "129084", "Unicode hex": "1F83C" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "129086", "Unicode hex": "1F83E" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "129085", "Unicode hex": "1F83D" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "129087", "Unicode hex": "1F83F" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "129088", "Unicode hex": "1F840" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "129090", "Unicode hex": "1F842" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "129089", "Unicode hex": "1F841" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "129091", "Unicode hex": "1F843" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "129092", "Unicode hex": "1F844" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "129094", "Unicode hex": "1F846" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "129093", "Unicode hex": "1F845" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "129095", "Unicode hex": "1F847" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11176", "Unicode hex": "2BA8" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11177", "Unicode hex": "2BA9" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "11178", "Unicode hex": "2BAA" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "11179", "Unicode hex": "2BAB" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "11180", "Unicode hex": "2BAC" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "11181", "Unicode hex": "2BAD" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "11182", "Unicode hex": "2BAE" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "11183", "Unicode hex": "2BAF" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "129120", "Unicode hex": "1F860" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "129122", "Unicode hex": "1F862" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "129121", "Unicode hex": "1F861" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "129123", "Unicode hex": "1F863" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "129124", "Unicode hex": "1F864" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "129125", "Unicode hex": "1F865" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "129127", "Unicode hex": "1F867" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "129126", "Unicode hex": "1F866" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "129136", "Unicode hex": "1F870" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "129138", "Unicode hex": "1F872" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "129137", "Unicode hex": "1F871" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "129139", "Unicode hex": "1F873" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "129140", "Unicode hex": "1F874" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "129141", "Unicode hex": "1F875" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129143", "Unicode hex": "1F877" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129142", "Unicode hex": "1F876" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129152", "Unicode hex": "1F880" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129154", "Unicode hex": "1F882" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129153", "Unicode hex": "1F881" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129155", "Unicode hex": "1F883" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129156", "Unicode hex": "1F884" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129157", "Unicode hex": "1F885" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129159", "Unicode hex": "1F887" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129158", "Unicode hex": "1F886" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129168", "Unicode hex": "1F890" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129170", "Unicode hex": "1F892" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129169", "Unicode hex": "1F891" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129171", "Unicode hex": "1F893" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129172", "Unicode hex": "1F894" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129174", "Unicode hex": "1F896" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "129173", "Unicode hex": "1F895" },
  { "Typeface name": "Wingdings 3", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "129175", "Unicode hex": "1F897" }
];
eD.default = yq;
var bq = it && it.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Ja, "__esModule", { value: !0 });
Ja.hex = Ja.dec = Ja.codePoint = void 0;
var vq = bq(eD), BR = {}, xq = String.fromCodePoint ? String.fromCodePoint : Tq;
for (var x1 = 0, AE = vq.default; x1 < AE.length; x1++) {
  var D1 = AE[x1], UE = parseInt(D1["Unicode dec"], 10), Dq = {
    codePoint: UE,
    string: xq(UE)
  };
  BR[D1["Typeface name"].toUpperCase() + "_" + D1["Dingbat dec"]] = Dq;
}
function tD(t, e) {
  return BR[t.toUpperCase() + "_" + e];
}
Ja.codePoint = tD;
function wq(t, e) {
  return tD(t, parseInt(e, 10));
}
Ja.dec = wq;
function Sq(t, e) {
  return tD(t, parseInt(e, 16));
}
Ja.hex = Sq;
function Tq(t) {
  if (t <= 65535)
    return String.fromCharCode(t);
  var e = Math.floor((t - 65536) / 1024) + 55296, n = (t - 65536) % 1024 + 56320;
  return String.fromCharCode(e, n);
}
var nD = {};
nD.uriToZipEntryName = Cq;
nD.replaceFragment = Eq;
function Cq(t, e) {
  return e.charAt(0) === "/" ? e.substr(1) : t + "/" + e;
}
function Eq(t, e) {
  var n = t.indexOf("#");
  return n !== -1 && (t = t.substring(0, n)), t + "#" + e;
}
Qx.createBodyReader = kq;
Qx._readNumberingProperties = NR;
var FE = Ja, Gr = $t, Ot = ut, MR = Ar.Result, Uo = Ar.warning, _q = Jo, RE = nD;
function kq(t) {
  return {
    readXmlElement: function(e) {
      return new OE(t).readXmlElement(e);
    },
    readXmlElements: function(e) {
      return new OE(t).readXmlElements(e);
    }
  };
}
function OE(t) {
  var e = [], n = [], r = [], i = t.relationships, o = t.contentTypes, a = t.docxFile, s = t.files, l = t.numbering, u = t.styles;
  function f(ie) {
    var Ee = ie.map(h);
    return IE(Ee);
  }
  function h(ie) {
    if (ie.type === "element") {
      var Ee = j[ie.name];
      if (Ee)
        return Ee(ie);
      if (!Object.prototype.hasOwnProperty.call(Uq, ie.name)) {
        var Re = Uo("An unrecognised element was ignored: " + ie.name);
        return Pf([Re]);
      }
    }
    return Wf();
  }
  function p(ie) {
    return E(ie).map(function(Ee) {
      return {
        type: "paragraphProperties",
        styleId: Ee.styleId,
        styleName: Ee.name,
        alignment: ie.firstOrEmpty("w:jc").attributes["w:val"],
        numbering: NR(Ee.styleId, ie.firstOrEmpty("w:numPr"), l),
        indent: y(ie.firstOrEmpty("w:ind"))
      };
    });
  }
  function y(ie) {
    return {
      start: ie.attributes["w:start"] || ie.attributes["w:left"],
      end: ie.attributes["w:end"] || ie.attributes["w:right"],
      firstLine: ie.attributes["w:firstLine"],
      hanging: ie.attributes["w:hanging"]
    };
  }
  function b(ie) {
    return I(ie).map(function(Ee) {
      var Re = ie.firstOrEmpty("w:sz").attributes["w:val"], k = /^[0-9]+$/.test(Re) ? parseInt(Re, 10) / 2 : null;
      return {
        type: "runProperties",
        styleId: Ee.styleId,
        styleName: Ee.name,
        verticalAlignment: ie.firstOrEmpty("w:vertAlign").attributes["w:val"],
        font: ie.firstOrEmpty("w:rFonts").attributes["w:ascii"],
        fontSize: k,
        isBold: v(ie.first("w:b")),
        isUnderline: x(ie.first("w:u")),
        isItalic: v(ie.first("w:i")),
        isStrikethrough: v(ie.first("w:strike")),
        isAllCaps: v(ie.first("w:caps")),
        isSmallCaps: v(ie.first("w:smallCaps")),
        highlight: S(ie.firstOrEmpty("w:highlight").attributes["w:val"])
      };
    });
  }
  function x(ie) {
    if (ie) {
      var Ee = ie.attributes["w:val"];
      return Ee !== void 0 && Ee !== "false" && Ee !== "0" && Ee !== "none";
    } else
      return !1;
  }
  function v(ie) {
    if (ie) {
      var Ee = ie.attributes["w:val"];
      return Ee !== "false" && Ee !== "0";
    } else
      return !1;
  }
  function D(ie) {
    return ie !== "false" && ie !== "0";
  }
  function S(ie) {
    return !ie || ie === "none" ? null : ie;
  }
  function E(ie) {
    return O(ie, "w:pStyle", "Paragraph", u.findParagraphStyleById);
  }
  function I(ie) {
    return O(ie, "w:rStyle", "Run", u.findCharacterStyleById);
  }
  function R(ie) {
    return O(ie, "w:tblStyle", "Table", u.findTableStyleById);
  }
  function O(ie, Ee, Re, k) {
    var ge = [], ue = ie.first(Ee), Y = null, H = null;
    if (ue && (Y = ue.attributes["w:val"], Y)) {
      var ae = k(Y);
      ae ? H = ae.name : ge.push(tt(Re, Y));
    }
    return dp({ styleId: Y, name: H }, ge);
  }
  function N(ie) {
    var Ee = ie.attributes["w:fldCharType"];
    if (Ee === "begin")
      e.push({ type: "begin", fldChar: ie }), n = [];
    else if (Ee === "end") {
      var Re = e.pop();
      if (Re.type === "begin" && (Re = $(Re)), Re.type === "checkbox")
        return sr(Ot.checkbox({
          checked: Re.checked
        }));
    } else if (Ee === "separate") {
      var k = e.pop(), ge = $(k);
      e.push(ge);
    }
    return Wf();
  }
  function q() {
    var ie = Gr.last(e.filter(function(Ee) {
      return Ee.type === "hyperlink";
    }));
    return ie ? ie.options : null;
  }
  function $(ie) {
    return le(
      n.join(""),
      ie.type === "begin" ? ie.fldChar : _q.emptyElement
    );
  }
  function le(ie, Ee) {
    var Re = /\s*HYPERLINK "(.*)"/.exec(ie);
    if (Re)
      return { type: "hyperlink", options: { href: Re[1] } };
    var k = /\s*HYPERLINK\s+\\l\s+"(.*)"/.exec(ie);
    if (k)
      return { type: "hyperlink", options: { anchor: k[1] } };
    var ge = /\s*FORMCHECKBOX\s*/.exec(ie);
    if (ge) {
      var ue = Ee.firstOrEmpty("w:ffData").firstOrEmpty("w:checkBox"), Y = ue.first("w:checked"), H = Y == null ? v(ue.first("w:default")) : v(Y);
      return { type: "checkbox", checked: H };
    }
    return { type: "unknown" };
  }
  function ve(ie) {
    return n.push(ie.text()), Wf();
  }
  function M(ie) {
    var Ee = ie.attributes["w:font"], Re = ie.attributes["w:char"], k = FE.hex(Ee, Re);
    return k == null && /^F0..$/.test(Re) && (k = FE.hex(Ee, Re.substring(2))), k == null ? Pf([Uo(
      "A w:sym element with an unsupported character was ignored: char " + Re + " in font " + Ee
    )]) : sr(new Ot.Text(k.string));
  }
  function ee(ie) {
    return function(Ee) {
      var Re = Ee.attributes["w:id"];
      return sr(new Ot.NoteReference({
        noteType: ie,
        noteId: Re
      }));
    };
  }
  function A(ie) {
    return sr(Ot.commentReference({
      commentId: ie.attributes["w:id"]
    }));
  }
  function oe(ie) {
    return f(ie.children);
  }
  var j = {
    "w:p": function(ie) {
      var Ee = ie.firstOrEmpty("w:pPr"), Re = !!Ee.firstOrEmpty("w:rPr").first("w:del");
      if (Re)
        return ie.children.forEach(function(ge) {
          r.push(ge);
        }), Wf();
      var k = ie.children;
      return r.length > 0 && (k = r.concat(k), r = []), bn.map(
        p(Ee),
        f(k),
        function(ge, ue) {
          return new Ot.Paragraph(ue, ge);
        }
      ).insertExtra();
    },
    "w:r": function(ie) {
      return bn.map(
        b(ie.firstOrEmpty("w:rPr")),
        f(ie.children),
        function(Ee, Re) {
          var k = q();
          return k !== null && (Re = [new Ot.Hyperlink(Re, k)]), new Ot.Run(Re, Ee);
        }
      );
    },
    "w:fldChar": N,
    "w:instrText": ve,
    "w:t": function(ie) {
      return sr(new Ot.Text(ie.text()));
    },
    "w:tab": function(ie) {
      return sr(new Ot.Tab());
    },
    "w:noBreakHyphen": function() {
      return sr(new Ot.Text("‑"));
    },
    "w:softHyphen": function(ie) {
      return sr(new Ot.Text("­"));
    },
    "w:sym": M,
    "w:hyperlink": function(ie) {
      var Ee = ie.attributes["r:id"], Re = ie.attributes["w:anchor"];
      return f(ie.children).map(function(k) {
        function ge(Y) {
          var H = ie.attributes["w:tgtFrame"] || null;
          return new Ot.Hyperlink(
            k,
            Gr.extend({ targetFrame: H }, Y)
          );
        }
        if (Ee) {
          var ue = i.findTargetByRelationshipId(Ee);
          return Re && (ue = RE.replaceFragment(ue, Re)), ge({ href: ue });
        } else return Re ? ge({ anchor: Re }) : k;
      });
    },
    "w:tbl": Q,
    "w:tr": Z,
    "w:tc": re,
    "w:footnoteReference": ee("footnote"),
    "w:endnoteReference": ee("endnote"),
    "w:commentReference": A,
    "w:br": function(ie) {
      var Ee = ie.attributes["w:type"];
      return Ee == null || Ee === "textWrapping" ? sr(Ot.lineBreak) : Ee === "page" ? sr(Ot.pageBreak) : Ee === "column" ? sr(Ot.columnBreak) : Pf([Uo("Unsupported break type: " + Ee)]);
    },
    "w:bookmarkStart": function(ie) {
      var Ee = ie.attributes["w:name"];
      return Ee === "_GoBack" ? Wf() : sr(new Ot.BookmarkStart({ name: Ee }));
    },
    "mc:AlternateContent": function(ie) {
      return oe(ie.first("mc:Fallback"));
    },
    "w:sdt": function(ie) {
      var Ee = ie.firstOrEmpty("w:sdtPr").first("wordml:checkbox");
      if (Ee) {
        var Re = Ee.first("wordml:checked"), k = !!Re && D(
          Re.attributes["wordml:val"]
        );
        return sr(Ot.checkbox({
          checked: k
        }));
      } else
        return f(ie.firstOrEmpty("w:sdtContent").children);
    },
    "w:ins": oe,
    "w:object": oe,
    "w:smartTag": oe,
    "w:drawing": oe,
    "w:pict": function(ie) {
      return oe(ie).toExtra();
    },
    "v:roundrect": oe,
    "v:shape": oe,
    "v:textbox": oe,
    "w:txbxContent": oe,
    "wp:inline": pe,
    "wp:anchor": pe,
    "v:imagedata": $e,
    "v:group": oe,
    "v:rect": oe
  };
  return {
    readXmlElement: h,
    readXmlElements: f
  };
  function Q(ie) {
    var Ee = G(ie.firstOrEmpty("w:tblPr"));
    return f(ie.children).flatMap(P).flatMap(function(Re) {
      return Ee.map(function(k) {
        return Ot.Table(Re, k);
      });
    });
  }
  function G(ie) {
    return R(ie).map(function(Ee) {
      return {
        styleId: Ee.styleId,
        styleName: Ee.name
      };
    });
  }
  function Z(ie) {
    var Ee = ie.firstOrEmpty("w:trPr"), Re = !!Ee.first("w:tblHeader");
    return f(ie.children).map(function(k) {
      return Ot.TableRow(k, { isHeader: Re });
    });
  }
  function re(ie) {
    return f(ie.children).map(function(Ee) {
      var Re = ie.firstOrEmpty("w:tcPr"), k = Re.firstOrEmpty("w:gridSpan").attributes["w:val"], ge = k ? parseInt(k, 10) : 1, ue = Ot.TableCell(Ee, { colSpan: ge });
      return ue._vMerge = V(Re), ue;
    });
  }
  function V(ie) {
    var Ee = ie.first("w:vMerge");
    if (Ee) {
      var Re = Ee.attributes["w:val"];
      return Re === "continue" || !Re;
    } else
      return null;
  }
  function P(ie) {
    var Ee = Gr.any(ie, function(ge) {
      return ge.type !== Ot.types.tableRow;
    });
    if (Ee)
      return dp(ie, [Uo(
        "unexpected non-row element in table, cell merging may be incorrect"
      )]);
    var Re = Gr.any(ie, function(ge) {
      return Gr.any(ge.children, function(ue) {
        return ue.type !== Ot.types.tableCell;
      });
    });
    if (Re)
      return dp(ie, [Uo(
        "unexpected non-cell element in table row, cell merging may be incorrect"
      )]);
    var k = {};
    return ie.forEach(function(ge) {
      var ue = 0;
      ge.children.forEach(function(Y) {
        Y._vMerge && k[ue] ? k[ue].rowSpan++ : (k[ue] = Y, Y._vMerge = !1), ue += Y.colSpan;
      });
    }), ie.forEach(function(ge) {
      ge.children = ge.children.filter(function(ue) {
        return !ue._vMerge;
      }), ge.children.forEach(function(ue) {
        delete ue._vMerge;
      });
    }), sr(ie);
  }
  function pe(ie) {
    var Ee = ie.getElementsByTagName("a:graphic").getElementsByTagName("a:graphicData").getElementsByTagName("pic:pic").getElementsByTagName("pic:blipFill").getElementsByTagName("a:blip");
    return IE(Ee.map(we.bind(null, ie)));
  }
  function we(ie, Ee) {
    var Re = ie.first("wp:docPr").attributes, k = be(Re.descr) ? Re.title : Re.descr, ge = _e(Ee);
    return ge === null ? Pf([Uo("Could not find image file for a:blip element")]) : ze(ge, k);
  }
  function be(ie) {
    return ie == null || /^\s*$/.test(ie);
  }
  function _e(ie) {
    var Ee = ie.attributes["r:embed"], Re = ie.attributes["r:link"];
    if (Ee)
      return Le(Ee);
    if (Re) {
      var k = i.findTargetByRelationshipId(Re);
      return {
        path: k,
        read: s.read.bind(s, k)
      };
    } else
      return null;
  }
  function $e(ie) {
    var Ee = ie.attributes["r:id"];
    return Ee ? ze(
      Le(Ee),
      ie.attributes["o:title"]
    ) : Pf([Uo("A v:imagedata element without a relationship ID was ignored")]);
  }
  function Le(ie) {
    var Ee = RE.uriToZipEntryName("word", i.findTargetByRelationshipId(ie));
    return {
      path: Ee,
      read: a.read.bind(a, Ee)
    };
  }
  function ze(ie, Ee) {
    var Re = o.findContentType(ie.path), k = Ot.Image({
      readImage: ie.read,
      altText: Ee,
      contentType: Re
    }), ge = Aq[Re] ? [] : Uo("Image of type " + Re + " is unlikely to display in web browsers");
    return dp(k, ge);
  }
  function tt(ie, Ee) {
    return Uo(
      ie + " style with ID " + Ee + " was referenced but not defined in the document"
    );
  }
}
function NR(t, e, n) {
  var r = e.firstOrEmpty("w:ilvl").attributes["w:val"], i = e.firstOrEmpty("w:numId").attributes["w:val"];
  if (r !== void 0 && i !== void 0)
    return n.findLevel(i, r);
  if (t != null) {
    var o = n.findLevelByParagraphStyleId(t);
    if (o != null)
      return o;
  }
  return null;
}
var Aq = {
  "image/png": !0,
  "image/gif": !0,
  "image/jpeg": !0,
  "image/svg+xml": !0,
  "image/tiff": !0
}, Uq = {
  "office-word:wrap": !0,
  "v:shadow": !0,
  "v:shapetype": !0,
  "w:annotationRef": !0,
  "w:bookmarkEnd": !0,
  "w:sectPr": !0,
  "w:proofErr": !0,
  "w:lastRenderedPageBreak": !0,
  "w:commentRangeStart": !0,
  "w:commentRangeEnd": !0,
  "w:del": !0,
  "w:footnoteRef": !0,
  "w:endnoteRef": !0,
  "w:pPr": !0,
  "w:rPr": !0,
  "w:tblPr": !0,
  "w:tblGrid": !0,
  "w:trPr": !0,
  "w:tcPr": !0
};
function Pf(t) {
  return new bn(null, null, t);
}
function Wf() {
  return new bn(null);
}
function sr(t) {
  return new bn(t);
}
function dp(t, e) {
  return new bn(t, null, e);
}
function bn(t, e, n) {
  this.value = t || [], this.extra = e || [], this._result = new MR({
    element: this.value,
    extra: e
  }, n), this.messages = this._result.messages;
}
bn.prototype.toExtra = function() {
  return new bn(null, ay(this.extra, this.value), this.messages);
};
bn.prototype.insertExtra = function() {
  var t = this.extra;
  return t && t.length ? new bn(ay(this.value, t), null, this.messages) : this;
};
bn.prototype.map = function(t) {
  var e = this._result.map(function(n) {
    return t(n.element);
  });
  return new bn(e.value, this.extra, e.messages);
};
bn.prototype.flatMap = function(t) {
  var e = this._result.flatMap(function(n) {
    return t(n.element)._result;
  });
  return new bn(e.value.element, ay(this.extra, e.value.extra), e.messages);
};
bn.map = function(t, e, n) {
  return new bn(
    n(t.value, e.value),
    ay(t.extra, e.extra),
    t.messages.concat(e.messages)
  );
};
function IE(t) {
  var e = MR.combine(Gr.pluck(t, "_result"));
  return new bn(
    Gr.flatten(Gr.pluck(e.value, "element")),
    Gr.filter(Gr.flatten(Gr.pluck(e.value, "extra")), Fq),
    e.messages
  );
}
function ay(t, e) {
  return Gr.flatten([t, e]);
}
function Fq(t) {
  return t;
}
var PR = {};
PR.DocumentXmlReader = Iq;
var Rq = ut, Oq = Ar.Result;
function Iq(t) {
  var e = t.bodyReader;
  function n(r) {
    var i = r.first("w:body");
    if (i == null)
      throw new Error("Could not find the body element: are you sure this is a docx file?");
    var o = e.readXmlElements(i.children).map(function(a) {
      return new Rq.Document(a, {
        notes: t.notes,
        comments: t.comments
      });
    });
    return new Oq(o.value, o.messages);
  }
  return {
    convertXmlToDocument: n
  };
}
var sy = {};
sy.readRelationships = Bq;
sy.defaultValue = new rD([]);
sy.Relationships = rD;
function Bq(t) {
  var e = [];
  return t.children.forEach(function(n) {
    if (n.name === "relationships:Relationship") {
      var r = {
        relationshipId: n.attributes.Id,
        target: n.attributes.Target,
        type: n.attributes.Type
      };
      e.push(r);
    }
  }), new rD(e);
}
function rD(t) {
  var e = {};
  t.forEach(function(r) {
    e[r.relationshipId] = r.target;
  });
  var n = {};
  return t.forEach(function(r) {
    n[r.type] || (n[r.type] = []), n[r.type].push(r.target);
  }), {
    findTargetByRelationshipId: function(r) {
      return e[r];
    },
    findTargetsByType: function(r) {
      return n[r] || [];
    }
  };
}
var iD = {};
iD.readContentTypesFromXml = Nq;
var Mq = {
  png: "png",
  gif: "gif",
  jpeg: "jpeg",
  jpg: "jpeg",
  tif: "tiff",
  tiff: "tiff",
  bmp: "bmp"
};
iD.defaultContentTypes = WR({}, {});
function Nq(t) {
  var e = {}, n = {};
  return t.children.forEach(function(r) {
    if (r.name === "content-types:Default" && (e[r.attributes.Extension] = r.attributes.ContentType), r.name === "content-types:Override") {
      var i = r.attributes.PartName;
      i.charAt(0) === "/" && (i = i.substring(1)), n[i] = r.attributes.ContentType;
    }
  }), WR(n, e);
}
function WR(t, e) {
  return {
    findContentType: function(n) {
      var r = t[n];
      if (r)
        return r;
      var i = n.split("."), o = i[i.length - 1];
      if (e.hasOwnProperty(o))
        return e[o];
      var a = Mq[o.toLowerCase()];
      return a ? "image/" + a : null;
    }
  };
}
var ly = {}, hp = $t;
ly.readNumberingXml = Pq;
ly.Numbering = oD;
ly.defaultNumbering = new oD({}, {});
function oD(t, e, n) {
  var r = hp.flatten(hp.values(e).map(function(s) {
    return hp.values(s.levels);
  })), i = hp.indexBy(
    r.filter(function(s) {
      return s.paragraphStyleId != null;
    }),
    "paragraphStyleId"
  );
  function o(s, l) {
    var u = t[s];
    if (u) {
      var f = e[u.abstractNumId];
      if (f) {
        if (f.numStyleLink == null)
          return e[u.abstractNumId].levels[l];
        var h = n.findNumberingStyleById(f.numStyleLink);
        return o(h.numId, l);
      } else return null;
    } else
      return null;
  }
  function a(s) {
    return i[s] || null;
  }
  return {
    findLevel: o,
    findLevelByParagraphStyleId: a
  };
}
function Pq(t, e) {
  if (!e || !e.styles)
    throw new Error("styles is missing");
  var n = Wq(t), r = zq(t);
  return new oD(r, n, e.styles);
}
function Wq(t) {
  var e = {};
  return t.getElementsByTagName("w:abstractNum").forEach(function(n) {
    var r = n.attributes["w:abstractNumId"];
    e[r] = Lq(n);
  }), e;
}
function Lq(t) {
  var e = {};
  t.getElementsByTagName("w:lvl").forEach(function(r) {
    var i = r.attributes["w:ilvl"], o = r.firstOrEmpty("w:numFmt").attributes["w:val"], a = r.firstOrEmpty("w:pStyle").attributes["w:val"];
    e[i] = {
      isOrdered: o !== "bullet",
      level: i,
      paragraphStyleId: a
    };
  });
  var n = t.firstOrEmpty("w:numStyleLink").attributes["w:val"];
  return { levels: e, numStyleLink: n };
}
function zq(t) {
  var e = {};
  return t.getElementsByTagName("w:num").forEach(function(n) {
    var r = n.attributes["w:numId"], i = n.first("w:abstractNumId").attributes["w:val"];
    e[r] = { abstractNumId: i };
  }), e;
}
var cy = {};
cy.readStylesXml = $q;
cy.Styles = Pd;
cy.defaultStyles = new Pd({}, {});
function Pd(t, e, n, r) {
  return {
    findParagraphStyleById: function(i) {
      return t[i];
    },
    findCharacterStyleById: function(i) {
      return e[i];
    },
    findTableStyleById: function(i) {
      return n[i];
    },
    findNumberingStyleById: function(i) {
      return r[i];
    }
  };
}
Pd.EMPTY = new Pd({}, {}, {}, {});
function $q(t) {
  var e = {}, n = {}, r = {}, i = {}, o = {
    paragraph: e,
    character: n,
    table: r
  };
  return t.getElementsByTagName("w:style").forEach(function(a) {
    var s = jq(a);
    if (s.type === "numbering")
      i[s.styleId] = Vq(a);
    else {
      var l = o[s.type];
      l && (l[s.styleId] = s);
    }
  }), new Pd(e, n, r, i);
}
function jq(t) {
  var e = t.attributes["w:type"], n = t.attributes["w:styleId"], r = Hq(t);
  return { type: e, styleId: n, name: r };
}
function Hq(t) {
  var e = t.first("w:name");
  return e ? e.attributes["w:val"] : null;
}
function Vq(t) {
  var e = t.firstOrEmpty("w:pPr").firstOrEmpty("w:numPr").firstOrEmpty("w:numId").attributes["w:val"];
  return { numId: e };
}
var aD = {}, qq = ut, Xq = Ar.Result;
aD.createFootnotesReader = LR.bind(it, "footnote");
aD.createEndnotesReader = LR.bind(it, "endnote");
function LR(t, e) {
  function n(o) {
    return Xq.combine(o.getElementsByTagName("w:" + t).filter(r).map(i));
  }
  function r(o) {
    var a = o.attributes["w:type"];
    return a !== "continuationSeparator" && a !== "separator";
  }
  function i(o) {
    var a = o.attributes["w:id"];
    return e.readXmlElements(o.children).map(function(s) {
      return qq.Note({ noteType: t, noteId: a, body: s });
    });
  }
  return n;
}
var zR = {}, Gq = ut, Jq = Ar.Result;
function Yq(t) {
  function e(r) {
    return Jq.combine(r.getElementsByTagName("w:comment").map(n));
  }
  function n(r) {
    var i = r.attributes["w:id"];
    function o(a) {
      return (r.attributes[a] || "").trim() || null;
    }
    return t.readXmlElements(r.children).map(function(a) {
      return Gq.comment({
        commentId: i,
        body: a,
        authorName: o("w:author"),
        authorInitials: o("w:initials")
      });
    });
  }
  return e;
}
zR.createCommentsReader = Yq;
var $R = {}, Zq = rn;
$R.Files = Kq;
function Kq() {
  function t(e) {
    return Zq.reject(new Error("could not open external image: '" + e + `'
cannot open linked files from a web browser`));
  }
  return {
    read: t
  };
}
Mx.read = iX;
Mx._findPartPaths = HR;
var Qq = rn, eX = ut, w1 = Ar.Result, sm = Zd, jR = Wx.readXmlFromZipFile, tX = Qx.createBodyReader, nX = PR.DocumentXmlReader, yu = sy, BE = iD, ME = ly, NE = cy, PE = aD, rX = zR, WE = $R.Files;
function iX(t, e) {
  return e = e || {}, Qq.props({
    contentTypes: aX(t),
    partPaths: HR(t),
    docxFile: t,
    files: e.path ? WE.relativeToFile(e.path) : new WE(null)
  }).also(function(n) {
    return {
      styles: lX(t, n.partPaths.styles)
    };
  }).also(function(n) {
    return {
      numbering: sX(t, n.partPaths.numbering, n.styles)
    };
  }).also(function(n) {
    return {
      footnotes: pp(n.partPaths.footnotes, n, function(r, i) {
        return i ? PE.createFootnotesReader(r)(i) : new w1([]);
      }),
      endnotes: pp(n.partPaths.endnotes, n, function(r, i) {
        return i ? PE.createEndnotesReader(r)(i) : new w1([]);
      }),
      comments: pp(n.partPaths.comments, n, function(r, i) {
        return i ? rX.createCommentsReader(r)(i) : new w1([]);
      })
    };
  }).also(function(n) {
    return {
      notes: n.footnotes.flatMap(function(r) {
        return n.endnotes.map(function(i) {
          return new eX.Notes(r.concat(i));
        });
      })
    };
  }).then(function(n) {
    return pp(n.partPaths.mainDocument, n, function(r, i) {
      return n.notes.flatMap(function(o) {
        return n.comments.flatMap(function(a) {
          var s = new nX({
            bodyReader: r,
            notes: o,
            comments: a
          });
          return s.convertXmlToDocument(i);
        });
      });
    });
  });
}
function HR(t) {
  return cX(t).then(function(e) {
    var n = LE({
      docxFile: t,
      relationships: e,
      relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
      basePath: "",
      fallbackPath: "word/document.xml"
    });
    if (!t.exists(n))
      throw new Error("Could not find main document part. Are you sure this is a valid .docx file?");
    return Ou({
      filename: VR(n),
      readElement: yu.readRelationships,
      defaultValue: yu.defaultValue
    })(t).then(function(r) {
      function i(o) {
        return LE({
          docxFile: t,
          relationships: r,
          relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/" + o,
          basePath: sm.splitPath(n).dirname,
          fallbackPath: "word/" + o + ".xml"
        });
      }
      return {
        mainDocument: n,
        comments: i("comments"),
        endnotes: i("endnotes"),
        footnotes: i("footnotes"),
        numbering: i("numbering"),
        styles: i("styles")
      };
    });
  });
}
function LE(t) {
  var e = t.docxFile, n = t.relationships, r = t.relationshipType, i = t.basePath, o = t.fallbackPath, a = n.findTargetsByType(r), s = a.map(function(u) {
    return oX(sm.joinPath(i, u), "/");
  }), l = s.filter(function(u) {
    return e.exists(u);
  });
  return l.length === 0 ? o : l[0];
}
function oX(t, e) {
  return t.substring(0, e.length) === e ? t.substring(e.length) : t;
}
function Ou(t) {
  return function(e) {
    return jR(e, t.filename).then(function(n) {
      return n ? t.readElement(n) : t.defaultValue;
    });
  };
}
function pp(t, e, n) {
  var r = Ou({
    filename: VR(t),
    readElement: yu.readRelationships,
    defaultValue: yu.defaultValue
  });
  return r(e.docxFile).then(function(i) {
    var o = new tX({
      relationships: i,
      contentTypes: e.contentTypes,
      docxFile: e.docxFile,
      numbering: e.numbering,
      styles: e.styles,
      files: e.files
    });
    return jR(e.docxFile, t).then(function(a) {
      return n(o, a);
    });
  });
}
function VR(t) {
  var e = sm.splitPath(t);
  return sm.joinPath(e.dirname, "_rels", e.basename + ".rels");
}
var aX = Ou({
  filename: "[Content_Types].xml",
  readElement: BE.readContentTypesFromXml,
  defaultValue: BE.defaultContentTypes
});
function sX(t, e, n) {
  return Ou({
    filename: e,
    readElement: function(r) {
      return ME.readNumberingXml(r, { styles: n });
    },
    defaultValue: ME.defaultNumbering
  })(t);
}
function lX(t, e) {
  return Ou({
    filename: e,
    readElement: NE.readStylesXml,
    defaultValue: NE.defaultStyles
  })(t);
}
var cX = Ou({
  filename: "_rels/.rels",
  readElement: yu.readRelationships,
  defaultValue: yu.defaultValue
}), sD = {}, uX = $t, fX = rn, Wd = Jo;
sD.writeStyleMap = hX;
sD.readStyleMap = mX;
var dX = "http://schemas.zwobble.org/mammoth/style-map", lm = "mammoth/style-map", qR = "/" + lm;
function hX(t, e) {
  return t.write(lm, e), pX(t).then(function() {
    return gX(t);
  });
}
function pX(t) {
  var e = "word/_rels/document.xml.rels", n = "http://schemas.openxmlformats.org/package/2006/relationships", r = "{" + n + "}Relationship";
  return t.read(e, "utf8").then(Wd.readString).then(function(i) {
    var o = i.children;
    XR(o, r, "Id", {
      Id: "rMammothStyleMap",
      Type: dX,
      Target: qR
    });
    var a = { "": n };
    return t.write(e, Wd.writeString(i, a));
  });
}
function gX(t) {
  var e = "[Content_Types].xml", n = "http://schemas.openxmlformats.org/package/2006/content-types", r = "{" + n + "}Override";
  return t.read(e, "utf8").then(Wd.readString).then(function(i) {
    var o = i.children;
    XR(o, r, "PartName", {
      PartName: qR,
      ContentType: "text/prs.mammoth.style-map"
    });
    var a = { "": n };
    return t.write(e, Wd.writeString(i, a));
  });
}
function XR(t, e, n, r) {
  var i = uX.find(t, function(o) {
    return o.name === e && o.attributes[n] === r[n];
  });
  i ? i.attributes = r : t.push(Wd.element(e, r));
}
function mX(t) {
  return t.exists(lm) ? t.read(lm, "utf8") : fX.resolve(null);
}
var lD = {}, Xs = {}, Fo = {}, Aa = {}, zE;
function GR() {
  if (zE) return Aa;
  zE = 1;
  var t = fy();
  function e(l, u, f) {
    return r(
      t.element(l, u, { fresh: !1 }),
      f
    );
  }
  function n(l, u, f) {
    var h = t.element(l, u, { fresh: !0 });
    return r(h, f);
  }
  function r(l, u) {
    return {
      type: "element",
      tag: l,
      children: u || []
    };
  }
  function i(l) {
    return {
      type: "text",
      value: l
    };
  }
  var o = {
    type: "forceWrite"
  };
  Aa.freshElement = n, Aa.nonFreshElement = e, Aa.elementWithTag = r, Aa.text = i, Aa.forceWrite = o;
  var a = {
    br: !0,
    hr: !0,
    img: !0,
    input: !0
  };
  function s(l) {
    return l.children.length === 0 && a[l.tag.tagName];
  }
  return Aa.isVoidElement = s, Aa;
}
var S1, $E;
function yX() {
  if ($E) return S1;
  $E = 1;
  var t = $t, e = GR();
  function n(x) {
    return r(u(x));
  }
  function r(x) {
    var v = [];
    return x.map(i).forEach(function(D) {
      l(v, D);
    }), v;
  }
  function i(x) {
    return o[x.type](x);
  }
  var o = {
    element: a,
    text: s,
    forceWrite: s
  };
  function a(x) {
    return e.elementWithTag(x.tag, r(x.children));
  }
  function s(x) {
    return x;
  }
  function l(x, v) {
    var D = x[x.length - 1];
    v.type === "element" && !v.tag.fresh && D && D.type === "element" && v.tag.matchesElement(D.tag) ? (v.tag.separator && l(D.children, e.text(v.tag.separator)), v.children.forEach(function(S) {
      l(D.children, S);
    })) : x.push(v);
  }
  function u(x) {
    return f(x, function(v) {
      return h[v.type](v);
    });
  }
  function f(x, v) {
    return t.flatten(t.map(x, v), !0);
  }
  var h = {
    element: y,
    text: b,
    forceWrite: p
  };
  function p(x) {
    return [x];
  }
  function y(x) {
    var v = u(x.children);
    return v.length === 0 && !e.isVoidElement(x) ? [] : [e.elementWithTag(x.tag, v)];
  }
  function b(x) {
    return x.value.length === 0 ? [] : [x];
  }
  return S1 = n, S1;
}
var jE;
function uy() {
  if (jE) return Fo;
  jE = 1;
  var t = GR();
  Fo.freshElement = t.freshElement, Fo.nonFreshElement = t.nonFreshElement, Fo.elementWithTag = t.elementWithTag, Fo.text = t.text, Fo.forceWrite = t.forceWrite, Fo.simplify = yX();
  function e(a, s) {
    s.forEach(function(l) {
      n(a, l);
    });
  }
  function n(a, s) {
    r[s.type](a, s);
  }
  var r = {
    element: i,
    text: o,
    forceWrite: function() {
    }
  };
  function i(a, s) {
    t.isVoidElement(s) ? a.selfClosing(s.tag.tagName, s.tag.attributes) : (a.open(s.tag.tagName, s.tag.attributes), e(a, s.children), a.close(s.tag.tagName));
  }
  function o(a, s) {
    a.text(s.value);
  }
  return Fo.write = e, Fo;
}
var HE;
function fy() {
  if (HE) return Xs;
  HE = 1;
  var t = $t, e = uy();
  Xs.topLevelElement = n, Xs.elements = r, Xs.element = o;
  function n(s, l) {
    return r([o(s, l, { fresh: !0 })]);
  }
  function r(s) {
    return new i(s.map(function(l) {
      return t.isString(l) ? o(l) : l;
    }));
  }
  function i(s) {
    this._elements = s;
  }
  i.prototype.wrap = function(l) {
    for (var u = l(), f = this._elements.length - 1; f >= 0; f--)
      u = this._elements[f].wrapNodes(u);
    return u;
  };
  function o(s, l, u) {
    return u = u || {}, new a(s, l, u);
  }
  function a(s, l, u) {
    var f = {};
    t.isArray(s) ? (s.forEach(function(h) {
      f[h] = !0;
    }), s = s[0]) : f[s] = !0, this.tagName = s, this.tagNames = f, this.attributes = l || {}, this.fresh = u.fresh, this.separator = u.separator;
  }
  return a.prototype.matchesElement = function(s) {
    return this.tagNames[s.tagName] && t.isEqual(this.attributes || {}, s.attributes || {});
  }, a.prototype.wrap = function(l) {
    return this.wrapNodes(l());
  }, a.prototype.wrapNodes = function(l) {
    return [e.elementWithTag(this, l)];
  }, Xs.empty = r([]), Xs.ignore = {
    wrap: function() {
      return [];
    }
  }, Xs;
}
var cD = {};
(function(t) {
  var e = $t, n = rn, r = uy();
  t.imgElement = i;
  function i(o) {
    return function(a, s) {
      return n.when(o(a)).then(function(l) {
        var u = {};
        return a.altText && (u.alt = a.altText), e.extend(u, l), [r.freshElement("img", u)];
      });
    };
  }
  t.inline = t.imgElement, t.dataUri = i(function(o) {
    return o.readAsBase64String().then(function(a) {
      return {
        src: "data:" + o.contentType + ";base64," + a
      };
    });
  });
})(cD);
var JR = {}, YR = {}, ZR = $t;
YR.writer = bX;
function bX(t) {
  return t = t || {}, t.prettyPrint ? vX() : KR();
}
var gp = {
  div: !0,
  p: !0,
  ul: !0,
  li: !0
};
function vX() {
  var t = 0, e = "  ", n = [], r = !0, i = !1, o = KR();
  function a(b, x) {
    gp[b] && p(), n.push(b), o.open(b, x), gp[b] && t++, r = !1;
  }
  function s(b) {
    gp[b] && (t--, p()), n.pop(), o.close(b);
  }
  function l(b) {
    h();
    var x = y() ? b : b.replace(`
`, `
` + e);
    o.text(x);
  }
  function u(b, x) {
    p(), o.selfClosing(b, x);
  }
  function f() {
    return n.length === 0 || gp[n[n.length - 1]];
  }
  function h() {
    i || (p(), i = !0);
  }
  function p() {
    if (i = !1, !r && f() && !y()) {
      o._append(`
`);
      for (var b = 0; b < t; b++)
        o._append(e);
    }
  }
  function y() {
    return ZR.some(n, function(b) {
      return b === "pre";
    });
  }
  return {
    asString: o.asString,
    open: a,
    close: s,
    text: l,
    selfClosing: u
  };
}
function KR() {
  var t = [];
  function e(l, u) {
    var f = i(u);
    t.push("<" + l + f + ">");
  }
  function n(l) {
    t.push("</" + l + ">");
  }
  function r(l, u) {
    var f = i(u);
    t.push("<" + l + f + " />");
  }
  function i(l) {
    return ZR.map(l, function(u, f) {
      return " " + f + '="' + DX(u) + '"';
    }).join("");
  }
  function o(l) {
    t.push(xX(l));
  }
  function a(l) {
    t.push(l);
  }
  function s() {
    return t.join("");
  }
  return {
    asString: s,
    open: e,
    close: n,
    text: o,
    selfClosing: r,
    _append: a
  };
}
function xX(t) {
  return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function DX(t) {
  return t.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
var QR = {}, wX = $t;
function VE(t) {
  return cm(t, t);
}
function cm(t, e) {
  return function() {
    return { start: t, end: e };
  };
}
function SX(t) {
  var e = t.href || "";
  return e ? {
    start: "[",
    end: "](" + e + ")",
    anchorPosition: "before"
  } : {};
}
function TX(t) {
  var e = t.src || "", n = t.alt || "";
  return e || n ? { start: "![" + n + "](" + e + ")" } : {};
}
function qE(t) {
  return function(e, n) {
    return {
      start: n ? `
` : "",
      end: n ? "" : `
`,
      list: {
        isOrdered: t.isOrdered,
        indent: n ? n.indent + 1 : 0,
        count: 0
      }
    };
  };
}
function CX(t, e, n) {
  e = e || { indent: 0, isOrdered: !1, count: 0 }, e.count++, n.hasClosed = !1;
  var r = e.isOrdered ? e.count + "." : "-", i = t8("	", e.indent) + r + " ";
  return {
    start: i,
    end: function() {
      if (!n.hasClosed)
        return n.hasClosed = !0, `
`;
    }
  };
}
var e8 = {
  p: cm("", `

`),
  br: cm("", `  
`),
  ul: qE({ isOrdered: !1 }),
  ol: qE({ isOrdered: !0 }),
  li: CX,
  strong: VE("__"),
  em: VE("*"),
  a: SX,
  img: TX
};
(function() {
  for (var t = 1; t <= 6; t++)
    e8["h" + t] = cm(t8("#", t) + " ", `

`);
})();
function t8(t, e) {
  return new Array(e + 1).join(t);
}
function EX() {
  var t = [], e = [], n = null, r = {};
  function i(f, h) {
    h = h || {};
    var p = e8[f] || function() {
      return {};
    }, y = p(h, n, r);
    e.push({ end: y.end, list: n }), y.list && (n = y.list);
    var b = y.anchorPosition === "before";
    b && o(h), t.push(y.start || ""), b || o(h);
  }
  function o(f) {
    f.id && t.push('<a id="' + f.id + '"></a>');
  }
  function a(f) {
    var h = e.pop();
    n = h.list;
    var p = wX.isFunction(h.end) ? h.end() : h.end;
    t.push(p || "");
  }
  function s(f, h) {
    i(f, h), a();
  }
  function l(f) {
    t.push(_X(f));
  }
  function u() {
    return t.join("");
  }
  return {
    asString: u,
    open: i,
    close: a,
    text: l,
    selfClosing: s
  };
}
QR.writer = EX;
function _X(t) {
  return t.replace(/\\/g, "\\\\").replace(/([\`\*_\{\}\[\]\(\)\#\+\-\.\!])/g, "\\$1");
}
var kX = YR, AX = QR;
JR.writer = UX;
function UX(t) {
  return t = t || {}, t.outputFormat === "markdown" ? AX.writer() : kX.writer(t);
}
var Ma = $t, XE = rn, Wp = ut, Vr = fy(), q0 = Ar, FX = cD, ht = uy(), RX = JR;
lD.DocumentConverter = OX;
function OX(t) {
  return {
    convertToHtml: function(e) {
      var n = Ma.indexBy(
        e.type === Wp.types.document ? e.comments : [],
        "commentId"
      ), r = new IX(t, n);
      return r.convertToHtml(e);
    }
  };
}
function IX(t, e) {
  var n = 1, r = [], i = [];
  t = Ma.extend({ ignoreEmptyParagraphs: !0 }, t);
  var o = t.idPrefix === void 0 ? "" : t.idPrefix, a = t.ignoreEmptyParagraphs, s = Vr.topLevelElement("p"), l = t.styleMap || [];
  function u(G) {
    var Z = [], re = h(G, Z, {}), V = [];
    n8(re, function(pe) {
      pe.type === "deferred" && V.push(pe);
    });
    var P = {};
    return XE.mapSeries(V, function(pe) {
      return pe.value().then(function(we) {
        P[pe.id] = we;
      });
    }).then(function() {
      function pe(be) {
        return T1(be, function(_e) {
          return _e.type === "deferred" ? P[_e.id] : _e.children ? [
            Ma.extend({}, _e, {
              children: pe(_e.children)
            })
          ] : [_e];
        });
      }
      var we = RX.writer({
        prettyPrint: t.prettyPrint,
        outputFormat: t.outputFormat
      });
      return ht.write(we, ht.simplify(pe(re))), new q0.Result(we.asString(), Z);
    });
  }
  function f(G, Z, re) {
    return T1(G, function(V) {
      return h(V, Z, re);
    });
  }
  function h(G, Z, re) {
    if (!re)
      throw new Error("options not set");
    var V = Q[G.type];
    return V ? V(G, Z, re) : [];
  }
  function p(G, Z, re) {
    return y(G, Z).wrap(function() {
      var V = f(G.children, Z, re);
      return a ? V : [ht.forceWrite].concat(V);
    });
  }
  function y(G, Z) {
    var re = D(G);
    return re ? re.to : (G.styleId && Z.push(GE("paragraph", G)), s);
  }
  function b(G, Z, re) {
    var V = function() {
      return f(G.children, Z, re);
    }, P = [];
    if (G.highlight !== null) {
      var pe = v({ type: "highlight", color: G.highlight });
      pe && P.push(pe);
    }
    G.isSmallCaps && P.push(x("smallCaps")), G.isAllCaps && P.push(x("allCaps")), G.isStrikethrough && P.push(x("strikethrough", "s")), G.isUnderline && P.push(x("underline")), G.verticalAlignment === Wp.verticalAlignment.subscript && P.push(Vr.element("sub", {}, { fresh: !1 })), G.verticalAlignment === Wp.verticalAlignment.superscript && P.push(Vr.element("sup", {}, { fresh: !1 })), G.isItalic && P.push(x("italic", "em")), G.isBold && P.push(x("bold", "strong"));
    var we = Vr.empty, be = D(G);
    return be ? we = be.to : G.styleId && Z.push(GE("run", G)), P.push(we), P.forEach(function(_e) {
      V = _e.wrap.bind(_e, V);
    }), V();
  }
  function x(G, Z) {
    var re = v({ type: G });
    return re || (Z ? Vr.element(Z, {}, { fresh: !1 }) : Vr.empty);
  }
  function v(G, Z) {
    var re = D(G);
    return re ? re.to : Z;
  }
  function D(G) {
    for (var Z = 0; Z < l.length; Z++)
      if (l[Z].from.matches(G))
        return l[Z];
  }
  function S(G) {
    return function(Z, re) {
      return XE.attempt(function() {
        return G(Z, re);
      }).caught(function(V) {
        return re.push(q0.error(V)), [];
      });
    };
  }
  function E(G) {
    return R(G.noteType, G.noteId);
  }
  function I(G) {
    return O(G.noteType, G.noteId);
  }
  function R(G, Z) {
    return N(G + "-" + Z);
  }
  function O(G, Z) {
    return N(G + "-ref-" + Z);
  }
  function N(G) {
    return o + G;
  }
  var q = Vr.elements([
    Vr.element("table", {}, { fresh: !0 })
  ]);
  function $(G, Z, re) {
    return v(G, q).wrap(function() {
      return le(G, Z, re);
    });
  }
  function le(G, Z, re) {
    var V = Ma.findIndex(G.children, function(be) {
      return !be.type === Wp.types.tableRow || !be.isHeader;
    });
    V === -1 && (V = G.children.length);
    var P;
    if (V === 0)
      P = f(
        G.children,
        Z,
        Ma.extend({}, re, { isTableHeader: !1 })
      );
    else {
      var pe = f(
        G.children.slice(0, V),
        Z,
        Ma.extend({}, re, { isTableHeader: !0 })
      ), we = f(
        G.children.slice(V),
        Z,
        Ma.extend({}, re, { isTableHeader: !1 })
      );
      P = [
        ht.freshElement("thead", {}, pe),
        ht.freshElement("tbody", {}, we)
      ];
    }
    return [ht.forceWrite].concat(P);
  }
  function ve(G, Z, re) {
    var V = f(G.children, Z, re);
    return [
      ht.freshElement("tr", {}, [ht.forceWrite].concat(V))
    ];
  }
  function M(G, Z, re) {
    var V = re.isTableHeader ? "th" : "td", P = f(G.children, Z, re), pe = {};
    return G.colSpan !== 1 && (pe.colspan = G.colSpan.toString()), G.rowSpan !== 1 && (pe.rowspan = G.rowSpan.toString()), [
      ht.freshElement(V, pe, [ht.forceWrite].concat(P))
    ];
  }
  function ee(G, Z, re) {
    return v(G, Vr.ignore).wrap(function() {
      var V = e[G.commentId], P = i.length + 1, pe = "[" + NX(V) + P + "]";
      return i.push({ label: pe, comment: V }), [
        ht.freshElement("a", {
          href: "#" + R("comment", G.commentId),
          id: O("comment", G.commentId)
        }, [ht.text(pe)])
      ];
    });
  }
  function A(G, Z, re) {
    var V = G.label, P = G.comment, pe = f(P.body, Z, re).concat([
      ht.nonFreshElement("p", {}, [
        ht.text(" "),
        ht.freshElement("a", { href: "#" + O("comment", P.commentId) }, [
          ht.text("↑")
        ])
      ])
    ]);
    return [
      ht.freshElement(
        "dt",
        { id: R("comment", P.commentId) },
        [ht.text("Comment " + V)]
      ),
      ht.freshElement("dd", {}, pe)
    ];
  }
  function oe(G, Z, re) {
    return j(G).wrap(function() {
      return [];
    });
  }
  function j(G) {
    var Z = D(G);
    return Z ? Z.to : G.breakType === "line" ? Vr.topLevelElement("br") : Vr.empty;
  }
  var Q = {
    document: function(G, Z, re) {
      var V = f(G.children, Z, re), P = r.map(function(we) {
        return G.notes.resolve(we);
      }), pe = f(P, Z, re);
      return V.concat([
        ht.freshElement("ol", {}, pe),
        ht.freshElement("dl", {}, T1(i, function(we) {
          return A(we, Z, re);
        }))
      ]);
    },
    paragraph: p,
    run: b,
    text: function(G, Z, re) {
      return [ht.text(G.value)];
    },
    tab: function(G, Z, re) {
      return [ht.text("	")];
    },
    hyperlink: function(G, Z, re) {
      var V = G.anchor ? "#" + N(G.anchor) : G.href, P = { href: V };
      G.targetFrame != null && (P.target = G.targetFrame);
      var pe = f(G.children, Z, re);
      return [ht.nonFreshElement("a", P, pe)];
    },
    checkbox: function(G) {
      var Z = { type: "checkbox" };
      return G.checked && (Z.checked = "checked"), [ht.freshElement("input", Z)];
    },
    bookmarkStart: function(G, Z, re) {
      var V = ht.freshElement("a", {
        id: N(G.name)
      }, [ht.forceWrite]);
      return [V];
    },
    noteReference: function(G, Z, re) {
      r.push(G);
      var V = ht.freshElement("a", {
        href: "#" + E(G),
        id: I(G)
      }, [ht.text("[" + n++ + "]")]);
      return [ht.freshElement("sup", {}, [V])];
    },
    note: function(G, Z, re) {
      var V = f(G.body, Z, re), P = ht.elementWithTag(Vr.element("p", {}, { fresh: !1 }), [
        ht.text(" "),
        ht.freshElement("a", { href: "#" + I(G) }, [ht.text("↑")])
      ]), pe = V.concat([P]);
      return ht.freshElement("li", { id: E(G) }, pe);
    },
    commentReference: ee,
    comment: A,
    image: MX(S(t.convertImage || FX.dataUri)),
    table: $,
    tableRow: ve,
    tableCell: M,
    break: oe
  };
  return {
    convertToHtml: u
  };
}
var BX = 1;
function MX(t) {
  return function(e, n, r) {
    return [
      {
        type: "deferred",
        id: BX++,
        value: function() {
          return t(e, n, r);
        }
      }
    ];
  };
}
function GE(t, e) {
  return q0.warning(
    "Unrecognised " + t + " style: '" + e.styleName + "' (Style ID: " + e.styleId + ")"
  );
}
function T1(t, e) {
  return Ma.flatten(t.map(e), !0);
}
function n8(t, e) {
  t.forEach(function(n) {
    e(n), n.children && n8(n.children, e);
  });
}
var NX = lD.commentAuthorLabel = function(e) {
  return e.authorInitials || "";
}, r8 = {}, PX = ut;
function i8(t) {
  if (t.type === "text")
    return t.value;
  if (t.type === PX.types.tab)
    return "	";
  var e = t.type === "paragraph" ? `

` : "";
  return (t.children || []).map(i8).join("") + e;
}
r8.convertElementToRawText = i8;
var dy = {}, bi = {}, o8 = {}, a8 = { exports: {} }, bu = a8.exports = function(t, e) {
  this._tokens = t, this._startIndex = e || 0;
};
bu.prototype.head = function() {
  return this._tokens[this._startIndex];
};
bu.prototype.tail = function(t) {
  return new bu(this._tokens, this._startIndex + 1);
};
bu.prototype.toArray = function() {
  return this._tokens.slice(this._startIndex);
};
bu.prototype.end = function() {
  return this._tokens[this._tokens.length - 1];
};
bu.prototype.to = function(t) {
  var e = this.head().source, n = t.head() || t.end();
  return e.to(n.source);
};
var WX = a8.exports, LX = WX;
o8.Parser = function(t) {
  var e = function(n, r) {
    return n(new LX(r));
  };
  return {
    parseTokens: e
  };
};
var uD = {}, s8 = {};
(function(t) {
  t.none = /* @__PURE__ */ Object.create({
    value: function() {
      throw new Error("Called value on none");
    },
    isNone: function() {
      return !0;
    },
    isSome: function() {
      return !1;
    },
    map: function() {
      return t.none;
    },
    flatMap: function() {
      return t.none;
    },
    filter: function() {
      return t.none;
    },
    toArray: function() {
      return [];
    },
    orElse: e,
    valueOrElse: e
  });
  function e(r) {
    return typeof r == "function" ? r() : r;
  }
  t.some = function(r) {
    return new n(r);
  };
  var n = function(r) {
    this._value = r;
  };
  n.prototype.value = function() {
    return this._value;
  }, n.prototype.isNone = function() {
    return !1;
  }, n.prototype.isSome = function() {
    return !0;
  }, n.prototype.map = function(r) {
    return new n(r(this._value));
  }, n.prototype.flatMap = function(r) {
    return r(this._value);
  }, n.prototype.filter = function(r) {
    return r(this._value) ? this : t.none;
  }, n.prototype.toArray = function() {
    return [this._value];
  }, n.prototype.orElse = function(r) {
    return this;
  }, n.prototype.valueOrElse = function(r) {
    return this._value;
  }, t.isOption = function(r) {
    return r === t.none || r instanceof n;
  }, t.fromNullable = function(r) {
    return r == null ? t.none : new n(r);
  };
})(s8);
var fD = {
  failure: function(t, e) {
    if (t.length < 1)
      throw new Error("Failure must have errors");
    return new _n({
      status: "failure",
      remaining: e,
      errors: t
    });
  },
  error: function(t, e) {
    if (t.length < 1)
      throw new Error("Failure must have errors");
    return new _n({
      status: "error",
      remaining: e,
      errors: t
    });
  },
  success: function(t, e, n) {
    return new _n({
      status: "success",
      value: t,
      source: n,
      remaining: e,
      errors: []
    });
  },
  cut: function(t) {
    return new _n({
      status: "cut",
      remaining: t,
      errors: []
    });
  }
}, _n = function(t) {
  this._value = t.value, this._status = t.status, this._hasValue = t.value !== void 0, this._remaining = t.remaining, this._source = t.source, this._errors = t.errors;
};
_n.prototype.map = function(t) {
  return this._hasValue ? new _n({
    value: t(this._value, this._source),
    status: this._status,
    remaining: this._remaining,
    source: this._source,
    errors: this._errors
  }) : this;
};
_n.prototype.changeRemaining = function(t) {
  return new _n({
    value: this._value,
    status: this._status,
    remaining: t,
    source: this._source,
    errors: this._errors
  });
};
_n.prototype.isSuccess = function() {
  return this._status === "success" || this._status === "cut";
};
_n.prototype.isFailure = function() {
  return this._status === "failure";
};
_n.prototype.isError = function() {
  return this._status === "error";
};
_n.prototype.isCut = function() {
  return this._status === "cut";
};
_n.prototype.value = function() {
  return this._value;
};
_n.prototype.remaining = function() {
  return this._remaining;
};
_n.prototype.source = function() {
  return this._source;
};
_n.prototype.errors = function() {
  return this._errors;
};
var dD = {};
dD.error = function(t) {
  return new hy(t);
};
var hy = function(t) {
  this.expected = t.expected, this.actual = t.actual, this._location = t.location;
};
hy.prototype.describe = function() {
  var t = this._location ? this._location.describe() + `:
` : "";
  return t + "Expected " + this.expected + `
but got ` + this.actual;
};
hy.prototype.lineNumber = function() {
  return this._location.lineNumber();
};
hy.prototype.characterNumber = function() {
  return this._location.characterNumber();
};
var l8 = {};
l8.fromArray = function(t) {
  var e = 0, n = function() {
    return e < t.length;
  };
  return new yl({
    hasNext: n,
    next: function() {
      if (n())
        return t[e++];
      throw new Error("No more elements");
    }
  });
};
var yl = function(t) {
  this._iterator = t;
};
yl.prototype.map = function(t) {
  var e = this._iterator;
  return new yl({
    hasNext: function() {
      return e.hasNext();
    },
    next: function() {
      return t(e.next());
    }
  });
};
yl.prototype.filter = function(t) {
  var e = this._iterator, n = !1, r = !1, i, o = function() {
    if (!n)
      for (n = !0, r = !1; e.hasNext() && !r; )
        i = e.next(), r = t(i);
  };
  return new yl({
    hasNext: function() {
      return o(), r;
    },
    next: function() {
      o();
      var a = i;
      return n = !1, a;
    }
  });
};
yl.prototype.first = function() {
  var t = this._iterator;
  return this._iterator.hasNext() ? t.next() : null;
};
yl.prototype.toArray = function() {
  for (var t = []; this._iterator.hasNext(); )
    t.push(this._iterator.next());
  return t;
};
(function(t) {
  var e = $t, n = s8, r = fD, i = dD, o = l8;
  t.token = function(p, y) {
    var b = y !== void 0;
    return function(x) {
      var v = x.head();
      if (v && v.name === p && (!b || v.value === y))
        return r.success(v.value, x.tail(), v.source);
      var D = f({ name: p, value: y });
      return h(x, D);
    };
  }, t.tokenOfType = function(p) {
    return t.token(p);
  }, t.firstOf = function(p, y) {
    return e.isArray(y) || (y = Array.prototype.slice.call(arguments, 1)), function(b) {
      return o.fromArray(y).map(function(x) {
        return x(b);
      }).filter(function(x) {
        return x.isSuccess() || x.isError();
      }).first() || h(b, p);
    };
  }, t.then = function(p, y) {
    return function(b) {
      var x = p(b);
      return x.map || console.log(x), x.map(y);
    };
  }, t.sequence = function() {
    var p = Array.prototype.slice.call(arguments, 0), y = function(x) {
      var v = e.foldl(p, function(S, E) {
        var I = S.result, R = S.hasCut;
        if (!I.isSuccess())
          return { result: I, hasCut: R };
        var O = E(I.remaining());
        if (O.isCut())
          return { result: I, hasCut: !0 };
        if (O.isSuccess()) {
          var N;
          E.isCaptured ? N = I.value().withValue(E, O.value()) : N = I.value();
          var q = O.remaining(), $ = x.to(q);
          return {
            result: r.success(N, q, $),
            hasCut: R
          };
        } else return R ? { result: r.error(O.errors(), O.remaining()), hasCut: R } : { result: O, hasCut: R };
      }, { result: r.success(new a(), x), hasCut: !1 }).result, D = x.to(v.remaining());
      return v.map(function(S) {
        return S.withValue(t.sequence.source, D);
      });
    };
    y.head = function() {
      var x = e.find(p, b);
      return t.then(
        y,
        t.sequence.extract(x)
      );
    }, y.map = function(x) {
      return t.then(
        y,
        function(v) {
          return x.apply(this, v.toArray());
        }
      );
    };
    function b(x) {
      return x.isCaptured;
    }
    return y;
  };
  var a = function(p, y) {
    this._values = p || {}, this._valuesArray = y || [];
  };
  a.prototype.withValue = function(p, y) {
    if (p.captureName && p.captureName in this._values)
      throw new Error('Cannot add second value for capture "' + p.captureName + '"');
    var b = e.clone(this._values);
    b[p.captureName] = y;
    var x = this._valuesArray.concat([y]);
    return new a(b, x);
  }, a.prototype.get = function(p) {
    if (p.captureName in this._values)
      return this._values[p.captureName];
    throw new Error('No value for capture "' + p.captureName + '"');
  }, a.prototype.toArray = function() {
    return this._valuesArray;
  }, t.sequence.capture = function(p, y) {
    var b = function() {
      return p.apply(this, arguments);
    };
    return b.captureName = y, b.isCaptured = !0, b;
  }, t.sequence.extract = function(p) {
    return function(y) {
      return y.get(p);
    };
  }, t.sequence.applyValues = function(p) {
    var y = Array.prototype.slice.call(arguments, 1);
    return function(b) {
      var x = y.map(function(v) {
        return b.get(v);
      });
      return p.apply(this, x);
    };
  }, t.sequence.source = {
    captureName: "☃source☃"
  }, t.sequence.cut = function() {
    return function(p) {
      return r.cut(p);
    };
  }, t.optional = function(p) {
    return function(y) {
      var b = p(y);
      return b.isSuccess() ? b.map(n.some) : b.isFailure() ? r.success(n.none, y) : b;
    };
  }, t.zeroOrMoreWithSeparator = function(p, y) {
    return u(p, y, !1);
  }, t.oneOrMoreWithSeparator = function(p, y) {
    return u(p, y, !0);
  };
  var s = t.zeroOrMore = function(p) {
    return function(y) {
      for (var b = [], x; (x = p(y)) && x.isSuccess(); )
        y = x.remaining(), b.push(x.value());
      return x.isError() ? x : r.success(b, y);
    };
  };
  t.oneOrMore = function(p) {
    return t.oneOrMoreWithSeparator(p, l);
  };
  function l(p) {
    return r.success(null, p);
  }
  var u = function(p, y, b) {
    return function(x) {
      var v = p(x);
      if (v.isSuccess()) {
        var D = t.sequence.capture(p, "main"), S = s(t.then(
          t.sequence(y, D),
          t.sequence.extract(D)
        )), E = S(v.remaining());
        return r.success([v.value()].concat(E.value()), E.remaining());
      } else return b || v.isError() ? v : r.success([], x);
    };
  };
  t.leftAssociative = function(p, y, b) {
    var x;
    b ? x = [{ func: b, rule: y }] : x = y, x = x.map(function(D) {
      return t.then(D.rule, function(S) {
        return function(E, I) {
          return D.func(E, S, I);
        };
      });
    });
    var v = t.firstOf.apply(null, ["rules"].concat(x));
    return function(D) {
      var S = D, E = p(D);
      if (!E.isSuccess())
        return E;
      for (var I = v(E.remaining()); I.isSuccess(); ) {
        var R = I.remaining(), O = S.to(I.remaining()), N = I.value();
        E = r.success(
          N(E.value(), O),
          R,
          O
        ), I = v(E.remaining());
      }
      return I.isError() ? I : E;
    };
  }, t.leftAssociative.firstOf = function() {
    return Array.prototype.slice.call(arguments, 0);
  }, t.nonConsuming = function(p) {
    return function(y) {
      return p(y).changeRemaining(y);
    };
  };
  var f = function(p) {
    return p.value ? p.name + ' "' + p.value + '"' : p.name;
  };
  function h(p, y) {
    var b, x = p.head();
    return x ? b = i.error({
      expected: y,
      actual: f(x),
      location: x.source
    }) : b = i.error({
      expected: y,
      actual: "end of tokens"
    }), r.failure([b], p);
  }
})(uD);
var c8 = { exports: {} };
c8.exports = function(t, e) {
  var n = {
    asString: function() {
      return t;
    },
    range: function(r, i) {
      return new bl(t, e, r, i);
    }
  };
  return n;
};
var bl = function(t, e, n, r) {
  this._string = t, this._description = e, this._startIndex = n, this._endIndex = r;
};
bl.prototype.to = function(t) {
  return new bl(this._string, this._description, this._startIndex, t._endIndex);
};
bl.prototype.describe = function() {
  var t = this._position(), e = this._description ? this._description + `
` : "";
  return e + "Line number: " + t.lineNumber + `
Character number: ` + t.characterNumber;
};
bl.prototype.lineNumber = function() {
  return this._position().lineNumber;
};
bl.prototype.characterNumber = function() {
  return this._position().characterNumber;
};
bl.prototype._position = function() {
  for (var t = this, e = 0, n = function() {
    return t._string.indexOf(`
`, e);
  }, r = 1; n() !== -1 && n() < this._startIndex; )
    e = n() + 1, r += 1;
  var i = this._startIndex - e + 1;
  return { lineNumber: r, characterNumber: i };
};
var u8 = c8.exports, f8 = function(t, e, n) {
  this.name = t, this.value = e, n && (this.source = n);
}, d8 = {};
(function(t) {
  var e = uD, n = fD;
  t.parser = function(o, a, s) {
    var l = {
      rule: p,
      leftAssociative: y,
      rightAssociative: b
    }, u = new r(s.map(h)), f = e.firstOf(o, a);
    function h(D) {
      return {
        name: D.name,
        rule: i(D.ruleBuilder.bind(null, l))
      };
    }
    function p() {
      return x(u);
    }
    function y(D) {
      return x(u.untilExclusive(D));
    }
    function b(D) {
      return x(u.untilInclusive(D));
    }
    function x(D) {
      return v.bind(null, D);
    }
    function v(D, S) {
      var E = f(S);
      return E.isSuccess() ? D.apply(E) : E;
    }
    return l;
  };
  function r(o) {
    function a(h) {
      return new r(o.slice(0, l().indexOf(h)));
    }
    function s(h) {
      return new r(o.slice(0, l().indexOf(h) + 1));
    }
    function l() {
      return o.map(function(h) {
        return h.name;
      });
    }
    function u(h) {
      for (var p, y; ; )
        if (p = f(h.remaining()), p.isSuccess())
          y = h.source().to(p.source()), h = n.success(
            p.value()(h.value(), y),
            p.remaining(),
            y
          );
        else return p.isFailure() ? h : p;
    }
    function f(h) {
      return e.firstOf("infix", o.map(function(p) {
        return p.rule;
      }))(h);
    }
    return {
      apply: u,
      untilExclusive: a,
      untilInclusive: s
    };
  }
  t.infix = function(o, a) {
    function s(l) {
      return t.infix(o, function(u) {
        var f = a(u);
        return function(h) {
          var p = f(h);
          return p.map(function(y) {
            return function(b, x) {
              return l(b, y, x);
            };
          });
        };
      });
    }
    return {
      name: o,
      ruleBuilder: a,
      map: s
    };
  };
  var i = function(o) {
    var a;
    return function(s) {
      return a || (a = o()), a(s);
    };
  };
})(d8);
var h8 = {}, C1 = f8, zX = u8;
h8.RegexTokeniser = $X;
function $X(t) {
  t = t.map(function(i) {
    return {
      name: i.name,
      regex: new RegExp(i.regex.source, "g")
    };
  });
  function e(i, o) {
    for (var a = new zX(i, o), s = 0, l = []; s < i.length; ) {
      var u = n(i, s, a);
      s = u.endIndex, l.push(u.token);
    }
    return l.push(r(i, a)), l;
  }
  function n(i, o, a) {
    for (var s = 0; s < t.length; s++) {
      var l = t[s].regex;
      l.lastIndex = o;
      var u = l.exec(i);
      if (u) {
        var h = o + u[0].length;
        if (u.index === o && h > o) {
          var f = u[1], p = new C1(
            t[s].name,
            f,
            a.range(o, h)
          );
          return { token: p, endIndex: h };
        }
      }
    }
    var h = o + 1, p = new C1(
      "unrecognisedCharacter",
      i.substring(o, h),
      a.range(o, h)
    );
    return { token: p, endIndex: h };
  }
  function r(i, o) {
    return new C1(
      "end",
      null,
      o.range(i.length, i.length)
    );
  }
  return {
    tokenise: e
  };
}
bi.Parser = o8.Parser;
bi.rules = uD;
bi.errors = dD;
bi.results = fD;
bi.StringSource = u8;
bi.Token = f8;
bi.bottomUp = d8;
bi.RegexTokeniser = h8.RegexTokeniser;
bi.rule = function(t) {
  var e;
  return function(n) {
    return e || (e = t()), e(n);
  };
};
var xn = {};
xn.paragraph = jX;
xn.run = HX;
xn.table = VX;
xn.bold = new vi("bold");
xn.italic = new vi("italic");
xn.underline = new vi("underline");
xn.strikethrough = new vi("strikethrough");
xn.allCaps = new vi("allCaps");
xn.smallCaps = new vi("smallCaps");
xn.highlight = qX;
xn.commentReference = new vi("commentReference");
xn.lineBreak = new py({ breakType: "line" });
xn.pageBreak = new py({ breakType: "page" });
xn.columnBreak = new py({ breakType: "column" });
xn.equalTo = GX;
xn.startsWith = JX;
function jX(t) {
  return new vi("paragraph", t);
}
function HX(t) {
  return new vi("run", t);
}
function VX(t) {
  return new vi("table", t);
}
function qX(t) {
  return new p8(t);
}
function vi(t, e) {
  e = e || {}, this._elementType = t, this._styleId = e.styleId, this._styleName = e.styleName, e.list && (this._listIndex = e.list.levelIndex, this._listIsOrdered = e.list.isOrdered);
}
vi.prototype.matches = function(t) {
  return t.type === this._elementType && (this._styleId === void 0 || t.styleId === this._styleId) && (this._styleName === void 0 || t.styleName && this._styleName.operator(this._styleName.operand, t.styleName)) && (this._listIndex === void 0 || XX(t, this._listIndex, this._listIsOrdered)) && (this._breakType === void 0 || this._breakType === t.breakType);
};
function p8(t) {
  t = t || {}, this._color = t.color;
}
p8.prototype.matches = function(t) {
  return t.type === "highlight" && (this._color === void 0 || t.color === this._color);
};
function py(t) {
  t = t || {}, this._breakType = t.breakType;
}
py.prototype.matches = function(t) {
  return t.type === "break" && (this._breakType === void 0 || t.breakType === this._breakType);
};
function XX(t, e, n) {
  return t.numbering && t.numbering.level == e && t.numbering.isOrdered == n;
}
function GX(t) {
  return {
    operator: YX,
    operand: t
  };
}
function JX(t) {
  return {
    operator: ZX,
    operand: t
  };
}
function YX(t, e) {
  return t.toUpperCase() === e.toUpperCase();
}
function ZX(t, e) {
  return e.toUpperCase().indexOf(t.toUpperCase()) === 0;
}
var g8 = {}, KX = bi, QX = KX.RegexTokeniser;
g8.tokenise = eG;
var JE = "'((?:\\\\.|[^'])*)";
function eG(t) {
  var e = "(?:[a-zA-Z\\-_]|\\\\.)", n = new QX([
    { name: "identifier", regex: new RegExp("(" + e + "(?:" + e + "|[0-9])*)") },
    { name: "dot", regex: /\./ },
    { name: "colon", regex: /:/ },
    { name: "gt", regex: />/ },
    { name: "whitespace", regex: /\s+/ },
    { name: "arrow", regex: /=>/ },
    { name: "equals", regex: /=/ },
    { name: "startsWith", regex: /\^=/ },
    { name: "open-paren", regex: /\(/ },
    { name: "close-paren", regex: /\)/ },
    { name: "open-square-bracket", regex: /\[/ },
    { name: "close-square-bracket", regex: /\]/ },
    { name: "string", regex: new RegExp(JE + "'") },
    { name: "unterminated-string", regex: new RegExp(JE) },
    { name: "integer", regex: /([0-9]+)/ },
    { name: "choice", regex: /\|/ },
    { name: "bang", regex: /(!)/ }
  ]);
  return n.tokenise(t);
}
var tG = $t, Ae = bi, Tn = xn, Lp = fy(), nG = g8.tokenise, E1 = Ar;
dy.readHtmlPath = aG;
dy.readDocumentMatcher = oG;
dy.readStyle = rG;
function rG(t) {
  return hD(pG, t);
}
function iG() {
  return Ae.rules.sequence(
    Ae.rules.sequence.capture(m8()),
    Ae.rules.tokenOfType("whitespace"),
    Ae.rules.tokenOfType("arrow"),
    Ae.rules.sequence.capture(Ae.rules.optional(Ae.rules.sequence(
      Ae.rules.tokenOfType("whitespace"),
      Ae.rules.sequence.capture(y8())
    ).head())),
    Ae.rules.tokenOfType("end")
  ).map(function(t, e) {
    return {
      from: t,
      to: e.valueOrElse(Lp.empty)
    };
  });
}
function oG(t) {
  return hD(m8(), t);
}
function m8() {
  var t = Ae.rules.sequence, e = function(O, N) {
    return Ae.rules.then(
      Ae.rules.token("identifier", O),
      function() {
        return N;
      }
    );
  }, n = e("p", Tn.paragraph), r = e("r", Tn.run), i = Ae.rules.firstOf(
    "p or r or table",
    n,
    r
  ), o = Ae.rules.sequence(
    Ae.rules.tokenOfType("dot"),
    Ae.rules.sequence.cut(),
    Ae.rules.sequence.capture(gy)
  ).map(function(O) {
    return { styleId: O };
  }), a = Ae.rules.firstOf(
    "style name matcher",
    Ae.rules.then(
      Ae.rules.sequence(
        Ae.rules.tokenOfType("equals"),
        Ae.rules.sequence.cut(),
        Ae.rules.sequence.capture($c)
      ).head(),
      function(O) {
        return { styleName: Tn.equalTo(O) };
      }
    ),
    Ae.rules.then(
      Ae.rules.sequence(
        Ae.rules.tokenOfType("startsWith"),
        Ae.rules.sequence.cut(),
        Ae.rules.sequence.capture($c)
      ).head(),
      function(O) {
        return { styleName: Tn.startsWith(O) };
      }
    )
  ), s = Ae.rules.sequence(
    Ae.rules.tokenOfType("open-square-bracket"),
    Ae.rules.sequence.cut(),
    Ae.rules.token("identifier", "style-name"),
    Ae.rules.sequence.capture(a),
    Ae.rules.tokenOfType("close-square-bracket")
  ).head(), l = Ae.rules.firstOf(
    "list type",
    e("ordered-list", { isOrdered: !0 }),
    e("unordered-list", { isOrdered: !1 })
  ), u = t(
    Ae.rules.tokenOfType("colon"),
    t.capture(l),
    t.cut(),
    Ae.rules.tokenOfType("open-paren"),
    t.capture(sG),
    Ae.rules.tokenOfType("close-paren")
  ).map(function(O, N) {
    return {
      list: {
        isOrdered: O.isOrdered,
        levelIndex: N - 1
      }
    };
  });
  function f(O) {
    var N = Ae.rules.firstOf.apply(
      Ae.rules.firstOf,
      ["matcher suffix"].concat(O)
    ), q = Ae.rules.zeroOrMore(N);
    return Ae.rules.then(q, function($) {
      var le = {};
      return $.forEach(function(ve) {
        tG.extend(le, ve);
      }), le;
    });
  }
  var h = t(
    t.capture(i),
    t.capture(f([
      o,
      s,
      u
    ]))
  ).map(function(O, N) {
    return O(N);
  }), p = t(
    Ae.rules.token("identifier", "table"),
    t.capture(f([
      o,
      s
    ]))
  ).map(function(O) {
    return Tn.table(O);
  }), y = e("b", Tn.bold), b = e("i", Tn.italic), x = e("u", Tn.underline), v = e("strike", Tn.strikethrough), D = e("all-caps", Tn.allCaps), S = e("small-caps", Tn.smallCaps), E = t(
    Ae.rules.token("identifier", "highlight"),
    Ae.rules.sequence.capture(Ae.rules.optional(Ae.rules.sequence(
      Ae.rules.tokenOfType("open-square-bracket"),
      Ae.rules.sequence.cut(),
      Ae.rules.token("identifier", "color"),
      Ae.rules.tokenOfType("equals"),
      Ae.rules.sequence.capture($c),
      Ae.rules.tokenOfType("close-square-bracket")
    ).head()))
  ).map(function(O) {
    return Tn.highlight({
      color: O.valueOrElse(void 0)
    });
  }), I = e("comment-reference", Tn.commentReference), R = t(
    Ae.rules.token("identifier", "br"),
    t.cut(),
    Ae.rules.tokenOfType("open-square-bracket"),
    Ae.rules.token("identifier", "type"),
    Ae.rules.tokenOfType("equals"),
    t.capture($c),
    Ae.rules.tokenOfType("close-square-bracket")
  ).map(function(O) {
    switch (O) {
      case "line":
        return Tn.lineBreak;
      case "page":
        return Tn.pageBreak;
      case "column":
        return Tn.columnBreak;
    }
  });
  return Ae.rules.firstOf(
    "element type",
    h,
    p,
    y,
    b,
    x,
    v,
    D,
    S,
    E,
    I,
    R
  );
}
function aG(t) {
  return hD(y8(), t);
}
function y8() {
  var t = Ae.rules.sequence.capture, e = Ae.rules.tokenOfType("whitespace"), n = Ae.rules.then(
    Ae.rules.optional(Ae.rules.sequence(
      Ae.rules.tokenOfType("colon"),
      Ae.rules.token("identifier", "fresh")
    )),
    function(a) {
      return a.map(function() {
        return !0;
      }).valueOrElse(!1);
    }
  ), r = Ae.rules.then(
    Ae.rules.optional(Ae.rules.sequence(
      Ae.rules.tokenOfType("colon"),
      Ae.rules.token("identifier", "separator"),
      Ae.rules.tokenOfType("open-paren"),
      t($c),
      Ae.rules.tokenOfType("close-paren")
    ).head()),
    function(a) {
      return a.valueOrElse("");
    }
  ), i = Ae.rules.oneOrMoreWithSeparator(
    gy,
    Ae.rules.tokenOfType("choice")
  ), o = Ae.rules.sequence(
    t(i),
    t(Ae.rules.zeroOrMore(fG)),
    t(n),
    t(r)
  ).map(function(a, s, l, u) {
    var f = {}, h = {};
    return s.forEach(function(p) {
      p.append && f[p.name] ? f[p.name] += " " + p.value : f[p.name] = p.value;
    }), l && (h.fresh = !0), u && (h.separator = u), Lp.element(a, f, h);
  });
  return Ae.rules.firstOf(
    "html path",
    Ae.rules.then(Ae.rules.tokenOfType("bang"), function() {
      return Lp.ignore;
    }),
    Ae.rules.then(
      Ae.rules.zeroOrMoreWithSeparator(
        o,
        Ae.rules.sequence(
          e,
          Ae.rules.tokenOfType("gt"),
          e
        )
      ),
      Lp.elements
    )
  );
}
var gy = Ae.rules.then(
  Ae.rules.tokenOfType("identifier"),
  b8
), sG = Ae.rules.tokenOfType("integer"), $c = Ae.rules.then(
  Ae.rules.tokenOfType("string"),
  b8
), lG = {
  n: `
`,
  r: "\r",
  t: "	"
};
function b8(t) {
  return t.replace(/\\(.)/g, function(e, n) {
    return lG[n] || n;
  });
}
var cG = Ae.rules.sequence(
  Ae.rules.tokenOfType("open-square-bracket"),
  Ae.rules.sequence.cut(),
  Ae.rules.sequence.capture(gy),
  Ae.rules.tokenOfType("equals"),
  Ae.rules.sequence.capture($c),
  Ae.rules.tokenOfType("close-square-bracket")
).map(function(t, e) {
  return { name: t, value: e, append: !1 };
}), uG = Ae.rules.sequence(
  Ae.rules.tokenOfType("dot"),
  Ae.rules.sequence.cut(),
  Ae.rules.sequence.capture(gy)
).map(function(t) {
  return { name: "class", value: t, append: !0 };
}), fG = Ae.rules.firstOf(
  "attribute or class",
  cG,
  uG
);
function hD(t, e) {
  var n = nG(e), r = Ae.Parser(), i = r.parseTokens(t, n);
  return i.isSuccess() ? E1.success(i.value()) : new E1.Result(null, [E1.warning(dG(e, i))]);
}
function dG(t, e) {
  return "Did not understand this style mapping, so ignored it: " + t + `
` + e.errors().map(hG).join(`
`);
}
function hG(t) {
  return "Error was at character number " + t.characterNumber() + ": Expected " + t.expected + " but got " + t.actual;
}
var pG = iG(), my = {};
my.readOptions = yG;
var v8 = $t, gG = my._defaultStyleMap = [
  "p.Heading1 => h1:fresh",
  "p.Heading2 => h2:fresh",
  "p.Heading3 => h3:fresh",
  "p.Heading4 => h4:fresh",
  "p.Heading5 => h5:fresh",
  "p.Heading6 => h6:fresh",
  "p[style-name='Heading 1'] => h1:fresh",
  "p[style-name='Heading 2'] => h2:fresh",
  "p[style-name='Heading 3'] => h3:fresh",
  "p[style-name='Heading 4'] => h4:fresh",
  "p[style-name='Heading 5'] => h5:fresh",
  "p[style-name='Heading 6'] => h6:fresh",
  "p[style-name='heading 1'] => h1:fresh",
  "p[style-name='heading 2'] => h2:fresh",
  "p[style-name='heading 3'] => h3:fresh",
  "p[style-name='heading 4'] => h4:fresh",
  "p[style-name='heading 5'] => h5:fresh",
  "p[style-name='heading 6'] => h6:fresh",
  "r[style-name='Strong'] => strong",
  "p[style-name='footnote text'] => p:fresh",
  "r[style-name='footnote reference'] =>",
  "p[style-name='endnote text'] => p:fresh",
  "r[style-name='endnote reference'] =>",
  "p[style-name='annotation text'] => p:fresh",
  "r[style-name='annotation reference'] =>",
  // LibreOffice
  "p[style-name='Footnote'] => p:fresh",
  "r[style-name='Footnote anchor'] =>",
  "p[style-name='Endnote'] => p:fresh",
  "r[style-name='Endnote anchor'] =>",
  "p:unordered-list(1) => ul > li:fresh",
  "p:unordered-list(2) => ul|ol > li > ul > li:fresh",
  "p:unordered-list(3) => ul|ol > li > ul|ol > li > ul > li:fresh",
  "p:unordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
  "p:unordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
  "p:ordered-list(1) => ol > li:fresh",
  "p:ordered-list(2) => ul|ol > li > ol > li:fresh",
  "p:ordered-list(3) => ul|ol > li > ul|ol > li > ol > li:fresh",
  "p:ordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
  "p:ordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
  "r[style-name='Hyperlink'] =>",
  "p[style-name='Normal'] => p:fresh"
], mG = my._standardOptions = {
  transformDocument: bG,
  includeDefaultStyleMap: !0,
  includeEmbeddedStyleMap: !0
};
function yG(t) {
  return t = t || {}, v8.extend({}, mG, t, {
    customStyleMap: YE(t.styleMap),
    readStyleMap: function() {
      var e = this.customStyleMap;
      return this.includeEmbeddedStyleMap && (e = e.concat(YE(this.embeddedStyleMap))), this.includeDefaultStyleMap && (e = e.concat(gG)), e;
    }
  });
}
function YE(t) {
  return t ? v8.isString(t) ? t.split(`
`).map(function(e) {
    return e.trim();
  }).filter(function(e) {
    return e !== "" && e.charAt(0) !== "#";
  }) : t : [];
}
function bG(t) {
  return t;
}
var x8 = {}, ZE = rn, vG = Zd;
x8.openZip = xG;
function xG(t) {
  return t.arrayBuffer ? ZE.resolve(vG.openArrayBuffer(t.arrayBuffer)) : ZE.reject(new Error("Could not find file in options"));
}
var Iu = {}, KE = $t;
Iu.paragraph = DG;
Iu.run = wG;
Iu._elements = w8;
Iu.getDescendantsOfType = SG;
Iu.getDescendants = S8;
function DG(t) {
  return D8("paragraph", t);
}
function wG(t) {
  return D8("run", t);
}
function D8(t, e) {
  return w8(function(n) {
    return n.type === t ? e(n) : n;
  });
}
function w8(t) {
  return function e(n) {
    if (n.children) {
      var r = KE.map(n.children, e);
      n = KE.extend(n, { children: r });
    }
    return t(n);
  };
}
function SG(t, e) {
  return S8(t).filter(function(n) {
    return n.type === e;
  });
}
function S8(t) {
  var e = [];
  return T8(t, function(n) {
    e.push(n);
  }), e;
}
function T8(t, e) {
  t.children && t.children.forEach(function(n) {
    T8(n, e), e(n);
  });
}
var C8 = {}, TG = fy(), CG = uy();
C8.element = EG;
function EG(t) {
  return function(e) {
    return CG.elementWithTag(TG.element(t), [e]);
  };
}
var _G = $t, E8 = Mx, pD = sD, kG = lD.DocumentConverter, AG = r8.convertElementToRawText, UG = dy.readStyle, FG = my.readOptions, yy = x8, RG = Ar.Result;
ro.convertToHtml = OG;
ro.convertToMarkdown = IG;
ro.convert = gD;
ro.extractRawText = PG;
ro.images = cD;
ro.transforms = Iu;
ro.underline = C8;
ro.embedStyleMap = WG;
ro.readEmbeddedStyleMap = BG;
function OG(t, e) {
  return gD(t, e);
}
function IG(t, e) {
  var n = Object.create(e || {});
  return n.outputFormat = "markdown", gD(t, n);
}
function gD(t, e) {
  return e = FG(e), yy.openZip(t).tap(function(n) {
    return pD.readStyleMap(n).then(function(r) {
      e.embeddedStyleMap = r;
    });
  }).then(function(n) {
    return E8.read(n, t).then(function(r) {
      return r.map(e.transformDocument);
    }).then(function(r) {
      return MG(r, e);
    });
  });
}
function BG(t) {
  return yy.openZip(t).then(pD.readStyleMap);
}
function MG(t, e) {
  var n = NG(e.readStyleMap()), r = _G.extend({}, e, {
    styleMap: n.value
  }), i = new kG(r);
  return t.flatMapThen(function(o) {
    return n.flatMapThen(function(a) {
      return i.convertToHtml(o);
    });
  });
}
function NG(t) {
  return RG.combine((t || []).map(UG)).map(function(e) {
    return e.filter(function(n) {
      return !!n;
    });
  });
}
function PG(t) {
  return yy.openZip(t).then(E8.read).then(function(e) {
    return e.map(AG);
  });
}
function WG(t, e) {
  return yy.openZip(t).tap(function(n) {
    return pD.writeStyleMap(n, e);
  }).then(function(n) {
    return n.toArrayBuffer();
  }).then(function(n) {
    return {
      toArrayBuffer: function() {
        return n;
      },
      toBuffer: function() {
        return Buffer.from(n);
      }
    };
  });
}
ro.styleMapping = function() {
  throw new Error(`Use a raw string instead of mammoth.styleMapping e.g. "p[style-name='Title'] => h1" instead of mammoth.styleMapping("p[style-name='Title'] => h1")`);
};
var Bu = {}, Gs = {};
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QE;
function LG() {
  if (QE) return Gs;
  QE = 1;
  var t = um;
  function e(T) {
    for (var F = "https://reactjs.org/docs/error-decoder.html?invariant=" + T, z = 1; z < arguments.length; z++) F += "&args[]=" + encodeURIComponent(arguments[z]);
    return "Minified React error #" + T + "; visit " + F + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = Object.prototype.hasOwnProperty, r = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, i = {}, o = {};
  function a(T) {
    return n.call(o, T) ? !0 : n.call(i, T) ? !1 : r.test(T) ? o[T] = !0 : (i[T] = !0, !1);
  }
  function s(T, F, z, J, me, fe, De) {
    this.acceptsBooleans = F === 2 || F === 3 || F === 4, this.attributeName = J, this.attributeNamespace = me, this.mustUseProperty = z, this.propertyName = T, this.type = F, this.sanitizeURL = fe, this.removeEmptyString = De;
  }
  var l = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(T) {
    l[T] = new s(T, 0, !1, T, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(T) {
    var F = T[0];
    l[F] = new s(F, 1, !1, T[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(T) {
    l[T] = new s(T, 2, !1, T.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(T) {
    l[T] = new s(T, 2, !1, T, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(T) {
    l[T] = new s(T, 3, !1, T.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(T) {
    l[T] = new s(T, 3, !0, T, null, !1, !1);
  }), ["capture", "download"].forEach(function(T) {
    l[T] = new s(T, 4, !1, T, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(T) {
    l[T] = new s(T, 6, !1, T, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(T) {
    l[T] = new s(T, 5, !1, T.toLowerCase(), null, !1, !1);
  });
  var u = /[\-:]([a-z])/g;
  function f(T) {
    return T[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(T) {
    var F = T.replace(
      u,
      f
    );
    l[F] = new s(F, 1, !1, T, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(T) {
    var F = T.replace(u, f);
    l[F] = new s(F, 1, !1, T, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(T) {
    var F = T.replace(u, f);
    l[F] = new s(F, 1, !1, T, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(T) {
    l[T] = new s(T, 1, !1, T.toLowerCase(), null, !1, !1);
  }), l.xlinkHref = new s("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(T) {
    l[T] = new s(T, 1, !1, T.toLowerCase(), null, !0, !0);
  });
  var h = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, p = ["Webkit", "ms", "Moz", "O"];
  Object.keys(h).forEach(function(T) {
    p.forEach(function(F) {
      F = F + T.charAt(0).toUpperCase() + T.substring(1), h[F] = h[T];
    });
  });
  var y = /["'&<>]/;
  function b(T) {
    if (typeof T == "boolean" || typeof T == "number") return "" + T;
    T = "" + T;
    var F = y.exec(T);
    if (F) {
      var z = "", J, me = 0;
      for (J = F.index; J < T.length; J++) {
        switch (T.charCodeAt(J)) {
          case 34:
            F = "&quot;";
            break;
          case 38:
            F = "&amp;";
            break;
          case 39:
            F = "&#x27;";
            break;
          case 60:
            F = "&lt;";
            break;
          case 62:
            F = "&gt;";
            break;
          default:
            continue;
        }
        me !== J && (z += T.substring(me, J)), me = J + 1, z += F;
      }
      T = me !== J ? z + T.substring(me, J) : z;
    }
    return T;
  }
  var x = /([A-Z])/g, v = /^ms-/, D = Array.isArray;
  function S(T, F) {
    return { insertionMode: T, selectedValue: F };
  }
  function E(T, F, z) {
    switch (F) {
      case "select":
        return S(1, z.value != null ? z.value : z.defaultValue);
      case "svg":
        return S(2, null);
      case "math":
        return S(3, null);
      case "foreignObject":
        return S(1, null);
      case "table":
        return S(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return S(5, null);
      case "colgroup":
        return S(7, null);
      case "tr":
        return S(6, null);
    }
    return 4 <= T.insertionMode || T.insertionMode === 0 ? S(1, null) : T;
  }
  var I = /* @__PURE__ */ new Map();
  function R(T, F, z) {
    if (typeof z != "object") throw Error(e(62));
    F = !0;
    for (var J in z) if (n.call(z, J)) {
      var me = z[J];
      if (me != null && typeof me != "boolean" && me !== "") {
        if (J.indexOf("--") === 0) {
          var fe = b(J);
          me = b(("" + me).trim());
        } else {
          fe = J;
          var De = I.get(fe);
          De !== void 0 || (De = b(fe.replace(x, "-$1").toLowerCase().replace(v, "-ms-")), I.set(fe, De)), fe = De, me = typeof me == "number" ? me === 0 || n.call(h, J) ? "" + me : me + "px" : b(("" + me).trim());
        }
        F ? (F = !1, T.push(' style="', fe, ":", me)) : T.push(";", fe, ":", me);
      }
    }
    F || T.push('"');
  }
  function O(T, F, z, J) {
    switch (z) {
      case "style":
        R(T, F, J);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < z.length) || z[0] !== "o" && z[0] !== "O" || z[1] !== "n" && z[1] !== "N") {
      if (F = l.hasOwnProperty(z) ? l[z] : null, F !== null) {
        switch (typeof J) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!F.acceptsBooleans) return;
        }
        switch (z = F.attributeName, F.type) {
          case 3:
            J && T.push(" ", z, '=""');
            break;
          case 4:
            J === !0 ? T.push(" ", z, '=""') : J !== !1 && T.push(" ", z, '="', b(J), '"');
            break;
          case 5:
            isNaN(J) || T.push(" ", z, '="', b(J), '"');
            break;
          case 6:
            !isNaN(J) && 1 <= J && T.push(" ", z, '="', b(J), '"');
            break;
          default:
            F.sanitizeURL && (J = "" + J), T.push(" ", z, '="', b(J), '"');
        }
      } else if (a(z)) {
        switch (typeof J) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (F = z.toLowerCase().slice(0, 5), F !== "data-" && F !== "aria-") return;
        }
        T.push(" ", z, '="', b(J), '"');
      }
    }
  }
  function N(T, F, z) {
    if (F != null) {
      if (z != null) throw Error(e(60));
      if (typeof F != "object" || !("__html" in F)) throw Error(e(61));
      F = F.__html, F != null && T.push("" + F);
    }
  }
  function q(T) {
    var F = "";
    return t.Children.forEach(T, function(z) {
      z != null && (F += z);
    }), F;
  }
  function $(T, F, z, J) {
    T.push(M(z));
    var me = z = null, fe;
    for (fe in F) if (n.call(F, fe)) {
      var De = F[fe];
      if (De != null) switch (fe) {
        case "children":
          z = De;
          break;
        case "dangerouslySetInnerHTML":
          me = De;
          break;
        default:
          O(T, J, fe, De);
      }
    }
    return T.push(">"), N(T, me, z), typeof z == "string" ? (T.push(b(z)), null) : z;
  }
  var le = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, ve = /* @__PURE__ */ new Map();
  function M(T) {
    var F = ve.get(T);
    if (F === void 0) {
      if (!le.test(T)) throw Error(e(65, T));
      F = "<" + T, ve.set(T, F);
    }
    return F;
  }
  function ee(T, F, z, J, me) {
    switch (F) {
      case "select":
        T.push(M("select"));
        var fe = null, De = null;
        for (Ve in z) if (n.call(z, Ve)) {
          var Oe = z[Ve];
          if (Oe != null) switch (Ve) {
            case "children":
              fe = Oe;
              break;
            case "dangerouslySetInnerHTML":
              De = Oe;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              O(T, J, Ve, Oe);
          }
        }
        return T.push(">"), N(T, De, fe), fe;
      case "option":
        De = me.selectedValue, T.push(M("option"));
        var je = Oe = null, qe = null, Ve = null;
        for (fe in z) if (n.call(z, fe)) {
          var ft = z[fe];
          if (ft != null) switch (fe) {
            case "children":
              Oe = ft;
              break;
            case "selected":
              qe = ft;
              break;
            case "dangerouslySetInnerHTML":
              Ve = ft;
              break;
            case "value":
              je = ft;
            default:
              O(T, J, fe, ft);
          }
        }
        if (De != null) if (z = je !== null ? "" + je : q(Oe), D(De)) {
          for (J = 0; J < De.length; J++)
            if ("" + De[J] === z) {
              T.push(' selected=""');
              break;
            }
        } else "" + De === z && T.push(' selected=""');
        else qe && T.push(' selected=""');
        return T.push(">"), N(T, Ve, Oe), Oe;
      case "textarea":
        T.push(M("textarea")), Ve = De = fe = null;
        for (Oe in z) if (n.call(z, Oe) && (je = z[Oe], je != null)) switch (Oe) {
          case "children":
            Ve = je;
            break;
          case "value":
            fe = je;
            break;
          case "defaultValue":
            De = je;
            break;
          case "dangerouslySetInnerHTML":
            throw Error(e(91));
          default:
            O(
              T,
              J,
              Oe,
              je
            );
        }
        if (fe === null && De !== null && (fe = De), T.push(">"), Ve != null) {
          if (fe != null) throw Error(e(92));
          if (D(Ve) && 1 < Ve.length) throw Error(e(93));
          fe = "" + Ve;
        }
        return typeof fe == "string" && fe[0] === `
` && T.push(`
`), fe !== null && T.push(b("" + fe)), null;
      case "input":
        T.push(M("input")), je = Ve = Oe = fe = null;
        for (De in z) if (n.call(z, De) && (qe = z[De], qe != null)) switch (De) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(e(399, "input"));
          case "defaultChecked":
            je = qe;
            break;
          case "defaultValue":
            Oe = qe;
            break;
          case "checked":
            Ve = qe;
            break;
          case "value":
            fe = qe;
            break;
          default:
            O(T, J, De, qe);
        }
        return Ve !== null ? O(T, J, "checked", Ve) : je !== null && O(T, J, "checked", je), fe !== null ? O(T, J, "value", fe) : Oe !== null && O(T, J, "value", Oe), T.push("/>"), null;
      case "menuitem":
        T.push(M("menuitem"));
        for (var Jt in z) if (n.call(z, Jt) && (fe = z[Jt], fe != null)) switch (Jt) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(e(400));
          default:
            O(T, J, Jt, fe);
        }
        return T.push(">"), null;
      case "title":
        T.push(M("title")), fe = null;
        for (ft in z) if (n.call(z, ft) && (De = z[ft], De != null)) switch (ft) {
          case "children":
            fe = De;
            break;
          case "dangerouslySetInnerHTML":
            throw Error(e(434));
          default:
            O(T, J, ft, De);
        }
        return T.push(">"), fe;
      case "listing":
      case "pre":
        T.push(M(F)), De = fe = null;
        for (je in z) if (n.call(z, je) && (Oe = z[je], Oe != null)) switch (je) {
          case "children":
            fe = Oe;
            break;
          case "dangerouslySetInnerHTML":
            De = Oe;
            break;
          default:
            O(T, J, je, Oe);
        }
        if (T.push(">"), De != null) {
          if (fe != null) throw Error(e(60));
          if (typeof De != "object" || !("__html" in De)) throw Error(e(61));
          z = De.__html, z != null && (typeof z == "string" && 0 < z.length && z[0] === `
` ? T.push(`
`, z) : T.push("" + z));
        }
        return typeof fe == "string" && fe[0] === `
` && T.push(`
`), fe;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        T.push(M(F));
        for (var Yt in z) if (n.call(z, Yt) && (fe = z[Yt], fe != null)) switch (Yt) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(e(399, F));
          default:
            O(T, J, Yt, fe);
        }
        return T.push("/>"), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return $(
          T,
          z,
          F,
          J
        );
      case "html":
        return me.insertionMode === 0 && T.push("<!DOCTYPE html>"), $(T, z, F, J);
      default:
        if (F.indexOf("-") === -1 && typeof z.is != "string") return $(T, z, F, J);
        T.push(M(F)), De = fe = null;
        for (qe in z) if (n.call(z, qe) && (Oe = z[qe], Oe != null)) switch (qe) {
          case "children":
            fe = Oe;
            break;
          case "dangerouslySetInnerHTML":
            De = Oe;
            break;
          case "style":
            R(T, J, Oe);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            break;
          default:
            a(qe) && typeof Oe != "function" && typeof Oe != "symbol" && T.push(" ", qe, '="', b(Oe), '"');
        }
        return T.push(">"), N(T, De, fe), fe;
    }
  }
  function A(T, F, z) {
    if (T.push('<!--$?--><template id="'), z === null) throw Error(e(395));
    return T.push(z), T.push('"></template>');
  }
  function oe(T, F, z, J) {
    switch (z.insertionMode) {
      case 0:
      case 1:
        return T.push('<div hidden id="'), T.push(F.segmentPrefix), F = J.toString(16), T.push(F), T.push('">');
      case 2:
        return T.push('<svg aria-hidden="true" style="display:none" id="'), T.push(F.segmentPrefix), F = J.toString(16), T.push(F), T.push('">');
      case 3:
        return T.push('<math aria-hidden="true" style="display:none" id="'), T.push(F.segmentPrefix), F = J.toString(16), T.push(F), T.push('">');
      case 4:
        return T.push('<table hidden id="'), T.push(F.segmentPrefix), F = J.toString(16), T.push(F), T.push('">');
      case 5:
        return T.push('<table hidden><tbody id="'), T.push(F.segmentPrefix), F = J.toString(16), T.push(F), T.push('">');
      case 6:
        return T.push('<table hidden><tr id="'), T.push(F.segmentPrefix), F = J.toString(16), T.push(F), T.push('">');
      case 7:
        return T.push('<table hidden><colgroup id="'), T.push(F.segmentPrefix), F = J.toString(16), T.push(F), T.push('">');
      default:
        throw Error(e(397));
    }
  }
  function j(T, F) {
    switch (F.insertionMode) {
      case 0:
      case 1:
        return T.push("</div>");
      case 2:
        return T.push("</svg>");
      case 3:
        return T.push("</math>");
      case 4:
        return T.push("</table>");
      case 5:
        return T.push("</tbody></table>");
      case 6:
        return T.push("</tr></table>");
      case 7:
        return T.push("</colgroup></table>");
      default:
        throw Error(e(397));
    }
  }
  var Q = /[<\u2028\u2029]/g;
  function G(T) {
    return JSON.stringify(T).replace(Q, function(F) {
      switch (F) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  function Z(T, F) {
    return F = F === void 0 ? "" : F, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: F + "P:", segmentPrefix: F + "S:", boundaryPrefix: F + "B:", idPrefix: F, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: T };
  }
  function re(T, F, z, J) {
    return z.generateStaticMarkup ? (T.push(b(F)), !1) : (F === "" ? T = J : (J && T.push("<!-- -->"), T.push(b(F)), T = !0), T);
  }
  var V = Object.assign, P = Symbol.for("react.element"), pe = Symbol.for("react.portal"), we = Symbol.for("react.fragment"), be = Symbol.for("react.strict_mode"), _e = Symbol.for("react.profiler"), $e = Symbol.for("react.provider"), Le = Symbol.for("react.context"), ze = Symbol.for("react.forward_ref"), tt = Symbol.for("react.suspense"), ie = Symbol.for("react.suspense_list"), Ee = Symbol.for("react.memo"), Re = Symbol.for("react.lazy"), k = Symbol.for("react.scope"), ge = Symbol.for("react.debug_trace_mode"), ue = Symbol.for("react.legacy_hidden"), Y = Symbol.for("react.default_value"), H = Symbol.iterator;
  function ae(T) {
    if (T == null) return null;
    if (typeof T == "function") return T.displayName || T.name || null;
    if (typeof T == "string") return T;
    switch (T) {
      case we:
        return "Fragment";
      case pe:
        return "Portal";
      case _e:
        return "Profiler";
      case be:
        return "StrictMode";
      case tt:
        return "Suspense";
      case ie:
        return "SuspenseList";
    }
    if (typeof T == "object") switch (T.$$typeof) {
      case Le:
        return (T.displayName || "Context") + ".Consumer";
      case $e:
        return (T._context.displayName || "Context") + ".Provider";
      case ze:
        var F = T.render;
        return T = T.displayName, T || (T = F.displayName || F.name || "", T = T !== "" ? "ForwardRef(" + T + ")" : "ForwardRef"), T;
      case Ee:
        return F = T.displayName || null, F !== null ? F : ae(T.type) || "Memo";
      case Re:
        F = T._payload, T = T._init;
        try {
          return ae(T(F));
        } catch {
        }
    }
    return null;
  }
  var Se = {};
  function ke(T, F) {
    if (T = T.contextTypes, !T) return Se;
    var z = {}, J;
    for (J in T) z[J] = F[J];
    return z;
  }
  var se = null;
  function K(T, F) {
    if (T !== F) {
      T.context._currentValue2 = T.parentValue, T = T.parent;
      var z = F.parent;
      if (T === null) {
        if (z !== null) throw Error(e(401));
      } else {
        if (z === null) throw Error(e(401));
        K(T, z);
      }
      F.context._currentValue2 = F.value;
    }
  }
  function ne(T) {
    T.context._currentValue2 = T.parentValue, T = T.parent, T !== null && ne(T);
  }
  function ce(T) {
    var F = T.parent;
    F !== null && ce(F), T.context._currentValue2 = T.value;
  }
  function xe(T, F) {
    if (T.context._currentValue2 = T.parentValue, T = T.parent, T === null) throw Error(e(402));
    T.depth === F.depth ? K(T, F) : xe(T, F);
  }
  function Be(T, F) {
    var z = F.parent;
    if (z === null) throw Error(e(402));
    T.depth === z.depth ? K(T, z) : Be(T, z), F.context._currentValue2 = F.value;
  }
  function Me(T) {
    var F = se;
    F !== T && (F === null ? ce(T) : T === null ? ne(F) : F.depth === T.depth ? K(F, T) : F.depth > T.depth ? xe(F, T) : Be(F, T), se = T);
  }
  var Je = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(T, F) {
    T = T._reactInternals, T.queue !== null && T.queue.push(F);
  }, enqueueReplaceState: function(T, F) {
    T = T._reactInternals, T.replace = !0, T.queue = [F];
  }, enqueueForceUpdate: function() {
  } };
  function He(T, F, z, J) {
    var me = T.state !== void 0 ? T.state : null;
    T.updater = Je, T.props = z, T.state = me;
    var fe = { queue: [], replace: !1 };
    T._reactInternals = fe;
    var De = F.contextType;
    if (T.context = typeof De == "object" && De !== null ? De._currentValue2 : J, De = F.getDerivedStateFromProps, typeof De == "function" && (De = De(z, me), me = De == null ? me : V({}, me, De), T.state = me), typeof F.getDerivedStateFromProps != "function" && typeof T.getSnapshotBeforeUpdate != "function" && (typeof T.UNSAFE_componentWillMount == "function" || typeof T.componentWillMount == "function")) if (F = T.state, typeof T.componentWillMount == "function" && T.componentWillMount(), typeof T.UNSAFE_componentWillMount == "function" && T.UNSAFE_componentWillMount(), F !== T.state && Je.enqueueReplaceState(T, T.state, null), fe.queue !== null && 0 < fe.queue.length) if (F = fe.queue, De = fe.replace, fe.queue = null, fe.replace = !1, De && F.length === 1) T.state = F[0];
    else {
      for (fe = De ? F[0] : T.state, me = !0, De = De ? 1 : 0; De < F.length; De++) {
        var Oe = F[De];
        Oe = typeof Oe == "function" ? Oe.call(T, fe, z, J) : Oe, Oe != null && (me ? (me = !1, fe = V({}, fe, Oe)) : V(fe, Oe));
      }
      T.state = fe;
    }
    else fe.queue = null;
  }
  var Ke = { id: 1, overflow: "" };
  function lt(T, F, z) {
    var J = T.id;
    T = T.overflow;
    var me = 32 - nt(J) - 1;
    J &= ~(1 << me), z += 1;
    var fe = 32 - nt(F) + me;
    if (30 < fe) {
      var De = me - me % 5;
      return fe = (J & (1 << De) - 1).toString(32), J >>= De, me -= De, { id: 1 << 32 - nt(F) + me | z << me | J, overflow: fe + T };
    }
    return { id: 1 << fe | z << me | J, overflow: T };
  }
  var nt = Math.clz32 ? Math.clz32 : At, Bt = Math.log, Bn = Math.LN2;
  function At(T) {
    return T >>>= 0, T === 0 ? 32 : 31 - (Bt(T) / Bn | 0) | 0;
  }
  function Ur(T, F) {
    return T === F && (T !== 0 || 1 / T === 1 / F) || T !== T && F !== F;
  }
  var xi = typeof Object.is == "function" ? Object.is : Ur, jt = null, Dn = null, Mn = null, at = null, on = !1, Di = !1, Qr = 0, Zn = null, wi = 0;
  function br() {
    if (jt === null) throw Error(e(321));
    return jt;
  }
  function Mt() {
    if (0 < wi) throw Error(e(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function oo() {
    return at === null ? Mn === null ? (on = !1, Mn = at = Mt()) : (on = !0, at = Mn) : at.next === null ? (on = !1, at = at.next = Mt()) : (on = !0, at = at.next), at;
  }
  function ao() {
    Dn = jt = null, Di = !1, Mn = null, wi = 0, at = Zn = null;
  }
  function Zo(T, F) {
    return typeof F == "function" ? F(T) : F;
  }
  function Ut(T, F, z) {
    if (jt = br(), at = oo(), on) {
      var J = at.queue;
      if (F = J.dispatch, Zn !== null && (z = Zn.get(J), z !== void 0)) {
        Zn.delete(J), J = at.memoizedState;
        do
          J = T(J, z.action), z = z.next;
        while (z !== null);
        return at.memoizedState = J, [J, F];
      }
      return [at.memoizedState, F];
    }
    return T = T === Zo ? typeof F == "function" ? F() : F : z !== void 0 ? z(F) : F, at.memoizedState = T, T = at.queue = { last: null, dispatch: null }, T = T.dispatch = hs.bind(null, jt, T), [at.memoizedState, T];
  }
  function so(T, F) {
    if (jt = br(), at = oo(), F = F === void 0 ? null : F, at !== null) {
      var z = at.memoizedState;
      if (z !== null && F !== null) {
        var J = z[1];
        e: if (J === null) J = !1;
        else {
          for (var me = 0; me < J.length && me < F.length; me++) if (!xi(F[me], J[me])) {
            J = !1;
            break e;
          }
          J = !0;
        }
        if (J) return z[0];
      }
    }
    return T = T(), at.memoizedState = [T, F], T;
  }
  function hs(T, F, z) {
    if (25 <= wi) throw Error(e(301));
    if (T === jt) if (Di = !0, T = { action: z, next: null }, Zn === null && (Zn = /* @__PURE__ */ new Map()), z = Zn.get(F), z === void 0) Zn.set(F, T);
    else {
      for (F = z; F.next !== null; ) F = F.next;
      F.next = T;
    }
  }
  function ps() {
    throw Error(e(394));
  }
  function Kn() {
  }
  var lo = { readContext: function(T) {
    return T._currentValue2;
  }, useContext: function(T) {
    return br(), T._currentValue2;
  }, useMemo: so, useReducer: Ut, useRef: function(T) {
    jt = br(), at = oo();
    var F = at.memoizedState;
    return F === null ? (T = { current: T }, at.memoizedState = T) : F;
  }, useState: function(T) {
    return Ut(Zo, T);
  }, useInsertionEffect: Kn, useLayoutEffect: function() {
  }, useCallback: function(T, F) {
    return so(function() {
      return T;
    }, F);
  }, useImperativeHandle: Kn, useEffect: Kn, useDebugValue: Kn, useDeferredValue: function(T) {
    return br(), T;
  }, useTransition: function() {
    return br(), [
      !1,
      ps
    ];
  }, useId: function() {
    var T = Dn.treeContext, F = T.overflow;
    T = T.id, T = (T & ~(1 << 32 - nt(T) - 1)).toString(32) + F;
    var z = Si;
    if (z === null) throw Error(e(404));
    return F = Qr++, T = ":" + z.idPrefix + "R" + T, 0 < F && (T += "H" + F.toString(32)), T + ":";
  }, useMutableSource: function(T, F) {
    return br(), F(T._source);
  }, useSyncExternalStore: function(T, F, z) {
    if (z === void 0) throw Error(e(407));
    return z();
  } }, Si = null, Fr = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function an(T) {
    return console.error(T), null;
  }
  function Qn() {
  }
  function Ti(T, F, z, J, me, fe, De, Oe, je) {
    var qe = [], Ve = /* @__PURE__ */ new Set();
    return F = { destination: null, responseState: F, progressiveChunkSize: J === void 0 ? 12800 : J, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: Ve, pingedTasks: qe, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: me === void 0 ? an : me, onAllReady: Qn, onShellReady: De === void 0 ? Qn : De, onShellError: Qn, onFatalError: Qn }, z = Or(F, 0, null, z, !1, !1), z.parentFlushed = !0, T = Rr(F, T, null, z, Ve, Se, null, Ke), qe.push(T), F;
  }
  function Rr(T, F, z, J, me, fe, De, Oe) {
    T.allPendingTasks++, z === null ? T.pendingRootTasks++ : z.pendingTasks++;
    var je = { node: F, ping: function() {
      var qe = T.pingedTasks;
      qe.push(je), qe.length === 1 && Xt(T);
    }, blockedBoundary: z, blockedSegment: J, abortSet: me, legacyContext: fe, context: De, treeContext: Oe };
    return me.add(je), je;
  }
  function Or(T, F, z, J, me, fe) {
    return { status: 0, id: -1, index: F, parentFlushed: !1, chunks: [], children: [], formatContext: J, boundary: z, lastPushedText: me, textEmbedded: fe };
  }
  function er(T, F) {
    if (T = T.onError(F), T != null && typeof T != "string") throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof T + '" instead');
    return T;
  }
  function Ir(T, F) {
    var z = T.onShellError;
    z(F), z = T.onFatalError, z(F), T.destination !== null ? (T.status = 2, T.destination.destroy(F)) : (T.status = 1, T.fatalError = F);
  }
  function sn(T, F, z, J, me) {
    for (jt = {}, Dn = F, Qr = 0, T = z(J, me); Di; ) Di = !1, Qr = 0, wi += 1, at = null, T = z(J, me);
    return ao(), T;
  }
  function Ko(T, F, z, J) {
    var me = z.render(), fe = J.childContextTypes;
    if (fe != null) {
      var De = F.legacyContext;
      if (typeof z.getChildContext != "function") J = De;
      else {
        z = z.getChildContext();
        for (var Oe in z) if (!(Oe in fe)) throw Error(e(108, ae(J) || "Unknown", Oe));
        J = V({}, De, z);
      }
      F.legacyContext = J, Ft(T, F, me), F.legacyContext = De;
    } else Ft(T, F, me);
  }
  function Qo(T, F) {
    if (T && T.defaultProps) {
      F = V({}, F), T = T.defaultProps;
      for (var z in T) F[z] === void 0 && (F[z] = T[z]);
      return F;
    }
    return F;
  }
  function vr(T, F, z, J, me) {
    if (typeof z == "function") if (z.prototype && z.prototype.isReactComponent) {
      me = ke(z, F.legacyContext);
      var fe = z.contextType;
      fe = new z(J, typeof fe == "object" && fe !== null ? fe._currentValue2 : me), He(fe, z, J, me), Ko(T, F, fe, z);
    } else {
      fe = ke(z, F.legacyContext), me = sn(T, F, z, J, fe);
      var De = Qr !== 0;
      if (typeof me == "object" && me !== null && typeof me.render == "function" && me.$$typeof === void 0) He(me, z, J, fe), Ko(T, F, me, z);
      else if (De) {
        J = F.treeContext, F.treeContext = lt(J, 1, 0);
        try {
          Ft(T, F, me);
        } finally {
          F.treeContext = J;
        }
      } else Ft(T, F, me);
    }
    else if (typeof z == "string") {
      switch (me = F.blockedSegment, fe = ee(me.chunks, z, J, T.responseState, me.formatContext), me.lastPushedText = !1, De = me.formatContext, me.formatContext = E(De, z, J), nr(T, F, fe), me.formatContext = De, z) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          me.chunks.push("</", z, ">");
      }
      me.lastPushedText = !1;
    } else {
      switch (z) {
        case ue:
        case ge:
        case be:
        case _e:
        case we:
          Ft(T, F, J.children);
          return;
        case ie:
          Ft(T, F, J.children);
          return;
        case k:
          throw Error(e(343));
        case tt:
          e: {
            z = F.blockedBoundary, me = F.blockedSegment, fe = J.fallback, J = J.children, De = /* @__PURE__ */ new Set();
            var Oe = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: De, errorDigest: null }, je = Or(T, me.chunks.length, Oe, me.formatContext, !1, !1);
            me.children.push(je), me.lastPushedText = !1;
            var qe = Or(T, 0, null, me.formatContext, !1, !1);
            qe.parentFlushed = !0, F.blockedBoundary = Oe, F.blockedSegment = qe;
            try {
              if (nr(
                T,
                F,
                J
              ), T.responseState.generateStaticMarkup || qe.lastPushedText && qe.textEmbedded && qe.chunks.push("<!-- -->"), qe.status = 1, Nn(Oe, qe), Oe.pendingTasks === 0) break e;
            } catch (Ve) {
              qe.status = 4, Oe.forceClientRender = !0, Oe.errorDigest = er(T, Ve);
            } finally {
              F.blockedBoundary = z, F.blockedSegment = me;
            }
            F = Rr(T, fe, z, je, De, F.legacyContext, F.context, F.treeContext), T.pingedTasks.push(F);
          }
          return;
      }
      if (typeof z == "object" && z !== null) switch (z.$$typeof) {
        case ze:
          if (J = sn(T, F, z.render, J, me), Qr !== 0) {
            z = F.treeContext, F.treeContext = lt(z, 1, 0);
            try {
              Ft(T, F, J);
            } finally {
              F.treeContext = z;
            }
          } else Ft(T, F, J);
          return;
        case Ee:
          z = z.type, J = Qo(z, J), vr(T, F, z, J, me);
          return;
        case $e:
          if (me = J.children, z = z._context, J = J.value, fe = z._currentValue2, z._currentValue2 = J, De = se, se = J = { parent: De, depth: De === null ? 0 : De.depth + 1, context: z, parentValue: fe, value: J }, F.context = J, Ft(T, F, me), T = se, T === null) throw Error(e(403));
          J = T.parentValue, T.context._currentValue2 = J === Y ? T.context._defaultValue : J, T = se = T.parent, F.context = T;
          return;
        case Le:
          J = J.children, J = J(z._currentValue2), Ft(T, F, J);
          return;
        case Re:
          me = z._init, z = me(z._payload), J = Qo(z, J), vr(
            T,
            F,
            z,
            J,
            void 0
          );
          return;
      }
      throw Error(e(130, z == null ? z : typeof z, ""));
    }
  }
  function Ft(T, F, z) {
    if (F.node = z, typeof z == "object" && z !== null) {
      switch (z.$$typeof) {
        case P:
          vr(T, F, z.type, z.props, z.ref);
          return;
        case pe:
          throw Error(e(257));
        case Re:
          var J = z._init;
          z = J(z._payload), Ft(T, F, z);
          return;
      }
      if (D(z)) {
        tr(T, F, z);
        return;
      }
      if (z === null || typeof z != "object" ? J = null : (J = H && z[H] || z["@@iterator"], J = typeof J == "function" ? J : null), J && (J = J.call(z))) {
        if (z = J.next(), !z.done) {
          var me = [];
          do
            me.push(z.value), z = J.next();
          while (!z.done);
          tr(T, F, me);
        }
        return;
      }
      throw T = Object.prototype.toString.call(z), Error(e(31, T === "[object Object]" ? "object with keys {" + Object.keys(z).join(", ") + "}" : T));
    }
    typeof z == "string" ? (J = F.blockedSegment, J.lastPushedText = re(F.blockedSegment.chunks, z, T.responseState, J.lastPushedText)) : typeof z == "number" && (J = F.blockedSegment, J.lastPushedText = re(F.blockedSegment.chunks, "" + z, T.responseState, J.lastPushedText));
  }
  function tr(T, F, z) {
    for (var J = z.length, me = 0; me < J; me++) {
      var fe = F.treeContext;
      F.treeContext = lt(fe, J, me);
      try {
        nr(T, F, z[me]);
      } finally {
        F.treeContext = fe;
      }
    }
  }
  function nr(T, F, z) {
    var J = F.blockedSegment.formatContext, me = F.legacyContext, fe = F.context;
    try {
      return Ft(T, F, z);
    } catch (je) {
      if (ao(), typeof je == "object" && je !== null && typeof je.then == "function") {
        z = je;
        var De = F.blockedSegment, Oe = Or(T, De.chunks.length, null, De.formatContext, De.lastPushedText, !0);
        De.children.push(Oe), De.lastPushedText = !1, T = Rr(T, F.node, F.blockedBoundary, Oe, F.abortSet, F.legacyContext, F.context, F.treeContext).ping, z.then(T, T), F.blockedSegment.formatContext = J, F.legacyContext = me, F.context = fe, Me(fe);
      } else throw F.blockedSegment.formatContext = J, F.legacyContext = me, F.context = fe, Me(fe), je;
    }
  }
  function Br(T) {
    var F = T.blockedBoundary;
    T = T.blockedSegment, T.status = 3, rr(this, F, T);
  }
  function Ci(T, F, z) {
    var J = T.blockedBoundary;
    T.blockedSegment.status = 3, J === null ? (F.allPendingTasks--, F.status !== 2 && (F.status = 2, F.destination !== null && F.destination.push(null))) : (J.pendingTasks--, J.forceClientRender || (J.forceClientRender = !0, T = z === void 0 ? Error(e(432)) : z, J.errorDigest = F.onError(T), J.parentFlushed && F.clientRenderedBoundaries.push(J)), J.fallbackAbortableTasks.forEach(function(me) {
      return Ci(me, F, z);
    }), J.fallbackAbortableTasks.clear(), F.allPendingTasks--, F.allPendingTasks === 0 && (J = F.onAllReady, J()));
  }
  function Nn(T, F) {
    if (F.chunks.length === 0 && F.children.length === 1 && F.children[0].boundary === null) {
      var z = F.children[0];
      z.id = F.id, z.parentFlushed = !0, z.status === 1 && Nn(T, z);
    } else T.completedSegments.push(F);
  }
  function rr(T, F, z) {
    if (F === null) {
      if (z.parentFlushed) {
        if (T.completedRootSegment !== null) throw Error(e(389));
        T.completedRootSegment = z;
      }
      T.pendingRootTasks--, T.pendingRootTasks === 0 && (T.onShellError = Qn, F = T.onShellReady, F());
    } else F.pendingTasks--, F.forceClientRender || (F.pendingTasks === 0 ? (z.parentFlushed && z.status === 1 && Nn(F, z), F.parentFlushed && T.completedBoundaries.push(F), F.fallbackAbortableTasks.forEach(Br, T), F.fallbackAbortableTasks.clear()) : z.parentFlushed && z.status === 1 && (Nn(F, z), F.completedSegments.length === 1 && F.parentFlushed && T.partialBoundaries.push(F)));
    T.allPendingTasks--, T.allPendingTasks === 0 && (T = T.onAllReady, T());
  }
  function Xt(T) {
    if (T.status !== 2) {
      var F = se, z = Fr.current;
      Fr.current = lo;
      var J = Si;
      Si = T.responseState;
      try {
        var me = T.pingedTasks, fe;
        for (fe = 0; fe < me.length; fe++) {
          var De = me[fe], Oe = T, je = De.blockedSegment;
          if (je.status === 0) {
            Me(De.context);
            try {
              Ft(Oe, De, De.node), Oe.responseState.generateStaticMarkup || je.lastPushedText && je.textEmbedded && je.chunks.push("<!-- -->"), De.abortSet.delete(De), je.status = 1, rr(Oe, De.blockedBoundary, je);
            } catch (Zt) {
              if (ao(), typeof Zt == "object" && Zt !== null && typeof Zt.then == "function") {
                var qe = De.ping;
                Zt.then(qe, qe);
              } else {
                De.abortSet.delete(De), je.status = 4;
                var Ve = De.blockedBoundary, ft = Zt, Jt = er(Oe, ft);
                if (Ve === null ? Ir(Oe, ft) : (Ve.pendingTasks--, Ve.forceClientRender || (Ve.forceClientRender = !0, Ve.errorDigest = Jt, Ve.parentFlushed && Oe.clientRenderedBoundaries.push(Ve))), Oe.allPendingTasks--, Oe.allPendingTasks === 0) {
                  var Yt = Oe.onAllReady;
                  Yt();
                }
              }
            } finally {
            }
          }
        }
        me.splice(0, fe), T.destination !== null && Gt(T, T.destination);
      } catch (Zt) {
        er(T, Zt), Ir(T, Zt);
      } finally {
        Si = J, Fr.current = z, z === lo && Me(F);
      }
    }
  }
  function Mr(T, F, z) {
    switch (z.parentFlushed = !0, z.status) {
      case 0:
        var J = z.id = T.nextSegmentId++;
        return z.lastPushedText = !1, z.textEmbedded = !1, T = T.responseState, F.push('<template id="'), F.push(T.placeholderPrefix), T = J.toString(16), F.push(T), F.push('"></template>');
      case 1:
        z.status = 2;
        var me = !0;
        J = z.chunks;
        var fe = 0;
        z = z.children;
        for (var De = 0; De < z.length; De++) {
          for (me = z[De]; fe < me.index; fe++) F.push(J[fe]);
          me = ei(T, F, me);
        }
        for (; fe < J.length - 1; fe++) F.push(J[fe]);
        return fe < J.length && (me = F.push(J[fe])), me;
      default:
        throw Error(e(390));
    }
  }
  function ei(T, F, z) {
    var J = z.boundary;
    if (J === null) return Mr(T, F, z);
    if (J.parentFlushed = !0, J.forceClientRender) return T.responseState.generateStaticMarkup || (J = J.errorDigest, F.push("<!--$!-->"), F.push("<template"), J && (F.push(' data-dgst="'), J = b(J), F.push(J), F.push('"')), F.push("></template>")), Mr(T, F, z), T = T.responseState.generateStaticMarkup ? !0 : F.push("<!--/$-->"), T;
    if (0 < J.pendingTasks) {
      J.rootSegmentID = T.nextSegmentId++, 0 < J.completedSegments.length && T.partialBoundaries.push(J);
      var me = T.responseState, fe = me.nextSuspenseID++;
      return me = me.boundaryPrefix + fe.toString(16), J = J.id = me, A(F, T.responseState, J), Mr(T, F, z), F.push("<!--/$-->");
    }
    if (J.byteSize > T.progressiveChunkSize) return J.rootSegmentID = T.nextSegmentId++, T.completedBoundaries.push(J), A(F, T.responseState, J.id), Mr(T, F, z), F.push("<!--/$-->");
    if (T.responseState.generateStaticMarkup || F.push("<!--$-->"), z = J.completedSegments, z.length !== 1) throw Error(e(391));
    return ei(T, F, z[0]), T = T.responseState.generateStaticMarkup ? !0 : F.push("<!--/$-->"), T;
  }
  function Ei(T, F, z) {
    return oe(F, T.responseState, z.formatContext, z.id), ei(T, F, z), j(F, z.formatContext);
  }
  function wn(T, F, z) {
    for (var J = z.completedSegments, me = 0; me < J.length; me++) ir(T, F, z, J[me]);
    if (J.length = 0, T = T.responseState, J = z.id, z = z.rootSegmentID, F.push(T.startInlineScript), T.sentCompleteBoundaryFunction ? F.push('$RC("') : (T.sentCompleteBoundaryFunction = !0, F.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), J === null) throw Error(e(395));
    return z = z.toString(16), F.push(J), F.push('","'), F.push(T.segmentPrefix), F.push(z), F.push('")<\/script>');
  }
  function ir(T, F, z, J) {
    if (J.status === 2) return !0;
    var me = J.id;
    if (me === -1) {
      if ((J.id = z.rootSegmentID) === -1) throw Error(e(392));
      return Ei(T, F, J);
    }
    return Ei(T, F, J), T = T.responseState, F.push(T.startInlineScript), T.sentCompleteSegmentFunction ? F.push('$RS("') : (T.sentCompleteSegmentFunction = !0, F.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), F.push(T.segmentPrefix), me = me.toString(16), F.push(me), F.push('","'), F.push(T.placeholderPrefix), F.push(me), F.push('")<\/script>');
  }
  function Gt(T, F) {
    try {
      var z = T.completedRootSegment;
      if (z !== null && T.pendingRootTasks === 0) {
        ei(T, F, z), T.completedRootSegment = null;
        var J = T.responseState.bootstrapChunks;
        for (z = 0; z < J.length - 1; z++) F.push(J[z]);
        z < J.length && F.push(J[z]);
      }
      var me = T.clientRenderedBoundaries, fe;
      for (fe = 0; fe < me.length; fe++) {
        var De = me[fe];
        J = F;
        var Oe = T.responseState, je = De.id, qe = De.errorDigest, Ve = De.errorMessage, ft = De.errorComponentStack;
        if (J.push(Oe.startInlineScript), Oe.sentClientRenderFunction ? J.push('$RX("') : (Oe.sentClientRenderFunction = !0, J.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), je === null) throw Error(e(395));
        if (J.push(je), J.push('"'), qe || Ve || ft) {
          J.push(",");
          var Jt = G(qe || "");
          J.push(Jt);
        }
        if (Ve || ft) {
          J.push(",");
          var Yt = G(Ve || "");
          J.push(Yt);
        }
        if (ft) {
          J.push(",");
          var Zt = G(ft);
          J.push(Zt);
        }
        if (!J.push(")<\/script>")) {
          T.destination = null, fe++, me.splice(0, fe);
          return;
        }
      }
      me.splice(0, fe);
      var Nr = T.completedBoundaries;
      for (fe = 0; fe < Nr.length; fe++) if (!wn(T, F, Nr[fe])) {
        T.destination = null, fe++, Nr.splice(0, fe);
        return;
      }
      Nr.splice(0, fe);
      var or = T.partialBoundaries;
      for (fe = 0; fe < or.length; fe++) {
        var ki = or[fe];
        e: {
          me = T, De = F;
          var Pr = ki.completedSegments;
          for (Oe = 0; Oe < Pr.length; Oe++) if (!ir(me, De, ki, Pr[Oe])) {
            Oe++, Pr.splice(0, Oe);
            var ti = !1;
            break e;
          }
          Pr.splice(0, Oe), ti = !0;
        }
        if (!ti) {
          T.destination = null, fe++, or.splice(0, fe);
          return;
        }
      }
      or.splice(0, fe);
      var xr = T.completedBoundaries;
      for (fe = 0; fe < xr.length; fe++) if (!wn(T, F, xr[fe])) {
        T.destination = null, fe++, xr.splice(0, fe);
        return;
      }
      xr.splice(0, fe);
    } finally {
      T.allPendingTasks === 0 && T.pingedTasks.length === 0 && T.clientRenderedBoundaries.length === 0 && T.completedBoundaries.length === 0 && F.push(null);
    }
  }
  function _i(T, F) {
    try {
      var z = T.abortableTasks;
      z.forEach(function(J) {
        return Ci(J, T, F);
      }), z.clear(), T.destination !== null && Gt(T, T.destination);
    } catch (J) {
      er(T, J), Ir(T, J);
    }
  }
  function Lt() {
  }
  function ln(T, F, z, J) {
    var me = !1, fe = null, De = "", Oe = { push: function(qe) {
      return qe !== null && (De += qe), !0;
    }, destroy: function(qe) {
      me = !0, fe = qe;
    } }, je = !1;
    if (T = Ti(T, Z(z, F ? F.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, 1 / 0, Lt, void 0, function() {
      je = !0;
    }), Xt(T), _i(T, J), T.status === 1) T.status = 2, Oe.destroy(T.fatalError);
    else if (T.status !== 2 && T.destination === null) {
      T.destination = Oe;
      try {
        Gt(T, Oe);
      } catch (qe) {
        er(T, qe), Ir(T, qe);
      }
    }
    if (me) throw fe;
    if (!je) throw Error(e(426));
    return De;
  }
  return Gs.renderToNodeStream = function() {
    throw Error(e(207));
  }, Gs.renderToStaticMarkup = function(T, F) {
    return ln(T, F, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Gs.renderToStaticNodeStream = function() {
    throw Error(e(208));
  }, Gs.renderToString = function(T, F) {
    return ln(T, F, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  }, Gs.version = "18.3.1", Gs;
}
var mp = {};
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e_;
function zG() {
  if (e_) return mp;
  e_ = 1;
  var t = um;
  function e(C) {
    for (var U = "https://reactjs.org/docs/error-decoder.html?invariant=" + C, W = 1; W < arguments.length; W++) U += "&args[]=" + encodeURIComponent(arguments[W]);
    return "Minified React error #" + C + "; visit " + U + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var n = null, r = 0;
  function i(C, U) {
    if (U.length !== 0) if (512 < U.length) 0 < r && (C.enqueue(new Uint8Array(n.buffer, 0, r)), n = new Uint8Array(512), r = 0), C.enqueue(U);
    else {
      var W = n.length - r;
      W < U.length && (W === 0 ? C.enqueue(n) : (n.set(U.subarray(0, W), r), C.enqueue(n), U = U.subarray(W)), n = new Uint8Array(512), r = 0), n.set(U, r), r += U.length;
    }
  }
  function o(C, U) {
    return i(C, U), !0;
  }
  function a(C) {
    n && 0 < r && (C.enqueue(new Uint8Array(n.buffer, 0, r)), n = null, r = 0);
  }
  var s = new TextEncoder();
  function l(C) {
    return s.encode(C);
  }
  function u(C) {
    return s.encode(C);
  }
  function f(C, U) {
    typeof C.error == "function" ? C.error(U) : C.close();
  }
  var h = Object.prototype.hasOwnProperty, p = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, y = {}, b = {};
  function x(C) {
    return h.call(b, C) ? !0 : h.call(y, C) ? !1 : p.test(C) ? b[C] = !0 : (y[C] = !0, !1);
  }
  function v(C, U, W, X, ye, he, Te) {
    this.acceptsBooleans = U === 2 || U === 3 || U === 4, this.attributeName = X, this.attributeNamespace = ye, this.mustUseProperty = W, this.propertyName = C, this.type = U, this.sanitizeURL = he, this.removeEmptyString = Te;
  }
  var D = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(C) {
    D[C] = new v(C, 0, !1, C, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(C) {
    var U = C[0];
    D[U] = new v(U, 1, !1, C[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(C) {
    D[C] = new v(C, 2, !1, C.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(C) {
    D[C] = new v(C, 2, !1, C, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(C) {
    D[C] = new v(C, 3, !1, C.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(C) {
    D[C] = new v(C, 3, !0, C, null, !1, !1);
  }), ["capture", "download"].forEach(function(C) {
    D[C] = new v(C, 4, !1, C, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(C) {
    D[C] = new v(C, 6, !1, C, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(C) {
    D[C] = new v(C, 5, !1, C.toLowerCase(), null, !1, !1);
  });
  var S = /[\-:]([a-z])/g;
  function E(C) {
    return C[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(C) {
    var U = C.replace(
      S,
      E
    );
    D[U] = new v(U, 1, !1, C, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(C) {
    var U = C.replace(S, E);
    D[U] = new v(U, 1, !1, C, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(C) {
    var U = C.replace(S, E);
    D[U] = new v(U, 1, !1, C, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(C) {
    D[C] = new v(C, 1, !1, C.toLowerCase(), null, !1, !1);
  }), D.xlinkHref = new v("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(C) {
    D[C] = new v(C, 1, !1, C.toLowerCase(), null, !0, !0);
  });
  var I = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, R = ["Webkit", "ms", "Moz", "O"];
  Object.keys(I).forEach(function(C) {
    R.forEach(function(U) {
      U = U + C.charAt(0).toUpperCase() + C.substring(1), I[U] = I[C];
    });
  });
  var O = /["'&<>]/;
  function N(C) {
    if (typeof C == "boolean" || typeof C == "number") return "" + C;
    C = "" + C;
    var U = O.exec(C);
    if (U) {
      var W = "", X, ye = 0;
      for (X = U.index; X < C.length; X++) {
        switch (C.charCodeAt(X)) {
          case 34:
            U = "&quot;";
            break;
          case 38:
            U = "&amp;";
            break;
          case 39:
            U = "&#x27;";
            break;
          case 60:
            U = "&lt;";
            break;
          case 62:
            U = "&gt;";
            break;
          default:
            continue;
        }
        ye !== X && (W += C.substring(ye, X)), ye = X + 1, W += U;
      }
      C = ye !== X ? W + C.substring(ye, X) : W;
    }
    return C;
  }
  var q = /([A-Z])/g, $ = /^ms-/, le = Array.isArray, ve = u("<script>"), M = u("<\/script>"), ee = u('<script src="'), A = u('<script type="module" src="'), oe = u('" async=""><\/script>'), j = /(<\/|<)(s)(cript)/gi;
  function Q(C, U, W, X) {
    return "" + U + (W === "s" ? "\\u0073" : "\\u0053") + X;
  }
  function G(C, U, W, X, ye) {
    C = C === void 0 ? "" : C, U = U === void 0 ? ve : u('<script nonce="' + N(U) + '">');
    var he = [];
    if (W !== void 0 && he.push(U, l(("" + W).replace(j, Q)), M), X !== void 0) for (W = 0; W < X.length; W++) he.push(ee, l(N(X[W])), oe);
    if (ye !== void 0) for (X = 0; X < ye.length; X++) he.push(A, l(N(ye[X])), oe);
    return { bootstrapChunks: he, startInlineScript: U, placeholderPrefix: u(C + "P:"), segmentPrefix: u(C + "S:"), boundaryPrefix: C + "B:", idPrefix: C, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
  }
  function Z(C, U) {
    return { insertionMode: C, selectedValue: U };
  }
  function re(C) {
    return Z(C === "http://www.w3.org/2000/svg" ? 2 : C === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null);
  }
  function V(C, U, W) {
    switch (U) {
      case "select":
        return Z(1, W.value != null ? W.value : W.defaultValue);
      case "svg":
        return Z(2, null);
      case "math":
        return Z(3, null);
      case "foreignObject":
        return Z(1, null);
      case "table":
        return Z(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return Z(5, null);
      case "colgroup":
        return Z(7, null);
      case "tr":
        return Z(6, null);
    }
    return 4 <= C.insertionMode || C.insertionMode === 0 ? Z(1, null) : C;
  }
  var P = u("<!-- -->");
  function pe(C, U, W, X) {
    return U === "" ? X : (X && C.push(P), C.push(l(N(U))), !0);
  }
  var we = /* @__PURE__ */ new Map(), be = u(' style="'), _e = u(":"), $e = u(";");
  function Le(C, U, W) {
    if (typeof W != "object") throw Error(e(62));
    U = !0;
    for (var X in W) if (h.call(W, X)) {
      var ye = W[X];
      if (ye != null && typeof ye != "boolean" && ye !== "") {
        if (X.indexOf("--") === 0) {
          var he = l(N(X));
          ye = l(N(("" + ye).trim()));
        } else {
          he = X;
          var Te = we.get(he);
          Te !== void 0 || (Te = u(N(he.replace(q, "-$1").toLowerCase().replace($, "-ms-"))), we.set(he, Te)), he = Te, ye = typeof ye == "number" ? ye === 0 || h.call(I, X) ? l("" + ye) : l(ye + "px") : l(N(("" + ye).trim()));
        }
        U ? (U = !1, C.push(be, he, _e, ye)) : C.push($e, he, _e, ye);
      }
    }
    U || C.push(ie);
  }
  var ze = u(" "), tt = u('="'), ie = u('"'), Ee = u('=""');
  function Re(C, U, W, X) {
    switch (W) {
      case "style":
        Le(C, U, X);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < W.length) || W[0] !== "o" && W[0] !== "O" || W[1] !== "n" && W[1] !== "N") {
      if (U = D.hasOwnProperty(W) ? D[W] : null, U !== null) {
        switch (typeof X) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!U.acceptsBooleans) return;
        }
        switch (W = l(U.attributeName), U.type) {
          case 3:
            X && C.push(ze, W, Ee);
            break;
          case 4:
            X === !0 ? C.push(ze, W, Ee) : X !== !1 && C.push(ze, W, tt, l(N(X)), ie);
            break;
          case 5:
            isNaN(X) || C.push(ze, W, tt, l(N(X)), ie);
            break;
          case 6:
            !isNaN(X) && 1 <= X && C.push(ze, W, tt, l(N(X)), ie);
            break;
          default:
            U.sanitizeURL && (X = "" + X), C.push(ze, W, tt, l(N(X)), ie);
        }
      } else if (x(W)) {
        switch (typeof X) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (U = W.toLowerCase().slice(0, 5), U !== "data-" && U !== "aria-") return;
        }
        C.push(ze, l(W), tt, l(N(X)), ie);
      }
    }
  }
  var k = u(">"), ge = u("/>");
  function ue(C, U, W) {
    if (U != null) {
      if (W != null) throw Error(e(60));
      if (typeof U != "object" || !("__html" in U)) throw Error(e(61));
      U = U.__html, U != null && C.push(l("" + U));
    }
  }
  function Y(C) {
    var U = "";
    return t.Children.forEach(C, function(W) {
      W != null && (U += W);
    }), U;
  }
  var H = u(' selected=""');
  function ae(C, U, W, X) {
    C.push(K(W));
    var ye = W = null, he;
    for (he in U) if (h.call(U, he)) {
      var Te = U[he];
      if (Te != null) switch (he) {
        case "children":
          W = Te;
          break;
        case "dangerouslySetInnerHTML":
          ye = Te;
          break;
        default:
          Re(C, X, he, Te);
      }
    }
    return C.push(k), ue(C, ye, W), typeof W == "string" ? (C.push(l(N(W))), null) : W;
  }
  var Se = u(`
`), ke = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, se = /* @__PURE__ */ new Map();
  function K(C) {
    var U = se.get(C);
    if (U === void 0) {
      if (!ke.test(C)) throw Error(e(65, C));
      U = u("<" + C), se.set(C, U);
    }
    return U;
  }
  var ne = u("<!DOCTYPE html>");
  function ce(C, U, W, X, ye) {
    switch (U) {
      case "select":
        C.push(K("select"));
        var he = null, Te = null;
        for (Ze in W) if (h.call(W, Ze)) {
          var Ie = W[Ze];
          if (Ie != null) switch (Ze) {
            case "children":
              he = Ie;
              break;
            case "dangerouslySetInnerHTML":
              Te = Ie;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              Re(C, X, Ze, Ie);
          }
        }
        return C.push(k), ue(C, Te, he), he;
      case "option":
        Te = ye.selectedValue, C.push(K("option"));
        var Xe = Ie = null, Qe = null, Ze = null;
        for (he in W) if (h.call(W, he)) {
          var bt = W[he];
          if (bt != null) switch (he) {
            case "children":
              Ie = bt;
              break;
            case "selected":
              Qe = bt;
              break;
            case "dangerouslySetInnerHTML":
              Ze = bt;
              break;
            case "value":
              Xe = bt;
            default:
              Re(C, X, he, bt);
          }
        }
        if (Te != null) if (W = Xe !== null ? "" + Xe : Y(Ie), le(Te)) {
          for (X = 0; X < Te.length; X++)
            if ("" + Te[X] === W) {
              C.push(H);
              break;
            }
        } else "" + Te === W && C.push(H);
        else Qe && C.push(H);
        return C.push(k), ue(C, Ze, Ie), Ie;
      case "textarea":
        C.push(K("textarea")), Ze = Te = he = null;
        for (Ie in W) if (h.call(W, Ie) && (Xe = W[Ie], Xe != null)) switch (Ie) {
          case "children":
            Ze = Xe;
            break;
          case "value":
            he = Xe;
            break;
          case "defaultValue":
            Te = Xe;
            break;
          case "dangerouslySetInnerHTML":
            throw Error(e(91));
          default:
            Re(C, X, Ie, Xe);
        }
        if (he === null && Te !== null && (he = Te), C.push(k), Ze != null) {
          if (he != null) throw Error(e(92));
          if (le(Ze) && 1 < Ze.length) throw Error(e(93));
          he = "" + Ze;
        }
        return typeof he == "string" && he[0] === `
` && C.push(Se), he !== null && C.push(l(N("" + he))), null;
      case "input":
        C.push(K("input")), Xe = Ze = Ie = he = null;
        for (Te in W) if (h.call(W, Te) && (Qe = W[Te], Qe != null)) switch (Te) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(e(399, "input"));
          case "defaultChecked":
            Xe = Qe;
            break;
          case "defaultValue":
            Ie = Qe;
            break;
          case "checked":
            Ze = Qe;
            break;
          case "value":
            he = Qe;
            break;
          default:
            Re(C, X, Te, Qe);
        }
        return Ze !== null ? Re(
          C,
          X,
          "checked",
          Ze
        ) : Xe !== null && Re(C, X, "checked", Xe), he !== null ? Re(C, X, "value", he) : Ie !== null && Re(C, X, "value", Ie), C.push(ge), null;
      case "menuitem":
        C.push(K("menuitem"));
        for (var un in W) if (h.call(W, un) && (he = W[un], he != null)) switch (un) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(e(400));
          default:
            Re(C, X, un, he);
        }
        return C.push(k), null;
      case "title":
        C.push(K("title")), he = null;
        for (bt in W) if (h.call(W, bt) && (Te = W[bt], Te != null)) switch (bt) {
          case "children":
            he = Te;
            break;
          case "dangerouslySetInnerHTML":
            throw Error(e(434));
          default:
            Re(C, X, bt, Te);
        }
        return C.push(k), he;
      case "listing":
      case "pre":
        C.push(K(U)), Te = he = null;
        for (Xe in W) if (h.call(W, Xe) && (Ie = W[Xe], Ie != null)) switch (Xe) {
          case "children":
            he = Ie;
            break;
          case "dangerouslySetInnerHTML":
            Te = Ie;
            break;
          default:
            Re(C, X, Xe, Ie);
        }
        if (C.push(k), Te != null) {
          if (he != null) throw Error(e(60));
          if (typeof Te != "object" || !("__html" in Te)) throw Error(e(61));
          W = Te.__html, W != null && (typeof W == "string" && 0 < W.length && W[0] === `
` ? C.push(Se, l(W)) : C.push(l("" + W)));
        }
        return typeof he == "string" && he[0] === `
` && C.push(Se), he;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        C.push(K(U));
        for (var Wn in W) if (h.call(W, Wn) && (he = W[Wn], he != null)) switch (Wn) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(e(399, U));
          default:
            Re(C, X, Wn, he);
        }
        return C.push(ge), null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return ae(C, W, U, X);
      case "html":
        return ye.insertionMode === 0 && C.push(ne), ae(C, W, U, X);
      default:
        if (U.indexOf("-") === -1 && typeof W.is != "string") return ae(C, W, U, X);
        C.push(K(U)), Te = he = null;
        for (Qe in W) if (h.call(W, Qe) && (Ie = W[Qe], Ie != null)) switch (Qe) {
          case "children":
            he = Ie;
            break;
          case "dangerouslySetInnerHTML":
            Te = Ie;
            break;
          case "style":
            Le(C, X, Ie);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            break;
          default:
            x(Qe) && typeof Ie != "function" && typeof Ie != "symbol" && C.push(ze, l(Qe), tt, l(N(Ie)), ie);
        }
        return C.push(k), ue(C, Te, he), he;
    }
  }
  var xe = u("</"), Be = u(">"), Me = u('<template id="'), Je = u('"></template>'), He = u("<!--$-->"), Ke = u('<!--$?--><template id="'), lt = u('"></template>'), nt = u("<!--$!-->"), Bt = u("<!--/$-->"), Bn = u("<template"), At = u('"'), Ur = u(' data-dgst="');
  u(' data-msg="'), u(' data-stck="');
  var xi = u("></template>");
  function jt(C, U, W) {
    if (i(C, Ke), W === null) throw Error(e(395));
    return i(C, W), o(C, lt);
  }
  var Dn = u('<div hidden id="'), Mn = u('">'), at = u("</div>"), on = u('<svg aria-hidden="true" style="display:none" id="'), Di = u('">'), Qr = u("</svg>"), Zn = u('<math aria-hidden="true" style="display:none" id="'), wi = u('">'), br = u("</math>"), Mt = u('<table hidden id="'), oo = u('">'), ao = u("</table>"), Zo = u('<table hidden><tbody id="'), Ut = u('">'), so = u("</tbody></table>"), hs = u('<table hidden><tr id="'), ps = u('">'), Kn = u("</tr></table>"), lo = u('<table hidden><colgroup id="'), Si = u('">'), Fr = u("</colgroup></table>");
  function an(C, U, W, X) {
    switch (W.insertionMode) {
      case 0:
      case 1:
        return i(C, Dn), i(C, U.segmentPrefix), i(C, l(X.toString(16))), o(C, Mn);
      case 2:
        return i(C, on), i(C, U.segmentPrefix), i(C, l(X.toString(16))), o(C, Di);
      case 3:
        return i(C, Zn), i(C, U.segmentPrefix), i(C, l(X.toString(16))), o(C, wi);
      case 4:
        return i(C, Mt), i(C, U.segmentPrefix), i(C, l(X.toString(16))), o(C, oo);
      case 5:
        return i(C, Zo), i(C, U.segmentPrefix), i(C, l(X.toString(16))), o(C, Ut);
      case 6:
        return i(C, hs), i(C, U.segmentPrefix), i(C, l(X.toString(16))), o(C, ps);
      case 7:
        return i(
          C,
          lo
        ), i(C, U.segmentPrefix), i(C, l(X.toString(16))), o(C, Si);
      default:
        throw Error(e(397));
    }
  }
  function Qn(C, U) {
    switch (U.insertionMode) {
      case 0:
      case 1:
        return o(C, at);
      case 2:
        return o(C, Qr);
      case 3:
        return o(C, br);
      case 4:
        return o(C, ao);
      case 5:
        return o(C, so);
      case 6:
        return o(C, Kn);
      case 7:
        return o(C, Fr);
      default:
        throw Error(e(397));
    }
  }
  var Ti = u('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), Rr = u('$RS("'), Or = u('","'), er = u('")<\/script>'), Ir = u('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), sn = u('$RC("'), Ko = u('","'), Qo = u('")<\/script>'), vr = u('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), Ft = u('$RX("'), tr = u('"'), nr = u(")<\/script>"), Br = u(","), Ci = /[<\u2028\u2029]/g;
  function Nn(C) {
    return JSON.stringify(C).replace(Ci, function(U) {
      switch (U) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  var rr = Object.assign, Xt = Symbol.for("react.element"), Mr = Symbol.for("react.portal"), ei = Symbol.for("react.fragment"), Ei = Symbol.for("react.strict_mode"), wn = Symbol.for("react.profiler"), ir = Symbol.for("react.provider"), Gt = Symbol.for("react.context"), _i = Symbol.for("react.forward_ref"), Lt = Symbol.for("react.suspense"), ln = Symbol.for("react.suspense_list"), T = Symbol.for("react.memo"), F = Symbol.for("react.lazy"), z = Symbol.for("react.scope"), J = Symbol.for("react.debug_trace_mode"), me = Symbol.for("react.legacy_hidden"), fe = Symbol.for("react.default_value"), De = Symbol.iterator;
  function Oe(C) {
    if (C == null) return null;
    if (typeof C == "function") return C.displayName || C.name || null;
    if (typeof C == "string") return C;
    switch (C) {
      case ei:
        return "Fragment";
      case Mr:
        return "Portal";
      case wn:
        return "Profiler";
      case Ei:
        return "StrictMode";
      case Lt:
        return "Suspense";
      case ln:
        return "SuspenseList";
    }
    if (typeof C == "object") switch (C.$$typeof) {
      case Gt:
        return (C.displayName || "Context") + ".Consumer";
      case ir:
        return (C._context.displayName || "Context") + ".Provider";
      case _i:
        var U = C.render;
        return C = C.displayName, C || (C = U.displayName || U.name || "", C = C !== "" ? "ForwardRef(" + C + ")" : "ForwardRef"), C;
      case T:
        return U = C.displayName || null, U !== null ? U : Oe(C.type) || "Memo";
      case F:
        U = C._payload, C = C._init;
        try {
          return Oe(C(U));
        } catch {
        }
    }
    return null;
  }
  var je = {};
  function qe(C, U) {
    if (C = C.contextTypes, !C) return je;
    var W = {}, X;
    for (X in C) W[X] = U[X];
    return W;
  }
  var Ve = null;
  function ft(C, U) {
    if (C !== U) {
      C.context._currentValue = C.parentValue, C = C.parent;
      var W = U.parent;
      if (C === null) {
        if (W !== null) throw Error(e(401));
      } else {
        if (W === null) throw Error(e(401));
        ft(C, W);
      }
      U.context._currentValue = U.value;
    }
  }
  function Jt(C) {
    C.context._currentValue = C.parentValue, C = C.parent, C !== null && Jt(C);
  }
  function Yt(C) {
    var U = C.parent;
    U !== null && Yt(U), C.context._currentValue = C.value;
  }
  function Zt(C, U) {
    if (C.context._currentValue = C.parentValue, C = C.parent, C === null) throw Error(e(402));
    C.depth === U.depth ? ft(C, U) : Zt(C, U);
  }
  function Nr(C, U) {
    var W = U.parent;
    if (W === null) throw Error(e(402));
    C.depth === W.depth ? ft(C, W) : Nr(C, W), U.context._currentValue = U.value;
  }
  function or(C) {
    var U = Ve;
    U !== C && (U === null ? Yt(C) : C === null ? Jt(U) : U.depth === C.depth ? ft(U, C) : U.depth > C.depth ? Zt(U, C) : Nr(U, C), Ve = C);
  }
  var ki = { isMounted: function() {
    return !1;
  }, enqueueSetState: function(C, U) {
    C = C._reactInternals, C.queue !== null && C.queue.push(U);
  }, enqueueReplaceState: function(C, U) {
    C = C._reactInternals, C.replace = !0, C.queue = [U];
  }, enqueueForceUpdate: function() {
  } };
  function Pr(C, U, W, X) {
    var ye = C.state !== void 0 ? C.state : null;
    C.updater = ki, C.props = W, C.state = ye;
    var he = { queue: [], replace: !1 };
    C._reactInternals = he;
    var Te = U.contextType;
    if (C.context = typeof Te == "object" && Te !== null ? Te._currentValue : X, Te = U.getDerivedStateFromProps, typeof Te == "function" && (Te = Te(W, ye), ye = Te == null ? ye : rr({}, ye, Te), C.state = ye), typeof U.getDerivedStateFromProps != "function" && typeof C.getSnapshotBeforeUpdate != "function" && (typeof C.UNSAFE_componentWillMount == "function" || typeof C.componentWillMount == "function")) if (U = C.state, typeof C.componentWillMount == "function" && C.componentWillMount(), typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount(), U !== C.state && ki.enqueueReplaceState(C, C.state, null), he.queue !== null && 0 < he.queue.length) if (U = he.queue, Te = he.replace, he.queue = null, he.replace = !1, Te && U.length === 1) C.state = U[0];
    else {
      for (he = Te ? U[0] : C.state, ye = !0, Te = Te ? 1 : 0; Te < U.length; Te++) {
        var Ie = U[Te];
        Ie = typeof Ie == "function" ? Ie.call(C, he, W, X) : Ie, Ie != null && (ye ? (ye = !1, he = rr({}, he, Ie)) : rr(he, Ie));
      }
      C.state = he;
    }
    else he.queue = null;
  }
  var ti = { id: 1, overflow: "" };
  function xr(C, U, W) {
    var X = C.id;
    C = C.overflow;
    var ye = 32 - ni(X) - 1;
    X &= ~(1 << ye), W += 1;
    var he = 32 - ni(U) + ye;
    if (30 < he) {
      var Te = ye - ye % 5;
      return he = (X & (1 << Te) - 1).toString(32), X >>= Te, ye -= Te, { id: 1 << 32 - ni(U) + ye | W << ye | X, overflow: he + C };
    }
    return { id: 1 << he | W << ye | X, overflow: C };
  }
  var ni = Math.clz32 ? Math.clz32 : ea, Mu = Math.log, Nu = Math.LN2;
  function ea(C) {
    return C >>>= 0, C === 0 ? 32 : 31 - (Mu(C) / Nu | 0) | 0;
  }
  function ar(C, U) {
    return C === U && (C !== 0 || 1 / C === 1 / U) || C !== C && U !== U;
  }
  var Pu = typeof Object.is == "function" ? Object.is : ar, Dr = null, gs = null, ta = null, gt = null, ri = !1, na = !1, ii = 0, Wr = null, ra = 0;
  function Lr() {
    if (Dr === null) throw Error(e(321));
    return Dr;
  }
  function Pn() {
    if (0 < ra) throw Error(e(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function ms() {
    return gt === null ? ta === null ? (ri = !1, ta = gt = Pn()) : (ri = !0, gt = ta) : gt.next === null ? (ri = !1, gt = gt.next = Pn()) : (ri = !0, gt = gt.next), gt;
  }
  function co() {
    gs = Dr = null, na = !1, ta = null, ra = 0, gt = Wr = null;
  }
  function _l(C, U) {
    return typeof U == "function" ? U(C) : U;
  }
  function ia(C, U, W) {
    if (Dr = Lr(), gt = ms(), ri) {
      var X = gt.queue;
      if (U = X.dispatch, Wr !== null && (W = Wr.get(X), W !== void 0)) {
        Wr.delete(X), X = gt.memoizedState;
        do
          X = C(X, W.action), W = W.next;
        while (W !== null);
        return gt.memoizedState = X, [X, U];
      }
      return [gt.memoizedState, U];
    }
    return C = C === _l ? typeof U == "function" ? U() : U : W !== void 0 ? W(U) : U, gt.memoizedState = C, C = gt.queue = { last: null, dispatch: null }, C = C.dispatch = Wu.bind(null, Dr, C), [gt.memoizedState, C];
  }
  function kl(C, U) {
    if (Dr = Lr(), gt = ms(), U = U === void 0 ? null : U, gt !== null) {
      var W = gt.memoizedState;
      if (W !== null && U !== null) {
        var X = W[1];
        e: if (X === null) X = !1;
        else {
          for (var ye = 0; ye < X.length && ye < U.length; ye++) if (!Pu(U[ye], X[ye])) {
            X = !1;
            break e;
          }
          X = !0;
        }
        if (X) return W[0];
      }
    }
    return C = C(), gt.memoizedState = [C, U], C;
  }
  function Wu(C, U, W) {
    if (25 <= ra) throw Error(e(301));
    if (C === Dr) if (na = !0, C = { action: W, next: null }, Wr === null && (Wr = /* @__PURE__ */ new Map()), W = Wr.get(U), W === void 0) Wr.set(U, C);
    else {
      for (U = W; U.next !== null; ) U = U.next;
      U.next = C;
    }
  }
  function Lu() {
    throw Error(e(394));
  }
  function oa() {
  }
  var Al = { readContext: function(C) {
    return C._currentValue;
  }, useContext: function(C) {
    return Lr(), C._currentValue;
  }, useMemo: kl, useReducer: ia, useRef: function(C) {
    Dr = Lr(), gt = ms();
    var U = gt.memoizedState;
    return U === null ? (C = { current: C }, gt.memoizedState = C) : U;
  }, useState: function(C) {
    return ia(_l, C);
  }, useInsertionEffect: oa, useLayoutEffect: function() {
  }, useCallback: function(C, U) {
    return kl(function() {
      return C;
    }, U);
  }, useImperativeHandle: oa, useEffect: oa, useDebugValue: oa, useDeferredValue: function(C) {
    return Lr(), C;
  }, useTransition: function() {
    return Lr(), [!1, Lu];
  }, useId: function() {
    var C = gs.treeContext, U = C.overflow;
    C = C.id, C = (C & ~(1 << 32 - ni(C) - 1)).toString(32) + U;
    var W = uo;
    if (W === null) throw Error(e(404));
    return U = ii++, C = ":" + W.idPrefix + "R" + C, 0 < U && (C += "H" + U.toString(32)), C + ":";
  }, useMutableSource: function(C, U) {
    return Lr(), U(C._source);
  }, useSyncExternalStore: function(C, U, W) {
    if (W === void 0) throw Error(e(407));
    return W();
  } }, uo = null, ys = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function zu(C) {
    return console.error(C), null;
  }
  function Ai() {
  }
  function bs(C, U, W, X, ye, he, Te, Ie, Xe) {
    var Qe = [], Ze = /* @__PURE__ */ new Set();
    return U = { destination: null, responseState: U, progressiveChunkSize: X === void 0 ? 12800 : X, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: Ze, pingedTasks: Qe, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: ye === void 0 ? zu : ye, onAllReady: he === void 0 ? Ai : he, onShellReady: Te === void 0 ? Ai : Te, onShellError: Ie === void 0 ? Ai : Ie, onFatalError: Xe === void 0 ? Ai : Xe }, W = Ui(U, 0, null, W, !1, !1), W.parentFlushed = !0, C = vs(U, C, null, W, Ze, je, null, ti), Qe.push(C), U;
  }
  function vs(C, U, W, X, ye, he, Te, Ie) {
    C.allPendingTasks++, W === null ? C.pendingRootTasks++ : W.pendingTasks++;
    var Xe = { node: U, ping: function() {
      var Qe = C.pingedTasks;
      Qe.push(Xe), Qe.length === 1 && Ml(C);
    }, blockedBoundary: W, blockedSegment: X, abortSet: ye, legacyContext: he, context: Te, treeContext: Ie };
    return ye.add(Xe), Xe;
  }
  function Ui(C, U, W, X, ye, he) {
    return { status: 0, id: -1, index: U, parentFlushed: !1, chunks: [], children: [], formatContext: X, boundary: W, lastPushedText: ye, textEmbedded: he };
  }
  function fo(C, U) {
    if (C = C.onError(U), C != null && typeof C != "string") throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof C + '" instead');
    return C;
  }
  function aa(C, U) {
    var W = C.onShellError;
    W(U), W = C.onFatalError, W(U), C.destination !== null ? (C.status = 2, f(C.destination, U)) : (C.status = 1, C.fatalError = U);
  }
  function Ul(C, U, W, X, ye) {
    for (Dr = {}, gs = U, ii = 0, C = W(X, ye); na; ) na = !1, ii = 0, ra += 1, gt = null, C = W(X, ye);
    return co(), C;
  }
  function Fl(C, U, W, X) {
    var ye = W.render(), he = X.childContextTypes;
    if (he != null) {
      var Te = U.legacyContext;
      if (typeof W.getChildContext != "function") X = Te;
      else {
        W = W.getChildContext();
        for (var Ie in W) if (!(Ie in he)) throw Error(e(108, Oe(X) || "Unknown", Ie));
        X = rr({}, Te, W);
      }
      U.legacyContext = X, cn(C, U, ye), U.legacyContext = Te;
    } else cn(C, U, ye);
  }
  function Rl(C, U) {
    if (C && C.defaultProps) {
      U = rr({}, U), C = C.defaultProps;
      for (var W in C) U[W] === void 0 && (U[W] = C[W]);
      return U;
    }
    return U;
  }
  function sa(C, U, W, X, ye) {
    if (typeof W == "function") if (W.prototype && W.prototype.isReactComponent) {
      ye = qe(W, U.legacyContext);
      var he = W.contextType;
      he = new W(X, typeof he == "object" && he !== null ? he._currentValue : ye), Pr(he, W, X, ye), Fl(C, U, he, W);
    } else {
      he = qe(W, U.legacyContext), ye = Ul(C, U, W, X, he);
      var Te = ii !== 0;
      if (typeof ye == "object" && ye !== null && typeof ye.render == "function" && ye.$$typeof === void 0) Pr(ye, W, X, he), Fl(C, U, ye, W);
      else if (Te) {
        X = U.treeContext, U.treeContext = xr(X, 1, 0);
        try {
          cn(C, U, ye);
        } finally {
          U.treeContext = X;
        }
      } else cn(C, U, ye);
    }
    else if (typeof W == "string") {
      switch (ye = U.blockedSegment, he = ce(ye.chunks, W, X, C.responseState, ye.formatContext), ye.lastPushedText = !1, Te = ye.formatContext, ye.formatContext = V(Te, W, X), la(C, U, he), ye.formatContext = Te, W) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          ye.chunks.push(xe, l(W), Be);
      }
      ye.lastPushedText = !1;
    } else {
      switch (W) {
        case me:
        case J:
        case Ei:
        case wn:
        case ei:
          cn(C, U, X.children);
          return;
        case ln:
          cn(C, U, X.children);
          return;
        case z:
          throw Error(e(343));
        case Lt:
          e: {
            W = U.blockedBoundary, ye = U.blockedSegment, he = X.fallback, X = X.children, Te = /* @__PURE__ */ new Set();
            var Ie = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: Te, errorDigest: null }, Xe = Ui(C, ye.chunks.length, Ie, ye.formatContext, !1, !1);
            ye.children.push(Xe), ye.lastPushedText = !1;
            var Qe = Ui(C, 0, null, ye.formatContext, !1, !1);
            Qe.parentFlushed = !0, U.blockedBoundary = Ie, U.blockedSegment = Qe;
            try {
              if (la(
                C,
                U,
                X
              ), Qe.lastPushedText && Qe.textEmbedded && Qe.chunks.push(P), Qe.status = 1, ca(Ie, Qe), Ie.pendingTasks === 0) break e;
            } catch (Ze) {
              Qe.status = 4, Ie.forceClientRender = !0, Ie.errorDigest = fo(C, Ze);
            } finally {
              U.blockedBoundary = W, U.blockedSegment = ye;
            }
            U = vs(C, he, W, Xe, Te, U.legacyContext, U.context, U.treeContext), C.pingedTasks.push(U);
          }
          return;
      }
      if (typeof W == "object" && W !== null) switch (W.$$typeof) {
        case _i:
          if (X = Ul(C, U, W.render, X, ye), ii !== 0) {
            W = U.treeContext, U.treeContext = xr(W, 1, 0);
            try {
              cn(C, U, X);
            } finally {
              U.treeContext = W;
            }
          } else cn(C, U, X);
          return;
        case T:
          W = W.type, X = Rl(W, X), sa(C, U, W, X, ye);
          return;
        case ir:
          if (ye = X.children, W = W._context, X = X.value, he = W._currentValue, W._currentValue = X, Te = Ve, Ve = X = { parent: Te, depth: Te === null ? 0 : Te.depth + 1, context: W, parentValue: he, value: X }, U.context = X, cn(C, U, ye), C = Ve, C === null) throw Error(e(403));
          X = C.parentValue, C.context._currentValue = X === fe ? C.context._defaultValue : X, C = Ve = C.parent, U.context = C;
          return;
        case Gt:
          X = X.children, X = X(W._currentValue), cn(C, U, X);
          return;
        case F:
          ye = W._init, W = ye(W._payload), X = Rl(W, X), sa(C, U, W, X, void 0);
          return;
      }
      throw Error(e(
        130,
        W == null ? W : typeof W,
        ""
      ));
    }
  }
  function cn(C, U, W) {
    if (U.node = W, typeof W == "object" && W !== null) {
      switch (W.$$typeof) {
        case Xt:
          sa(C, U, W.type, W.props, W.ref);
          return;
        case Mr:
          throw Error(e(257));
        case F:
          var X = W._init;
          W = X(W._payload), cn(C, U, W);
          return;
      }
      if (le(W)) {
        Ol(C, U, W);
        return;
      }
      if (W === null || typeof W != "object" ? X = null : (X = De && W[De] || W["@@iterator"], X = typeof X == "function" ? X : null), X && (X = X.call(W))) {
        if (W = X.next(), !W.done) {
          var ye = [];
          do
            ye.push(W.value), W = X.next();
          while (!W.done);
          Ol(C, U, ye);
        }
        return;
      }
      throw C = Object.prototype.toString.call(W), Error(e(31, C === "[object Object]" ? "object with keys {" + Object.keys(W).join(", ") + "}" : C));
    }
    typeof W == "string" ? (X = U.blockedSegment, X.lastPushedText = pe(U.blockedSegment.chunks, W, C.responseState, X.lastPushedText)) : typeof W == "number" && (X = U.blockedSegment, X.lastPushedText = pe(U.blockedSegment.chunks, "" + W, C.responseState, X.lastPushedText));
  }
  function Ol(C, U, W) {
    for (var X = W.length, ye = 0; ye < X; ye++) {
      var he = U.treeContext;
      U.treeContext = xr(he, X, ye);
      try {
        la(C, U, W[ye]);
      } finally {
        U.treeContext = he;
      }
    }
  }
  function la(C, U, W) {
    var X = U.blockedSegment.formatContext, ye = U.legacyContext, he = U.context;
    try {
      return cn(C, U, W);
    } catch (Xe) {
      if (co(), typeof Xe == "object" && Xe !== null && typeof Xe.then == "function") {
        W = Xe;
        var Te = U.blockedSegment, Ie = Ui(C, Te.chunks.length, null, Te.formatContext, Te.lastPushedText, !0);
        Te.children.push(Ie), Te.lastPushedText = !1, C = vs(C, U.node, U.blockedBoundary, Ie, U.abortSet, U.legacyContext, U.context, U.treeContext).ping, W.then(C, C), U.blockedSegment.formatContext = X, U.legacyContext = ye, U.context = he, or(he);
      } else throw U.blockedSegment.formatContext = X, U.legacyContext = ye, U.context = he, or(he), Xe;
    }
  }
  function $u(C) {
    var U = C.blockedBoundary;
    C = C.blockedSegment, C.status = 3, Bl(this, U, C);
  }
  function Il(C, U, W) {
    var X = C.blockedBoundary;
    C.blockedSegment.status = 3, X === null ? (U.allPendingTasks--, U.status !== 2 && (U.status = 2, U.destination !== null && U.destination.close())) : (X.pendingTasks--, X.forceClientRender || (X.forceClientRender = !0, C = W === void 0 ? Error(e(432)) : W, X.errorDigest = U.onError(C), X.parentFlushed && U.clientRenderedBoundaries.push(X)), X.fallbackAbortableTasks.forEach(function(ye) {
      return Il(ye, U, W);
    }), X.fallbackAbortableTasks.clear(), U.allPendingTasks--, U.allPendingTasks === 0 && (X = U.onAllReady, X()));
  }
  function ca(C, U) {
    if (U.chunks.length === 0 && U.children.length === 1 && U.children[0].boundary === null) {
      var W = U.children[0];
      W.id = U.id, W.parentFlushed = !0, W.status === 1 && ca(C, W);
    } else C.completedSegments.push(U);
  }
  function Bl(C, U, W) {
    if (U === null) {
      if (W.parentFlushed) {
        if (C.completedRootSegment !== null) throw Error(e(389));
        C.completedRootSegment = W;
      }
      C.pendingRootTasks--, C.pendingRootTasks === 0 && (C.onShellError = Ai, U = C.onShellReady, U());
    } else U.pendingTasks--, U.forceClientRender || (U.pendingTasks === 0 ? (W.parentFlushed && W.status === 1 && ca(U, W), U.parentFlushed && C.completedBoundaries.push(U), U.fallbackAbortableTasks.forEach($u, C), U.fallbackAbortableTasks.clear()) : W.parentFlushed && W.status === 1 && (ca(U, W), U.completedSegments.length === 1 && U.parentFlushed && C.partialBoundaries.push(U)));
    C.allPendingTasks--, C.allPendingTasks === 0 && (C = C.onAllReady, C());
  }
  function Ml(C) {
    if (C.status !== 2) {
      var U = Ve, W = ys.current;
      ys.current = Al;
      var X = uo;
      uo = C.responseState;
      try {
        var ye = C.pingedTasks, he;
        for (he = 0; he < ye.length; he++) {
          var Te = ye[he], Ie = C, Xe = Te.blockedSegment;
          if (Xe.status === 0) {
            or(Te.context);
            try {
              cn(Ie, Te, Te.node), Xe.lastPushedText && Xe.textEmbedded && Xe.chunks.push(P), Te.abortSet.delete(Te), Xe.status = 1, Bl(Ie, Te.blockedBoundary, Xe);
            } catch (Ln) {
              if (co(), typeof Ln == "object" && Ln !== null && typeof Ln.then == "function") {
                var Qe = Te.ping;
                Ln.then(Qe, Qe);
              } else {
                Te.abortSet.delete(Te), Xe.status = 4;
                var Ze = Te.blockedBoundary, bt = Ln, un = fo(Ie, bt);
                if (Ze === null ? aa(Ie, bt) : (Ze.pendingTasks--, Ze.forceClientRender || (Ze.forceClientRender = !0, Ze.errorDigest = un, Ze.parentFlushed && Ie.clientRenderedBoundaries.push(Ze))), Ie.allPendingTasks--, Ie.allPendingTasks === 0) {
                  var Wn = Ie.onAllReady;
                  Wn();
                }
              }
            } finally {
            }
          }
        }
        ye.splice(0, he), C.destination !== null && xs(C, C.destination);
      } catch (Ln) {
        fo(C, Ln), aa(C, Ln);
      } finally {
        uo = X, ys.current = W, W === Al && or(U);
      }
    }
  }
  function ua(C, U, W) {
    switch (W.parentFlushed = !0, W.status) {
      case 0:
        var X = W.id = C.nextSegmentId++;
        return W.lastPushedText = !1, W.textEmbedded = !1, C = C.responseState, i(U, Me), i(U, C.placeholderPrefix), C = l(X.toString(16)), i(U, C), o(U, Je);
      case 1:
        W.status = 2;
        var ye = !0;
        X = W.chunks;
        var he = 0;
        W = W.children;
        for (var Te = 0; Te < W.length; Te++) {
          for (ye = W[Te]; he < ye.index; he++) i(U, X[he]);
          ye = fa(C, U, ye);
        }
        for (; he < X.length - 1; he++) i(U, X[he]);
        return he < X.length && (ye = o(U, X[he])), ye;
      default:
        throw Error(e(390));
    }
  }
  function fa(C, U, W) {
    var X = W.boundary;
    if (X === null) return ua(C, U, W);
    if (X.parentFlushed = !0, X.forceClientRender) X = X.errorDigest, o(U, nt), i(U, Bn), X && (i(U, Ur), i(U, l(N(X))), i(U, At)), o(U, xi), ua(C, U, W);
    else if (0 < X.pendingTasks) {
      X.rootSegmentID = C.nextSegmentId++, 0 < X.completedSegments.length && C.partialBoundaries.push(X);
      var ye = C.responseState, he = ye.nextSuspenseID++;
      ye = u(ye.boundaryPrefix + he.toString(16)), X = X.id = ye, jt(U, C.responseState, X), ua(C, U, W);
    } else if (X.byteSize > C.progressiveChunkSize) X.rootSegmentID = C.nextSegmentId++, C.completedBoundaries.push(X), jt(U, C.responseState, X.id), ua(C, U, W);
    else {
      if (o(U, He), W = X.completedSegments, W.length !== 1) throw Error(e(391));
      fa(C, U, W[0]);
    }
    return o(U, Bt);
  }
  function Nl(C, U, W) {
    return an(U, C.responseState, W.formatContext, W.id), fa(C, U, W), Qn(U, W.formatContext);
  }
  function Pl(C, U, W) {
    for (var X = W.completedSegments, ye = 0; ye < X.length; ye++) Wl(C, U, W, X[ye]);
    if (X.length = 0, C = C.responseState, X = W.id, W = W.rootSegmentID, i(U, C.startInlineScript), C.sentCompleteBoundaryFunction ? i(U, sn) : (C.sentCompleteBoundaryFunction = !0, i(U, Ir)), X === null) throw Error(e(395));
    return W = l(W.toString(16)), i(U, X), i(U, Ko), i(U, C.segmentPrefix), i(U, W), o(U, Qo);
  }
  function Wl(C, U, W, X) {
    if (X.status === 2) return !0;
    var ye = X.id;
    if (ye === -1) {
      if ((X.id = W.rootSegmentID) === -1) throw Error(e(392));
      return Nl(C, U, X);
    }
    return Nl(C, U, X), C = C.responseState, i(U, C.startInlineScript), C.sentCompleteSegmentFunction ? i(U, Rr) : (C.sentCompleteSegmentFunction = !0, i(U, Ti)), i(U, C.segmentPrefix), ye = l(ye.toString(16)), i(U, ye), i(U, Or), i(U, C.placeholderPrefix), i(U, ye), o(U, er);
  }
  function xs(C, U) {
    n = new Uint8Array(512), r = 0;
    try {
      var W = C.completedRootSegment;
      if (W !== null && C.pendingRootTasks === 0) {
        fa(C, U, W), C.completedRootSegment = null;
        var X = C.responseState.bootstrapChunks;
        for (W = 0; W < X.length - 1; W++) i(U, X[W]);
        W < X.length && o(U, X[W]);
      }
      var ye = C.clientRenderedBoundaries, he;
      for (he = 0; he < ye.length; he++) {
        var Te = ye[he];
        X = U;
        var Ie = C.responseState, Xe = Te.id, Qe = Te.errorDigest, Ze = Te.errorMessage, bt = Te.errorComponentStack;
        if (i(X, Ie.startInlineScript), Ie.sentClientRenderFunction ? i(X, Ft) : (Ie.sentClientRenderFunction = !0, i(
          X,
          vr
        )), Xe === null) throw Error(e(395));
        i(X, Xe), i(X, tr), (Qe || Ze || bt) && (i(X, Br), i(X, l(Nn(Qe || "")))), (Ze || bt) && (i(X, Br), i(X, l(Nn(Ze || "")))), bt && (i(X, Br), i(X, l(Nn(bt)))), o(X, nr);
      }
      ye.splice(0, he);
      var un = C.completedBoundaries;
      for (he = 0; he < un.length; he++) Pl(C, U, un[he]);
      un.splice(0, he), a(U), n = new Uint8Array(512), r = 0;
      var Wn = C.partialBoundaries;
      for (he = 0; he < Wn.length; he++) {
        var Ln = Wn[he];
        e: {
          ye = C, Te = U;
          var da = Ln.completedSegments;
          for (Ie = 0; Ie < da.length; Ie++) if (!Wl(
            ye,
            Te,
            Ln,
            da[Ie]
          )) {
            Ie++, da.splice(0, Ie);
            var zl = !1;
            break e;
          }
          da.splice(0, Ie), zl = !0;
        }
        if (!zl) {
          C.destination = null, he++, Wn.splice(0, he);
          return;
        }
      }
      Wn.splice(0, he);
      var ho = C.completedBoundaries;
      for (he = 0; he < ho.length; he++) Pl(C, U, ho[he]);
      ho.splice(0, he);
    } finally {
      a(U), C.allPendingTasks === 0 && C.pingedTasks.length === 0 && C.clientRenderedBoundaries.length === 0 && C.completedBoundaries.length === 0 && U.close();
    }
  }
  function Ll(C, U) {
    try {
      var W = C.abortableTasks;
      W.forEach(function(X) {
        return Il(X, C, U);
      }), W.clear(), C.destination !== null && xs(C, C.destination);
    } catch (X) {
      fo(C, X), aa(C, X);
    }
  }
  return mp.renderToReadableStream = function(C, U) {
    return new Promise(function(W, X) {
      var ye, he, Te = new Promise(function(Ze, bt) {
        he = Ze, ye = bt;
      }), Ie = bs(C, G(U ? U.identifierPrefix : void 0, U ? U.nonce : void 0, U ? U.bootstrapScriptContent : void 0, U ? U.bootstrapScripts : void 0, U ? U.bootstrapModules : void 0), re(U ? U.namespaceURI : void 0), U ? U.progressiveChunkSize : void 0, U ? U.onError : void 0, he, function() {
        var Ze = new ReadableStream({ type: "bytes", pull: function(bt) {
          if (Ie.status === 1) Ie.status = 2, f(bt, Ie.fatalError);
          else if (Ie.status !== 2 && Ie.destination === null) {
            Ie.destination = bt;
            try {
              xs(Ie, bt);
            } catch (un) {
              fo(Ie, un), aa(Ie, un);
            }
          }
        }, cancel: function() {
          Ll(Ie);
        } }, { highWaterMark: 0 });
        Ze.allReady = Te, W(Ze);
      }, function(Ze) {
        Te.catch(function() {
        }), X(Ze);
      }, ye);
      if (U && U.signal) {
        var Xe = U.signal, Qe = function() {
          Ll(Ie, Xe.reason), Xe.removeEventListener("abort", Qe);
        };
        Xe.addEventListener("abort", Qe);
      }
      Ml(Ie);
    });
  }, mp.version = "18.3.1", mp;
}
var Js = {};
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var t_;
function $G() {
  return t_ || (t_ = 1, process.env.NODE_ENV !== "production" && function() {
    var t = um, e = "18.3.1", n = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(c) {
      {
        for (var d = arguments.length, g = new Array(d > 1 ? d - 1 : 0), w = 1; w < d; w++)
          g[w - 1] = arguments[w];
        o("warn", c, g);
      }
    }
    function i(c) {
      {
        for (var d = arguments.length, g = new Array(d > 1 ? d - 1 : 0), w = 1; w < d; w++)
          g[w - 1] = arguments[w];
        o("error", c, g);
      }
    }
    function o(c, d, g) {
      {
        var w = n.ReactDebugCurrentFrame, _ = w.getStackAddendum();
        _ !== "" && (d += "%s", g = g.concat([_]));
        var B = g.map(function(L) {
          return String(L);
        });
        B.unshift("Warning: " + d), Function.prototype.apply.call(console[c], console, B);
      }
    }
    function a(c) {
      c();
    }
    function s(c) {
    }
    function l(c, d) {
      u(c, d);
    }
    function u(c, d) {
      return c.push(d);
    }
    function f(c) {
    }
    function h(c) {
      c.push(null);
    }
    function p(c) {
      return c;
    }
    function y(c) {
      return c;
    }
    function b(c, d) {
      c.destroy(d);
    }
    function x(c) {
      {
        var d = typeof Symbol == "function" && Symbol.toStringTag, g = d && c[Symbol.toStringTag] || c.constructor.name || "Object";
        return g;
      }
    }
    function v(c) {
      try {
        return D(c), !1;
      } catch {
        return !0;
      }
    }
    function D(c) {
      return "" + c;
    }
    function S(c, d) {
      if (v(c))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", d, x(c)), D(c);
    }
    function E(c, d) {
      if (v(c))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", d, x(c)), D(c);
    }
    function I(c) {
      if (v(c))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", x(c)), D(c);
    }
    var R = Object.prototype.hasOwnProperty, O = 0, N = 1, q = 2, $ = 3, le = 4, ve = 5, M = 6, ee = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", A = ee + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", oe = new RegExp("^[" + ee + "][" + A + "]*$"), j = {}, Q = {};
    function G(c) {
      return R.call(Q, c) ? !0 : R.call(j, c) ? !1 : oe.test(c) ? (Q[c] = !0, !0) : (j[c] = !0, i("Invalid attribute name: `%s`", c), !1);
    }
    function Z(c, d, g, w) {
      if (g !== null && g.type === O)
        return !1;
      switch (typeof d) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (g !== null)
            return !g.acceptsBooleans;
          var _ = c.toLowerCase().slice(0, 5);
          return _ !== "data-" && _ !== "aria-";
        }
        default:
          return !1;
      }
    }
    function re(c) {
      return P.hasOwnProperty(c) ? P[c] : null;
    }
    function V(c, d, g, w, _, B, L) {
      this.acceptsBooleans = d === q || d === $ || d === le, this.attributeName = w, this.attributeNamespace = _, this.mustUseProperty = g, this.propertyName = c, this.type = d, this.sanitizeURL = B, this.removeEmptyString = L;
    }
    var P = {}, pe = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    pe.forEach(function(c) {
      P[c] = new V(
        c,
        O,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(c) {
      var d = c[0], g = c[1];
      P[d] = new V(
        d,
        N,
        !1,
        // mustUseProperty
        g,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(c) {
      P[c] = new V(
        c,
        q,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(c) {
      P[c] = new V(
        c,
        q,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(c) {
      P[c] = new V(
        c,
        $,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      P[c] = new V(
        c,
        $,
        !0,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      P[c] = new V(
        c,
        le,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      P[c] = new V(
        c,
        M,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(c) {
      P[c] = new V(
        c,
        ve,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var we = /[\-\:]([a-z])/g, be = function(c) {
      return c[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      var d = c.replace(we, be);
      P[d] = new V(
        d,
        N,
        !1,
        // mustUseProperty
        c,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      var d = c.replace(we, be);
      P[d] = new V(
        d,
        N,
        !1,
        // mustUseProperty
        c,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      var d = c.replace(we, be);
      P[d] = new V(
        d,
        N,
        !1,
        // mustUseProperty
        c,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(c) {
      P[c] = new V(
        c,
        N,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var _e = "xlinkHref";
    P[_e] = new V(
      "xlinkHref",
      N,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(c) {
      P[c] = new V(
        c,
        N,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var $e = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Le(c, d) {
      return c + d.charAt(0).toUpperCase() + d.substring(1);
    }
    var ze = ["Webkit", "ms", "Moz", "O"];
    Object.keys($e).forEach(function(c) {
      ze.forEach(function(d) {
        $e[Le(d, c)] = $e[c];
      });
    });
    var tt = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function ie(c, d) {
      tt[d.type] || d.onChange || d.onInput || d.readOnly || d.disabled || d.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), d.onChange || d.readOnly || d.disabled || d.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Ee(c, d) {
      if (c.indexOf("-") === -1)
        return typeof d.is == "string";
      switch (c) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Re = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, k = {}, ge = new RegExp("^(aria)-[" + A + "]*$"), ue = new RegExp("^(aria)[A-Z][" + A + "]*$");
    function Y(c, d) {
      {
        if (R.call(k, d) && k[d])
          return !0;
        if (ue.test(d)) {
          var g = "aria-" + d.slice(4).toLowerCase(), w = Re.hasOwnProperty(g) ? g : null;
          if (w == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", d), k[d] = !0, !0;
          if (d !== w)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", d, w), k[d] = !0, !0;
        }
        if (ge.test(d)) {
          var _ = d.toLowerCase(), B = Re.hasOwnProperty(_) ? _ : null;
          if (B == null)
            return k[d] = !0, !1;
          if (d !== B)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", d, B), k[d] = !0, !0;
        }
      }
      return !0;
    }
    function H(c, d) {
      {
        var g = [];
        for (var w in d) {
          var _ = Y(c, w);
          _ || g.push(w);
        }
        var B = g.map(function(L) {
          return "`" + L + "`";
        }).join(", ");
        g.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", B, c) : g.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", B, c);
      }
    }
    function ae(c, d) {
      Ee(c, d) || H(c, d);
    }
    var Se = !1;
    function ke(c, d) {
      {
        if (c !== "input" && c !== "textarea" && c !== "select")
          return;
        d != null && d.value === null && !Se && (Se = !0, c === "select" && d.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", c) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", c));
      }
    }
    var se = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, K = function() {
    };
    {
      var ne = {}, ce = /^on./, xe = /^on[^A-Z]/, Be = new RegExp("^(aria)-[" + A + "]*$"), Me = new RegExp("^(aria)[A-Z][" + A + "]*$");
      K = function(c, d, g, w) {
        if (R.call(ne, d) && ne[d])
          return !0;
        var _ = d.toLowerCase();
        if (_ === "onfocusin" || _ === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), ne[d] = !0, !0;
        if (w != null) {
          var B = w.registrationNameDependencies, L = w.possibleRegistrationNames;
          if (B.hasOwnProperty(d))
            return !0;
          var te = L.hasOwnProperty(_) ? L[_] : null;
          if (te != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", d, te), ne[d] = !0, !0;
          if (ce.test(d))
            return i("Unknown event handler property `%s`. It will be ignored.", d), ne[d] = !0, !0;
        } else if (ce.test(d))
          return xe.test(d) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", d), ne[d] = !0, !0;
        if (Be.test(d) || Me.test(d))
          return !0;
        if (_ === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), ne[d] = !0, !0;
        if (_ === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), ne[d] = !0, !0;
        if (_ === "is" && g !== null && g !== void 0 && typeof g != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof g), ne[d] = !0, !0;
        if (typeof g == "number" && isNaN(g))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", d), ne[d] = !0, !0;
        var de = re(d), Ce = de !== null && de.type === O;
        if (se.hasOwnProperty(_)) {
          var Ue = se[_];
          if (Ue !== d)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", d, Ue), ne[d] = !0, !0;
        } else if (!Ce && d !== _)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", d, _), ne[d] = !0, !0;
        return typeof g == "boolean" && Z(d, g, de) ? (g ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', g, d, d, g, d) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', g, d, d, g, d, d, d), ne[d] = !0, !0) : Ce ? !0 : Z(d, g, de) ? (ne[d] = !0, !1) : ((g === "false" || g === "true") && de !== null && de.type === $ && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", g, d, g === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', d, g), ne[d] = !0), !0);
      };
    }
    var Je = function(c, d, g) {
      {
        var w = [];
        for (var _ in d) {
          var B = K(c, _, d[_], g);
          B || w.push(_);
        }
        var L = w.map(function(te) {
          return "`" + te + "`";
        }).join(", ");
        w.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", L, c) : w.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", L, c);
      }
    };
    function He(c, d, g) {
      Ee(c, d) || Je(c, d, g);
    }
    var Ke = function() {
    };
    {
      var lt = /^(?:webkit|moz|o)[A-Z]/, nt = /^-ms-/, Bt = /-(.)/g, Bn = /;\s*$/, At = {}, Ur = {}, xi = !1, jt = !1, Dn = function(c) {
        return c.replace(Bt, function(d, g) {
          return g.toUpperCase();
        });
      }, Mn = function(c) {
        At.hasOwnProperty(c) && At[c] || (At[c] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          c,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Dn(c.replace(nt, "ms-"))
        ));
      }, at = function(c) {
        At.hasOwnProperty(c) && At[c] || (At[c] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", c, c.charAt(0).toUpperCase() + c.slice(1)));
      }, on = function(c, d) {
        Ur.hasOwnProperty(d) && Ur[d] || (Ur[d] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, c, d.replace(Bn, "")));
      }, Di = function(c, d) {
        xi || (xi = !0, i("`NaN` is an invalid value for the `%s` css style property.", c));
      }, Qr = function(c, d) {
        jt || (jt = !0, i("`Infinity` is an invalid value for the `%s` css style property.", c));
      };
      Ke = function(c, d) {
        c.indexOf("-") > -1 ? Mn(c) : lt.test(c) ? at(c) : Bn.test(d) && on(c, d), typeof d == "number" && (isNaN(d) ? Di(c, d) : isFinite(d) || Qr(c, d));
      };
    }
    var Zn = Ke, wi = /["'&<>]/;
    function br(c) {
      I(c);
      var d = "" + c, g = wi.exec(d);
      if (!g)
        return d;
      var w, _ = "", B, L = 0;
      for (B = g.index; B < d.length; B++) {
        switch (d.charCodeAt(B)) {
          case 34:
            w = "&quot;";
            break;
          case 38:
            w = "&amp;";
            break;
          case 39:
            w = "&#x27;";
            break;
          case 60:
            w = "&lt;";
            break;
          case 62:
            w = "&gt;";
            break;
          default:
            continue;
        }
        L !== B && (_ += d.substring(L, B)), L = B + 1, _ += w;
      }
      return L !== B ? _ + d.substring(L, B) : _;
    }
    function Mt(c) {
      return typeof c == "boolean" || typeof c == "number" ? "" + c : br(c);
    }
    var oo = /([A-Z])/g, ao = /^ms-/;
    function Zo(c) {
      return c.replace(oo, "-$1").toLowerCase().replace(ao, "-ms-");
    }
    var Ut = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, so = !1;
    function hs(c) {
      !so && Ut.test(c) && (so = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(c)));
    }
    var ps = Array.isArray;
    function Kn(c) {
      return ps(c);
    }
    var lo = "<script>";
    function Si(c, d, g, w, _) {
      var B = c === void 0 ? "" : c, L = lo, te = [];
      return {
        bootstrapChunks: te,
        startInlineScript: L,
        placeholderPrefix: B + "P:",
        segmentPrefix: B + "S:",
        boundaryPrefix: B + "B:",
        idPrefix: B,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var Fr = 0, an = 1, Qn = 2, Ti = 3, Rr = 4, Or = 5, er = 6, Ir = 7;
    function sn(c, d) {
      return {
        insertionMode: c,
        selectedValue: d
      };
    }
    function Ko(c, d, g) {
      switch (d) {
        case "select":
          return sn(an, g.value != null ? g.value : g.defaultValue);
        case "svg":
          return sn(Qn, null);
        case "math":
          return sn(Ti, null);
        case "foreignObject":
          return sn(an, null);
        case "table":
          return sn(Rr, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return sn(Or, null);
        case "colgroup":
          return sn(Ir, null);
        case "tr":
          return sn(er, null);
      }
      return c.insertionMode >= Rr || c.insertionMode === Fr ? sn(an, null) : c;
    }
    var Qo = null;
    function vr(c) {
      var d = c.nextSuspenseID++;
      return c.boundaryPrefix + d.toString(16);
    }
    function Ft(c, d, g) {
      var w = c.idPrefix, _ = ":" + w + "R" + d;
      return g > 0 && (_ += "H" + g.toString(32)), _ + ":";
    }
    function tr(c) {
      return Mt(c);
    }
    var nr = "<!-- -->";
    function Br(c, d, g, w) {
      return d === "" ? w : (w && c.push(nr), c.push(tr(d)), !0);
    }
    function Ci(c, d, g, w) {
      g && w && c.push(nr);
    }
    var Nn = /* @__PURE__ */ new Map();
    function rr(c) {
      var d = Nn.get(c);
      if (d !== void 0)
        return d;
      var g = Mt(Zo(c));
      return Nn.set(c, g), g;
    }
    var Xt = ' style="', Mr = ":", ei = ";";
    function Ei(c, d, g) {
      if (typeof g != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var w = !0;
      for (var _ in g)
        if (R.call(g, _)) {
          var B = g[_];
          if (!(B == null || typeof B == "boolean" || B === "")) {
            var L = void 0, te = void 0, de = _.indexOf("--") === 0;
            de ? (L = Mt(_), E(B, _), te = Mt(("" + B).trim())) : (Zn(_, B), L = rr(_), typeof B == "number" ? B !== 0 && !R.call($e, _) ? te = B + "px" : te = "" + B : (E(B, _), te = Mt(("" + B).trim()))), w ? (w = !1, c.push(Xt, L, Mr, te)) : c.push(ei, L, Mr, te);
          }
        }
      w || c.push(Gt);
    }
    var wn = " ", ir = '="', Gt = '"', _i = '=""';
    function Lt(c, d, g, w) {
      switch (g) {
        case "style": {
          Ei(c, d, w);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(g.length > 2 && (g[0] === "o" || g[0] === "O") && (g[1] === "n" || g[1] === "N"))
      ) {
        var _ = re(g);
        if (_ !== null) {
          switch (typeof w) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!_.acceptsBooleans)
                return;
          }
          var B = _.attributeName, L = B;
          switch (_.type) {
            case $:
              w && c.push(wn, L, _i);
              return;
            case le:
              w === !0 ? c.push(wn, L, _i) : w === !1 || c.push(wn, L, ir, Mt(w), Gt);
              return;
            case ve:
              isNaN(w) || c.push(wn, L, ir, Mt(w), Gt);
              break;
            case M:
              !isNaN(w) && w >= 1 && c.push(wn, L, ir, Mt(w), Gt);
              break;
            default:
              _.sanitizeURL && (S(w, B), w = "" + w, hs(w)), c.push(wn, L, ir, Mt(w), Gt);
          }
        } else if (G(g)) {
          switch (typeof w) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var te = g.toLowerCase().slice(0, 5);
              if (te !== "data-" && te !== "aria-")
                return;
            }
          }
          c.push(wn, g, ir, Mt(w), Gt);
        }
      }
    }
    var ln = ">", T = "/>";
    function F(c, d, g) {
      if (d != null) {
        if (g != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof d != "object" || !("__html" in d))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var w = d.__html;
        w != null && (I(w), c.push("" + w));
      }
    }
    var z = !1, J = !1, me = !1, fe = !1, De = !1, Oe = !1, je = !1;
    function qe(c, d) {
      {
        var g = c[d];
        if (g != null) {
          var w = Kn(g);
          c.multiple && !w ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", d) : !c.multiple && w && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", d);
        }
      }
    }
    function Ve(c, d, g) {
      ie("select", d), qe(d, "value"), qe(d, "defaultValue"), d.value !== void 0 && d.defaultValue !== void 0 && !me && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), me = !0), c.push(ar("select"));
      var w = null, _ = null;
      for (var B in d)
        if (R.call(d, B)) {
          var L = d[B];
          if (L == null)
            continue;
          switch (B) {
            case "children":
              w = L;
              break;
            case "dangerouslySetInnerHTML":
              _ = L;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              Lt(c, g, B, L);
              break;
          }
        }
      return c.push(ln), F(c, _, w), w;
    }
    function ft(c) {
      var d = "";
      return t.Children.forEach(c, function(g) {
        g != null && (d += g, !De && typeof g != "string" && typeof g != "number" && (De = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), d;
    }
    var Jt = ' selected=""';
    function Yt(c, d, g, w) {
      var _ = w.selectedValue;
      c.push(ar("option"));
      var B = null, L = null, te = null, de = null;
      for (var Ce in d)
        if (R.call(d, Ce)) {
          var Ue = d[Ce];
          if (Ue == null)
            continue;
          switch (Ce) {
            case "children":
              B = Ue;
              break;
            case "selected":
              te = Ue, je || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), je = !0);
              break;
            case "dangerouslySetInnerHTML":
              de = Ue;
              break;
            case "value":
              L = Ue;
            default:
              Lt(c, g, Ce, Ue);
              break;
          }
        }
      if (_ != null) {
        var Pe;
        if (L !== null ? (S(L, "value"), Pe = "" + L) : (de !== null && (Oe || (Oe = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), Pe = ft(B)), Kn(_))
          for (var Ge = 0; Ge < _.length; Ge++) {
            S(_[Ge], "value");
            var pt = "" + _[Ge];
            if (pt === Pe) {
              c.push(Jt);
              break;
            }
          }
        else
          S(_, "select.value"), "" + _ === Pe && c.push(Jt);
      } else te && c.push(Jt);
      return c.push(ln), F(c, de, B), B;
    }
    function Zt(c, d, g) {
      ie("input", d), d.checked !== void 0 && d.defaultChecked !== void 0 && !J && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", d.type), J = !0), d.value !== void 0 && d.defaultValue !== void 0 && !z && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", d.type), z = !0), c.push(ar("input"));
      var w = null, _ = null, B = null, L = null;
      for (var te in d)
        if (R.call(d, te)) {
          var de = d[te];
          if (de == null)
            continue;
          switch (te) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              L = de;
              break;
            case "defaultValue":
              _ = de;
              break;
            case "checked":
              B = de;
              break;
            case "value":
              w = de;
              break;
            default:
              Lt(c, g, te, de);
              break;
          }
        }
      return B !== null ? Lt(c, g, "checked", B) : L !== null && Lt(c, g, "checked", L), w !== null ? Lt(c, g, "value", w) : _ !== null && Lt(c, g, "value", _), c.push(T), null;
    }
    function Nr(c, d, g) {
      ie("textarea", d), d.value !== void 0 && d.defaultValue !== void 0 && !fe && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), fe = !0), c.push(ar("textarea"));
      var w = null, _ = null, B = null;
      for (var L in d)
        if (R.call(d, L)) {
          var te = d[L];
          if (te == null)
            continue;
          switch (L) {
            case "children":
              B = te;
              break;
            case "value":
              w = te;
              break;
            case "defaultValue":
              _ = te;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              Lt(c, g, L, te);
              break;
          }
        }
      if (w === null && _ !== null && (w = _), c.push(ln), B != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), w != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (Kn(B)) {
          if (B.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          I(B[0]), w = "" + B[0];
        }
        I(B), w = "" + B;
      }
      return typeof w == "string" && w[0] === `
` && c.push(ni), w !== null && (S(w, "value"), c.push(tr("" + w))), null;
    }
    function or(c, d, g, w) {
      c.push(ar(g));
      for (var _ in d)
        if (R.call(d, _)) {
          var B = d[_];
          if (B == null)
            continue;
          switch (_) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(g + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              Lt(c, w, _, B);
              break;
          }
        }
      return c.push(T), null;
    }
    function ki(c, d, g) {
      c.push(ar("menuitem"));
      for (var w in d)
        if (R.call(d, w)) {
          var _ = d[w];
          if (_ == null)
            continue;
          switch (w) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              Lt(c, g, w, _);
              break;
          }
        }
      return c.push(ln), null;
    }
    function Pr(c, d, g) {
      c.push(ar("title"));
      var w = null;
      for (var _ in d)
        if (R.call(d, _)) {
          var B = d[_];
          if (B == null)
            continue;
          switch (_) {
            case "children":
              w = B;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              Lt(c, g, _, B);
              break;
          }
        }
      c.push(ln);
      {
        var L = Array.isArray(w) && w.length < 2 ? w[0] || null : w;
        Array.isArray(w) && w.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : L != null && L.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : L != null && typeof L != "string" && typeof L != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return w;
    }
    function ti(c, d, g, w) {
      c.push(ar(g));
      var _ = null, B = null;
      for (var L in d)
        if (R.call(d, L)) {
          var te = d[L];
          if (te == null)
            continue;
          switch (L) {
            case "children":
              _ = te;
              break;
            case "dangerouslySetInnerHTML":
              B = te;
              break;
            default:
              Lt(c, w, L, te);
              break;
          }
        }
      return c.push(ln), F(c, B, _), typeof _ == "string" ? (c.push(tr(_)), null) : _;
    }
    function xr(c, d, g, w) {
      c.push(ar(g));
      var _ = null, B = null;
      for (var L in d)
        if (R.call(d, L)) {
          var te = d[L];
          if (te == null)
            continue;
          switch (L) {
            case "children":
              _ = te;
              break;
            case "dangerouslySetInnerHTML":
              B = te;
              break;
            case "style":
              Ei(c, w, te);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              G(L) && typeof te != "function" && typeof te != "symbol" && c.push(wn, L, ir, Mt(te), Gt);
              break;
          }
        }
      return c.push(ln), F(c, B, _), _;
    }
    var ni = `
`;
    function Mu(c, d, g, w) {
      c.push(ar(g));
      var _ = null, B = null;
      for (var L in d)
        if (R.call(d, L)) {
          var te = d[L];
          if (te == null)
            continue;
          switch (L) {
            case "children":
              _ = te;
              break;
            case "dangerouslySetInnerHTML":
              B = te;
              break;
            default:
              Lt(c, w, L, te);
              break;
          }
        }
      if (c.push(ln), B != null) {
        if (_ != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof B != "object" || !("__html" in B))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var de = B.__html;
        de != null && (typeof de == "string" && de.length > 0 && de[0] === `
` ? c.push(ni, de) : (I(de), c.push("" + de)));
      }
      return typeof _ == "string" && _[0] === `
` && c.push(ni), _;
    }
    var Nu = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, ea = /* @__PURE__ */ new Map();
    function ar(c) {
      var d = ea.get(c);
      if (d === void 0) {
        if (!Nu.test(c))
          throw new Error("Invalid tag: " + c);
        d = "<" + c, ea.set(c, d);
      }
      return d;
    }
    var Pu = "<!DOCTYPE html>";
    function Dr(c, d, g, w, _) {
      switch (ae(d, g), ke(d, g), He(d, g, null), !g.suppressContentEditableWarning && g.contentEditable && g.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), _.insertionMode !== Qn && _.insertionMode !== Ti && d.indexOf("-") === -1 && typeof g.is != "string" && d.toLowerCase() !== d && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", d), d) {
        case "select":
          return Ve(c, g, w);
        case "option":
          return Yt(c, g, w, _);
        case "textarea":
          return Nr(c, g, w);
        case "input":
          return Zt(c, g, w);
        case "menuitem":
          return ki(c, g, w);
        case "title":
          return Pr(c, g, w);
        case "listing":
        case "pre":
          return Mu(c, g, d, w);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return or(c, g, d, w);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return ti(c, g, d, w);
        case "html":
          return _.insertionMode === Fr && c.push(Pu), ti(c, g, d, w);
        default:
          return d.indexOf("-") === -1 && typeof g.is != "string" ? ti(c, g, d, w) : xr(c, g, d, w);
      }
    }
    var gs = "</", ta = ">";
    function gt(c, d, g) {
      switch (d) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          c.push(gs, d, ta);
      }
    }
    function ri(c, d) {
      for (var g = d.bootstrapChunks, w = 0; w < g.length - 1; w++)
        l(c, g[w]);
      return w < g.length ? u(c, g[w]) : !0;
    }
    var na = '<template id="', ii = '"></template>';
    function Wr(c, d, g) {
      l(c, na), l(c, d.placeholderPrefix);
      var w = g.toString(16);
      return l(c, w), u(c, ii);
    }
    var ra = "<!--$-->", Lr = '<!--$?--><template id="', Pn = '"></template>', ms = "<!--$!-->", co = "<!--/$-->", _l = "<template", ia = '"', kl = ' data-dgst="', Wu = ' data-msg="', Lu = ' data-stck="', oa = "></template>";
    function Al(c, d) {
      return u(c, ra);
    }
    function uo(c, d, g) {
      if (l(c, Lr), g === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return l(c, g), u(c, Pn);
    }
    function ys(c, d, g, w, _) {
      var B;
      return B = u(c, ms), l(c, _l), g && (l(c, kl), l(c, Mt(g)), l(c, ia)), w && (l(c, Wu), l(c, Mt(w)), l(c, ia)), _ && (l(c, Lu), l(c, Mt(_)), l(c, ia)), B = u(c, oa), B;
    }
    function zu(c, d) {
      return u(c, co);
    }
    function Ai(c, d) {
      return u(c, co);
    }
    function bs(c, d) {
      return u(c, co);
    }
    var vs = '<div hidden id="', Ui = '">', fo = "</div>", aa = '<svg aria-hidden="true" style="display:none" id="', Ul = '">', Fl = "</svg>", Rl = '<math aria-hidden="true" style="display:none" id="', sa = '">', cn = "</math>", Ol = '<table hidden id="', la = '">', $u = "</table>", Il = '<table hidden><tbody id="', ca = '">', Bl = "</tbody></table>", Ml = '<table hidden><tr id="', ua = '">', fa = "</tr></table>", Nl = '<table hidden><colgroup id="', Pl = '">', Wl = "</colgroup></table>";
    function xs(c, d, g, w) {
      switch (g.insertionMode) {
        case Fr:
        case an:
          return l(c, vs), l(c, d.segmentPrefix), l(c, w.toString(16)), u(c, Ui);
        case Qn:
          return l(c, aa), l(c, d.segmentPrefix), l(c, w.toString(16)), u(c, Ul);
        case Ti:
          return l(c, Rl), l(c, d.segmentPrefix), l(c, w.toString(16)), u(c, sa);
        case Rr:
          return l(c, Ol), l(c, d.segmentPrefix), l(c, w.toString(16)), u(c, la);
        case Or:
          return l(c, Il), l(c, d.segmentPrefix), l(c, w.toString(16)), u(c, ca);
        case er:
          return l(c, Ml), l(c, d.segmentPrefix), l(c, w.toString(16)), u(c, ua);
        case Ir:
          return l(c, Nl), l(c, d.segmentPrefix), l(c, w.toString(16)), u(c, Pl);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Ll(c, d) {
      switch (d.insertionMode) {
        case Fr:
        case an:
          return u(c, fo);
        case Qn:
          return u(c, Fl);
        case Ti:
          return u(c, cn);
        case Rr:
          return u(c, $u);
        case Or:
          return u(c, Bl);
        case er:
          return u(c, fa);
        case Ir:
          return u(c, Wl);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var C = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", U = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', W = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', X = C + ';$RS("', ye = '$RS("', he = '","', Te = '")<\/script>';
    function Ie(c, d, g) {
      l(c, d.startInlineScript), d.sentCompleteSegmentFunction ? l(c, ye) : (d.sentCompleteSegmentFunction = !0, l(c, X)), l(c, d.segmentPrefix);
      var w = g.toString(16);
      return l(c, w), l(c, he), l(c, d.placeholderPrefix), l(c, w), u(c, Te);
    }
    var Xe = U + ';$RC("', Qe = '$RC("', Ze = '","', bt = '")<\/script>';
    function un(c, d, g, w) {
      if (l(c, d.startInlineScript), d.sentCompleteBoundaryFunction ? l(c, Qe) : (d.sentCompleteBoundaryFunction = !0, l(c, Xe)), g === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var _ = w.toString(16);
      return l(c, g), l(c, Ze), l(c, d.segmentPrefix), l(c, _), u(c, bt);
    }
    var Wn = W + ';$RX("', Ln = '$RX("', da = '"', zl = ")<\/script>", ho = ",";
    function by(c, d, g, w, _, B) {
      if (l(c, d.startInlineScript), d.sentClientRenderFunction ? l(c, Ln) : (d.sentClientRenderFunction = !0, l(c, Wn)), g === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return l(c, g), l(c, da), (w || _ || B) && (l(c, ho), l(c, ju(w || ""))), (_ || B) && (l(c, ho), l(c, ju(_ || ""))), B && (l(c, ho), l(c, ju(B))), u(c, zl);
    }
    var vy = /[<\u2028\u2029]/g;
    function ju(c) {
      var d = JSON.stringify(c);
      return d.replace(vy, function(g) {
        switch (g) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function xy(c, d) {
      var g = Si(d);
      return {
        // Keep this in sync with ReactDOMServerFormatConfig
        bootstrapChunks: g.bootstrapChunks,
        startInlineScript: g.startInlineScript,
        placeholderPrefix: g.placeholderPrefix,
        segmentPrefix: g.segmentPrefix,
        boundaryPrefix: g.boundaryPrefix,
        idPrefix: g.idPrefix,
        nextSuspenseID: g.nextSuspenseID,
        sentCompleteSegmentFunction: g.sentCompleteSegmentFunction,
        sentCompleteBoundaryFunction: g.sentCompleteBoundaryFunction,
        sentClientRenderFunction: g.sentClientRenderFunction,
        // This is an extra field for the legacy renderer
        generateStaticMarkup: c
      };
    }
    function Dy() {
      return {
        insertionMode: an,
        // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
        selectedValue: null
      };
    }
    function nh(c, d, g, w) {
      return g.generateStaticMarkup ? (c.push(Mt(d)), !1) : Br(c, d, g, w);
    }
    function rh(c, d, g, w) {
      if (!d.generateStaticMarkup)
        return Ci(c, d, g, w);
    }
    function wy(c, d) {
      return d.generateStaticMarkup ? !0 : Al(c);
    }
    function Sy(c, d, g, w, _) {
      return d.generateStaticMarkup ? !0 : ys(c, d, g, w, _);
    }
    function Ty(c, d) {
      return d.generateStaticMarkup ? !0 : zu(c);
    }
    function Cy(c, d) {
      return d.generateStaticMarkup ? !0 : bs(c);
    }
    var Sn = Object.assign, Ey = Symbol.for("react.element"), ih = Symbol.for("react.portal"), $l = Symbol.for("react.fragment"), zn = Symbol.for("react.strict_mode"), oh = Symbol.for("react.profiler"), jl = Symbol.for("react.provider"), Hl = Symbol.for("react.context"), Vl = Symbol.for("react.forward_ref"), ql = Symbol.for("react.suspense"), Ds = Symbol.for("react.suspense_list"), ws = Symbol.for("react.memo"), ha = Symbol.for("react.lazy"), Hu = Symbol.for("react.scope"), Vu = Symbol.for("react.debug_trace_mode"), qu = Symbol.for("react.legacy_hidden"), Xl = Symbol.for("react.default_value"), ah = Symbol.iterator, _y = "@@iterator";
    function ky(c) {
      if (c === null || typeof c != "object")
        return null;
      var d = ah && c[ah] || c[_y];
      return typeof d == "function" ? d : null;
    }
    function Ay(c, d, g) {
      var w = c.displayName;
      if (w)
        return w;
      var _ = d.displayName || d.name || "";
      return _ !== "" ? g + "(" + _ + ")" : g;
    }
    function Xu(c) {
      return c.displayName || "Context";
    }
    function St(c) {
      if (c == null)
        return null;
      if (typeof c.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof c == "function")
        return c.displayName || c.name || null;
      if (typeof c == "string")
        return c;
      switch (c) {
        case $l:
          return "Fragment";
        case ih:
          return "Portal";
        case oh:
          return "Profiler";
        case zn:
          return "StrictMode";
        case ql:
          return "Suspense";
        case Ds:
          return "SuspenseList";
      }
      if (typeof c == "object")
        switch (c.$$typeof) {
          case Hl:
            var d = c;
            return Xu(d) + ".Consumer";
          case jl:
            var g = c;
            return Xu(g._context) + ".Provider";
          case Vl:
            return Ay(c, c.render, "ForwardRef");
          case ws:
            var w = c.displayName || null;
            return w !== null ? w : St(c.type) || "Memo";
          case ha: {
            var _ = c, B = _._payload, L = _._init;
            try {
              return St(L(B));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Ss = 0, sh, Gu, Dt, pa, Ju, Yu, Zu;
    function Ku() {
    }
    Ku.__reactDisabledLog = !0;
    function lh() {
      {
        if (Ss === 0) {
          sh = console.log, Gu = console.info, Dt = console.warn, pa = console.error, Ju = console.group, Yu = console.groupCollapsed, Zu = console.groupEnd;
          var c = {
            configurable: !0,
            enumerable: !0,
            value: Ku,
            writable: !0
          };
          Object.defineProperties(console, {
            info: c,
            log: c,
            warn: c,
            error: c,
            group: c,
            groupCollapsed: c,
            groupEnd: c
          });
        }
        Ss++;
      }
    }
    function ch() {
      {
        if (Ss--, Ss === 0) {
          var c = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Sn({}, c, {
              value: sh
            }),
            info: Sn({}, c, {
              value: Gu
            }),
            warn: Sn({}, c, {
              value: Dt
            }),
            error: Sn({}, c, {
              value: pa
            }),
            group: Sn({}, c, {
              value: Ju
            }),
            groupCollapsed: Sn({}, c, {
              value: Yu
            }),
            groupEnd: Sn({}, c, {
              value: Zu
            })
          });
        }
        Ss < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Gl = n.ReactCurrentDispatcher, Jl;
    function Ts(c, d, g) {
      {
        if (Jl === void 0)
          try {
            throw Error();
          } catch (_) {
            var w = _.stack.trim().match(/\n( *(at )?)/);
            Jl = w && w[1] || "";
          }
        return `
` + Jl + c;
      }
    }
    var Qu = !1, ga;
    {
      var ef = typeof WeakMap == "function" ? WeakMap : Map;
      ga = new ef();
    }
    function po(c, d) {
      if (!c || Qu)
        return "";
      {
        var g = ga.get(c);
        if (g !== void 0)
          return g;
      }
      var w;
      Qu = !0;
      var _ = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var B;
      B = Gl.current, Gl.current = null, lh();
      try {
        if (d) {
          var L = function() {
            throw Error();
          };
          if (Object.defineProperty(L.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(L, []);
            } catch (Vt) {
              w = Vt;
            }
            Reflect.construct(c, [], L);
          } else {
            try {
              L.call();
            } catch (Vt) {
              w = Vt;
            }
            c.call(L.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Vt) {
            w = Vt;
          }
          c();
        }
      } catch (Vt) {
        if (Vt && w && typeof Vt.stack == "string") {
          for (var te = Vt.stack.split(`
`), de = w.stack.split(`
`), Ce = te.length - 1, Ue = de.length - 1; Ce >= 1 && Ue >= 0 && te[Ce] !== de[Ue]; )
            Ue--;
          for (; Ce >= 1 && Ue >= 0; Ce--, Ue--)
            if (te[Ce] !== de[Ue]) {
              if (Ce !== 1 || Ue !== 1)
                do
                  if (Ce--, Ue--, Ue < 0 || te[Ce] !== de[Ue]) {
                    var Pe = `
` + te[Ce].replace(" at new ", " at ");
                    return c.displayName && Pe.includes("<anonymous>") && (Pe = Pe.replace("<anonymous>", c.displayName)), typeof c == "function" && ga.set(c, Pe), Pe;
                  }
                while (Ce >= 1 && Ue >= 0);
              break;
            }
        }
      } finally {
        Qu = !1, Gl.current = B, ch(), Error.prepareStackTrace = _;
      }
      var Ge = c ? c.displayName || c.name : "", pt = Ge ? Ts(Ge) : "";
      return typeof c == "function" && ga.set(c, pt), pt;
    }
    function tf(c, d, g) {
      return po(c, !0);
    }
    function Cs(c, d, g) {
      return po(c, !1);
    }
    function Uy(c) {
      var d = c.prototype;
      return !!(d && d.isReactComponent);
    }
    function Es(c, d, g) {
      if (c == null)
        return "";
      if (typeof c == "function")
        return po(c, Uy(c));
      if (typeof c == "string")
        return Ts(c);
      switch (c) {
        case ql:
          return Ts("Suspense");
        case Ds:
          return Ts("SuspenseList");
      }
      if (typeof c == "object")
        switch (c.$$typeof) {
          case Vl:
            return Cs(c.render);
          case ws:
            return Es(c.type, d, g);
          case ha: {
            var w = c, _ = w._payload, B = w._init;
            try {
              return Es(B(_), d, g);
            } catch {
            }
          }
        }
      return "";
    }
    var uh = {}, nf = n.ReactDebugCurrentFrame;
    function Yl(c) {
      if (c) {
        var d = c._owner, g = Es(c.type, c._source, d ? d.type : null);
        nf.setExtraStackFrame(g);
      } else
        nf.setExtraStackFrame(null);
    }
    function Zl(c, d, g, w, _) {
      {
        var B = Function.call.bind(R);
        for (var L in c)
          if (B(c, L)) {
            var te = void 0;
            try {
              if (typeof c[L] != "function") {
                var de = Error((w || "React class") + ": " + g + " type `" + L + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof c[L] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw de.name = "Invariant Violation", de;
              }
              te = c[L](d, L, w, g, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ce) {
              te = Ce;
            }
            te && !(te instanceof Error) && (Yl(_), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", w || "React class", g, L, typeof te), Yl(null)), te instanceof Error && !(te.message in uh) && (uh[te.message] = !0, Yl(_), i("Failed %s type: %s", g, te.message), Yl(null));
          }
      }
    }
    var Kl;
    Kl = {};
    var _s = {};
    Object.freeze(_s);
    function ks(c, d) {
      {
        var g = c.contextTypes;
        if (!g)
          return _s;
        var w = {};
        for (var _ in g)
          w[_] = d[_];
        {
          var B = St(c) || "Unknown";
          Zl(g, w, "context", B);
        }
        return w;
      }
    }
    function fh(c, d, g, w) {
      {
        if (typeof c.getChildContext != "function") {
          {
            var _ = St(d) || "Unknown";
            Kl[_] || (Kl[_] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", _, _));
          }
          return g;
        }
        var B = c.getChildContext();
        for (var L in B)
          if (!(L in w))
            throw new Error((St(d) || "Unknown") + '.getChildContext(): key "' + L + '" is not defined in childContextTypes.');
        {
          var te = St(d) || "Unknown";
          Zl(w, B, "child context", te);
        }
        return Sn({}, g, B);
      }
    }
    var go;
    go = {};
    var Ql = null, Fi = null;
    function rf(c) {
      c.context._currentValue2 = c.parentValue;
    }
    function mo(c) {
      c.context._currentValue2 = c.value;
    }
    function ec(c, d) {
      if (c !== d) {
        rf(c);
        var g = c.parent, w = d.parent;
        if (g === null) {
          if (w !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (w === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          ec(g, w);
        }
        mo(d);
      }
    }
    function Ri(c) {
      rf(c);
      var d = c.parent;
      d !== null && Ri(d);
    }
    function tc(c) {
      var d = c.parent;
      d !== null && tc(d), mo(c);
    }
    function nc(c, d) {
      rf(c);
      var g = c.parent;
      if (g === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      g.depth === d.depth ? ec(g, d) : nc(g, d);
    }
    function As(c, d) {
      var g = d.parent;
      if (g === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      c.depth === g.depth ? ec(c, g) : As(c, g), mo(d);
    }
    function Us(c) {
      var d = Fi, g = c;
      d !== g && (d === null ? tc(g) : g === null ? Ri(d) : d.depth === g.depth ? ec(d, g) : d.depth > g.depth ? nc(d, g) : As(d, g), Fi = g);
    }
    function dh(c, d) {
      var g;
      g = c._currentValue2, c._currentValue2 = d, c._currentRenderer2 !== void 0 && c._currentRenderer2 !== null && c._currentRenderer2 !== go && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), c._currentRenderer2 = go;
      var w = Fi, _ = {
        parent: w,
        depth: w === null ? 0 : w.depth + 1,
        context: c,
        parentValue: g,
        value: d
      };
      return Fi = _, _;
    }
    function hh(c) {
      var d = Fi;
      if (d === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      d.context !== c && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var g = d.parentValue;
        g === Xl ? d.context._currentValue2 = d.context._defaultValue : d.context._currentValue2 = g, c._currentRenderer2 !== void 0 && c._currentRenderer2 !== null && c._currentRenderer2 !== go && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), c._currentRenderer2 = go;
      }
      return Fi = d.parent;
    }
    function ph() {
      return Fi;
    }
    function Oi(c) {
      var d = c._currentValue2;
      return d;
    }
    function of(c) {
      return c._reactInternals;
    }
    function Fy(c, d) {
      c._reactInternals = d;
    }
    var gh = {}, ma = {}, Fs, af, rc, ic, oc, ya, Rs, Os, ac;
    {
      Fs = /* @__PURE__ */ new Set(), af = /* @__PURE__ */ new Set(), rc = /* @__PURE__ */ new Set(), Rs = /* @__PURE__ */ new Set(), ic = /* @__PURE__ */ new Set(), Os = /* @__PURE__ */ new Set(), ac = /* @__PURE__ */ new Set();
      var Is = /* @__PURE__ */ new Set();
      ya = function(c, d) {
        if (!(c === null || typeof c == "function")) {
          var g = d + "_" + c;
          Is.has(g) || (Is.add(g), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", d, c));
        }
      }, oc = function(c, d) {
        if (d === void 0) {
          var g = St(c) || "Component";
          ic.has(g) || (ic.add(g), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", g));
        }
      };
    }
    function sc(c, d) {
      {
        var g = c.constructor, w = g && St(g) || "ReactClass", _ = w + "." + d;
        if (gh[_])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, d, d, w), gh[_] = !0;
      }
    }
    var lc = {
      isMounted: function(c) {
        return !1;
      },
      enqueueSetState: function(c, d, g) {
        var w = of(c);
        w.queue === null ? sc(c, "setState") : (w.queue.push(d), g != null && ya(g, "setState"));
      },
      enqueueReplaceState: function(c, d, g) {
        var w = of(c);
        w.replace = !0, w.queue = [d], g != null && ya(g, "setState");
      },
      enqueueForceUpdate: function(c, d) {
        var g = of(c);
        g.queue === null ? sc(c, "forceUpdate") : d != null && ya(d, "setState");
      }
    };
    function sf(c, d, g, w, _) {
      var B = g(_, w);
      oc(d, B);
      var L = B == null ? w : Sn({}, w, B);
      return L;
    }
    function mh(c, d, g) {
      var w = _s, _ = c.contextType;
      if ("contextType" in c) {
        var B = (
          // Allow null for conditional declaration
          _ === null || _ !== void 0 && _.$$typeof === Hl && _._context === void 0
        );
        if (!B && !ac.has(c)) {
          ac.add(c);
          var L = "";
          _ === void 0 ? L = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof _ != "object" ? L = " However, it is set to a " + typeof _ + "." : _.$$typeof === jl ? L = " Did you accidentally pass the Context.Provider instead?" : _._context !== void 0 ? L = " Did you accidentally pass the Context.Consumer instead?" : L = " However, it is set to an object with keys {" + Object.keys(_).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", St(c) || "Component", L);
        }
      }
      typeof _ == "object" && _ !== null ? w = Oi(_) : w = g;
      var te = new c(d, w);
      {
        if (typeof c.getDerivedStateFromProps == "function" && (te.state === null || te.state === void 0)) {
          var de = St(c) || "Component";
          Fs.has(de) || (Fs.add(de), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", de, te.state === null ? "null" : "undefined", de));
        }
        if (typeof c.getDerivedStateFromProps == "function" || typeof te.getSnapshotBeforeUpdate == "function") {
          var Ce = null, Ue = null, Pe = null;
          if (typeof te.componentWillMount == "function" && te.componentWillMount.__suppressDeprecationWarning !== !0 ? Ce = "componentWillMount" : typeof te.UNSAFE_componentWillMount == "function" && (Ce = "UNSAFE_componentWillMount"), typeof te.componentWillReceiveProps == "function" && te.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Ue = "componentWillReceiveProps" : typeof te.UNSAFE_componentWillReceiveProps == "function" && (Ue = "UNSAFE_componentWillReceiveProps"), typeof te.componentWillUpdate == "function" && te.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Pe = "componentWillUpdate" : typeof te.UNSAFE_componentWillUpdate == "function" && (Pe = "UNSAFE_componentWillUpdate"), Ce !== null || Ue !== null || Pe !== null) {
            var Ge = St(c) || "Component", pt = typeof c.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            rc.has(Ge) || (rc.add(Ge), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Ge, pt, Ce !== null ? `
  ` + Ce : "", Ue !== null ? `
  ` + Ue : "", Pe !== null ? `
  ` + Pe : ""));
          }
        }
      }
      return te;
    }
    function yh(c, d, g) {
      {
        var w = St(d) || "Component", _ = c.render;
        _ || (d.prototype && typeof d.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", w) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", w)), c.getInitialState && !c.getInitialState.isReactClassApproved && !c.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", w), c.getDefaultProps && !c.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", w), c.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", w), c.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", w), c.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", w), d.contextType && d.contextTypes && !Os.has(d) && (Os.add(d), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", w)), typeof c.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", w), d.prototype && d.prototype.isPureReactComponent && typeof c.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", St(d) || "A pure component"), typeof c.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", w), typeof c.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", w), typeof c.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", w), typeof c.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", w);
        var B = c.props !== g;
        c.props !== void 0 && B && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", w, w), c.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", w, w), typeof c.getSnapshotBeforeUpdate == "function" && typeof c.componentDidUpdate != "function" && !af.has(d) && (af.add(d), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", St(d))), typeof c.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", w), typeof c.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", w), typeof d.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", w);
        var L = c.state;
        L && (typeof L != "object" || Kn(L)) && i("%s.state: must be set to an object or null", w), typeof c.getChildContext == "function" && typeof d.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", w);
      }
    }
    function bh(c, d) {
      var g = d.state;
      if (typeof d.componentWillMount == "function") {
        if (d.componentWillMount.__suppressDeprecationWarning !== !0) {
          var w = St(c) || "Unknown";
          ma[w] || (r(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            w
          ), ma[w] = !0);
        }
        d.componentWillMount();
      }
      typeof d.UNSAFE_componentWillMount == "function" && d.UNSAFE_componentWillMount(), g !== d.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", St(c) || "Component"), lc.enqueueReplaceState(d, d.state, null));
    }
    function Ry(c, d, g, w) {
      if (c.queue !== null && c.queue.length > 0) {
        var _ = c.queue, B = c.replace;
        if (c.queue = null, c.replace = !1, B && _.length === 1)
          d.state = _[0];
        else {
          for (var L = B ? _[0] : d.state, te = !0, de = B ? 1 : 0; de < _.length; de++) {
            var Ce = _[de], Ue = typeof Ce == "function" ? Ce.call(d, L, g, w) : Ce;
            Ue != null && (te ? (te = !1, L = Sn({}, L, Ue)) : Sn(L, Ue));
          }
          d.state = L;
        }
      } else
        c.queue = null;
    }
    function vh(c, d, g, w) {
      yh(c, d, g);
      var _ = c.state !== void 0 ? c.state : null;
      c.updater = lc, c.props = g, c.state = _;
      var B = {
        queue: [],
        replace: !1
      };
      Fy(c, B);
      var L = d.contextType;
      if (typeof L == "object" && L !== null ? c.context = Oi(L) : c.context = w, c.state === g) {
        var te = St(d) || "Component";
        Rs.has(te) || (Rs.add(te), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", te));
      }
      var de = d.getDerivedStateFromProps;
      typeof de == "function" && (c.state = sf(c, d, de, _, g)), typeof d.getDerivedStateFromProps != "function" && typeof c.getSnapshotBeforeUpdate != "function" && (typeof c.UNSAFE_componentWillMount == "function" || typeof c.componentWillMount == "function") && (bh(d, c), Ry(B, c, g, w));
    }
    var Oy = {
      id: 1,
      overflow: ""
    };
    function Iy(c) {
      var d = c.overflow, g = c.id, w = g & ~By(g);
      return w.toString(32) + d;
    }
    function lf(c, d, g) {
      var w = c.id, _ = c.overflow, B = Bs(w) - 1, L = w & ~(1 << B), te = g + 1, de = Bs(d) + B;
      if (de > 30) {
        var Ce = B - B % 5, Ue = (1 << Ce) - 1, Pe = (L & Ue).toString(32), Ge = L >> Ce, pt = B - Ce, Vt = Bs(d) + pt, So = te << pt, To = So | Ge, ci = Pe + _;
        return {
          id: 1 << Vt | To,
          overflow: ci
        };
      } else {
        var Ta = te << B, hb = Ta | L, _8 = _;
        return {
          id: 1 << de | hb,
          overflow: _8
        };
      }
    }
    function Bs(c) {
      return 32 - My(c);
    }
    function By(c) {
      return 1 << Bs(c) - 1;
    }
    var My = Math.clz32 ? Math.clz32 : Ny, cf = Math.log, cc = Math.LN2;
    function Ny(c) {
      var d = c >>> 0;
      return d === 0 ? 32 : 31 - (cf(d) / cc | 0) | 0;
    }
    function Py(c, d) {
      return c === d && (c !== 0 || 1 / c === 1 / d) || c !== c && d !== d;
    }
    var Wy = typeof Object.is == "function" ? Object.is : Py, oi = null, uf = null, uc = null, xt = null, $n = !1, ba = !1, yo = 0, dt = null, Ii = 0, fc = 25, jn = !1, Hn;
    function zr() {
      if (oi === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return jn && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), oi;
    }
    function Ly(c, d) {
      if (d === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Hn), !1;
      c.length !== d.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Hn, "[" + c.join(", ") + "]", "[" + d.join(", ") + "]");
      for (var g = 0; g < d.length && g < c.length; g++)
        if (!Wy(c[g], d[g]))
          return !1;
      return !0;
    }
    function wr() {
      if (Ii > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Bi() {
      return xt === null ? uc === null ? ($n = !1, uc = xt = wr()) : ($n = !0, xt = uc) : xt.next === null ? ($n = !1, xt = xt.next = wr()) : ($n = !0, xt = xt.next), xt;
    }
    function bo(c, d) {
      oi = d, uf = c, jn = !1, yo = 0;
    }
    function zy(c, d, g, w) {
      for (; ba; )
        ba = !1, yo = 0, Ii += 1, xt = null, g = c(d, w);
      return Ms(), g;
    }
    function ff() {
      var c = yo !== 0;
      return c;
    }
    function Ms() {
      jn = !1, oi = null, uf = null, ba = !1, uc = null, Ii = 0, dt = null, xt = null;
    }
    function $y(c) {
      return jn && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), Oi(c);
    }
    function jy(c) {
      return Hn = "useContext", zr(), Oi(c);
    }
    function dc(c, d) {
      return typeof d == "function" ? d(c) : d;
    }
    function df(c) {
      return Hn = "useState", xh(
        dc,
        // useReducer has a special case to support lazy useState initializers
        c
      );
    }
    function xh(c, d, g) {
      if (c !== dc && (Hn = "useReducer"), oi = zr(), xt = Bi(), $n) {
        var w = xt.queue, _ = w.dispatch;
        if (dt !== null) {
          var B = dt.get(w);
          if (B !== void 0) {
            dt.delete(w);
            var L = xt.memoizedState, te = B;
            do {
              var de = te.action;
              jn = !0, L = c(L, de), jn = !1, te = te.next;
            } while (te !== null);
            return xt.memoizedState = L, [L, _];
          }
        }
        return [xt.memoizedState, _];
      } else {
        jn = !0;
        var Ce;
        c === dc ? Ce = typeof d == "function" ? d() : d : Ce = g !== void 0 ? g(d) : d, jn = !1, xt.memoizedState = Ce;
        var Ue = xt.queue = {
          last: null,
          dispatch: null
        }, Pe = Ue.dispatch = wh.bind(null, oi, Ue);
        return [xt.memoizedState, Pe];
      }
    }
    function Dh(c, d) {
      oi = zr(), xt = Bi();
      var g = d === void 0 ? null : d;
      if (xt !== null) {
        var w = xt.memoizedState;
        if (w !== null && g !== null) {
          var _ = w[1];
          if (Ly(g, _))
            return w[0];
        }
      }
      jn = !0;
      var B = c();
      return jn = !1, xt.memoizedState = [B, g], B;
    }
    function hf(c) {
      oi = zr(), xt = Bi();
      var d = xt.memoizedState;
      if (d === null) {
        var g = {
          current: c
        };
        return Object.seal(g), xt.memoizedState = g, g;
      } else
        return d;
    }
    function Hy(c, d) {
      Hn = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function wh(c, d, g) {
      if (Ii >= fc)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (c === oi) {
        ba = !0;
        var w = {
          action: g,
          next: null
        };
        dt === null && (dt = /* @__PURE__ */ new Map());
        var _ = dt.get(d);
        if (_ === void 0)
          dt.set(d, w);
        else {
          for (var B = _; B.next !== null; )
            B = B.next;
          B.next = w;
        }
      }
    }
    function Sh(c, d) {
      return Dh(function() {
        return c;
      }, d);
    }
    function Vy(c, d, g) {
      return zr(), d(c._source);
    }
    function qy(c, d, g) {
      if (g === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return g();
    }
    function Xy(c) {
      return zr(), c;
    }
    function Gy() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function Jy() {
      return zr(), [!1, Gy];
    }
    function Yy() {
      var c = uf, d = Iy(c.treeContext), g = pf;
      if (g === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var w = yo++;
      return Ft(g, d, w);
    }
    function hc() {
    }
    var Th = {
      readContext: $y,
      useContext: jy,
      useMemo: Dh,
      useReducer: xh,
      useRef: hf,
      useState: df,
      useInsertionEffect: hc,
      useLayoutEffect: Hy,
      useCallback: Sh,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: hc,
      // Effects are not run in the server environment.
      useEffect: hc,
      // Debugging effect
      useDebugValue: hc,
      useDeferredValue: Xy,
      useTransition: Jy,
      useId: Yy,
      // Subscriptions are not setup in a server environment.
      useMutableSource: Vy,
      useSyncExternalStore: qy
    }, pf = null;
    function Ch(c) {
      pf = c;
    }
    function pc(c) {
      try {
        var d = "", g = c;
        do {
          switch (g.tag) {
            case 0:
              d += Ts(g.type, null, null);
              break;
            case 1:
              d += Cs(g.type, null, null);
              break;
            case 2:
              d += tf(g.type, null, null);
              break;
          }
          g = g.parent;
        } while (g);
        return d;
      } catch (w) {
        return `
Error generating stack: ` + w.message + `
` + w.stack;
      }
    }
    var gc = n.ReactCurrentDispatcher, Ns = n.ReactDebugCurrentFrame, mc = 0, va = 1, yc = 2, bc = 3, vc = 4, xa = 0, gf = 1, vo = 2, Eh = 12800;
    function Zy(c) {
      return console.error(c), null;
    }
    function Da() {
    }
    function wa(c, d, g, w, _, B, L, te, de) {
      var Ce = [], Ue = /* @__PURE__ */ new Set(), Pe = {
        destination: null,
        responseState: d,
        progressiveChunkSize: w === void 0 ? Eh : w,
        status: xa,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: Ue,
        pingedTasks: Ce,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: _ === void 0 ? Zy : _,
        onAllReady: Da,
        onShellReady: L === void 0 ? Da : L,
        onShellError: Da,
        onFatalError: Da
      }, Ge = xc(
        Pe,
        0,
        null,
        g,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      Ge.parentFlushed = !0;
      var pt = xo(Pe, c, null, Ge, Ue, _s, Ql, Oy);
      return Ce.push(pt), Pe;
    }
    function Ky(c, d) {
      var g = c.pingedTasks;
      g.push(d), g.length === 1 && a(function() {
        return Cf(c);
      });
    }
    function Qy(c, d) {
      return {
        id: Qo,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: d,
        errorDigest: null
      };
    }
    function xo(c, d, g, w, _, B, L, te) {
      c.allPendingTasks++, g === null ? c.pendingRootTasks++ : g.pendingTasks++;
      var de = {
        node: d,
        ping: function() {
          return Ky(c, de);
        },
        blockedBoundary: g,
        blockedSegment: w,
        abortSet: _,
        legacyContext: B,
        context: L,
        treeContext: te
      };
      return de.componentStack = null, _.add(de), de;
    }
    function xc(c, d, g, w, _, B) {
      return {
        status: mc,
        id: -1,
        // lazily assigned later
        index: d,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: w,
        boundary: g,
        lastPushedText: _,
        textEmbedded: B
      };
    }
    var ai = null;
    function mf() {
      return ai === null || ai.componentStack === null ? "" : pc(ai.componentStack);
    }
    function Do(c, d) {
      c.componentStack = {
        tag: 0,
        parent: c.componentStack,
        type: d
      };
    }
    function Ps(c, d) {
      c.componentStack = {
        tag: 1,
        parent: c.componentStack,
        type: d
      };
    }
    function si(c, d) {
      c.componentStack = {
        tag: 2,
        parent: c.componentStack,
        type: d
      };
    }
    function $r(c) {
      c.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : c.componentStack = c.componentStack.parent;
    }
    var li = null;
    function Dc(c, d) {
      {
        var g;
        typeof d == "string" ? g = d : d && typeof d.message == "string" ? g = d.message : g = String(d);
        var w = li || mf();
        li = null, c.errorMessage = g, c.errorComponentStack = w;
      }
    }
    function Ws(c, d) {
      var g = c.onError(d);
      if (g != null && typeof g != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof g + '" instead');
      return g;
    }
    function Sr(c, d) {
      var g = c.onShellError;
      g(d);
      var w = c.onFatalError;
      w(d), c.destination !== null ? (c.status = vo, b(c.destination, d)) : (c.status = gf, c.fatalError = d);
    }
    function Ls(c, d, g) {
      Do(d, "Suspense");
      var w = d.blockedBoundary, _ = d.blockedSegment, B = g.fallback, L = g.children, te = /* @__PURE__ */ new Set(), de = Qy(c, te), Ce = _.chunks.length, Ue = xc(
        c,
        Ce,
        de,
        _.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      _.children.push(Ue), _.lastPushedText = !1;
      var Pe = xc(
        c,
        0,
        null,
        _.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      Pe.parentFlushed = !0, d.blockedBoundary = de, d.blockedSegment = Pe;
      try {
        if (fn(c, d, L), rh(Pe.chunks, c.responseState, Pe.lastPushedText, Pe.textEmbedded), Pe.status = va, Sa(de, Pe), de.pendingTasks === 0) {
          $r(d);
          return;
        }
      } catch (pt) {
        Pe.status = vc, de.forceClientRender = !0, de.errorDigest = Ws(c, pt), Dc(de, pt);
      } finally {
        d.blockedBoundary = w, d.blockedSegment = _;
      }
      var Ge = xo(c, B, w, Ue, te, d.legacyContext, d.context, d.treeContext);
      Ge.componentStack = d.componentStack, c.pingedTasks.push(Ge), $r(d);
    }
    function yf(c, d, g, w) {
      Do(d, g);
      var _ = d.blockedSegment, B = Dr(_.chunks, g, w, c.responseState, _.formatContext);
      _.lastPushedText = !1;
      var L = _.formatContext;
      _.formatContext = Ko(L, g, w), fn(c, d, B), _.formatContext = L, gt(_.chunks, g), _.lastPushedText = !1, $r(d);
    }
    function zs(c) {
      return c.prototype && c.prototype.isReactComponent;
    }
    function $s(c, d, g, w, _) {
      var B = {};
      bo(d, B);
      var L = g(w, _);
      return zy(g, w, L, _);
    }
    function _h(c, d, g, w, _) {
      var B = g.render();
      g.props !== _ && (vf || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", St(w) || "a component"), vf = !0);
      {
        var L = w.childContextTypes;
        if (L != null) {
          var te = d.legacyContext, de = fh(g, w, te, L);
          d.legacyContext = de, Vn(c, d, B), d.legacyContext = te;
          return;
        }
      }
      Vn(c, d, B);
    }
    function eb(c, d, g, w) {
      si(d, g);
      var _ = ks(g, d.legacyContext), B = mh(g, w, _);
      vh(B, g, w, _), _h(c, d, B, g, w), $r(d);
    }
    var kh = {}, js = {}, bf = {}, Ah = {}, vf = !1, Hs = {}, xf = !1, Df = !1, wf = !1;
    function Uh(c, d, g, w) {
      var _;
      if (_ = ks(g, d.legacyContext), Ps(d, g), g.prototype && typeof g.prototype.render == "function") {
        var B = St(g) || "Unknown";
        kh[B] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", B, B), kh[B] = !0);
      }
      var L = $s(c, d, g, w, _), te = ff();
      if (typeof L == "object" && L !== null && typeof L.render == "function" && L.$$typeof === void 0) {
        var de = St(g) || "Unknown";
        js[de] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", de, de, de), js[de] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof L == "object" && L !== null && typeof L.render == "function" && L.$$typeof === void 0
      ) {
        {
          var Ce = St(g) || "Unknown";
          js[Ce] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Ce, Ce, Ce), js[Ce] = !0);
        }
        vh(L, g, w, _), _h(c, d, L, g, w);
      } else if (Fh(g), te) {
        var Ue = d.treeContext, Pe = 1, Ge = 0;
        d.treeContext = lf(Ue, Pe, Ge);
        try {
          Vn(c, d, L);
        } finally {
          d.treeContext = Ue;
        }
      } else
        Vn(c, d, L);
      $r(d);
    }
    function Fh(c) {
      {
        if (c && c.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", c.displayName || c.name || "Component"), c.defaultProps !== void 0) {
          var d = St(c) || "Unknown";
          Hs[d] || (i("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", d), Hs[d] = !0);
        }
        if (typeof c.getDerivedStateFromProps == "function") {
          var g = St(c) || "Unknown";
          Ah[g] || (i("%s: Function components do not support getDerivedStateFromProps.", g), Ah[g] = !0);
        }
        if (typeof c.contextType == "object" && c.contextType !== null) {
          var w = St(c) || "Unknown";
          bf[w] || (i("%s: Function components do not support contextType.", w), bf[w] = !0);
        }
      }
    }
    function Sf(c, d) {
      if (c && c.defaultProps) {
        var g = Sn({}, d), w = c.defaultProps;
        for (var _ in w)
          g[_] === void 0 && (g[_] = w[_]);
        return g;
      }
      return d;
    }
    function Rh(c, d, g, w, _) {
      Ps(d, g.render);
      var B = $s(c, d, g.render, w, _), L = ff();
      if (L) {
        var te = d.treeContext, de = 1, Ce = 0;
        d.treeContext = lf(te, de, Ce);
        try {
          Vn(c, d, B);
        } finally {
          d.treeContext = te;
        }
      } else
        Vn(c, d, B);
      $r(d);
    }
    function tb(c, d, g, w, _) {
      var B = g.type, L = Sf(B, w);
      Tf(c, d, B, L, _);
    }
    function nb(c, d, g, w) {
      g._context === void 0 ? g !== g.Consumer && (wf || (wf = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : g = g._context;
      var _ = w.children;
      typeof _ != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var B = Oi(g), L = _(B);
      Vn(c, d, L);
    }
    function Oh(c, d, g, w) {
      var _ = g._context, B = w.value, L = w.children, te;
      te = d.context, d.context = dh(_, B), Vn(c, d, L), d.context = hh(_), te !== d.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function rb(c, d, g, w, _) {
      Do(d, "Lazy");
      var B = g._payload, L = g._init, te = L(B), de = Sf(te, w);
      Tf(c, d, te, de, _), $r(d);
    }
    function Tf(c, d, g, w, _) {
      if (typeof g == "function")
        if (zs(g)) {
          eb(c, d, g, w);
          return;
        } else {
          Uh(c, d, g, w);
          return;
        }
      if (typeof g == "string") {
        yf(c, d, g, w);
        return;
      }
      switch (g) {
        case qu:
        case Vu:
        case zn:
        case oh:
        case $l: {
          Vn(c, d, w.children);
          return;
        }
        case Ds: {
          Do(d, "SuspenseList"), Vn(c, d, w.children), $r(d);
          return;
        }
        case Hu:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case ql: {
          Ls(c, d, w);
          return;
        }
      }
      if (typeof g == "object" && g !== null)
        switch (g.$$typeof) {
          case Vl: {
            Rh(c, d, g, w, _);
            return;
          }
          case ws: {
            tb(c, d, g, w, _);
            return;
          }
          case jl: {
            Oh(c, d, g, w);
            return;
          }
          case Hl: {
            nb(c, d, g, w);
            return;
          }
          case ha: {
            rb(c, d, g, w);
            return;
          }
        }
      var B = "";
      throw (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (B += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (g == null ? g : typeof g) + "." + B));
    }
    function ib(c, d) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      c[Symbol.toStringTag] === "Generator" && (xf || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), xf = !0), c.entries === d && (Df || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Df = !0);
    }
    function Vn(c, d, g) {
      try {
        return ob(c, d, g);
      } catch (w) {
        throw typeof w == "object" && w !== null && typeof w.then == "function" || (li = li !== null ? li : mf()), w;
      }
    }
    function ob(c, d, g) {
      if (d.node = g, typeof g == "object" && g !== null) {
        switch (g.$$typeof) {
          case Ey: {
            var w = g, _ = w.type, B = w.props, L = w.ref;
            Tf(c, d, _, B, L);
            return;
          }
          case ih:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case ha: {
            var te = g, de = te._payload, Ce = te._init, Ue;
            try {
              Ue = Ce(de);
            } catch (Ta) {
              throw typeof Ta == "object" && Ta !== null && typeof Ta.then == "function" && Do(d, "Lazy"), Ta;
            }
            Vn(c, d, Ue);
            return;
          }
        }
        if (Kn(g)) {
          wc(c, d, g);
          return;
        }
        var Pe = ky(g);
        if (Pe) {
          ib(g, Pe);
          var Ge = Pe.call(g);
          if (Ge) {
            var pt = Ge.next();
            if (!pt.done) {
              var Vt = [];
              do
                Vt.push(pt.value), pt = Ge.next();
              while (!pt.done);
              wc(c, d, Vt);
              return;
            }
            return;
          }
        }
        var So = Object.prototype.toString.call(g);
        throw new Error("Objects are not valid as a React child (found: " + (So === "[object Object]" ? "object with keys {" + Object.keys(g).join(", ") + "}" : So) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof g == "string") {
        var To = d.blockedSegment;
        To.lastPushedText = nh(d.blockedSegment.chunks, g, c.responseState, To.lastPushedText);
        return;
      }
      if (typeof g == "number") {
        var ci = d.blockedSegment;
        ci.lastPushedText = nh(d.blockedSegment.chunks, "" + g, c.responseState, ci.lastPushedText);
        return;
      }
      typeof g == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function wc(c, d, g) {
      for (var w = g.length, _ = 0; _ < w; _++) {
        var B = d.treeContext;
        d.treeContext = lf(B, w, _);
        try {
          fn(c, d, g[_]);
        } finally {
          d.treeContext = B;
        }
      }
    }
    function ab(c, d, g) {
      var w = d.blockedSegment, _ = w.chunks.length, B = xc(
        c,
        _,
        null,
        w.formatContext,
        // Adopt the parent segment's leading text embed
        w.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      w.children.push(B), w.lastPushedText = !1;
      var L = xo(c, d.node, d.blockedBoundary, B, d.abortSet, d.legacyContext, d.context, d.treeContext);
      d.componentStack !== null && (L.componentStack = d.componentStack.parent);
      var te = L.ping;
      g.then(te, te);
    }
    function fn(c, d, g) {
      var w = d.blockedSegment.formatContext, _ = d.legacyContext, B = d.context, L = null;
      L = d.componentStack;
      try {
        return Vn(c, d, g);
      } catch (te) {
        if (Ms(), typeof te == "object" && te !== null && typeof te.then == "function") {
          ab(c, d, te), d.blockedSegment.formatContext = w, d.legacyContext = _, d.context = B, Us(B), d.componentStack = L;
          return;
        } else
          throw d.blockedSegment.formatContext = w, d.legacyContext = _, d.context = B, Us(B), d.componentStack = L, te;
      }
    }
    function sb(c, d, g, w) {
      var _ = Ws(c, w);
      if (d === null ? Sr(c, w) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = !0, d.errorDigest = _, Dc(d, w), d.parentFlushed && c.clientRenderedBoundaries.push(d))), c.allPendingTasks--, c.allPendingTasks === 0) {
        var B = c.onAllReady;
        B();
      }
    }
    function Ih(c) {
      var d = this, g = c.blockedBoundary, w = c.blockedSegment;
      w.status = bc, Mh(d, g, w);
    }
    function Bh(c, d, g) {
      var w = c.blockedBoundary, _ = c.blockedSegment;
      if (_.status = bc, w === null)
        d.allPendingTasks--, d.status !== vo && (d.status = vo, d.destination !== null && h(d.destination));
      else {
        if (w.pendingTasks--, !w.forceClientRender) {
          w.forceClientRender = !0;
          var B = g === void 0 ? new Error("The render was aborted by the server without a reason.") : g;
          w.errorDigest = d.onError(B);
          {
            var L = "The server did not finish this Suspense boundary: ";
            B && typeof B.message == "string" ? B = L + B.message : B = L + String(B);
            var te = ai;
            ai = c;
            try {
              Dc(w, B);
            } finally {
              ai = te;
            }
          }
          w.parentFlushed && d.clientRenderedBoundaries.push(w);
        }
        if (w.fallbackAbortableTasks.forEach(function(Ce) {
          return Bh(Ce, d, g);
        }), w.fallbackAbortableTasks.clear(), d.allPendingTasks--, d.allPendingTasks === 0) {
          var de = d.onAllReady;
          de();
        }
      }
    }
    function Sa(c, d) {
      if (d.chunks.length === 0 && d.children.length === 1 && d.children[0].boundary === null) {
        var g = d.children[0];
        g.id = d.id, g.parentFlushed = !0, g.status === va && Sa(c, g);
      } else {
        var w = c.completedSegments;
        w.push(d);
      }
    }
    function Mh(c, d, g) {
      if (d === null) {
        if (g.parentFlushed) {
          if (c.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          c.completedRootSegment = g;
        }
        if (c.pendingRootTasks--, c.pendingRootTasks === 0) {
          c.onShellError = Da;
          var w = c.onShellReady;
          w();
        }
      } else if (d.pendingTasks--, !d.forceClientRender) {
        if (d.pendingTasks === 0)
          g.parentFlushed && g.status === va && Sa(d, g), d.parentFlushed && c.completedBoundaries.push(d), d.fallbackAbortableTasks.forEach(Ih, c), d.fallbackAbortableTasks.clear();
        else if (g.parentFlushed && g.status === va) {
          Sa(d, g);
          var _ = d.completedSegments;
          _.length === 1 && d.parentFlushed && c.partialBoundaries.push(d);
        }
      }
      if (c.allPendingTasks--, c.allPendingTasks === 0) {
        var B = c.onAllReady;
        B();
      }
    }
    function lb(c, d) {
      var g = d.blockedSegment;
      if (g.status === mc) {
        Us(d.context);
        var w = null;
        w = ai, ai = d;
        try {
          Vn(c, d, d.node), rh(g.chunks, c.responseState, g.lastPushedText, g.textEmbedded), d.abortSet.delete(d), g.status = va, Mh(c, d.blockedBoundary, g);
        } catch (B) {
          if (Ms(), typeof B == "object" && B !== null && typeof B.then == "function") {
            var _ = d.ping;
            B.then(_, _);
          } else
            d.abortSet.delete(d), g.status = vc, sb(c, d.blockedBoundary, g, B);
        } finally {
          ai = w;
        }
      }
    }
    function Cf(c) {
      if (c.status !== vo) {
        var d = ph(), g = gc.current;
        gc.current = Th;
        var w;
        w = Ns.getCurrentStack, Ns.getCurrentStack = mf;
        var _ = pf;
        Ch(c.responseState);
        try {
          var B = c.pingedTasks, L;
          for (L = 0; L < B.length; L++) {
            var te = B[L];
            lb(c, te);
          }
          B.splice(0, L), c.destination !== null && Tc(c, c.destination);
        } catch (de) {
          Ws(c, de), Sr(c, de);
        } finally {
          Ch(_), gc.current = g, Ns.getCurrentStack = w, g === Th && Us(d);
        }
      }
    }
    function wo(c, d, g) {
      switch (g.parentFlushed = !0, g.status) {
        case mc: {
          var w = g.id = c.nextSegmentId++;
          return g.lastPushedText = !1, g.textEmbedded = !1, Wr(d, c.responseState, w);
        }
        case va: {
          g.status = yc;
          for (var _ = !0, B = g.chunks, L = 0, te = g.children, de = 0; de < te.length; de++) {
            for (var Ce = te[de]; L < Ce.index; L++)
              l(d, B[L]);
            _ = Vs(c, d, Ce);
          }
          for (; L < B.length - 1; L++)
            l(d, B[L]);
          return L < B.length && (_ = u(d, B[L])), _;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Vs(c, d, g) {
      var w = g.boundary;
      if (w === null)
        return wo(c, d, g);
      if (w.parentFlushed = !0, w.forceClientRender)
        return Sy(d, c.responseState, w.errorDigest, w.errorMessage, w.errorComponentStack), wo(c, d, g), Cy(d, c.responseState);
      if (w.pendingTasks > 0) {
        w.rootSegmentID = c.nextSegmentId++, w.completedSegments.length > 0 && c.partialBoundaries.push(w);
        var _ = w.id = vr(c.responseState);
        return uo(d, c.responseState, _), wo(c, d, g), Ai(d, c.responseState);
      } else {
        if (w.byteSize > c.progressiveChunkSize)
          return w.rootSegmentID = c.nextSegmentId++, c.completedBoundaries.push(w), uo(d, c.responseState, w.id), wo(c, d, g), Ai(d, c.responseState);
        wy(d, c.responseState);
        var B = w.completedSegments;
        if (B.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var L = B[0];
        return Vs(c, d, L), Ty(d, c.responseState);
      }
    }
    function cb(c, d, g) {
      return by(d, c.responseState, g.id, g.errorDigest, g.errorMessage, g.errorComponentStack);
    }
    function Ef(c, d, g) {
      return xs(d, c.responseState, g.formatContext, g.id), Vs(c, d, g), Ll(d, g.formatContext);
    }
    function qs(c, d, g) {
      for (var w = g.completedSegments, _ = 0; _ < w.length; _++) {
        var B = w[_];
        Nh(c, d, g, B);
      }
      return w.length = 0, un(d, c.responseState, g.id, g.rootSegmentID);
    }
    function Sc(c, d, g) {
      for (var w = g.completedSegments, _ = 0; _ < w.length; _++) {
        var B = w[_];
        if (!Nh(c, d, g, B))
          return _++, w.splice(0, _), !1;
      }
      return w.splice(0, _), !0;
    }
    function Nh(c, d, g, w) {
      if (w.status === yc)
        return !0;
      var _ = w.id;
      if (_ === -1) {
        var B = w.id = g.rootSegmentID;
        if (B === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Ef(c, d, w);
      } else
        return Ef(c, d, w), Ie(d, c.responseState, _);
    }
    function Tc(c, d) {
      try {
        var g = c.completedRootSegment;
        g !== null && c.pendingRootTasks === 0 && (Vs(c, d, g), c.completedRootSegment = null, ri(d, c.responseState));
        var w = c.clientRenderedBoundaries, _;
        for (_ = 0; _ < w.length; _++) {
          var B = w[_];
          if (!cb(c, d, B)) {
            c.destination = null, _++, w.splice(0, _);
            return;
          }
        }
        w.splice(0, _);
        var L = c.completedBoundaries;
        for (_ = 0; _ < L.length; _++) {
          var te = L[_];
          if (!qs(c, d, te)) {
            c.destination = null, _++, L.splice(0, _);
            return;
          }
        }
        L.splice(0, _);
        var de = c.partialBoundaries;
        for (_ = 0; _ < de.length; _++) {
          var Ce = de[_];
          if (!Sc(c, d, Ce)) {
            c.destination = null, _++, de.splice(0, _);
            return;
          }
        }
        de.splice(0, _);
        var Ue = c.completedBoundaries;
        for (_ = 0; _ < Ue.length; _++) {
          var Pe = Ue[_];
          if (!qs(c, d, Pe)) {
            c.destination = null, _++, Ue.splice(0, _);
            return;
          }
        }
        Ue.splice(0, _);
      } finally {
        c.allPendingTasks === 0 && c.pingedTasks.length === 0 && c.clientRenderedBoundaries.length === 0 && c.completedBoundaries.length === 0 && (c.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), h(d));
      }
    }
    function Ph(c) {
      a(function() {
        return Cf(c);
      });
    }
    function ub(c, d) {
      if (c.status === gf) {
        c.status = vo, b(d, c.fatalError);
        return;
      }
      if (c.status !== vo && c.destination === null) {
        c.destination = d;
        try {
          Tc(c, d);
        } catch (g) {
          Ws(c, g), Sr(c, g);
        }
      }
    }
    function Wh(c, d) {
      try {
        var g = c.abortableTasks;
        g.forEach(function(w) {
          return Bh(w, c, d);
        }), g.clear(), c.destination !== null && Tc(c, c.destination);
      } catch (w) {
        Ws(c, w), Sr(c, w);
      }
    }
    function _f() {
    }
    function Lh(c, d, g, w) {
      var _ = !1, B = null, L = "", te = {
        push: function(Pe) {
          return Pe !== null && (L += Pe), !0;
        },
        destroy: function(Pe) {
          _ = !0, B = Pe;
        }
      }, de = !1;
      function Ce() {
        de = !0;
      }
      var Ue = wa(c, xy(g, d ? d.identifierPrefix : void 0), Dy(), 1 / 0, _f, void 0, Ce);
      if (Ph(Ue), Wh(Ue, w), ub(Ue, te), _)
        throw B;
      if (!de)
        throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return L;
    }
    function fb(c, d) {
      return Lh(c, d, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function zh(c, d) {
      return Lh(c, d, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function db() {
      throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
    }
    function m() {
      throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
    }
    Js.renderToNodeStream = db, Js.renderToStaticMarkup = zh, Js.renderToStaticNodeStream = m, Js.renderToString = fb, Js.version = e;
  }()), Js;
}
var yp = {};
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var n_;
function jG() {
  return n_ || (n_ = 1, process.env.NODE_ENV !== "production" && function() {
    var t = um, e = "18.3.1", n = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(m) {
      {
        for (var c = arguments.length, d = new Array(c > 1 ? c - 1 : 0), g = 1; g < c; g++)
          d[g - 1] = arguments[g];
        o("warn", m, d);
      }
    }
    function i(m) {
      {
        for (var c = arguments.length, d = new Array(c > 1 ? c - 1 : 0), g = 1; g < c; g++)
          d[g - 1] = arguments[g];
        o("error", m, d);
      }
    }
    function o(m, c, d) {
      {
        var g = n.ReactDebugCurrentFrame, w = g.getStackAddendum();
        w !== "" && (c += "%s", d = d.concat([w]));
        var _ = d.map(function(B) {
          return String(B);
        });
        _.unshift("Warning: " + c), Function.prototype.apply.call(console[m], console, _);
      }
    }
    function a(m) {
      m();
    }
    var s = 512, l = null, u = 0;
    function f(m) {
      l = new Uint8Array(s), u = 0;
    }
    function h(m, c) {
      if (c.length !== 0) {
        if (c.length > s) {
          u > 0 && (m.enqueue(new Uint8Array(l.buffer, 0, u)), l = new Uint8Array(s), u = 0), m.enqueue(c);
          return;
        }
        var d = c, g = l.length - u;
        g < d.length && (g === 0 ? m.enqueue(l) : (l.set(d.subarray(0, g), u), m.enqueue(l), d = d.subarray(g)), l = new Uint8Array(s), u = 0), l.set(d, u), u += d.length;
      }
    }
    function p(m, c) {
      return h(m, c), !0;
    }
    function y(m) {
      l && u > 0 && (m.enqueue(new Uint8Array(l.buffer, 0, u)), l = null, u = 0);
    }
    function b(m) {
      m.close();
    }
    var x = new TextEncoder();
    function v(m) {
      return x.encode(m);
    }
    function D(m) {
      return x.encode(m);
    }
    function S(m, c) {
      typeof m.error == "function" ? m.error(c) : m.close();
    }
    function E(m) {
      {
        var c = typeof Symbol == "function" && Symbol.toStringTag, d = c && m[Symbol.toStringTag] || m.constructor.name || "Object";
        return d;
      }
    }
    function I(m) {
      try {
        return R(m), !1;
      } catch {
        return !0;
      }
    }
    function R(m) {
      return "" + m;
    }
    function O(m, c) {
      if (I(m))
        return i("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", c, E(m)), R(m);
    }
    function N(m, c) {
      if (I(m))
        return i("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", c, E(m)), R(m);
    }
    function q(m) {
      if (I(m))
        return i("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", E(m)), R(m);
    }
    var $ = Object.prototype.hasOwnProperty, le = 0, ve = 1, M = 2, ee = 3, A = 4, oe = 5, j = 6, Q = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", G = Q + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Z = new RegExp("^[" + Q + "][" + G + "]*$"), re = {}, V = {};
    function P(m) {
      return $.call(V, m) ? !0 : $.call(re, m) ? !1 : Z.test(m) ? (V[m] = !0, !0) : (re[m] = !0, i("Invalid attribute name: `%s`", m), !1);
    }
    function pe(m, c, d, g) {
      if (d !== null && d.type === le)
        return !1;
      switch (typeof c) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (d !== null)
            return !d.acceptsBooleans;
          var w = m.toLowerCase().slice(0, 5);
          return w !== "data-" && w !== "aria-";
        }
        default:
          return !1;
      }
    }
    function we(m) {
      return _e.hasOwnProperty(m) ? _e[m] : null;
    }
    function be(m, c, d, g, w, _, B) {
      this.acceptsBooleans = c === M || c === ee || c === A, this.attributeName = g, this.attributeNamespace = w, this.mustUseProperty = d, this.propertyName = m, this.type = c, this.sanitizeURL = _, this.removeEmptyString = B;
    }
    var _e = {}, $e = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    $e.forEach(function(m) {
      _e[m] = new be(
        m,
        le,
        !1,
        // mustUseProperty
        m,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(m) {
      var c = m[0], d = m[1];
      _e[c] = new be(
        c,
        ve,
        !1,
        // mustUseProperty
        d,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(m) {
      _e[m] = new be(
        m,
        M,
        !1,
        // mustUseProperty
        m.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(m) {
      _e[m] = new be(
        m,
        M,
        !1,
        // mustUseProperty
        m,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(m) {
      _e[m] = new be(
        m,
        ee,
        !1,
        // mustUseProperty
        m.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(m) {
      _e[m] = new be(
        m,
        ee,
        !0,
        // mustUseProperty
        m,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(m) {
      _e[m] = new be(
        m,
        A,
        !1,
        // mustUseProperty
        m,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(m) {
      _e[m] = new be(
        m,
        j,
        !1,
        // mustUseProperty
        m,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(m) {
      _e[m] = new be(
        m,
        oe,
        !1,
        // mustUseProperty
        m.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Le = /[\-\:]([a-z])/g, ze = function(m) {
      return m[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(m) {
      var c = m.replace(Le, ze);
      _e[c] = new be(
        c,
        ve,
        !1,
        // mustUseProperty
        m,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(m) {
      var c = m.replace(Le, ze);
      _e[c] = new be(
        c,
        ve,
        !1,
        // mustUseProperty
        m,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(m) {
      var c = m.replace(Le, ze);
      _e[c] = new be(
        c,
        ve,
        !1,
        // mustUseProperty
        m,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(m) {
      _e[m] = new be(
        m,
        ve,
        !1,
        // mustUseProperty
        m.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var tt = "xlinkHref";
    _e[tt] = new be(
      "xlinkHref",
      ve,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(m) {
      _e[m] = new be(
        m,
        ve,
        !1,
        // mustUseProperty
        m.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var ie = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Ee(m, c) {
      return m + c.charAt(0).toUpperCase() + c.substring(1);
    }
    var Re = ["Webkit", "ms", "Moz", "O"];
    Object.keys(ie).forEach(function(m) {
      Re.forEach(function(c) {
        ie[Ee(c, m)] = ie[m];
      });
    });
    var k = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function ge(m, c) {
      k[c.type] || c.onChange || c.onInput || c.readOnly || c.disabled || c.value == null || i("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), c.onChange || c.readOnly || c.disabled || c.checked == null || i("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function ue(m, c) {
      if (m.indexOf("-") === -1)
        return typeof c.is == "string";
      switch (m) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Y = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, H = {}, ae = new RegExp("^(aria)-[" + G + "]*$"), Se = new RegExp("^(aria)[A-Z][" + G + "]*$");
    function ke(m, c) {
      {
        if ($.call(H, c) && H[c])
          return !0;
        if (Se.test(c)) {
          var d = "aria-" + c.slice(4).toLowerCase(), g = Y.hasOwnProperty(d) ? d : null;
          if (g == null)
            return i("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", c), H[c] = !0, !0;
          if (c !== g)
            return i("Invalid ARIA attribute `%s`. Did you mean `%s`?", c, g), H[c] = !0, !0;
        }
        if (ae.test(c)) {
          var w = c.toLowerCase(), _ = Y.hasOwnProperty(w) ? w : null;
          if (_ == null)
            return H[c] = !0, !1;
          if (c !== _)
            return i("Unknown ARIA attribute `%s`. Did you mean `%s`?", c, _), H[c] = !0, !0;
        }
      }
      return !0;
    }
    function se(m, c) {
      {
        var d = [];
        for (var g in c) {
          var w = ke(m, g);
          w || d.push(g);
        }
        var _ = d.map(function(B) {
          return "`" + B + "`";
        }).join(", ");
        d.length === 1 ? i("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", _, m) : d.length > 1 && i("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", _, m);
      }
    }
    function K(m, c) {
      ue(m, c) || se(m, c);
    }
    var ne = !1;
    function ce(m, c) {
      {
        if (m !== "input" && m !== "textarea" && m !== "select")
          return;
        c != null && c.value === null && !ne && (ne = !0, m === "select" && c.multiple ? i("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", m) : i("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", m));
      }
    }
    var xe = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Be = function() {
    };
    {
      var Me = {}, Je = /^on./, He = /^on[^A-Z]/, Ke = new RegExp("^(aria)-[" + G + "]*$"), lt = new RegExp("^(aria)[A-Z][" + G + "]*$");
      Be = function(m, c, d, g) {
        if ($.call(Me, c) && Me[c])
          return !0;
        var w = c.toLowerCase();
        if (w === "onfocusin" || w === "onfocusout")
          return i("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Me[c] = !0, !0;
        if (g != null) {
          var _ = g.registrationNameDependencies, B = g.possibleRegistrationNames;
          if (_.hasOwnProperty(c))
            return !0;
          var L = B.hasOwnProperty(w) ? B[w] : null;
          if (L != null)
            return i("Invalid event handler property `%s`. Did you mean `%s`?", c, L), Me[c] = !0, !0;
          if (Je.test(c))
            return i("Unknown event handler property `%s`. It will be ignored.", c), Me[c] = !0, !0;
        } else if (Je.test(c))
          return He.test(c) && i("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", c), Me[c] = !0, !0;
        if (Ke.test(c) || lt.test(c))
          return !0;
        if (w === "innerhtml")
          return i("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Me[c] = !0, !0;
        if (w === "aria")
          return i("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Me[c] = !0, !0;
        if (w === "is" && d !== null && d !== void 0 && typeof d != "string")
          return i("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof d), Me[c] = !0, !0;
        if (typeof d == "number" && isNaN(d))
          return i("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", c), Me[c] = !0, !0;
        var te = we(c), de = te !== null && te.type === le;
        if (xe.hasOwnProperty(w)) {
          var Ce = xe[w];
          if (Ce !== c)
            return i("Invalid DOM property `%s`. Did you mean `%s`?", c, Ce), Me[c] = !0, !0;
        } else if (!de && c !== w)
          return i("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", c, w), Me[c] = !0, !0;
        return typeof d == "boolean" && pe(c, d, te) ? (d ? i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', d, c, c, d, c) : i('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', d, c, c, d, c, c, c), Me[c] = !0, !0) : de ? !0 : pe(c, d, te) ? (Me[c] = !0, !1) : ((d === "false" || d === "true") && te !== null && te.type === ee && (i("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", d, c, d === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', c, d), Me[c] = !0), !0);
      };
    }
    var nt = function(m, c, d) {
      {
        var g = [];
        for (var w in c) {
          var _ = Be(m, w, c[w], d);
          _ || g.push(w);
        }
        var B = g.map(function(L) {
          return "`" + L + "`";
        }).join(", ");
        g.length === 1 ? i("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", B, m) : g.length > 1 && i("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", B, m);
      }
    };
    function Bt(m, c, d) {
      ue(m, c) || nt(m, c, d);
    }
    var Bn = function() {
    };
    {
      var At = /^(?:webkit|moz|o)[A-Z]/, Ur = /^-ms-/, xi = /-(.)/g, jt = /;\s*$/, Dn = {}, Mn = {}, at = !1, on = !1, Di = function(m) {
        return m.replace(xi, function(c, d) {
          return d.toUpperCase();
        });
      }, Qr = function(m) {
        Dn.hasOwnProperty(m) && Dn[m] || (Dn[m] = !0, i(
          "Unsupported style property %s. Did you mean %s?",
          m,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Di(m.replace(Ur, "ms-"))
        ));
      }, Zn = function(m) {
        Dn.hasOwnProperty(m) && Dn[m] || (Dn[m] = !0, i("Unsupported vendor-prefixed style property %s. Did you mean %s?", m, m.charAt(0).toUpperCase() + m.slice(1)));
      }, wi = function(m, c) {
        Mn.hasOwnProperty(c) && Mn[c] || (Mn[c] = !0, i(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, m, c.replace(jt, "")));
      }, br = function(m, c) {
        at || (at = !0, i("`NaN` is an invalid value for the `%s` css style property.", m));
      }, Mt = function(m, c) {
        on || (on = !0, i("`Infinity` is an invalid value for the `%s` css style property.", m));
      };
      Bn = function(m, c) {
        m.indexOf("-") > -1 ? Qr(m) : At.test(m) ? Zn(m) : jt.test(c) && wi(m, c), typeof c == "number" && (isNaN(c) ? br(m, c) : isFinite(c) || Mt(m, c));
      };
    }
    var oo = Bn, ao = /["'&<>]/;
    function Zo(m) {
      q(m);
      var c = "" + m, d = ao.exec(c);
      if (!d)
        return c;
      var g, w = "", _, B = 0;
      for (_ = d.index; _ < c.length; _++) {
        switch (c.charCodeAt(_)) {
          case 34:
            g = "&quot;";
            break;
          case 38:
            g = "&amp;";
            break;
          case 39:
            g = "&#x27;";
            break;
          case 60:
            g = "&lt;";
            break;
          case 62:
            g = "&gt;";
            break;
          default:
            continue;
        }
        B !== _ && (w += c.substring(B, _)), B = _ + 1, w += g;
      }
      return B !== _ ? w + c.substring(B, _) : w;
    }
    function Ut(m) {
      return typeof m == "boolean" || typeof m == "number" ? "" + m : Zo(m);
    }
    var so = /([A-Z])/g, hs = /^ms-/;
    function ps(m) {
      return m.replace(so, "-$1").toLowerCase().replace(hs, "-ms-");
    }
    var Kn = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, lo = !1;
    function Si(m) {
      !lo && Kn.test(m) && (lo = !0, i("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(m)));
    }
    var Fr = Array.isArray;
    function an(m) {
      return Fr(m);
    }
    var Qn = D("<script>"), Ti = D("<\/script>"), Rr = D('<script src="'), Or = D('<script type="module" src="'), er = D('" async=""><\/script>');
    function Ir(m) {
      return q(m), ("" + m).replace(sn, Ko);
    }
    var sn = /(<\/|<)(s)(cript)/gi, Ko = function(m, c, d, g) {
      return "" + c + (d === "s" ? "\\u0073" : "\\u0053") + g;
    };
    function Qo(m, c, d, g, w) {
      var _ = m === void 0 ? "" : m, B = c === void 0 ? Qn : D('<script nonce="' + Ut(c) + '">'), L = [];
      if (d !== void 0 && L.push(B, v(Ir(d)), Ti), g !== void 0)
        for (var te = 0; te < g.length; te++)
          L.push(Rr, v(Ut(g[te])), er);
      if (w !== void 0)
        for (var de = 0; de < w.length; de++)
          L.push(Or, v(Ut(w[de])), er);
      return {
        bootstrapChunks: L,
        startInlineScript: B,
        placeholderPrefix: D(_ + "P:"),
        segmentPrefix: D(_ + "S:"),
        boundaryPrefix: _ + "B:",
        idPrefix: _,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      };
    }
    var vr = 0, Ft = 1, tr = 2, nr = 3, Br = 4, Ci = 5, Nn = 6, rr = 7;
    function Xt(m, c) {
      return {
        insertionMode: m,
        selectedValue: c
      };
    }
    function Mr(m) {
      var c = m === "http://www.w3.org/2000/svg" ? tr : m === "http://www.w3.org/1998/Math/MathML" ? nr : vr;
      return Xt(c, null);
    }
    function ei(m, c, d) {
      switch (c) {
        case "select":
          return Xt(Ft, d.value != null ? d.value : d.defaultValue);
        case "svg":
          return Xt(tr, null);
        case "math":
          return Xt(nr, null);
        case "foreignObject":
          return Xt(Ft, null);
        case "table":
          return Xt(Br, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return Xt(Ci, null);
        case "colgroup":
          return Xt(rr, null);
        case "tr":
          return Xt(Nn, null);
      }
      return m.insertionMode >= Br || m.insertionMode === vr ? Xt(Ft, null) : m;
    }
    var Ei = null;
    function wn(m) {
      var c = m.nextSuspenseID++;
      return D(m.boundaryPrefix + c.toString(16));
    }
    function ir(m, c, d) {
      var g = m.idPrefix, w = ":" + g + "R" + c;
      return d > 0 && (w += "H" + d.toString(32)), w + ":";
    }
    function Gt(m) {
      return Ut(m);
    }
    var _i = D("<!-- -->");
    function Lt(m, c, d, g) {
      return c === "" ? g : (g && m.push(_i), m.push(v(Gt(c))), !0);
    }
    function ln(m, c, d, g) {
      d && g && m.push(_i);
    }
    var T = /* @__PURE__ */ new Map();
    function F(m) {
      var c = T.get(m);
      if (c !== void 0)
        return c;
      var d = D(Ut(ps(m)));
      return T.set(m, d), d;
    }
    var z = D(' style="'), J = D(":"), me = D(";");
    function fe(m, c, d) {
      if (typeof d != "object")
        throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var g = !0;
      for (var w in d)
        if ($.call(d, w)) {
          var _ = d[w];
          if (!(_ == null || typeof _ == "boolean" || _ === "")) {
            var B = void 0, L = void 0, te = w.indexOf("--") === 0;
            te ? (B = v(Ut(w)), N(_, w), L = v(Ut(("" + _).trim()))) : (oo(w, _), B = F(w), typeof _ == "number" ? _ !== 0 && !$.call(ie, w) ? L = v(_ + "px") : L = v("" + _) : (N(_, w), L = v(Ut(("" + _).trim())))), g ? (g = !1, m.push(z, B, J, L)) : m.push(me, B, J, L);
          }
        }
      g || m.push(je);
    }
    var De = D(" "), Oe = D('="'), je = D('"'), qe = D('=""');
    function Ve(m, c, d, g) {
      switch (d) {
        case "style": {
          fe(m, c, g);
          return;
        }
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (
        // shouldIgnoreAttribute
        // We have already filtered out null/undefined and reserved words.
        !(d.length > 2 && (d[0] === "o" || d[0] === "O") && (d[1] === "n" || d[1] === "N"))
      ) {
        var w = we(d);
        if (w !== null) {
          switch (typeof g) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!w.acceptsBooleans)
                return;
          }
          var _ = w.attributeName, B = v(_);
          switch (w.type) {
            case ee:
              g && m.push(De, B, qe);
              return;
            case A:
              g === !0 ? m.push(De, B, qe) : g === !1 || m.push(De, B, Oe, v(Ut(g)), je);
              return;
            case oe:
              isNaN(g) || m.push(De, B, Oe, v(Ut(g)), je);
              break;
            case j:
              !isNaN(g) && g >= 1 && m.push(De, B, Oe, v(Ut(g)), je);
              break;
            default:
              w.sanitizeURL && (O(g, _), g = "" + g, Si(g)), m.push(De, B, Oe, v(Ut(g)), je);
          }
        } else if (P(d)) {
          switch (typeof g) {
            case "function":
            case "symbol":
              return;
            case "boolean": {
              var L = d.toLowerCase().slice(0, 5);
              if (L !== "data-" && L !== "aria-")
                return;
            }
          }
          m.push(De, v(d), Oe, v(Ut(g)), je);
        }
      }
    }
    var ft = D(">"), Jt = D("/>");
    function Yt(m, c, d) {
      if (c != null) {
        if (d != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof c != "object" || !("__html" in c))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var g = c.__html;
        g != null && (q(g), m.push(v("" + g)));
      }
    }
    var Zt = !1, Nr = !1, or = !1, ki = !1, Pr = !1, ti = !1, xr = !1;
    function ni(m, c) {
      {
        var d = m[c];
        if (d != null) {
          var g = an(d);
          m.multiple && !g ? i("The `%s` prop supplied to <select> must be an array if `multiple` is true.", c) : !m.multiple && g && i("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", c);
        }
      }
    }
    function Mu(m, c, d) {
      ge("select", c), ni(c, "value"), ni(c, "defaultValue"), c.value !== void 0 && c.defaultValue !== void 0 && !or && (i("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), or = !0), m.push(Pn("select"));
      var g = null, w = null;
      for (var _ in c)
        if ($.call(c, _)) {
          var B = c[_];
          if (B == null)
            continue;
          switch (_) {
            case "children":
              g = B;
              break;
            case "dangerouslySetInnerHTML":
              w = B;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              Ve(m, d, _, B);
              break;
          }
        }
      return m.push(ft), Yt(m, w, g), g;
    }
    function Nu(m) {
      var c = "";
      return t.Children.forEach(m, function(d) {
        d != null && (c += d, !Pr && typeof d != "string" && typeof d != "number" && (Pr = !0, i("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }), c;
    }
    var ea = D(' selected=""');
    function ar(m, c, d, g) {
      var w = g.selectedValue;
      m.push(Pn("option"));
      var _ = null, B = null, L = null, te = null;
      for (var de in c)
        if ($.call(c, de)) {
          var Ce = c[de];
          if (Ce == null)
            continue;
          switch (de) {
            case "children":
              _ = Ce;
              break;
            case "selected":
              L = Ce, xr || (i("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), xr = !0);
              break;
            case "dangerouslySetInnerHTML":
              te = Ce;
              break;
            case "value":
              B = Ce;
            default:
              Ve(m, d, de, Ce);
              break;
          }
        }
      if (w != null) {
        var Ue;
        if (B !== null ? (O(B, "value"), Ue = "" + B) : (te !== null && (ti || (ti = !0, i("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), Ue = Nu(_)), an(w))
          for (var Pe = 0; Pe < w.length; Pe++) {
            O(w[Pe], "value");
            var Ge = "" + w[Pe];
            if (Ge === Ue) {
              m.push(ea);
              break;
            }
          }
        else
          O(w, "select.value"), "" + w === Ue && m.push(ea);
      } else L && m.push(ea);
      return m.push(ft), Yt(m, te, _), _;
    }
    function Pu(m, c, d) {
      ge("input", c), c.checked !== void 0 && c.defaultChecked !== void 0 && !Nr && (i("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", c.type), Nr = !0), c.value !== void 0 && c.defaultValue !== void 0 && !Zt && (i("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", c.type), Zt = !0), m.push(Pn("input"));
      var g = null, w = null, _ = null, B = null;
      for (var L in c)
        if ($.call(c, L)) {
          var te = c[L];
          if (te == null)
            continue;
          switch (L) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            case "defaultChecked":
              B = te;
              break;
            case "defaultValue":
              w = te;
              break;
            case "checked":
              _ = te;
              break;
            case "value":
              g = te;
              break;
            default:
              Ve(m, d, L, te);
              break;
          }
        }
      return _ !== null ? Ve(m, d, "checked", _) : B !== null && Ve(m, d, "checked", B), g !== null ? Ve(m, d, "value", g) : w !== null && Ve(m, d, "value", w), m.push(Jt), null;
    }
    function Dr(m, c, d) {
      ge("textarea", c), c.value !== void 0 && c.defaultValue !== void 0 && !ki && (i("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components"), ki = !0), m.push(Pn("textarea"));
      var g = null, w = null, _ = null;
      for (var B in c)
        if ($.call(c, B)) {
          var L = c[B];
          if (L == null)
            continue;
          switch (B) {
            case "children":
              _ = L;
              break;
            case "value":
              g = L;
              break;
            case "defaultValue":
              w = L;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            default:
              Ve(m, d, B, L);
              break;
          }
        }
      if (g === null && w !== null && (g = w), m.push(ft), _ != null) {
        if (i("Use the `defaultValue` or `value` props instead of setting children on <textarea>."), g != null)
          throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (an(_)) {
          if (_.length > 1)
            throw new Error("<textarea> can only have at most one child.");
          q(_[0]), g = "" + _[0];
        }
        q(_), g = "" + _;
      }
      return typeof g == "string" && g[0] === `
` && m.push(ii), g !== null && (O(g, "value"), m.push(v(Gt("" + g)))), null;
    }
    function gs(m, c, d, g) {
      m.push(Pn(d));
      for (var w in c)
        if ($.call(c, w)) {
          var _ = c[w];
          if (_ == null)
            continue;
          switch (w) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error(d + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              Ve(m, g, w, _);
              break;
          }
        }
      return m.push(Jt), null;
    }
    function ta(m, c, d) {
      m.push(Pn("menuitem"));
      for (var g in c)
        if ($.call(c, g)) {
          var w = c[g];
          if (w == null)
            continue;
          switch (g) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
            default:
              Ve(m, d, g, w);
              break;
          }
        }
      return m.push(ft), null;
    }
    function gt(m, c, d) {
      m.push(Pn("title"));
      var g = null;
      for (var w in c)
        if ($.call(c, w)) {
          var _ = c[w];
          if (_ == null)
            continue;
          switch (w) {
            case "children":
              g = _;
              break;
            case "dangerouslySetInnerHTML":
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
            default:
              Ve(m, d, w, _);
              break;
          }
        }
      m.push(ft);
      {
        var B = Array.isArray(g) && g.length < 2 ? g[0] || null : g;
        Array.isArray(g) && g.length > 1 ? i("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : B != null && B.$$typeof != null ? i("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering") : B != null && typeof B != "string" && typeof B != "number" && i("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
      }
      return g;
    }
    function ri(m, c, d, g) {
      m.push(Pn(d));
      var w = null, _ = null;
      for (var B in c)
        if ($.call(c, B)) {
          var L = c[B];
          if (L == null)
            continue;
          switch (B) {
            case "children":
              w = L;
              break;
            case "dangerouslySetInnerHTML":
              _ = L;
              break;
            default:
              Ve(m, g, B, L);
              break;
          }
        }
      return m.push(ft), Yt(m, _, w), typeof w == "string" ? (m.push(v(Gt(w))), null) : w;
    }
    function na(m, c, d, g) {
      m.push(Pn(d));
      var w = null, _ = null;
      for (var B in c)
        if ($.call(c, B)) {
          var L = c[B];
          if (L == null)
            continue;
          switch (B) {
            case "children":
              w = L;
              break;
            case "dangerouslySetInnerHTML":
              _ = L;
              break;
            case "style":
              fe(m, g, L);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
              break;
            default:
              P(B) && typeof L != "function" && typeof L != "symbol" && m.push(De, v(B), Oe, v(Ut(L)), je);
              break;
          }
        }
      return m.push(ft), Yt(m, _, w), w;
    }
    var ii = D(`
`);
    function Wr(m, c, d, g) {
      m.push(Pn(d));
      var w = null, _ = null;
      for (var B in c)
        if ($.call(c, B)) {
          var L = c[B];
          if (L == null)
            continue;
          switch (B) {
            case "children":
              w = L;
              break;
            case "dangerouslySetInnerHTML":
              _ = L;
              break;
            default:
              Ve(m, g, B, L);
              break;
          }
        }
      if (m.push(ft), _ != null) {
        if (w != null)
          throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof _ != "object" || !("__html" in _))
          throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        var te = _.__html;
        te != null && (typeof te == "string" && te.length > 0 && te[0] === `
` ? m.push(ii, v(te)) : (q(te), m.push(v("" + te))));
      }
      return typeof w == "string" && w[0] === `
` && m.push(ii), w;
    }
    var ra = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Lr = /* @__PURE__ */ new Map();
    function Pn(m) {
      var c = Lr.get(m);
      if (c === void 0) {
        if (!ra.test(m))
          throw new Error("Invalid tag: " + m);
        c = D("<" + m), Lr.set(m, c);
      }
      return c;
    }
    var ms = D("<!DOCTYPE html>");
    function co(m, c, d, g, w) {
      switch (K(c, d), ce(c, d), Bt(c, d, null), !d.suppressContentEditableWarning && d.contentEditable && d.children != null && i("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), w.insertionMode !== tr && w.insertionMode !== nr && c.indexOf("-") === -1 && typeof d.is != "string" && c.toLowerCase() !== c && i("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", c), c) {
        case "select":
          return Mu(m, d, g);
        case "option":
          return ar(m, d, g, w);
        case "textarea":
          return Dr(m, d, g);
        case "input":
          return Pu(m, d, g);
        case "menuitem":
          return ta(m, d, g);
        case "title":
          return gt(m, d, g);
        case "listing":
        case "pre":
          return Wr(m, d, c, g);
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return gs(m, d, c, g);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return ri(m, d, c, g);
        case "html":
          return w.insertionMode === vr && m.push(ms), ri(m, d, c, g);
        default:
          return c.indexOf("-") === -1 && typeof d.is != "string" ? ri(m, d, c, g) : na(m, d, c, g);
      }
    }
    var _l = D("</"), ia = D(">");
    function kl(m, c, d) {
      switch (c) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          m.push(_l, v(c), ia);
      }
    }
    function Wu(m, c) {
      for (var d = c.bootstrapChunks, g = 0; g < d.length - 1; g++)
        h(m, d[g]);
      return g < d.length ? p(m, d[g]) : !0;
    }
    var Lu = D('<template id="'), oa = D('"></template>');
    function Al(m, c, d) {
      h(m, Lu), h(m, c.placeholderPrefix);
      var g = v(d.toString(16));
      return h(m, g), p(m, oa);
    }
    var uo = D("<!--$-->"), ys = D('<!--$?--><template id="'), zu = D('"></template>'), Ai = D("<!--$!-->"), bs = D("<!--/$-->"), vs = D("<template"), Ui = D('"'), fo = D(' data-dgst="'), aa = D(' data-msg="'), Ul = D(' data-stck="'), Fl = D("></template>");
    function Rl(m, c) {
      return p(m, uo);
    }
    function sa(m, c, d) {
      if (h(m, ys), d === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return h(m, d), p(m, zu);
    }
    function cn(m, c, d, g, w) {
      var _;
      return _ = p(m, Ai), h(m, vs), d && (h(m, fo), h(m, v(Ut(d))), h(m, Ui)), g && (h(m, aa), h(m, v(Ut(g))), h(m, Ui)), w && (h(m, Ul), h(m, v(Ut(w))), h(m, Ui)), _ = p(m, Fl), _;
    }
    function Ol(m, c) {
      return p(m, bs);
    }
    function la(m, c) {
      return p(m, bs);
    }
    function $u(m, c) {
      return p(m, bs);
    }
    var Il = D('<div hidden id="'), ca = D('">'), Bl = D("</div>"), Ml = D('<svg aria-hidden="true" style="display:none" id="'), ua = D('">'), fa = D("</svg>"), Nl = D('<math aria-hidden="true" style="display:none" id="'), Pl = D('">'), Wl = D("</math>"), xs = D('<table hidden id="'), Ll = D('">'), C = D("</table>"), U = D('<table hidden><tbody id="'), W = D('">'), X = D("</tbody></table>"), ye = D('<table hidden><tr id="'), he = D('">'), Te = D("</tr></table>"), Ie = D('<table hidden><colgroup id="'), Xe = D('">'), Qe = D("</colgroup></table>");
    function Ze(m, c, d, g) {
      switch (d.insertionMode) {
        case vr:
        case Ft:
          return h(m, Il), h(m, c.segmentPrefix), h(m, v(g.toString(16))), p(m, ca);
        case tr:
          return h(m, Ml), h(m, c.segmentPrefix), h(m, v(g.toString(16))), p(m, ua);
        case nr:
          return h(m, Nl), h(m, c.segmentPrefix), h(m, v(g.toString(16))), p(m, Pl);
        case Br:
          return h(m, xs), h(m, c.segmentPrefix), h(m, v(g.toString(16))), p(m, Ll);
        case Ci:
          return h(m, U), h(m, c.segmentPrefix), h(m, v(g.toString(16))), p(m, W);
        case Nn:
          return h(m, ye), h(m, c.segmentPrefix), h(m, v(g.toString(16))), p(m, he);
        case rr:
          return h(m, Ie), h(m, c.segmentPrefix), h(m, v(g.toString(16))), p(m, Xe);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function bt(m, c) {
      switch (c.insertionMode) {
        case vr:
        case Ft:
          return p(m, Bl);
        case tr:
          return p(m, fa);
        case nr:
          return p(m, Wl);
        case Br:
          return p(m, C);
        case Ci:
          return p(m, X);
        case Nn:
          return p(m, Te);
        case rr:
          return p(m, Qe);
        default:
          throw new Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var un = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}", Wn = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}', Ln = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}', da = D(un + ';$RS("'), zl = D('$RS("'), ho = D('","'), by = D('")<\/script>');
    function vy(m, c, d) {
      h(m, c.startInlineScript), c.sentCompleteSegmentFunction ? h(m, zl) : (c.sentCompleteSegmentFunction = !0, h(m, da)), h(m, c.segmentPrefix);
      var g = v(d.toString(16));
      return h(m, g), h(m, ho), h(m, c.placeholderPrefix), h(m, g), p(m, by);
    }
    var ju = D(Wn + ';$RC("'), xy = D('$RC("'), Dy = D('","'), nh = D('")<\/script>');
    function rh(m, c, d, g) {
      if (h(m, c.startInlineScript), c.sentCompleteBoundaryFunction ? h(m, xy) : (c.sentCompleteBoundaryFunction = !0, h(m, ju)), d === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      var w = v(g.toString(16));
      return h(m, d), h(m, Dy), h(m, c.segmentPrefix), h(m, w), p(m, nh);
    }
    var wy = D(Ln + ';$RX("'), Sy = D('$RX("'), Ty = D('"'), Cy = D(")<\/script>"), Sn = D(",");
    function Ey(m, c, d, g, w, _) {
      if (h(m, c.startInlineScript), c.sentClientRenderFunction ? h(m, Sy) : (c.sentClientRenderFunction = !0, h(m, wy)), d === null)
        throw new Error("An ID must have been assigned before we can complete the boundary.");
      return h(m, d), h(m, Ty), (g || w || _) && (h(m, Sn), h(m, v($l(g || "")))), (w || _) && (h(m, Sn), h(m, v($l(w || "")))), _ && (h(m, Sn), h(m, v($l(_)))), p(m, Cy);
    }
    var ih = /[<\u2028\u2029]/g;
    function $l(m) {
      var c = JSON.stringify(m);
      return c.replace(ih, function(d) {
        switch (d) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var zn = Object.assign, oh = Symbol.for("react.element"), jl = Symbol.for("react.portal"), Hl = Symbol.for("react.fragment"), Vl = Symbol.for("react.strict_mode"), ql = Symbol.for("react.profiler"), Ds = Symbol.for("react.provider"), ws = Symbol.for("react.context"), ha = Symbol.for("react.forward_ref"), Hu = Symbol.for("react.suspense"), Vu = Symbol.for("react.suspense_list"), qu = Symbol.for("react.memo"), Xl = Symbol.for("react.lazy"), ah = Symbol.for("react.scope"), _y = Symbol.for("react.debug_trace_mode"), ky = Symbol.for("react.legacy_hidden"), Ay = Symbol.for("react.default_value"), Xu = Symbol.iterator, St = "@@iterator";
    function Ss(m) {
      if (m === null || typeof m != "object")
        return null;
      var c = Xu && m[Xu] || m[St];
      return typeof c == "function" ? c : null;
    }
    function sh(m, c, d) {
      var g = m.displayName;
      if (g)
        return g;
      var w = c.displayName || c.name || "";
      return w !== "" ? d + "(" + w + ")" : d;
    }
    function Gu(m) {
      return m.displayName || "Context";
    }
    function Dt(m) {
      if (m == null)
        return null;
      if (typeof m.tag == "number" && i("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof m == "function")
        return m.displayName || m.name || null;
      if (typeof m == "string")
        return m;
      switch (m) {
        case Hl:
          return "Fragment";
        case jl:
          return "Portal";
        case ql:
          return "Profiler";
        case Vl:
          return "StrictMode";
        case Hu:
          return "Suspense";
        case Vu:
          return "SuspenseList";
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case ws:
            var c = m;
            return Gu(c) + ".Consumer";
          case Ds:
            var d = m;
            return Gu(d._context) + ".Provider";
          case ha:
            return sh(m, m.render, "ForwardRef");
          case qu:
            var g = m.displayName || null;
            return g !== null ? g : Dt(m.type) || "Memo";
          case Xl: {
            var w = m, _ = w._payload, B = w._init;
            try {
              return Dt(B(_));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var pa = 0, Ju, Yu, Zu, Ku, lh, ch, Gl;
    function Jl() {
    }
    Jl.__reactDisabledLog = !0;
    function Ts() {
      {
        if (pa === 0) {
          Ju = console.log, Yu = console.info, Zu = console.warn, Ku = console.error, lh = console.group, ch = console.groupCollapsed, Gl = console.groupEnd;
          var m = {
            configurable: !0,
            enumerable: !0,
            value: Jl,
            writable: !0
          };
          Object.defineProperties(console, {
            info: m,
            log: m,
            warn: m,
            error: m,
            group: m,
            groupCollapsed: m,
            groupEnd: m
          });
        }
        pa++;
      }
    }
    function Qu() {
      {
        if (pa--, pa === 0) {
          var m = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: zn({}, m, {
              value: Ju
            }),
            info: zn({}, m, {
              value: Yu
            }),
            warn: zn({}, m, {
              value: Zu
            }),
            error: zn({}, m, {
              value: Ku
            }),
            group: zn({}, m, {
              value: lh
            }),
            groupCollapsed: zn({}, m, {
              value: ch
            }),
            groupEnd: zn({}, m, {
              value: Gl
            })
          });
        }
        pa < 0 && i("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ga = n.ReactCurrentDispatcher, ef;
    function po(m, c, d) {
      {
        if (ef === void 0)
          try {
            throw Error();
          } catch (w) {
            var g = w.stack.trim().match(/\n( *(at )?)/);
            ef = g && g[1] || "";
          }
        return `
` + ef + m;
      }
    }
    var tf = !1, Cs;
    {
      var Uy = typeof WeakMap == "function" ? WeakMap : Map;
      Cs = new Uy();
    }
    function Es(m, c) {
      if (!m || tf)
        return "";
      {
        var d = Cs.get(m);
        if (d !== void 0)
          return d;
      }
      var g;
      tf = !0;
      var w = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var _;
      _ = ga.current, ga.current = null, Ts();
      try {
        if (c) {
          var B = function() {
            throw Error();
          };
          if (Object.defineProperty(B.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(B, []);
            } catch (pt) {
              g = pt;
            }
            Reflect.construct(m, [], B);
          } else {
            try {
              B.call();
            } catch (pt) {
              g = pt;
            }
            m.call(B.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (pt) {
            g = pt;
          }
          m();
        }
      } catch (pt) {
        if (pt && g && typeof pt.stack == "string") {
          for (var L = pt.stack.split(`
`), te = g.stack.split(`
`), de = L.length - 1, Ce = te.length - 1; de >= 1 && Ce >= 0 && L[de] !== te[Ce]; )
            Ce--;
          for (; de >= 1 && Ce >= 0; de--, Ce--)
            if (L[de] !== te[Ce]) {
              if (de !== 1 || Ce !== 1)
                do
                  if (de--, Ce--, Ce < 0 || L[de] !== te[Ce]) {
                    var Ue = `
` + L[de].replace(" at new ", " at ");
                    return m.displayName && Ue.includes("<anonymous>") && (Ue = Ue.replace("<anonymous>", m.displayName)), typeof m == "function" && Cs.set(m, Ue), Ue;
                  }
                while (de >= 1 && Ce >= 0);
              break;
            }
        }
      } finally {
        tf = !1, ga.current = _, Qu(), Error.prepareStackTrace = w;
      }
      var Pe = m ? m.displayName || m.name : "", Ge = Pe ? po(Pe) : "";
      return typeof m == "function" && Cs.set(m, Ge), Ge;
    }
    function uh(m, c, d) {
      return Es(m, !0);
    }
    function nf(m, c, d) {
      return Es(m, !1);
    }
    function Yl(m) {
      var c = m.prototype;
      return !!(c && c.isReactComponent);
    }
    function Zl(m, c, d) {
      if (m == null)
        return "";
      if (typeof m == "function")
        return Es(m, Yl(m));
      if (typeof m == "string")
        return po(m);
      switch (m) {
        case Hu:
          return po("Suspense");
        case Vu:
          return po("SuspenseList");
      }
      if (typeof m == "object")
        switch (m.$$typeof) {
          case ha:
            return nf(m.render);
          case qu:
            return Zl(m.type, c, d);
          case Xl: {
            var g = m, w = g._payload, _ = g._init;
            try {
              return Zl(_(w), c, d);
            } catch {
            }
          }
        }
      return "";
    }
    var Kl = {}, _s = n.ReactDebugCurrentFrame;
    function ks(m) {
      if (m) {
        var c = m._owner, d = Zl(m.type, m._source, c ? c.type : null);
        _s.setExtraStackFrame(d);
      } else
        _s.setExtraStackFrame(null);
    }
    function fh(m, c, d, g, w) {
      {
        var _ = Function.call.bind($);
        for (var B in m)
          if (_(m, B)) {
            var L = void 0;
            try {
              if (typeof m[B] != "function") {
                var te = Error((g || "React class") + ": " + d + " type `" + B + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof m[B] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw te.name = "Invariant Violation", te;
              }
              L = m[B](c, B, g, d, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              L = de;
            }
            L && !(L instanceof Error) && (ks(w), i("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", g || "React class", d, B, typeof L), ks(null)), L instanceof Error && !(L.message in Kl) && (Kl[L.message] = !0, ks(w), i("Failed %s type: %s", d, L.message), ks(null));
          }
      }
    }
    var go;
    go = {};
    var Ql = {};
    Object.freeze(Ql);
    function Fi(m, c) {
      {
        var d = m.contextTypes;
        if (!d)
          return Ql;
        var g = {};
        for (var w in d)
          g[w] = c[w];
        {
          var _ = Dt(m) || "Unknown";
          fh(d, g, "context", _);
        }
        return g;
      }
    }
    function rf(m, c, d, g) {
      {
        if (typeof m.getChildContext != "function") {
          {
            var w = Dt(c) || "Unknown";
            go[w] || (go[w] = !0, i("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", w, w));
          }
          return d;
        }
        var _ = m.getChildContext();
        for (var B in _)
          if (!(B in g))
            throw new Error((Dt(c) || "Unknown") + '.getChildContext(): key "' + B + '" is not defined in childContextTypes.');
        {
          var L = Dt(c) || "Unknown";
          fh(g, _, "child context", L);
        }
        return zn({}, d, _);
      }
    }
    var mo;
    mo = {};
    var ec = null, Ri = null;
    function tc(m) {
      m.context._currentValue = m.parentValue;
    }
    function nc(m) {
      m.context._currentValue = m.value;
    }
    function As(m, c) {
      if (m !== c) {
        tc(m);
        var d = m.parent, g = c.parent;
        if (d === null) {
          if (g !== null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (g === null)
            throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
          As(d, g);
        }
        nc(c);
      }
    }
    function Us(m) {
      tc(m);
      var c = m.parent;
      c !== null && Us(c);
    }
    function dh(m) {
      var c = m.parent;
      c !== null && dh(c), nc(m);
    }
    function hh(m, c) {
      tc(m);
      var d = m.parent;
      if (d === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      d.depth === c.depth ? As(d, c) : hh(d, c);
    }
    function ph(m, c) {
      var d = c.parent;
      if (d === null)
        throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      m.depth === d.depth ? As(m, d) : ph(m, d), nc(c);
    }
    function Oi(m) {
      var c = Ri, d = m;
      c !== d && (c === null ? dh(d) : d === null ? Us(c) : c.depth === d.depth ? As(c, d) : c.depth > d.depth ? hh(c, d) : ph(c, d), Ri = d);
    }
    function of(m, c) {
      var d;
      d = m._currentValue, m._currentValue = c, m._currentRenderer !== void 0 && m._currentRenderer !== null && m._currentRenderer !== mo && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), m._currentRenderer = mo;
      var g = Ri, w = {
        parent: g,
        depth: g === null ? 0 : g.depth + 1,
        context: m,
        parentValue: d,
        value: c
      };
      return Ri = w, w;
    }
    function Fy(m) {
      var c = Ri;
      if (c === null)
        throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
      c.context !== m && i("The parent context is not the expected context. This is probably a bug in React.");
      {
        var d = c.parentValue;
        d === Ay ? c.context._currentValue = c.context._defaultValue : c.context._currentValue = d, m._currentRenderer !== void 0 && m._currentRenderer !== null && m._currentRenderer !== mo && i("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), m._currentRenderer = mo;
      }
      return Ri = c.parent;
    }
    function gh() {
      return Ri;
    }
    function ma(m) {
      var c = m._currentValue;
      return c;
    }
    function Fs(m) {
      return m._reactInternals;
    }
    function af(m, c) {
      m._reactInternals = c;
    }
    var rc = {}, ic = {}, oc, ya, Rs, Os, ac, Is, sc, lc, sf;
    {
      oc = /* @__PURE__ */ new Set(), ya = /* @__PURE__ */ new Set(), Rs = /* @__PURE__ */ new Set(), sc = /* @__PURE__ */ new Set(), Os = /* @__PURE__ */ new Set(), lc = /* @__PURE__ */ new Set(), sf = /* @__PURE__ */ new Set();
      var mh = /* @__PURE__ */ new Set();
      Is = function(m, c) {
        if (!(m === null || typeof m == "function")) {
          var d = c + "_" + m;
          mh.has(d) || (mh.add(d), i("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", c, m));
        }
      }, ac = function(m, c) {
        if (c === void 0) {
          var d = Dt(m) || "Component";
          Os.has(d) || (Os.add(d), i("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", d));
        }
      };
    }
    function yh(m, c) {
      {
        var d = m.constructor, g = d && Dt(d) || "ReactClass", w = g + "." + c;
        if (rc[w])
          return;
        i(`%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, c, c, g), rc[w] = !0;
      }
    }
    var bh = {
      isMounted: function(m) {
        return !1;
      },
      enqueueSetState: function(m, c, d) {
        var g = Fs(m);
        g.queue === null ? yh(m, "setState") : (g.queue.push(c), d != null && Is(d, "setState"));
      },
      enqueueReplaceState: function(m, c, d) {
        var g = Fs(m);
        g.replace = !0, g.queue = [c], d != null && Is(d, "setState");
      },
      enqueueForceUpdate: function(m, c) {
        var d = Fs(m);
        d.queue === null ? yh(m, "forceUpdate") : c != null && Is(c, "setState");
      }
    };
    function Ry(m, c, d, g, w) {
      var _ = d(w, g);
      ac(c, _);
      var B = _ == null ? g : zn({}, g, _);
      return B;
    }
    function vh(m, c, d) {
      var g = Ql, w = m.contextType;
      if ("contextType" in m) {
        var _ = (
          // Allow null for conditional declaration
          w === null || w !== void 0 && w.$$typeof === ws && w._context === void 0
        );
        if (!_ && !sf.has(m)) {
          sf.add(m);
          var B = "";
          w === void 0 ? B = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof w != "object" ? B = " However, it is set to a " + typeof w + "." : w.$$typeof === Ds ? B = " Did you accidentally pass the Context.Provider instead?" : w._context !== void 0 ? B = " Did you accidentally pass the Context.Consumer instead?" : B = " However, it is set to an object with keys {" + Object.keys(w).join(", ") + "}.", i("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Dt(m) || "Component", B);
        }
      }
      typeof w == "object" && w !== null ? g = ma(w) : g = d;
      var L = new m(c, g);
      {
        if (typeof m.getDerivedStateFromProps == "function" && (L.state === null || L.state === void 0)) {
          var te = Dt(m) || "Component";
          oc.has(te) || (oc.add(te), i("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", te, L.state === null ? "null" : "undefined", te));
        }
        if (typeof m.getDerivedStateFromProps == "function" || typeof L.getSnapshotBeforeUpdate == "function") {
          var de = null, Ce = null, Ue = null;
          if (typeof L.componentWillMount == "function" && L.componentWillMount.__suppressDeprecationWarning !== !0 ? de = "componentWillMount" : typeof L.UNSAFE_componentWillMount == "function" && (de = "UNSAFE_componentWillMount"), typeof L.componentWillReceiveProps == "function" && L.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Ce = "componentWillReceiveProps" : typeof L.UNSAFE_componentWillReceiveProps == "function" && (Ce = "UNSAFE_componentWillReceiveProps"), typeof L.componentWillUpdate == "function" && L.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Ue = "componentWillUpdate" : typeof L.UNSAFE_componentWillUpdate == "function" && (Ue = "UNSAFE_componentWillUpdate"), de !== null || Ce !== null || Ue !== null) {
            var Pe = Dt(m) || "Component", Ge = typeof m.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Rs.has(Pe) || (Rs.add(Pe), i(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Pe, Ge, de !== null ? `
  ` + de : "", Ce !== null ? `
  ` + Ce : "", Ue !== null ? `
  ` + Ue : ""));
          }
        }
      }
      return L;
    }
    function Oy(m, c, d) {
      {
        var g = Dt(c) || "Component", w = m.render;
        w || (c.prototype && typeof c.prototype.render == "function" ? i("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", g) : i("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", g)), m.getInitialState && !m.getInitialState.isReactClassApproved && !m.state && i("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", g), m.getDefaultProps && !m.getDefaultProps.isReactClassApproved && i("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", g), m.propTypes && i("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", g), m.contextType && i("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", g), m.contextTypes && i("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", g), c.contextType && c.contextTypes && !lc.has(c) && (lc.add(c), i("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", g)), typeof m.componentShouldUpdate == "function" && i("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", g), c.prototype && c.prototype.isPureReactComponent && typeof m.shouldComponentUpdate < "u" && i("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Dt(c) || "A pure component"), typeof m.componentDidUnmount == "function" && i("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", g), typeof m.componentDidReceiveProps == "function" && i("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", g), typeof m.componentWillRecieveProps == "function" && i("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", g), typeof m.UNSAFE_componentWillRecieveProps == "function" && i("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", g);
        var _ = m.props !== d;
        m.props !== void 0 && _ && i("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", g, g), m.defaultProps && i("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", g, g), typeof m.getSnapshotBeforeUpdate == "function" && typeof m.componentDidUpdate != "function" && !ya.has(c) && (ya.add(c), i("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Dt(c))), typeof m.getDerivedStateFromProps == "function" && i("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", g), typeof m.getDerivedStateFromError == "function" && i("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", g), typeof c.getSnapshotBeforeUpdate == "function" && i("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", g);
        var B = m.state;
        B && (typeof B != "object" || an(B)) && i("%s.state: must be set to an object or null", g), typeof m.getChildContext == "function" && typeof c.childContextTypes != "object" && i("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", g);
      }
    }
    function Iy(m, c) {
      var d = c.state;
      if (typeof c.componentWillMount == "function") {
        if (c.componentWillMount.__suppressDeprecationWarning !== !0) {
          var g = Dt(m) || "Unknown";
          ic[g] || (r(
            // keep this warning in sync with ReactStrictModeWarning.js
            `componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`,
            g
          ), ic[g] = !0);
        }
        c.componentWillMount();
      }
      typeof c.UNSAFE_componentWillMount == "function" && c.UNSAFE_componentWillMount(), d !== c.state && (i("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Dt(m) || "Component"), bh.enqueueReplaceState(c, c.state, null));
    }
    function lf(m, c, d, g) {
      if (m.queue !== null && m.queue.length > 0) {
        var w = m.queue, _ = m.replace;
        if (m.queue = null, m.replace = !1, _ && w.length === 1)
          c.state = w[0];
        else {
          for (var B = _ ? w[0] : c.state, L = !0, te = _ ? 1 : 0; te < w.length; te++) {
            var de = w[te], Ce = typeof de == "function" ? de.call(c, B, d, g) : de;
            Ce != null && (L ? (L = !1, B = zn({}, B, Ce)) : zn(B, Ce));
          }
          c.state = B;
        }
      } else
        m.queue = null;
    }
    function Bs(m, c, d, g) {
      Oy(m, c, d);
      var w = m.state !== void 0 ? m.state : null;
      m.updater = bh, m.props = d, m.state = w;
      var _ = {
        queue: [],
        replace: !1
      };
      af(m, _);
      var B = c.contextType;
      if (typeof B == "object" && B !== null ? m.context = ma(B) : m.context = g, m.state === d) {
        var L = Dt(c) || "Component";
        sc.has(L) || (sc.add(L), i("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", L));
      }
      var te = c.getDerivedStateFromProps;
      typeof te == "function" && (m.state = Ry(m, c, te, w, d)), typeof c.getDerivedStateFromProps != "function" && typeof m.getSnapshotBeforeUpdate != "function" && (typeof m.UNSAFE_componentWillMount == "function" || typeof m.componentWillMount == "function") && (Iy(c, m), lf(_, m, d, g));
    }
    var By = {
      id: 1,
      overflow: ""
    };
    function My(m) {
      var c = m.overflow, d = m.id, g = d & ~Ny(d);
      return g.toString(32) + c;
    }
    function cf(m, c, d) {
      var g = m.id, w = m.overflow, _ = cc(g) - 1, B = g & ~(1 << _), L = d + 1, te = cc(c) + _;
      if (te > 30) {
        var de = _ - _ % 5, Ce = (1 << de) - 1, Ue = (B & Ce).toString(32), Pe = B >> de, Ge = _ - de, pt = cc(c) + Ge, Vt = L << Ge, So = Vt | Pe, To = Ue + w;
        return {
          id: 1 << pt | So,
          overflow: To
        };
      } else {
        var ci = L << _, Ta = ci | B, hb = w;
        return {
          id: 1 << te | Ta,
          overflow: hb
        };
      }
    }
    function cc(m) {
      return 32 - Py(m);
    }
    function Ny(m) {
      return 1 << cc(m) - 1;
    }
    var Py = Math.clz32 ? Math.clz32 : uf, Wy = Math.log, oi = Math.LN2;
    function uf(m) {
      var c = m >>> 0;
      return c === 0 ? 32 : 31 - (Wy(c) / oi | 0) | 0;
    }
    function uc(m, c) {
      return m === c && (m !== 0 || 1 / m === 1 / c) || m !== m && c !== c;
    }
    var xt = typeof Object.is == "function" ? Object.is : uc, $n = null, ba = null, yo = null, dt = null, Ii = !1, fc = !1, jn = 0, Hn = null, zr = 0, Ly = 25, wr = !1, Bi;
    function bo() {
      if ($n === null)
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return wr && i("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks"), $n;
    }
    function zy(m, c) {
      if (c === null)
        return i("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Bi), !1;
      m.length !== c.length && i(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Bi, "[" + m.join(", ") + "]", "[" + c.join(", ") + "]");
      for (var d = 0; d < c.length && d < m.length; d++)
        if (!xt(m[d], c[d]))
          return !1;
      return !0;
    }
    function ff() {
      if (zr > 0)
        throw new Error("Rendered more hooks than during the previous render");
      return {
        memoizedState: null,
        queue: null,
        next: null
      };
    }
    function Ms() {
      return dt === null ? yo === null ? (Ii = !1, yo = dt = ff()) : (Ii = !0, dt = yo) : dt.next === null ? (Ii = !1, dt = dt.next = ff()) : (Ii = !0, dt = dt.next), dt;
    }
    function $y(m, c) {
      $n = c, ba = m, wr = !1, jn = 0;
    }
    function jy(m, c, d, g) {
      for (; fc; )
        fc = !1, jn = 0, zr += 1, dt = null, d = m(c, g);
      return df(), d;
    }
    function dc() {
      var m = jn !== 0;
      return m;
    }
    function df() {
      wr = !1, $n = null, ba = null, fc = !1, yo = null, zr = 0, Hn = null, dt = null;
    }
    function xh(m) {
      return wr && i("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), ma(m);
    }
    function Dh(m) {
      return Bi = "useContext", bo(), ma(m);
    }
    function hf(m, c) {
      return typeof c == "function" ? c(m) : c;
    }
    function Hy(m) {
      return Bi = "useState", wh(
        hf,
        // useReducer has a special case to support lazy useState initializers
        m
      );
    }
    function wh(m, c, d) {
      if (m !== hf && (Bi = "useReducer"), $n = bo(), dt = Ms(), Ii) {
        var g = dt.queue, w = g.dispatch;
        if (Hn !== null) {
          var _ = Hn.get(g);
          if (_ !== void 0) {
            Hn.delete(g);
            var B = dt.memoizedState, L = _;
            do {
              var te = L.action;
              wr = !0, B = m(B, te), wr = !1, L = L.next;
            } while (L !== null);
            return dt.memoizedState = B, [B, w];
          }
        }
        return [dt.memoizedState, w];
      } else {
        wr = !0;
        var de;
        m === hf ? de = typeof c == "function" ? c() : c : de = d !== void 0 ? d(c) : c, wr = !1, dt.memoizedState = de;
        var Ce = dt.queue = {
          last: null,
          dispatch: null
        }, Ue = Ce.dispatch = Xy.bind(null, $n, Ce);
        return [dt.memoizedState, Ue];
      }
    }
    function Sh(m, c) {
      $n = bo(), dt = Ms();
      var d = c === void 0 ? null : c;
      if (dt !== null) {
        var g = dt.memoizedState;
        if (g !== null && d !== null) {
          var w = g[1];
          if (zy(d, w))
            return g[0];
        }
      }
      wr = !0;
      var _ = m();
      return wr = !1, dt.memoizedState = [_, d], _;
    }
    function Vy(m) {
      $n = bo(), dt = Ms();
      var c = dt.memoizedState;
      if (c === null) {
        var d = {
          current: m
        };
        return Object.seal(d), dt.memoizedState = d, d;
      } else
        return c;
    }
    function qy(m, c) {
      Bi = "useLayoutEffect", i("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function Xy(m, c, d) {
      if (zr >= Ly)
        throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (m === $n) {
        fc = !0;
        var g = {
          action: d,
          next: null
        };
        Hn === null && (Hn = /* @__PURE__ */ new Map());
        var w = Hn.get(c);
        if (w === void 0)
          Hn.set(c, g);
        else {
          for (var _ = w; _.next !== null; )
            _ = _.next;
          _.next = g;
        }
      }
    }
    function Gy(m, c) {
      return Sh(function() {
        return m;
      }, c);
    }
    function Jy(m, c, d) {
      return bo(), c(m._source);
    }
    function Yy(m, c, d) {
      if (d === void 0)
        throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return d();
    }
    function hc(m) {
      return bo(), m;
    }
    function Th() {
      throw new Error("startTransition cannot be called during server rendering.");
    }
    function pf() {
      return bo(), [!1, Th];
    }
    function Ch() {
      var m = ba, c = My(m.treeContext), d = Ns;
      if (d === null)
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      var g = jn++;
      return ir(d, c, g);
    }
    function pc() {
    }
    var gc = {
      readContext: xh,
      useContext: Dh,
      useMemo: Sh,
      useReducer: wh,
      useRef: Vy,
      useState: Hy,
      useInsertionEffect: pc,
      useLayoutEffect: qy,
      useCallback: Gy,
      // useImperativeHandle is not run in the server environment
      useImperativeHandle: pc,
      // Effects are not run in the server environment.
      useEffect: pc,
      // Debugging effect
      useDebugValue: pc,
      useDeferredValue: hc,
      useTransition: pf,
      useId: Ch,
      // Subscriptions are not setup in a server environment.
      useMutableSource: Jy,
      useSyncExternalStore: Yy
    }, Ns = null;
    function mc(m) {
      Ns = m;
    }
    function va(m) {
      try {
        var c = "", d = m;
        do {
          switch (d.tag) {
            case 0:
              c += po(d.type, null, null);
              break;
            case 1:
              c += nf(d.type, null, null);
              break;
            case 2:
              c += uh(d.type, null, null);
              break;
          }
          d = d.parent;
        } while (d);
        return c;
      } catch (g) {
        return `
Error generating stack: ` + g.message + `
` + g.stack;
      }
    }
    var yc = n.ReactCurrentDispatcher, bc = n.ReactDebugCurrentFrame, vc = 0, xa = 1, gf = 2, vo = 3, Eh = 4, Zy = 0, Da = 1, wa = 2, Ky = 12800;
    function Qy(m) {
      return console.error(m), null;
    }
    function xo() {
    }
    function xc(m, c, d, g, w, _, B, L, te) {
      var de = [], Ce = /* @__PURE__ */ new Set(), Ue = {
        destination: null,
        responseState: c,
        progressiveChunkSize: g === void 0 ? Ky : g,
        status: Zy,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: Ce,
        pingedTasks: de,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: w === void 0 ? Qy : w,
        onAllReady: _ === void 0 ? xo : _,
        onShellReady: B === void 0 ? xo : B,
        onShellError: L === void 0 ? xo : L,
        onFatalError: te === void 0 ? xo : te
      }, Pe = Ps(
        Ue,
        0,
        null,
        d,
        // Root segments are never embedded in Text on either edge
        !1,
        !1
      );
      Pe.parentFlushed = !0;
      var Ge = Do(Ue, m, null, Pe, Ce, Ql, ec, By);
      return de.push(Ge), Ue;
    }
    function ai(m, c) {
      var d = m.pingedTasks;
      d.push(c), d.length === 1 && a(function() {
        return Ef(m);
      });
    }
    function mf(m, c) {
      return {
        id: Ei,
        rootSegmentID: -1,
        parentFlushed: !1,
        pendingTasks: 0,
        forceClientRender: !1,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks: c,
        errorDigest: null
      };
    }
    function Do(m, c, d, g, w, _, B, L) {
      m.allPendingTasks++, d === null ? m.pendingRootTasks++ : d.pendingTasks++;
      var te = {
        node: c,
        ping: function() {
          return ai(m, te);
        },
        blockedBoundary: d,
        blockedSegment: g,
        abortSet: w,
        legacyContext: _,
        context: B,
        treeContext: L
      };
      return te.componentStack = null, w.add(te), te;
    }
    function Ps(m, c, d, g, w, _) {
      return {
        status: vc,
        id: -1,
        // lazily assigned later
        index: c,
        parentFlushed: !1,
        chunks: [],
        children: [],
        formatContext: g,
        boundary: d,
        lastPushedText: w,
        textEmbedded: _
      };
    }
    var si = null;
    function $r() {
      return si === null || si.componentStack === null ? "" : va(si.componentStack);
    }
    function li(m, c) {
      m.componentStack = {
        tag: 0,
        parent: m.componentStack,
        type: c
      };
    }
    function Dc(m, c) {
      m.componentStack = {
        tag: 1,
        parent: m.componentStack,
        type: c
      };
    }
    function Ws(m, c) {
      m.componentStack = {
        tag: 2,
        parent: m.componentStack,
        type: c
      };
    }
    function Sr(m) {
      m.componentStack === null ? i("Unexpectedly popped too many stack frames. This is a bug in React.") : m.componentStack = m.componentStack.parent;
    }
    var Ls = null;
    function yf(m, c) {
      {
        var d;
        typeof c == "string" ? d = c : c && typeof c.message == "string" ? d = c.message : d = String(c);
        var g = Ls || $r();
        Ls = null, m.errorMessage = d, m.errorComponentStack = g;
      }
    }
    function zs(m, c) {
      var d = m.onError(c);
      if (d != null && typeof d != "string")
        throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof d + '" instead');
      return d;
    }
    function $s(m, c) {
      var d = m.onShellError;
      d(c);
      var g = m.onFatalError;
      g(c), m.destination !== null ? (m.status = wa, S(m.destination, c)) : (m.status = Da, m.fatalError = c);
    }
    function _h(m, c, d) {
      li(c, "Suspense");
      var g = c.blockedBoundary, w = c.blockedSegment, _ = d.fallback, B = d.children, L = /* @__PURE__ */ new Set(), te = mf(m, L), de = w.chunks.length, Ce = Ps(
        m,
        de,
        te,
        w.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      w.children.push(Ce), w.lastPushedText = !1;
      var Ue = Ps(
        m,
        0,
        null,
        w.formatContext,
        // boundaries never require text embedding at their edges because comment nodes bound them
        !1,
        !1
      );
      Ue.parentFlushed = !0, c.blockedBoundary = te, c.blockedSegment = Ue;
      try {
        if (Sa(m, c, B), ln(Ue.chunks, m.responseState, Ue.lastPushedText, Ue.textEmbedded), Ue.status = xa, wo(te, Ue), te.pendingTasks === 0) {
          Sr(c);
          return;
        }
      } catch (Ge) {
        Ue.status = Eh, te.forceClientRender = !0, te.errorDigest = zs(m, Ge), yf(te, Ge);
      } finally {
        c.blockedBoundary = g, c.blockedSegment = w;
      }
      var Pe = Do(m, _, g, Ce, L, c.legacyContext, c.context, c.treeContext);
      Pe.componentStack = c.componentStack, m.pingedTasks.push(Pe), Sr(c);
    }
    function eb(m, c, d, g) {
      li(c, d);
      var w = c.blockedSegment, _ = co(w.chunks, d, g, m.responseState, w.formatContext);
      w.lastPushedText = !1;
      var B = w.formatContext;
      w.formatContext = ei(B, d, g), Sa(m, c, _), w.formatContext = B, kl(w.chunks, d), w.lastPushedText = !1, Sr(c);
    }
    function kh(m) {
      return m.prototype && m.prototype.isReactComponent;
    }
    function js(m, c, d, g, w) {
      var _ = {};
      $y(c, _);
      var B = d(g, w);
      return jy(d, g, B, w);
    }
    function bf(m, c, d, g, w) {
      var _ = d.render();
      d.props !== w && (wf || i("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Dt(g) || "a component"), wf = !0);
      {
        var B = g.childContextTypes;
        if (B != null) {
          var L = c.legacyContext, te = rf(d, g, L, B);
          c.legacyContext = te, fn(m, c, _), c.legacyContext = L;
          return;
        }
      }
      fn(m, c, _);
    }
    function Ah(m, c, d, g) {
      Ws(c, d);
      var w = Fi(d, c.legacyContext), _ = vh(d, g, w);
      Bs(_, d, g, w), bf(m, c, _, d, g), Sr(c);
    }
    var vf = {}, Hs = {}, xf = {}, Df = {}, wf = !1, Uh = {}, Fh = !1, Sf = !1, Rh = !1;
    function tb(m, c, d, g) {
      var w;
      if (w = Fi(d, c.legacyContext), Dc(c, d), d.prototype && typeof d.prototype.render == "function") {
        var _ = Dt(d) || "Unknown";
        vf[_] || (i("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", _, _), vf[_] = !0);
      }
      var B = js(m, c, d, g, w), L = dc();
      if (typeof B == "object" && B !== null && typeof B.render == "function" && B.$$typeof === void 0) {
        var te = Dt(d) || "Unknown";
        Hs[te] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", te, te, te), Hs[te] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof B == "object" && B !== null && typeof B.render == "function" && B.$$typeof === void 0
      ) {
        {
          var de = Dt(d) || "Unknown";
          Hs[de] || (i("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", de, de, de), Hs[de] = !0);
        }
        Bs(B, d, g, w), bf(m, c, B, d, g);
      } else if (nb(d), L) {
        var Ce = c.treeContext, Ue = 1, Pe = 0;
        c.treeContext = cf(Ce, Ue, Pe);
        try {
          fn(m, c, B);
        } finally {
          c.treeContext = Ce;
        }
      } else
        fn(m, c, B);
      Sr(c);
    }
    function nb(m) {
      {
        if (m && m.childContextTypes && i("%s(...): childContextTypes cannot be defined on a function component.", m.displayName || m.name || "Component"), m.defaultProps !== void 0) {
          var c = Dt(m) || "Unknown";
          Uh[c] || (i("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", c), Uh[c] = !0);
        }
        if (typeof m.getDerivedStateFromProps == "function") {
          var d = Dt(m) || "Unknown";
          Df[d] || (i("%s: Function components do not support getDerivedStateFromProps.", d), Df[d] = !0);
        }
        if (typeof m.contextType == "object" && m.contextType !== null) {
          var g = Dt(m) || "Unknown";
          xf[g] || (i("%s: Function components do not support contextType.", g), xf[g] = !0);
        }
      }
    }
    function Oh(m, c) {
      if (m && m.defaultProps) {
        var d = zn({}, c), g = m.defaultProps;
        for (var w in g)
          d[w] === void 0 && (d[w] = g[w]);
        return d;
      }
      return c;
    }
    function rb(m, c, d, g, w) {
      Dc(c, d.render);
      var _ = js(m, c, d.render, g, w), B = dc();
      if (B) {
        var L = c.treeContext, te = 1, de = 0;
        c.treeContext = cf(L, te, de);
        try {
          fn(m, c, _);
        } finally {
          c.treeContext = L;
        }
      } else
        fn(m, c, _);
      Sr(c);
    }
    function Tf(m, c, d, g, w) {
      var _ = d.type, B = Oh(_, g);
      wc(m, c, _, B, w);
    }
    function ib(m, c, d, g) {
      d._context === void 0 ? d !== d.Consumer && (Rh || (Rh = !0, i("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : d = d._context;
      var w = g.children;
      typeof w != "function" && i("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
      var _ = ma(d), B = w(_);
      fn(m, c, B);
    }
    function Vn(m, c, d, g) {
      var w = d._context, _ = g.value, B = g.children, L;
      L = c.context, c.context = of(w, _), fn(m, c, B), c.context = Fy(w), L !== c.context && i("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
    }
    function ob(m, c, d, g, w) {
      li(c, "Lazy");
      var _ = d._payload, B = d._init, L = B(_), te = Oh(L, g);
      wc(m, c, L, te, w), Sr(c);
    }
    function wc(m, c, d, g, w) {
      if (typeof d == "function")
        if (kh(d)) {
          Ah(m, c, d, g);
          return;
        } else {
          tb(m, c, d, g);
          return;
        }
      if (typeof d == "string") {
        eb(m, c, d, g);
        return;
      }
      switch (d) {
        case ky:
        case _y:
        case Vl:
        case ql:
        case Hl: {
          fn(m, c, g.children);
          return;
        }
        case Vu: {
          li(c, "SuspenseList"), fn(m, c, g.children), Sr(c);
          return;
        }
        case ah:
          throw new Error("ReactDOMServer does not yet support scope components.");
        case Hu: {
          _h(m, c, g);
          return;
        }
      }
      if (typeof d == "object" && d !== null)
        switch (d.$$typeof) {
          case ha: {
            rb(m, c, d, g, w);
            return;
          }
          case qu: {
            Tf(m, c, d, g, w);
            return;
          }
          case Ds: {
            Vn(m, c, d, g);
            return;
          }
          case ws: {
            ib(m, c, d, g);
            return;
          }
          case Xl: {
            ob(m, c, d, g);
            return;
          }
        }
      var _ = "";
      throw (d === void 0 || typeof d == "object" && d !== null && Object.keys(d).length === 0) && (_ += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (d == null ? d : typeof d) + "." + _));
    }
    function ab(m, c) {
      typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
      m[Symbol.toStringTag] === "Generator" && (Fh || i("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Fh = !0), m.entries === c && (Sf || i("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Sf = !0);
    }
    function fn(m, c, d) {
      try {
        return sb(m, c, d);
      } catch (g) {
        throw typeof g == "object" && g !== null && typeof g.then == "function" || (Ls = Ls !== null ? Ls : $r()), g;
      }
    }
    function sb(m, c, d) {
      if (c.node = d, typeof d == "object" && d !== null) {
        switch (d.$$typeof) {
          case oh: {
            var g = d, w = g.type, _ = g.props, B = g.ref;
            wc(m, c, w, _, B);
            return;
          }
          case jl:
            throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Xl: {
            var L = d, te = L._payload, de = L._init, Ce;
            try {
              Ce = de(te);
            } catch (ci) {
              throw typeof ci == "object" && ci !== null && typeof ci.then == "function" && li(c, "Lazy"), ci;
            }
            fn(m, c, Ce);
            return;
          }
        }
        if (an(d)) {
          Ih(m, c, d);
          return;
        }
        var Ue = Ss(d);
        if (Ue) {
          ab(d, Ue);
          var Pe = Ue.call(d);
          if (Pe) {
            var Ge = Pe.next();
            if (!Ge.done) {
              var pt = [];
              do
                pt.push(Ge.value), Ge = Pe.next();
              while (!Ge.done);
              Ih(m, c, pt);
              return;
            }
            return;
          }
        }
        var Vt = Object.prototype.toString.call(d);
        throw new Error("Objects are not valid as a React child (found: " + (Vt === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : Vt) + "). If you meant to render a collection of children, use an array instead.");
      }
      if (typeof d == "string") {
        var So = c.blockedSegment;
        So.lastPushedText = Lt(c.blockedSegment.chunks, d, m.responseState, So.lastPushedText);
        return;
      }
      if (typeof d == "number") {
        var To = c.blockedSegment;
        To.lastPushedText = Lt(c.blockedSegment.chunks, "" + d, m.responseState, To.lastPushedText);
        return;
      }
      typeof d == "function" && i("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function Ih(m, c, d) {
      for (var g = d.length, w = 0; w < g; w++) {
        var _ = c.treeContext;
        c.treeContext = cf(_, g, w);
        try {
          Sa(m, c, d[w]);
        } finally {
          c.treeContext = _;
        }
      }
    }
    function Bh(m, c, d) {
      var g = c.blockedSegment, w = g.chunks.length, _ = Ps(
        m,
        w,
        null,
        g.formatContext,
        // Adopt the parent segment's leading text embed
        g.lastPushedText,
        // Assume we are text embedded at the trailing edge
        !0
      );
      g.children.push(_), g.lastPushedText = !1;
      var B = Do(m, c.node, c.blockedBoundary, _, c.abortSet, c.legacyContext, c.context, c.treeContext);
      c.componentStack !== null && (B.componentStack = c.componentStack.parent);
      var L = B.ping;
      d.then(L, L);
    }
    function Sa(m, c, d) {
      var g = c.blockedSegment.formatContext, w = c.legacyContext, _ = c.context, B = null;
      B = c.componentStack;
      try {
        return fn(m, c, d);
      } catch (L) {
        if (df(), typeof L == "object" && L !== null && typeof L.then == "function") {
          Bh(m, c, L), c.blockedSegment.formatContext = g, c.legacyContext = w, c.context = _, Oi(_), c.componentStack = B;
          return;
        } else
          throw c.blockedSegment.formatContext = g, c.legacyContext = w, c.context = _, Oi(_), c.componentStack = B, L;
      }
    }
    function Mh(m, c, d, g) {
      var w = zs(m, g);
      if (c === null ? $s(m, g) : (c.pendingTasks--, c.forceClientRender || (c.forceClientRender = !0, c.errorDigest = w, yf(c, g), c.parentFlushed && m.clientRenderedBoundaries.push(c))), m.allPendingTasks--, m.allPendingTasks === 0) {
        var _ = m.onAllReady;
        _();
      }
    }
    function lb(m) {
      var c = this, d = m.blockedBoundary, g = m.blockedSegment;
      g.status = vo, Vs(c, d, g);
    }
    function Cf(m, c, d) {
      var g = m.blockedBoundary, w = m.blockedSegment;
      if (w.status = vo, g === null)
        c.allPendingTasks--, c.status !== wa && (c.status = wa, c.destination !== null && b(c.destination));
      else {
        if (g.pendingTasks--, !g.forceClientRender) {
          g.forceClientRender = !0;
          var _ = d === void 0 ? new Error("The render was aborted by the server without a reason.") : d;
          g.errorDigest = c.onError(_);
          {
            var B = "The server did not finish this Suspense boundary: ";
            _ && typeof _.message == "string" ? _ = B + _.message : _ = B + String(_);
            var L = si;
            si = m;
            try {
              yf(g, _);
            } finally {
              si = L;
            }
          }
          g.parentFlushed && c.clientRenderedBoundaries.push(g);
        }
        if (g.fallbackAbortableTasks.forEach(function(de) {
          return Cf(de, c, d);
        }), g.fallbackAbortableTasks.clear(), c.allPendingTasks--, c.allPendingTasks === 0) {
          var te = c.onAllReady;
          te();
        }
      }
    }
    function wo(m, c) {
      if (c.chunks.length === 0 && c.children.length === 1 && c.children[0].boundary === null) {
        var d = c.children[0];
        d.id = c.id, d.parentFlushed = !0, d.status === xa && wo(m, d);
      } else {
        var g = m.completedSegments;
        g.push(c);
      }
    }
    function Vs(m, c, d) {
      if (c === null) {
        if (d.parentFlushed) {
          if (m.completedRootSegment !== null)
            throw new Error("There can only be one root segment. This is a bug in React.");
          m.completedRootSegment = d;
        }
        if (m.pendingRootTasks--, m.pendingRootTasks === 0) {
          m.onShellError = xo;
          var g = m.onShellReady;
          g();
        }
      } else if (c.pendingTasks--, !c.forceClientRender) {
        if (c.pendingTasks === 0)
          d.parentFlushed && d.status === xa && wo(c, d), c.parentFlushed && m.completedBoundaries.push(c), c.fallbackAbortableTasks.forEach(lb, m), c.fallbackAbortableTasks.clear();
        else if (d.parentFlushed && d.status === xa) {
          wo(c, d);
          var w = c.completedSegments;
          w.length === 1 && c.parentFlushed && m.partialBoundaries.push(c);
        }
      }
      if (m.allPendingTasks--, m.allPendingTasks === 0) {
        var _ = m.onAllReady;
        _();
      }
    }
    function cb(m, c) {
      var d = c.blockedSegment;
      if (d.status === vc) {
        Oi(c.context);
        var g = null;
        g = si, si = c;
        try {
          fn(m, c, c.node), ln(d.chunks, m.responseState, d.lastPushedText, d.textEmbedded), c.abortSet.delete(c), d.status = xa, Vs(m, c.blockedBoundary, d);
        } catch (_) {
          if (df(), typeof _ == "object" && _ !== null && typeof _.then == "function") {
            var w = c.ping;
            _.then(w, w);
          } else
            c.abortSet.delete(c), d.status = Eh, Mh(m, c.blockedBoundary, d, _);
        } finally {
          si = g;
        }
      }
    }
    function Ef(m) {
      if (m.status !== wa) {
        var c = gh(), d = yc.current;
        yc.current = gc;
        var g;
        g = bc.getCurrentStack, bc.getCurrentStack = $r;
        var w = Ns;
        mc(m.responseState);
        try {
          var _ = m.pingedTasks, B;
          for (B = 0; B < _.length; B++) {
            var L = _[B];
            cb(m, L);
          }
          _.splice(0, B), m.destination !== null && _f(m, m.destination);
        } catch (te) {
          zs(m, te), $s(m, te);
        } finally {
          mc(w), yc.current = d, bc.getCurrentStack = g, d === gc && Oi(c);
        }
      }
    }
    function qs(m, c, d) {
      switch (d.parentFlushed = !0, d.status) {
        case vc: {
          var g = d.id = m.nextSegmentId++;
          return d.lastPushedText = !1, d.textEmbedded = !1, Al(c, m.responseState, g);
        }
        case xa: {
          d.status = gf;
          for (var w = !0, _ = d.chunks, B = 0, L = d.children, te = 0; te < L.length; te++) {
            for (var de = L[te]; B < de.index; B++)
              h(c, _[B]);
            w = Sc(m, c, de);
          }
          for (; B < _.length - 1; B++)
            h(c, _[B]);
          return B < _.length && (w = p(c, _[B])), w;
        }
        default:
          throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Sc(m, c, d) {
      var g = d.boundary;
      if (g === null)
        return qs(m, c, d);
      if (g.parentFlushed = !0, g.forceClientRender)
        return cn(c, m.responseState, g.errorDigest, g.errorMessage, g.errorComponentStack), qs(m, c, d), $u(c, m.responseState);
      if (g.pendingTasks > 0) {
        g.rootSegmentID = m.nextSegmentId++, g.completedSegments.length > 0 && m.partialBoundaries.push(g);
        var w = g.id = wn(m.responseState);
        return sa(c, m.responseState, w), qs(m, c, d), la(c, m.responseState);
      } else {
        if (g.byteSize > m.progressiveChunkSize)
          return g.rootSegmentID = m.nextSegmentId++, m.completedBoundaries.push(g), sa(c, m.responseState, g.id), qs(m, c, d), la(c, m.responseState);
        Rl(c, m.responseState);
        var _ = g.completedSegments;
        if (_.length !== 1)
          throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        var B = _[0];
        return Sc(m, c, B), Ol(c, m.responseState);
      }
    }
    function Nh(m, c, d) {
      return Ey(c, m.responseState, d.id, d.errorDigest, d.errorMessage, d.errorComponentStack);
    }
    function Tc(m, c, d) {
      return Ze(c, m.responseState, d.formatContext, d.id), Sc(m, c, d), bt(c, d.formatContext);
    }
    function Ph(m, c, d) {
      for (var g = d.completedSegments, w = 0; w < g.length; w++) {
        var _ = g[w];
        Wh(m, c, d, _);
      }
      return g.length = 0, rh(c, m.responseState, d.id, d.rootSegmentID);
    }
    function ub(m, c, d) {
      for (var g = d.completedSegments, w = 0; w < g.length; w++) {
        var _ = g[w];
        if (!Wh(m, c, d, _))
          return w++, g.splice(0, w), !1;
      }
      return g.splice(0, w), !0;
    }
    function Wh(m, c, d, g) {
      if (g.status === gf)
        return !0;
      var w = g.id;
      if (w === -1) {
        var _ = g.id = d.rootSegmentID;
        if (_ === -1)
          throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Tc(m, c, g);
      } else
        return Tc(m, c, g), vy(c, m.responseState, w);
    }
    function _f(m, c) {
      f();
      try {
        var d = m.completedRootSegment;
        d !== null && m.pendingRootTasks === 0 && (Sc(m, c, d), m.completedRootSegment = null, Wu(c, m.responseState));
        var g = m.clientRenderedBoundaries, w;
        for (w = 0; w < g.length; w++) {
          var _ = g[w];
          Nh(m, c, _);
        }
        g.splice(0, w);
        var B = m.completedBoundaries;
        for (w = 0; w < B.length; w++) {
          var L = B[w];
          Ph(m, c, L);
        }
        B.splice(0, w), y(c), f(c);
        var te = m.partialBoundaries;
        for (w = 0; w < te.length; w++) {
          var de = te[w];
          if (!ub(m, c, de)) {
            m.destination = null, w++, te.splice(0, w);
            return;
          }
        }
        te.splice(0, w);
        var Ce = m.completedBoundaries;
        for (w = 0; w < Ce.length; w++) {
          var Ue = Ce[w];
          Ph(m, c, Ue);
        }
        Ce.splice(0, w);
      } finally {
        y(c), m.allPendingTasks === 0 && m.pingedTasks.length === 0 && m.clientRenderedBoundaries.length === 0 && m.completedBoundaries.length === 0 && (m.abortableTasks.size !== 0 && i("There was still abortable task at the root when we closed. This is a bug in React."), b(c));
      }
    }
    function Lh(m) {
      a(function() {
        return Ef(m);
      });
    }
    function fb(m, c) {
      if (m.status === Da) {
        m.status = wa, S(c, m.fatalError);
        return;
      }
      if (m.status !== wa && m.destination === null) {
        m.destination = c;
        try {
          _f(m, c);
        } catch (d) {
          zs(m, d), $s(m, d);
        }
      }
    }
    function zh(m, c) {
      try {
        var d = m.abortableTasks;
        d.forEach(function(g) {
          return Cf(g, m, c);
        }), d.clear(), m.destination !== null && _f(m, m.destination);
      } catch (g) {
        zs(m, g), $s(m, g);
      }
    }
    function db(m, c) {
      return new Promise(function(d, g) {
        var w, _, B = new Promise(function(Pe, Ge) {
          _ = Pe, w = Ge;
        });
        function L() {
          var Pe = new ReadableStream(
            {
              type: "bytes",
              pull: function(Ge) {
                fb(de, Ge);
              },
              cancel: function(Ge) {
                zh(de);
              }
            },
            // $FlowFixMe size() methods are not allowed on byte streams.
            {
              highWaterMark: 0
            }
          );
          Pe.allReady = B, d(Pe);
        }
        function te(Pe) {
          B.catch(function() {
          }), g(Pe);
        }
        var de = xc(m, Qo(c ? c.identifierPrefix : void 0, c ? c.nonce : void 0, c ? c.bootstrapScriptContent : void 0, c ? c.bootstrapScripts : void 0, c ? c.bootstrapModules : void 0), Mr(c ? c.namespaceURI : void 0), c ? c.progressiveChunkSize : void 0, c ? c.onError : void 0, _, L, te, w);
        if (c && c.signal) {
          var Ce = c.signal, Ue = function() {
            zh(de, Ce.reason), Ce.removeEventListener("abort", Ue);
          };
          Ce.addEventListener("abort", Ue);
        }
        Lh(de);
      });
    }
    yp.renderToReadableStream = db, yp.version = e;
  }()), yp;
}
var vl, X0;
process.env.NODE_ENV === "production" ? (vl = LG(), X0 = zG()) : (vl = $G(), X0 = jG());
Bu.version = vl.version;
Bu.renderToString = vl.renderToString;
Bu.renderToStaticMarkup = vl.renderToStaticMarkup;
Bu.renderToNodeStream = vl.renderToNodeStream;
Bu.renderToStaticNodeStream = vl.renderToStaticNodeStream;
Bu.renderToReadableStream = X0.renderToReadableStream;
export {
  UJ as $,
  DJ as A,
  mJ as B,
  U_ as C,
  We as D,
  dJ as E,
  Fe as F,
  pJ as G,
  XG as H,
  jf as I,
  vu as J,
  GG as K,
  nl as L,
  VG as M,
  Ye as N,
  v_ as O,
  xu as P,
  mn as Q,
  hn as R,
  et as S,
  P_ as T,
  W_ as U,
  kJ as V,
  AJ as W,
  Hp as X,
  FJ as Y,
  RJ as Z,
  O$ as _,
  ns as a,
  $$ as a0,
  j$ as a1,
  OJ as a2,
  IJ as a3,
  Nt as a4,
  qn as a5,
  BJ as a6,
  MJ as a7,
  NJ as a8,
  PJ as a9,
  ro as aA,
  Bu as aB,
  WJ as aa,
  LJ as ab,
  zJ as ac,
  XJ as ad,
  $J as ae,
  jJ as af,
  Z2 as ag,
  VJ as ah,
  HJ as ai,
  qJ as aj,
  fj as ak,
  Rt as al,
  GJ as am,
  JJ as an,
  yJ as ao,
  dI as ap,
  bJ as aq,
  vJ as ar,
  wJ as as,
  TJ as at,
  EJ as au,
  di as av,
  QW as aw,
  _J as ax,
  CJ as ay,
  SJ as az,
  sJ as b,
  zd as c,
  st as d,
  JG as e,
  __ as f,
  xJ as g,
  aJ as h,
  rJ as i,
  nJ as j,
  YG as k,
  Ld as l,
  eJ as m,
  R_ as n,
  ZG as o,
  KG as p,
  iJ as q,
  lJ as r,
  gJ as s,
  oJ as t,
  QG as u,
  tJ as v,
  cJ as w,
  fJ as x,
  uJ as y,
  hJ as z
};
